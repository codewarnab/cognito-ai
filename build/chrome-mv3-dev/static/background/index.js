(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"8LKeO":[function(require,module,exports) {
var u = globalThis.process?.argv || [];
var h = ()=>globalThis.process?.env || {};
var B = new Set(u), _ = (e)=>B.has(e), G = u.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var U = _("--dry-run"), g = ()=>_("--verbose") || h().VERBOSE === "true", N = g();
var m = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var y = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), v = (...e)=>m("\uD83D\uDD35 INFO", ...e), f = (...e)=>m("\uD83D\uDFE0 WARN", ...e), M = 0, i = (...e)=>g() && m(`\u{1F7E1} ${M++}`, ...e);
var b = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime, t = ()=>setInterval(e.getPlatformInfo, 24e3);
    e.onStartup.addListener(t), t();
};
var n = {
    "isContentScript": false,
    "isBackground": true,
    "isReact": false,
    "runtimes": [
        "background-service-runtime"
    ],
    "host": "localhost",
    "port": 50961,
    "entryFilePath": "C:\\Users\\User\\code\\hackathons\\chrome-ai\\.plasmo\\static\\background\\index.ts",
    "bundleId": "c338908e704c91f1",
    "envHash": "d99a5ffa57acd638",
    "verbose": "false",
    "secure": false,
    "serverPort": 50960
};
module.bundle.HMR_BUNDLE_ID = n.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: n.verbose
    }
};
var D = module.bundle.Module;
function H(e) {
    D.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = H;
module.bundle.hotData = {};
var c = globalThis.browser || globalThis.chrome || null;
function R() {
    return !n.host || n.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : n.host;
}
function x() {
    return !n.host || n.host === "0.0.0.0" ? "localhost" : n.host;
}
function d() {
    return n.port || location.port;
}
var P = "__plasmo_runtime_page_", S = "__plasmo_runtime_script_";
var O = `${n.secure ? "https" : "http"}://${R()}:${d()}/`;
async function k(e = 1470) {
    for(;;)try {
        await fetch(O);
        break;
    } catch  {
        await new Promise((o)=>setTimeout(o, e));
    }
}
if (c.runtime.getManifest().manifest_version === 3) {
    let e = c.runtime.getURL("/__plasmo_hmr_proxy__?url=");
    globalThis.addEventListener("fetch", function(t) {
        let o = t.request.url;
        if (o.startsWith(e)) {
            let s = new URL(decodeURIComponent(o.slice(e.length)));
            s.hostname === n.host && s.port === `${n.port}` ? (s.searchParams.set("t", Date.now().toString()), t.respondWith(fetch(s).then((r)=>new Response(r.body, {
                    headers: {
                        "Content-Type": r.headers.get("Content-Type") ?? "text/javascript"
                    }
                })))) : t.respondWith(new Response("Plasmo HMR", {
                status: 200,
                statusText: "Testing"
            }));
        }
    });
}
function E(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function C(e = d()) {
    let t = x();
    return `${n.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function L(e) {
    typeof e.message == "string" && y("[plasmo/parcel-runtime]: " + e.message);
}
function T(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C(Number(d()) + 1));
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        await e(s);
    }), t.addEventListener("error", L), t;
}
function A(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C());
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        if (s.type === "update" && await e(s.assets), s.type === "error") for (let r of s.diagnostics.ansi){
            let l = r.codeframe || r.stack;
            f("[plasmo/parcel-runtime]: " + r.message + `
` + l + `

` + r.hints.join(`
`));
        }
    }), t.addEventListener("error", L), t.addEventListener("open", ()=>{
        v(`[plasmo/parcel-runtime]: Connected to HMR server for ${n.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        f(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${n.entryFilePath}`);
    }), t;
}
var w = module.bundle.parent, a = {
    buildReady: !1,
    bgChanged: !1,
    csChanged: !1,
    pageChanged: !1,
    scriptPorts: new Set,
    pagePorts: new Set
};
async function p(e = !1) {
    if (e || a.buildReady && a.pageChanged) {
        i("BGSW Runtime - reloading Page");
        for (let t of a.pagePorts)t.postMessage(null);
    }
    if (e || a.buildReady && (a.bgChanged || a.csChanged)) {
        i("BGSW Runtime - reloading CS");
        let t = await c?.tabs.query({
            active: !0
        });
        for (let o of a.scriptPorts){
            let s = t.some((r)=>r.id === o.sender.tab?.id);
            o.postMessage({
                __plasmo_cs_active_tab__: s
            });
        }
        c.runtime.reload();
    }
}
if (!w || !w.isParcelRequire) {
    b();
    let e = A(async (t)=>{
        i("BGSW Runtime - On HMR Update"), a.bgChanged ||= t.filter((s)=>s.envHash === n.envHash).some((s)=>E(module.bundle, s.id));
        let o = t.find((s)=>s.type === "json");
        if (o) {
            let s = new Set(t.map((l)=>l.id)), r = Object.values(o.depsByBundle).map((l)=>Object.values(l)).flat();
            a.bgChanged ||= r.every((l)=>s.has(l));
        }
        p();
    });
    e.addEventListener("open", ()=>{
        let t = setInterval(()=>e.send("ping"), 24e3);
        e.addEventListener("close", ()=>clearInterval(t));
    }), e.addEventListener("close", async ()=>{
        await k(), p(!0);
    });
}
T(async (e)=>{
    switch(i("BGSW Runtime - On Build Repackaged"), e.type){
        case "build_ready":
            a.buildReady ||= !0, p();
            break;
        case "cs_changed":
            a.csChanged ||= !0, p();
            break;
    }
});
c.runtime.onConnect.addListener(function(e) {
    let t = e.name.startsWith(P), o = e.name.startsWith(S);
    if (t || o) {
        let s = t ? a.pagePorts : a.scriptPorts;
        s.add(e), e.onDisconnect.addListener(()=>{
            s.delete(e);
        }), e.onMessage.addListener(function(r) {
            i("BGSW Runtime - On source changed", r), r.__plasmo_cs_changed__ && (a.csChanged ||= !0), r.__plasmo_page_changed__ && (a.pageChanged ||= !0), p();
        });
    }
});
c.runtime.onMessage.addListener(function(t) {
    return t.__plasmo_full_reload__ && (i("BGSW Runtime - On top-level code changed"), p()), !0;
});

},{}],"8oeFb":[function(require,module,exports) {
var _background = require("../../../src/background");

},{"../../../src/background":"kimL1"}],"kimL1":[function(require,module,exports) {
/**
 * MV3 Background Service Worker - Main Entry Point
 * 
 * Handles:
 * - Side panel initialization
 * - Extension lifecycle events
 * - Notion MCP OAuth and SSE connection
 */ var _indexJs = require("@modelcontextprotocol/sdk/client/index.js");
var _sseJs = require("@modelcontextprotocol/sdk/client/sse.js");
var _notionClient = require("./mcp/notionClient");
var _oauth = require("./mcp/oauth");
var _constants = require("./constants");
// ============================================================================
// Notion MCP State
// ============================================================================
let notionMcpClient = null;
let notionTokens = null;
let notionClientCredentials = null;
let oauthState = null;
let notionStatus = {
    state: "disconnected"
};
let isEnabled = false;
/**
 * Start OAuth flow for Notion MCP with dynamic client registration
 */ async function startNotionAuth() {
    try {
        console.log("[Background] Starting Notion OAuth flow with dynamic client registration");
        // Step 1: Register a dynamic client
        console.log("[Background] Registering dynamic client...");
        notionStatus = {
            state: "registering"
        };
        broadcastStatusUpdate();
        const clientCredentials = await (0, _oauth.registerDynamicClient)((0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI);
        // Store client credentials
        notionClientCredentials = clientCredentials;
        await (0, _oauth.storeClientCredentials)(clientCredentials);
        console.log("[Background] Dynamic client registered:", clientCredentials.client_id);
        // Step 2: Generate state for CSRF protection
        const state = (0, _oauth.generateState)();
        // Store state in memory for the callback
        oauthState = {
            state,
            codeVerifier: "",
            created_at: Date.now()
        };
        // Step 3: Build authorization URL using the dynamic client ID
        const authUrl = (0, _oauth.buildAuthUrl)(clientCredentials.client_id, (0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI, state);
        console.log("[Background] Launching OAuth with URL:", authUrl);
        // Update status
        notionStatus = {
            state: "authorizing"
        };
        broadcastStatusUpdate();
        // Step 4: Launch OAuth flow using Chrome Identity API
        const redirectUrl = await chrome.identity.launchWebAuthFlow({
            url: authUrl,
            interactive: true
        });
        if (!redirectUrl) throw new Error("OAuth flow cancelled");
        console.log("[Background] OAuth redirect URL:", redirectUrl);
        // Step 5: Extract code and state from redirect URL
        const url = new URL(redirectUrl);
        const code = url.searchParams.get("code");
        const returnedState = url.searchParams.get("state");
        if (!code) throw new Error("No authorization code received");
        // Verify state
        if (!oauthState || returnedState !== oauthState.state) throw new Error("State mismatch - possible CSRF attack");
        console.log("[Background] Exchanging code for tokens");
        // Step 6: Exchange code for tokens using dynamic client credentials
        const tokens = await (0, _oauth.exchangeCodeForTokens)(code, clientCredentials.client_id, clientCredentials.client_secret, (0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI);
        // Store tokens
        notionTokens = tokens;
        await (0, _oauth.storeTokens)(tokens);
        console.log("[Background] Tokens stored successfully");
        // Update status
        notionStatus = {
            state: "authenticated"
        };
        broadcastStatusUpdate();
        console.log("[Background] Notion MCP OAuth successful");
        return {
            success: true,
            data: {
                state: "authenticated"
            }
        };
    } catch (error) {
        console.error("[Background] Notion MCP OAuth error:", error);
        notionStatus = {
            state: "error",
            error: error instanceof Error ? error.message : "Authentication failed"
        };
        broadcastStatusUpdate();
        return {
            success: false,
            error: error instanceof Error ? error.message : "Authentication failed"
        };
    } finally{
        oauthState = null;
    }
}
/**
 * Refresh Notion access token
 */ async function refreshNotionToken() {
    if (!notionTokens?.refresh_token) {
        console.error("[Background] No refresh token available");
        notionStatus = {
            state: "needs-auth",
            error: "No refresh token"
        };
        broadcastStatusUpdate();
        return false;
    }
    // Load client credentials if not in memory
    if (!notionClientCredentials) notionClientCredentials = await (0, _oauth.getStoredClientCredentials)();
    if (!notionClientCredentials) {
        console.error("[Background] No client credentials available for token refresh");
        notionStatus = {
            state: "needs-auth",
            error: "No client credentials"
        };
        broadcastStatusUpdate();
        return false;
    }
    try {
        console.log("[Background] Refreshing Notion token");
        notionStatus = {
            state: "token-refresh"
        };
        broadcastStatusUpdate();
        const newTokens = await (0, _oauth.refreshAccessToken)(notionTokens.refresh_token, notionClientCredentials.client_id, notionClientCredentials.client_secret);
        notionTokens = newTokens;
        await (0, _oauth.storeTokens)(newTokens);
        notionStatus = {
            state: "authenticated"
        };
        broadcastStatusUpdate();
        console.log("[Background] Token refreshed successfully");
        return true;
    } catch (error) {
        console.error("[Background] Token refresh failed:", error);
        // Clear invalid tokens
        await (0, _oauth.clearTokens)();
        notionTokens = null;
        notionStatus = {
            state: "needs-auth",
            error: "Token refresh failed. Please re-authenticate."
        };
        broadcastStatusUpdate();
        return false;
    }
}
/**
 * Ensure we have a valid access token
 */ async function ensureValidToken() {
    if (!notionTokens) // Try to load from storage
    notionTokens = await (0, _oauth.getStoredTokens)();
    if (!notionTokens) return null;
    (0, _oauth.isTokenExpired)(notionTokens);
    return notionTokens.access_token;
}
// ============================================================================
// Notion MCP Connection Functions
// ============================================================================
/**
 * Connect to Notion MCP server
 */ async function connectNotionMcp() {
    try {
        console.log("[Background] Connecting to Notion MCP");
        const accessToken = await ensureValidToken();
        if (!accessToken) return {
            success: false,
            error: "Authentication required"
        };
        // Create SSE client
        notionMcpClient = new (0, _notionClient.McpSSEClient)((0, _constants.NOTION_CONFIG).MCP_SSE_URL, accessToken, {
            onStatusChange: (status)=>{
                notionStatus = status;
                broadcastStatusUpdate();
                // Handle token expiry (but not format errors)
                if (status.state === "needs-auth") ;
                else status.state;
            },
            onMessage: (message)=>{
                console.log("[Background] MCP message:", message);
            }
        });
        // Connect
        await notionMcpClient.connect();
        // Initialize MCP protocol
        await notionMcpClient.initialize();
        return {
            success: true,
            data: notionMcpClient.getStatus()
        };
    } catch (error) {
        console.error("[Background] Notion MCP connection error:", error);
        return {
            success: false,
            error: error instanceof Error ? error.message : "Connection failed"
        };
    }
}
/**
 * Disconnect from Notion MCP server
 */ function disconnectNotionMcp() {
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    notionStatus = {
        state: "authenticated"
    };
    broadcastStatusUpdate();
}
/**
 * Handle token expiry - attempt refresh and reconnect
 */ async function handleTokenExpiry() {
    console.log("[Background] Handling token expiry");
    // Disconnect current client
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    // Try to refresh
    const refreshed = await refreshNotionToken();
    // If enabled and refresh succeeded, reconnect
    if (refreshed && isEnabled) await connectNotionMcp();
}
/**
 * Handle invalid token format - clear tokens and require re-auth
 */ async function handleInvalidToken() {
    console.log("[Background] Handling invalid token format");
    // Disconnect current client
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    // Clear invalid tokens and client credentials - don't try to refresh
    await (0, _oauth.clearTokens)();
    await (0, _oauth.clearClientCredentials)();
    notionTokens = null;
    notionClientCredentials = null;
    notionStatus = {
        state: "invalid-token",
        error: "Invalid token format - please re-authenticate"
    };
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    broadcastStatusUpdate();
}
/**
 * Enable Notion MCP (connect if authenticated)
 */ async function enableNotionMcp() {
    isEnabled = true;
    // Store enabled state
    await chrome.storage.local.set({
        "mcp.notion.enabled": true
    });
    // If already connected, perform health check
    if (notionMcpClient && notionStatus.state === "connected") {
        console.log("[Background] Already connected, performing health check");
        const healthCheck = await performHealthCheck();
        if (healthCheck.success) return {
            success: true,
            data: notionStatus
        };
        else {
            console.warn("[Background] Health check failed, reconnecting...", healthCheck.error);
            // Health check failed, try to reconnect
            disconnectNotionMcp();
        }
    }
    // If authenticated, connect
    if (notionTokens || await (0, _oauth.getStoredTokens)()) {
        const connectResult = await connectNotionMcp();
        // If connection successful, perform health check
        if (connectResult.success && notionMcpClient) {
            console.log("[Background] Connection successful, performing health check");
            const healthCheck = await performHealthCheck();
            if (!healthCheck.success) {
                console.warn("[Background] Health check failed after connection:", healthCheck.error);
                notionStatus = {
                    ...notionStatus,
                    error: `Connected but health check failed: ${healthCheck.error}`
                };
                broadcastStatusUpdate();
            } else console.log("[Background] Health check passed:", healthCheck.data);
        }
        return connectResult;
    }
    // Otherwise, need auth
    return {
        success: false,
        error: "Authentication required. Please connect first."
    };
}
/**
 * Disable Notion MCP (disconnect)
 */ async function disableNotionMcp() {
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    disconnectNotionMcp();
    return {
        success: true
    };
}
/**
 * Disconnect and clear authentication
 */ async function disconnectNotionAuth() {
    disconnectNotionMcp();
    await (0, _oauth.clearTokens)();
    await (0, _oauth.clearClientCredentials)();
    notionTokens = null;
    notionClientCredentials = null;
    notionStatus = {
        state: "disconnected"
    };
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    broadcastStatusUpdate();
    return {
        success: true
    };
}
/**
 * Get current Notion MCP status
 */ function getNotionStatus() {
    return notionStatus;
}
/**
 * Perform health check on Notion MCP connection using official MCP SDK
 * Validates connection and retrieves available tools
 * Similar to: https://modelcontextprotocol.io/docs/tools/clients
 */ async function performHealthCheck() {
    let client = undefined;
    try {
        console.log("[Background] Performing Notion MCP health check with SDK");
        // Get access token
        const accessToken = await ensureValidToken();
        if (!accessToken) return {
            success: false,
            error: "No valid access token available"
        };
        const url = new URL((0, _constants.NOTION_CONFIG).MCP_SSE_URL);
        try {
            // Create MCP client
            client = new (0, _indexJs.Client)({
                name: "chrome-ai-health-check",
                version: "1.0.0"
            }, {
                capabilities: {
                    roots: {
                        listChanged: true
                    }
                }
            });
            console.log("[Background] Connecting to MCP server with SSE transport...");
            // Create SSE transport with authorization
            // Use requestInit to add Authorization header to POST requests
            const transport = new (0, _sseJs.SSEClientTransport)(url, {
                requestInit: {
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Accept": "application/json, text/event-stream"
                    }
                },
                // Use custom fetch to add Authorization header to SSE connection
                fetch: async (input, init)=>{
                    const headers = new Headers(init?.headers);
                    headers.set("Authorization", `Bearer ${accessToken}`);
                    headers.set("Accept", "text/event-stream, application/json");
                    return fetch(input, {
                        ...init,
                        headers
                    });
                }
            });
            // Connect to the server
            await client.connect(transport);
            console.log("[Background] Connected using SSE transport");
            // Get tools from the connected client
            const toolsResponse = await client.listTools();
            console.log("[Background] Tools response:", toolsResponse);
            // Disconnect after getting tools
            await client.close();
            if (toolsResponse && toolsResponse.tools) {
                const toolCount = toolsResponse.tools.length;
                console.log("[Background] Health check passed. Tools available:", toolCount);
                return {
                    success: true,
                    data: {
                        state: "connected",
                        tools: toolsResponse.tools.map((tool)=>({
                                name: tool.name,
                                description: tool.description,
                                inputSchema: tool.inputSchema
                            })),
                        toolCount: toolCount
                    }
                };
            } else return {
                success: false,
                error: "No tools available from server"
            };
        } catch (transportError) {
            console.error("[Background] Health check failed:", transportError);
            // Clean up client if exists
            if (client) try {
                await client.close();
            } catch (closeError) {
                console.error("[Background] Error closing client:", closeError);
            }
            return {
                success: false,
                error: transportError instanceof Error ? transportError.message : "Connection failed"
            };
        }
    } catch (error) {
        console.error("[Background] Health check error:", error);
        // Clean up client if exists
        if (client) try {
            await client.close();
        } catch (closeError) {
            console.error("[Background] Error closing client:", closeError);
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : "Health check failed"
        };
    }
}
/**
 * Call a Notion MCP tool
 */ async function callNotionTool(name, args) {
    if (!notionMcpClient) return {
        success: false,
        error: "Not connected"
    };
    try {
        const result = await notionMcpClient.callTool(name, args);
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error("[Background] Tool call error:", error);
        return {
            success: false,
            error: error instanceof Error ? error.message : "Tool call failed"
        };
    }
}
/**
 * Broadcast status update to all listeners
 */ function broadcastStatusUpdate() {
    chrome.runtime.sendMessage({
        type: "mcp/notion/status/update",
        payload: notionStatus
    }).catch(()=>{
    // Ignore errors if no listeners
    });
}
// ============================================================================
// Message Handler
// ============================================================================
chrome.runtime.onMessage.addListener((message, sender, sendResponse)=>{
    // Handle Notion MCP messages
    if (message.type?.startsWith("mcp/notion/")) {
        (async ()=>{
            let response;
            switch(message.type){
                case "mcp/notion/auth/start":
                    response = await startNotionAuth();
                    break;
                case "mcp/notion/enable":
                    response = await enableNotionMcp();
                    break;
                case "mcp/notion/disable":
                    response = await disableNotionMcp();
                    break;
                case "mcp/notion/disconnect":
                    response = await disconnectNotionAuth();
                    break;
                case "mcp/notion/status/get":
                    response = {
                        success: true,
                        data: getNotionStatus()
                    };
                    break;
                case "mcp/notion/tool/call":
                    response = await callNotionTool(message.payload?.name, message.payload?.arguments);
                    break;
                case "mcp/notion/health/check":
                    response = await performHealthCheck();
                    break;
                default:
                    response = {
                        success: false,
                        error: "Unknown message type"
                    };
            }
            sendResponse(response);
        })();
        return true; // Will respond asynchronously
    }
});
// ============================================================================
// Runtime Listeners
// ============================================================================
// Global notification click handler for reminders
chrome.notifications.onClicked.addListener(async (notificationId)=>{
    try {
        if (!notificationId.startsWith("reminder:")) return;
        const id = notificationId.split(":")[1];
        const { reminders = {} } = await chrome.storage.local.get("reminders");
        const reminder = reminders[id];
        if (reminder?.url) await chrome.tabs.create({
            url: reminder.url
        });
        // Cleanup: remove reminder and clear notification
        if (reminders[id]) {
            delete reminders[id];
            await chrome.storage.local.set({
                reminders
            });
        }
        chrome.notifications.clear(notificationId);
    } catch (error) {
        console.error("[Background] Error handling notification click:", error);
    }
});
/**
 * Extension install/update handler
 */ chrome.runtime.onInstalled.addListener(async (details)=>{
    console.log("[Background] onInstalled:", details.reason);
    try {
        // Enable side panel on all existing tabs
        if (chrome.sidePanel) chrome.sidePanel.setPanelBehavior({
            openPanelOnActionClick: true
        }).catch(console.error);
        // Load saved state
        const stored = await chrome.storage.local.get([
            "mcp.notion.enabled"
        ]);
        isEnabled = stored["mcp.notion.enabled"] || false;
        // If enabled, try to restore connection
        if (isEnabled) {
            const tokens = await (0, _oauth.getStoredTokens)();
            const credentials = await (0, _oauth.getStoredClientCredentials)();
            if (tokens && credentials) {
                notionTokens = tokens;
                notionClientCredentials = credentials;
                await connectNotionMcp();
            }
        }
        console.log("[Background] Side panel configured");
    } catch (error) {
        console.error("[Background] onInstalled error:", error);
    }
});
/**
 * Extension startup handler
 */ chrome.runtime.onStartup.addListener(async ()=>{
    console.log("[Background] onStartup - Extension ready");
    // Load saved state
    const stored = await chrome.storage.local.get([
        "mcp.notion.enabled"
    ]);
    isEnabled = stored["mcp.notion.enabled"] || false;
    // If enabled, try to restore connection
    if (isEnabled) {
        const tokens = await (0, _oauth.getStoredTokens)();
        const credentials = await (0, _oauth.getStoredClientCredentials)();
        if (tokens && credentials) {
            notionTokens = tokens;
            notionClientCredentials = credentials;
            await connectNotionMcp();
        }
    }
});
/**
 * Action click handler - open side panel
 */ if (chrome.action) chrome.action.onClicked.addListener(async (tab)=>{
    if (chrome.sidePanel && tab.id) try {
        await chrome.sidePanel.open({
            tabId: tab.id
        });
    } catch (error) {
        console.error("[Background] Error opening side panel:", error);
    }
});
// Create cleanup alarm (runs every hour)
chrome.alarms.create("cleanup-expired-sessions", {
    periodInMinutes: 60
});
/**
 * Handle reminder alarms - show notification when reminder fires
 */ chrome.alarms.onAlarm.addListener(async (alarm)=>{
    // Only handle reminder alarms
    if (!alarm.name.startsWith("reminder:")) return;
    const id = alarm.name.split(":")[1];
    console.log("[Background] Reminder alarm fired:", id);
    try {
        // Get the reminder from storage
        const { reminders = {} } = await chrome.storage.local.get("reminders");
        const reminder = reminders[id];
        if (!reminder) {
            console.warn("[Background] Reminder not found:", id);
            return;
        }
        // Create notification with AI-generated content or fallback to original title
        const simpleIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==";
        const notificationTitle = reminder.generatedTitle || "\u23f0 Reminder";
        const notificationMessage = reminder.generatedDescription || reminder.title;
        // Use a namespaced notification ID to distinguish reminders
        chrome.notifications.create(`reminder:${id}`, {
            type: "basic",
            iconUrl: simpleIcon,
            title: notificationTitle,
            message: notificationMessage,
            priority: 2,
            requireInteraction: false
        });
        console.log("[Background] Reminder notification created:", {
            title: notificationTitle,
            message: notificationMessage
        });
    // Do not remove the reminder here; it will be removed by the global
    // notification click handler to avoid race conditions and ensure the
    // click handler has access to the stored reminder data.
    } catch (error) {
        console.error("[Background] Error handling reminder alarm:", error);
    }
});
// ============================================================================
// Initialization
// ============================================================================
console.log("[Background] Service worker loaded - CopilotKit powered extension ready");
console.log("[Background] Browser actions event listeners initialized");
// ============================================================================
// Offscreen Document: Summarizer Broker
// ============================================================================
// Ensure a single offscreen document exists
async function ensureOffscreenDocument() {
    try {
        // Chrome 116+ has chrome.offscreen.hasDocument
        // Fallback: try creating and ignore if already exists
        const hasDoc = typeof chrome.offscreen?.hasDocument === "function" ? await chrome.offscreen.hasDocument() : false;
        if (!hasDoc) {
            await chrome.offscreen.createDocument({
                url: "offscreen.html",
                // Using IFRAME_SCRIPTING is appropriate for running DOM APIs & scripts
                reasons: [
                    chrome.offscreen.Reason.IFRAME_SCRIPTING
                ],
                justification: "Run Chrome Summarizer API in an isolated offscreen document"
            });
            console.log("[Background] Offscreen document created");
        }
    } catch (error) {
        // Some Chrome versions throw if a document already exists
        console.warn("[Background] ensureOffscreenDocument warning:", error);
    }
}
// Wire summarize messages coming from UI to the offscreen document
chrome.runtime.onMessage.addListener((message, _sender, sendResponse)=>{
    if (message?.type === "summarize:availability") {
        (async ()=>{
            await ensureOffscreenDocument();
            try {
                const res = await chrome.runtime.sendMessage({
                    type: "offscreen/summarize/availability"
                });
                sendResponse(res);
            } catch (error) {
                sendResponse({
                    ok: false,
                    code: "error",
                    message: error instanceof Error ? error.message : "unknown"
                });
            }
        })();
        return true;
    }
    if (message?.type === "summarize:request") {
        (async ()=>{
            const msg = message;
            await ensureOffscreenDocument();
            try {
                const res = await chrome.runtime.sendMessage({
                    type: "offscreen/summarize/request",
                    payload: msg.payload
                });
                sendResponse(res);
            } catch (error) {
                sendResponse({
                    ok: false,
                    code: "error",
                    message: error instanceof Error ? error.message : "unknown"
                });
            }
        })();
        return true;
    }
});

},{"@modelcontextprotocol/sdk/client/index.js":"em2GV","@modelcontextprotocol/sdk/client/sse.js":"630Jy","./mcp/notionClient":"apA8I","./mcp/oauth":"bEC4Y","./constants":"aZX5f"}],"em2GV":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Client = void 0;
const protocol_js_1 = require("31457f837fb41349");
const types_js_1 = require("42936a4e62889fac");
const ajv_1 = __importDefault(require("88c9732a6748db7e"));
/**
 * An MCP client on top of a pluggable transport.
 *
 * The client will automatically begin the initialization flow with the server when connect() is called.
 *
 * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
 *
 * ```typescript
 * // Custom schemas
 * const CustomRequestSchema = RequestSchema.extend({...})
 * const CustomNotificationSchema = NotificationSchema.extend({...})
 * const CustomResultSchema = ResultSchema.extend({...})
 *
 * // Type aliases
 * type CustomRequest = z.infer<typeof CustomRequestSchema>
 * type CustomNotification = z.infer<typeof CustomNotificationSchema>
 * type CustomResult = z.infer<typeof CustomResultSchema>
 *
 * // Create typed client
 * const client = new Client<CustomRequest, CustomNotification, CustomResult>({
 *   name: "CustomClient",
 *   version: "1.0.0"
 * })
 * ```
 */ class Client extends protocol_js_1.Protocol {
    /**
     * Initializes this client with the given name and version information.
     */ constructor(_clientInfo, options){
        var _a;
        super(options);
        this._clientInfo = _clientInfo;
        this._cachedToolOutputValidators = new Map();
        this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
        this._ajv = new ajv_1.default();
    }
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */ registerCapabilities(capabilities) {
        if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
        this._capabilities = (0, protocol_js_1.mergeCapabilities)(this._capabilities, capabilities);
    }
    assertCapability(capability, method) {
        var _a;
        if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
    async connect(transport, options) {
        await super.connect(transport);
        // When transport sessionId is already set this means we are trying to reconnect.
        // In this case we don't need to initialize again.
        if (transport.sessionId !== undefined) return;
        try {
            const result = await this.request({
                method: "initialize",
                params: {
                    protocolVersion: types_js_1.LATEST_PROTOCOL_VERSION,
                    capabilities: this._capabilities,
                    clientInfo: this._clientInfo
                }
            }, types_js_1.InitializeResultSchema, options);
            if (result === undefined) throw new Error(`Server sent invalid initialize result: ${result}`);
            if (!types_js_1.SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
            this._serverCapabilities = result.capabilities;
            this._serverVersion = result.serverInfo;
            // HTTP transports must set the protocol version in each header after initialization.
            if (transport.setProtocolVersion) transport.setProtocolVersion(result.protocolVersion);
            this._instructions = result.instructions;
            await this.notification({
                method: "notifications/initialized"
            });
        } catch (error) {
            this.close();
            throw error;
        }
    }
    /**
     * After initialization has completed, this will be populated with the server's reported capabilities.
     */ getServerCapabilities() {
        return this._serverCapabilities;
    }
    /**
     * After initialization has completed, this will be populated with information about the server's name and version.
     */ getServerVersion() {
        return this._serverVersion;
    }
    /**
     * After initialization has completed, this may be populated with information about the server's instructions.
     */ getInstructions() {
        return this._instructions;
    }
    assertCapabilityForMethod(method) {
        var _a, _b, _c, _d, _e;
        switch(method){
            case "logging/setLevel":
                if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) throw new Error(`Server does not support logging (required for ${method})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) throw new Error(`Server does not support prompts (required for ${method})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
            case "resources/subscribe":
            case "resources/unsubscribe":
                if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) throw new Error(`Server does not support resources (required for ${method})`);
                if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) throw new Error(`Server does not support resource subscriptions (required for ${method})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) throw new Error(`Server does not support tools (required for ${method})`);
                break;
            case "completion/complete":
                if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) throw new Error(`Server does not support completions (required for ${method})`);
                break;
            case "initialize":
                break;
            case "ping":
                break;
        }
    }
    assertNotificationCapability(method) {
        var _a;
        switch(method){
            case "notifications/roots/list_changed":
                if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
                break;
            case "notifications/initialized":
                break;
            case "notifications/cancelled":
                break;
            case "notifications/progress":
                break;
        }
    }
    assertRequestHandlerCapability(method) {
        switch(method){
            case "sampling/createMessage":
                if (!this._capabilities.sampling) throw new Error(`Client does not support sampling capability (required for ${method})`);
                break;
            case "elicitation/create":
                if (!this._capabilities.elicitation) throw new Error(`Client does not support elicitation capability (required for ${method})`);
                break;
            case "roots/list":
                if (!this._capabilities.roots) throw new Error(`Client does not support roots capability (required for ${method})`);
                break;
            case "ping":
                break;
        }
    }
    async ping(options) {
        return this.request({
            method: "ping"
        }, types_js_1.EmptyResultSchema, options);
    }
    async complete(params, options) {
        return this.request({
            method: "completion/complete",
            params
        }, types_js_1.CompleteResultSchema, options);
    }
    async setLoggingLevel(level, options) {
        return this.request({
            method: "logging/setLevel",
            params: {
                level
            }
        }, types_js_1.EmptyResultSchema, options);
    }
    async getPrompt(params, options) {
        return this.request({
            method: "prompts/get",
            params
        }, types_js_1.GetPromptResultSchema, options);
    }
    async listPrompts(params, options) {
        return this.request({
            method: "prompts/list",
            params
        }, types_js_1.ListPromptsResultSchema, options);
    }
    async listResources(params, options) {
        return this.request({
            method: "resources/list",
            params
        }, types_js_1.ListResourcesResultSchema, options);
    }
    async listResourceTemplates(params, options) {
        return this.request({
            method: "resources/templates/list",
            params
        }, types_js_1.ListResourceTemplatesResultSchema, options);
    }
    async readResource(params, options) {
        return this.request({
            method: "resources/read",
            params
        }, types_js_1.ReadResourceResultSchema, options);
    }
    async subscribeResource(params, options) {
        return this.request({
            method: "resources/subscribe",
            params
        }, types_js_1.EmptyResultSchema, options);
    }
    async unsubscribeResource(params, options) {
        return this.request({
            method: "resources/unsubscribe",
            params
        }, types_js_1.EmptyResultSchema, options);
    }
    async callTool(params, resultSchema = types_js_1.CallToolResultSchema, options) {
        const result = await this.request({
            method: "tools/call",
            params
        }, resultSchema, options);
        // Check if the tool has an outputSchema
        const validator = this.getToolOutputValidator(params.name);
        if (validator) {
            // If tool has outputSchema, it MUST return structuredContent (unless it's an error)
            if (!result.structuredContent && !result.isError) throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
            // Only validate structured content if present (not when there's an error)
            if (result.structuredContent) try {
                // Validate the structured content (which is already an object) against the schema
                const isValid = validator(result.structuredContent);
                if (!isValid) throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`);
            } catch (error) {
                if (error instanceof types_js_1.McpError) throw error;
                throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return result;
    }
    cacheToolOutputSchemas(tools) {
        this._cachedToolOutputValidators.clear();
        for (const tool of tools){
            // If the tool has an outputSchema, create and cache the Ajv validator
            if (tool.outputSchema) try {
                const validator = this._ajv.compile(tool.outputSchema);
                this._cachedToolOutputValidators.set(tool.name, validator);
            } catch (_a) {
            // Ignore schema compilation errors
            }
        }
    }
    getToolOutputValidator(toolName) {
        return this._cachedToolOutputValidators.get(toolName);
    }
    async listTools(params, options) {
        const result = await this.request({
            method: "tools/list",
            params
        }, types_js_1.ListToolsResultSchema, options);
        // Cache the tools and their output schemas for future validation
        this.cacheToolOutputSchemas(result.tools);
        return result;
    }
    async sendRootsListChanged() {
        return this.notification({
            method: "notifications/roots/list_changed"
        });
    }
}
exports.Client = Client;

},{"31457f837fb41349":"c36uq","42936a4e62889fac":"cqTxf","88c9732a6748db7e":"fIIXC"}],"c36uq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Protocol = exports.DEFAULT_REQUEST_TIMEOUT_MSEC = void 0;
exports.mergeCapabilities = mergeCapabilities;
const types_js_1 = require("d2c272aeee3e37dc");
/**
 * The default request timeout, in miliseconds.
 */ exports.DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
/**
 * Implements MCP protocol framing on top of a pluggable transport, including
 * features like request/response linking, notifications, and progress.
 */ class Protocol {
    constructor(_options){
        this._options = _options;
        this._requestMessageId = 0;
        this._requestHandlers = new Map();
        this._requestHandlerAbortControllers = new Map();
        this._notificationHandlers = new Map();
        this._responseHandlers = new Map();
        this._progressHandlers = new Map();
        this._timeoutInfo = new Map();
        this._pendingDebouncedNotifications = new Set();
        this.setNotificationHandler(types_js_1.CancelledNotificationSchema, (notification)=>{
            const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
            controller === null || controller === void 0 || controller.abort(notification.params.reason);
        });
        this.setNotificationHandler(types_js_1.ProgressNotificationSchema, (notification)=>{
            this._onprogress(notification);
        });
        this.setRequestHandler(types_js_1.PingRequestSchema, // Automatic pong by default.
        (_request)=>({}));
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
        this._timeoutInfo.set(messageId, {
            timeoutId: setTimeout(onTimeout, timeout),
            startTime: Date.now(),
            timeout,
            maxTotalTimeout,
            resetTimeoutOnProgress,
            onTimeout
        });
    }
    _resetTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (!info) return false;
        const totalElapsed = Date.now() - info.startTime;
        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
            this._timeoutInfo.delete(messageId);
            throw new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
                maxTotalTimeout: info.maxTotalTimeout,
                totalElapsed
            });
        }
        clearTimeout(info.timeoutId);
        info.timeoutId = setTimeout(info.onTimeout, info.timeout);
        return true;
    }
    _cleanupTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (info) {
            clearTimeout(info.timeoutId);
            this._timeoutInfo.delete(messageId);
        }
    }
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */ async connect(transport) {
        var _a, _b, _c;
        this._transport = transport;
        const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
        this._transport.onclose = ()=>{
            _onclose === null || _onclose === void 0 || _onclose();
            this._onclose();
        };
        const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
        this._transport.onerror = (error)=>{
            _onerror === null || _onerror === void 0 || _onerror(error);
            this._onerror(error);
        };
        const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
        this._transport.onmessage = (message, extra)=>{
            _onmessage === null || _onmessage === void 0 || _onmessage(message, extra);
            if ((0, types_js_1.isJSONRPCResponse)(message) || (0, types_js_1.isJSONRPCError)(message)) this._onresponse(message);
            else if ((0, types_js_1.isJSONRPCRequest)(message)) this._onrequest(message, extra);
            else if ((0, types_js_1.isJSONRPCNotification)(message)) this._onnotification(message);
            else this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
        };
        await this._transport.start();
    }
    _onclose() {
        var _a;
        const responseHandlers = this._responseHandlers;
        this._responseHandlers = new Map();
        this._progressHandlers.clear();
        this._pendingDebouncedNotifications.clear();
        this._transport = undefined;
        (_a = this.onclose) === null || _a === void 0 || _a.call(this);
        const error = new types_js_1.McpError(types_js_1.ErrorCode.ConnectionClosed, "Connection closed");
        for (const handler of responseHandlers.values())handler(error);
    }
    _onerror(error) {
        var _a;
        (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
    }
    _onnotification(notification) {
        var _a;
        const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
        // Ignore notifications not being subscribed to.
        if (handler === undefined) return;
        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.
        Promise.resolve().then(()=>handler(notification)).catch((error)=>this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
        var _a, _b;
        const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
        // Capture the current transport at request time to ensure responses go to the correct client
        const capturedTransport = this._transport;
        if (handler === undefined) {
            capturedTransport === null || capturedTransport === void 0 || capturedTransport.send({
                jsonrpc: "2.0",
                id: request.id,
                error: {
                    code: types_js_1.ErrorCode.MethodNotFound,
                    message: "Method not found"
                }
            }).catch((error)=>this._onerror(new Error(`Failed to send an error response: ${error}`)));
            return;
        }
        const abortController = new AbortController();
        this._requestHandlerAbortControllers.set(request.id, abortController);
        const fullExtra = {
            signal: abortController.signal,
            sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
            _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
            sendNotification: (notification)=>this.notification(notification, {
                    relatedRequestId: request.id
                }),
            sendRequest: (r, resultSchema, options)=>this.request(r, resultSchema, {
                    ...options,
                    relatedRequestId: request.id
                }),
            authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
            requestId: request.id,
            requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
        };
        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.
        Promise.resolve().then(()=>handler(request, fullExtra)).then((result)=>{
            if (abortController.signal.aborted) return;
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                result,
                jsonrpc: "2.0",
                id: request.id
            });
        }, (error)=>{
            var _a;
            if (abortController.signal.aborted) return;
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                jsonrpc: "2.0",
                id: request.id,
                error: {
                    code: Number.isSafeInteger(error["code"]) ? error["code"] : types_js_1.ErrorCode.InternalError,
                    message: (_a = error.message) !== null && _a !== void 0 ? _a : "Internal error"
                }
            });
        }).catch((error)=>this._onerror(new Error(`Failed to send response: ${error}`))).finally(()=>{
            this._requestHandlerAbortControllers.delete(request.id);
        });
    }
    _onprogress(notification) {
        const { progressToken, ...params } = notification.params;
        const messageId = Number(progressToken);
        const handler = this._progressHandlers.get(messageId);
        if (!handler) {
            this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
            return;
        }
        const responseHandler = this._responseHandlers.get(messageId);
        const timeoutInfo = this._timeoutInfo.get(messageId);
        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) try {
            this._resetTimeout(messageId);
        } catch (error) {
            responseHandler(error);
            return;
        }
        handler(params);
    }
    _onresponse(response) {
        const messageId = Number(response.id);
        const handler = this._responseHandlers.get(messageId);
        if (handler === undefined) {
            this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
            return;
        }
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        if ((0, types_js_1.isJSONRPCResponse)(response)) handler(response);
        else {
            const error = new types_js_1.McpError(response.error.code, response.error.message, response.error.data);
            handler(error);
        }
    }
    get transport() {
        return this._transport;
    }
    /**
     * Closes the connection.
     */ async close() {
        var _a;
        await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
    }
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */ request(request, resultSchema, options) {
        const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
        return new Promise((resolve, reject)=>{
            var _a, _b, _c, _d, _e, _f;
            if (!this._transport) {
                reject(new Error("Not connected"));
                return;
            }
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) this.assertCapabilityForMethod(request.method);
            (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 || _b.throwIfAborted();
            const messageId = this._requestMessageId++;
            const jsonrpcRequest = {
                ...request,
                jsonrpc: "2.0",
                id: messageId
            };
            if (options === null || options === void 0 ? void 0 : options.onprogress) {
                this._progressHandlers.set(messageId, options.onprogress);
                jsonrpcRequest.params = {
                    ...request.params,
                    _meta: {
                        ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
                        progressToken: messageId
                    }
                };
            }
            const cancel = (reason)=>{
                var _a;
                this._responseHandlers.delete(messageId);
                this._progressHandlers.delete(messageId);
                this._cleanupTimeout(messageId);
                (_a = this._transport) === null || _a === void 0 || _a.send({
                    jsonrpc: "2.0",
                    method: "notifications/cancelled",
                    params: {
                        requestId: messageId,
                        reason: String(reason)
                    }
                }, {
                    relatedRequestId,
                    resumptionToken,
                    onresumptiontoken
                }).catch((error)=>this._onerror(new Error(`Failed to send cancellation: ${error}`)));
                reject(reason);
            };
            this._responseHandlers.set(messageId, (response)=>{
                var _a;
                if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) return;
                if (response instanceof Error) return reject(response);
                try {
                    const result = resultSchema.parse(response.result);
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            });
            (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 || _d.addEventListener("abort", ()=>{
                var _a;
                cancel((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.reason);
            });
            const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : exports.DEFAULT_REQUEST_TIMEOUT_MSEC;
            const timeoutHandler = ()=>cancel(new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Request timed out", {
                    timeout
                }));
            this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
            this._transport.send(jsonrpcRequest, {
                relatedRequestId,
                resumptionToken,
                onresumptiontoken
            }).catch((error)=>{
                this._cleanupTimeout(messageId);
                reject(error);
            });
        });
    }
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */ async notification(notification, options) {
        var _a, _b;
        if (!this._transport) throw new Error("Not connected");
        this.assertNotificationCapability(notification.method);
        const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
        // A notification can only be debounced if it's in the list AND it's "simple"
        // (i.e., has no parameters and no related request ID that could be lost).
        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
        if (canDebounce) {
            // If a notification of this type is already scheduled, do nothing.
            if (this._pendingDebouncedNotifications.has(notification.method)) return;
            // Mark this notification type as pending.
            this._pendingDebouncedNotifications.add(notification.method);
            // Schedule the actual send to happen in the next microtask.
            // This allows all synchronous calls in the current event loop tick to be coalesced.
            Promise.resolve().then(()=>{
                var _a;
                // Un-mark the notification so the next one can be scheduled.
                this._pendingDebouncedNotifications.delete(notification.method);
                // SAFETY CHECK: If the connection was closed while this was pending, abort.
                if (!this._transport) return;
                const jsonrpcNotification = {
                    ...notification,
                    jsonrpc: "2.0"
                };
                // Send the notification, but don't await it here to avoid blocking.
                // Handle potential errors with a .catch().
                (_a = this._transport) === null || _a === void 0 || _a.send(jsonrpcNotification, options).catch((error)=>this._onerror(error));
            });
            // Return immediately.
            return;
        }
        const jsonrpcNotification = {
            ...notification,
            jsonrpc: "2.0"
        };
        await this._transport.send(jsonrpcNotification, options);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */ setRequestHandler(requestSchema, handler) {
        const method = requestSchema.shape.method.value;
        this.assertRequestHandlerCapability(method);
        this._requestHandlers.set(method, (request, extra)=>{
            return Promise.resolve(handler(requestSchema.parse(request), extra));
        });
    }
    /**
     * Removes the request handler for the given method.
     */ removeRequestHandler(method) {
        this._requestHandlers.delete(method);
    }
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */ assertCanSetRequestHandler(method) {
        if (this._requestHandlers.has(method)) throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */ setNotificationHandler(notificationSchema, handler) {
        this._notificationHandlers.set(notificationSchema.shape.method.value, (notification)=>Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    /**
     * Removes the notification handler for the given method.
     */ removeNotificationHandler(method) {
        this._notificationHandlers.delete(method);
    }
}
exports.Protocol = Protocol;
function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value])=>{
        if (value && typeof value === "object") acc[key] = acc[key] ? {
            ...acc[key],
            ...value
        } : value;
        else acc[key] = value;
        return acc;
    }, {
        ...base
    });
}

},{"d2c272aeee3e37dc":"cqTxf"}],"cqTxf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceListChangedNotificationSchema = exports.ReadResourceResultSchema = exports.ReadResourceRequestSchema = exports.ListResourceTemplatesResultSchema = exports.ListResourceTemplatesRequestSchema = exports.ListResourcesResultSchema = exports.ListResourcesRequestSchema = exports.ResourceTemplateSchema = exports.ResourceSchema = exports.BlobResourceContentsSchema = exports.TextResourceContentsSchema = exports.ResourceContentsSchema = exports.PaginatedResultSchema = exports.PaginatedRequestSchema = exports.ProgressNotificationSchema = exports.ProgressSchema = exports.PingRequestSchema = exports.isInitializedNotification = exports.InitializedNotificationSchema = exports.InitializeResultSchema = exports.ServerCapabilitiesSchema = exports.isInitializeRequest = exports.InitializeRequestSchema = exports.ClientCapabilitiesSchema = exports.ImplementationSchema = exports.BaseMetadataSchema = exports.IconsSchema = exports.IconSchema = exports.CancelledNotificationSchema = exports.EmptyResultSchema = exports.JSONRPCMessageSchema = exports.isJSONRPCError = exports.JSONRPCErrorSchema = exports.ErrorCode = exports.isJSONRPCResponse = exports.JSONRPCResponseSchema = exports.isJSONRPCNotification = exports.JSONRPCNotificationSchema = exports.isJSONRPCRequest = exports.JSONRPCRequestSchema = exports.RequestIdSchema = exports.ResultSchema = exports.NotificationSchema = exports.RequestSchema = exports.CursorSchema = exports.ProgressTokenSchema = exports.JSONRPC_VERSION = exports.SUPPORTED_PROTOCOL_VERSIONS = exports.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = exports.LATEST_PROTOCOL_VERSION = void 0;
exports.ClientRequestSchema = exports.RootsListChangedNotificationSchema = exports.ListRootsResultSchema = exports.ListRootsRequestSchema = exports.RootSchema = exports.CompleteResultSchema = exports.CompleteRequestSchema = exports.PromptReferenceSchema = exports.ResourceReferenceSchema = exports.ResourceTemplateReferenceSchema = exports.ElicitResultSchema = exports.ElicitRequestSchema = exports.PrimitiveSchemaDefinitionSchema = exports.EnumSchemaSchema = exports.NumberSchemaSchema = exports.StringSchemaSchema = exports.BooleanSchemaSchema = exports.CreateMessageResultSchema = exports.CreateMessageRequestSchema = exports.SamplingMessageSchema = exports.ModelPreferencesSchema = exports.ModelHintSchema = exports.LoggingMessageNotificationSchema = exports.SetLevelRequestSchema = exports.LoggingLevelSchema = exports.ToolListChangedNotificationSchema = exports.CallToolRequestSchema = exports.CompatibilityCallToolResultSchema = exports.CallToolResultSchema = exports.ListToolsResultSchema = exports.ListToolsRequestSchema = exports.ToolSchema = exports.ToolAnnotationsSchema = exports.PromptListChangedNotificationSchema = exports.GetPromptResultSchema = exports.PromptMessageSchema = exports.ContentBlockSchema = exports.ResourceLinkSchema = exports.EmbeddedResourceSchema = exports.AudioContentSchema = exports.ImageContentSchema = exports.TextContentSchema = exports.GetPromptRequestSchema = exports.ListPromptsResultSchema = exports.ListPromptsRequestSchema = exports.PromptSchema = exports.PromptArgumentSchema = exports.ResourceUpdatedNotificationSchema = exports.UnsubscribeRequestSchema = exports.SubscribeRequestSchema = void 0;
exports.McpError = exports.ServerResultSchema = exports.ServerNotificationSchema = exports.ServerRequestSchema = exports.ClientResultSchema = exports.ClientNotificationSchema = void 0;
const zod_1 = require("10ab419ef9be205a");
exports.LATEST_PROTOCOL_VERSION = "2025-06-18";
exports.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
exports.SUPPORTED_PROTOCOL_VERSIONS = [
    exports.LATEST_PROTOCOL_VERSION,
    "2025-03-26",
    "2024-11-05",
    "2024-10-07"
];
/* JSON-RPC types */ exports.JSONRPC_VERSION = "2.0";
/**
 * A progress token, used to associate progress notifications with the original request.
 */ exports.ProgressTokenSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number().int()
]);
/**
 * An opaque token used to represent a cursor for pagination.
 */ exports.CursorSchema = zod_1.z.string();
const RequestMetaSchema = zod_1.z.object({
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */ progressToken: zod_1.z.optional(exports.ProgressTokenSchema)
}).passthrough();
const BaseRequestParamsSchema = zod_1.z.object({
    _meta: zod_1.z.optional(RequestMetaSchema)
}).passthrough();
exports.RequestSchema = zod_1.z.object({
    method: zod_1.z.string(),
    params: zod_1.z.optional(BaseRequestParamsSchema)
});
const BaseNotificationParamsSchema = zod_1.z.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
exports.NotificationSchema = zod_1.z.object({
    method: zod_1.z.string(),
    params: zod_1.z.optional(BaseNotificationParamsSchema)
});
exports.ResultSchema = zod_1.z.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * A uniquely identifying ID for a request in JSON-RPC.
 */ exports.RequestIdSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number().int()
]);
/**
 * A request that expects a response.
 */ exports.JSONRPCRequestSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema
}).merge(exports.RequestSchema).strict();
const isJSONRPCRequest = (value)=>exports.JSONRPCRequestSchema.safeParse(value).success;
exports.isJSONRPCRequest = isJSONRPCRequest;
/**
 * A notification which does not expect a response.
 */ exports.JSONRPCNotificationSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION)
}).merge(exports.NotificationSchema).strict();
const isJSONRPCNotification = (value)=>exports.JSONRPCNotificationSchema.safeParse(value).success;
exports.isJSONRPCNotification = isJSONRPCNotification;
/**
 * A successful (non-error) response to a request.
 */ exports.JSONRPCResponseSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema,
    result: exports.ResultSchema
}).strict();
const isJSONRPCResponse = (value)=>exports.JSONRPCResponseSchema.safeParse(value).success;
exports.isJSONRPCResponse = isJSONRPCResponse;
/**
 * Error codes defined by the JSON-RPC specification.
 */ var ErrorCode;
(function(ErrorCode) {
    // SDK error codes
    ErrorCode[ErrorCode["ConnectionClosed"] = -32000] = "ConnectionClosed";
    ErrorCode[ErrorCode["RequestTimeout"] = -32001] = "RequestTimeout";
    // Standard JSON-RPC error codes
    ErrorCode[ErrorCode["ParseError"] = -32700] = "ParseError";
    ErrorCode[ErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode[ErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode[ErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode[ErrorCode["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));
/**
 * A response to a request that indicates an error occurred.
 */ exports.JSONRPCErrorSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema,
    error: zod_1.z.object({
        /**
         * The error type that occurred.
         */ code: zod_1.z.number().int(),
        /**
         * A short description of the error. The message SHOULD be limited to a concise single sentence.
         */ message: zod_1.z.string(),
        /**
         * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
         */ data: zod_1.z.optional(zod_1.z.unknown())
    })
}).strict();
const isJSONRPCError = (value)=>exports.JSONRPCErrorSchema.safeParse(value).success;
exports.isJSONRPCError = isJSONRPCError;
exports.JSONRPCMessageSchema = zod_1.z.union([
    exports.JSONRPCRequestSchema,
    exports.JSONRPCNotificationSchema,
    exports.JSONRPCResponseSchema,
    exports.JSONRPCErrorSchema
]);
/* Empty result */ /**
 * A response that indicates success but carries no data.
 */ exports.EmptyResultSchema = exports.ResultSchema.strict();
/* Cancellation */ /**
 * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
 *
 * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
 *
 * This notification indicates that the result will be unused, so any associated processing SHOULD cease.
 *
 * A client MUST NOT attempt to cancel its `initialize` request.
 */ exports.CancelledNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */ requestId: exports.RequestIdSchema,
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */ reason: zod_1.z.string().optional()
    })
});
/* Base Metadata */ /**
 * Icon schema for use in tools, prompts, resources, and implementations.
 */ exports.IconSchema = zod_1.z.object({
    /**
     * URL or data URI for the icon.
     */ src: zod_1.z.string(),
    /**
     * Optional MIME type for the icon.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * Optional array of strings that specify sizes at which the icon can be used.
     * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
     *
     * If not provided, the client should assume that the icon can be used at any size.
     */ sizes: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
}).passthrough();
/**
 * Base schema to add `icons` property.
 *
 */ exports.IconsSchema = zod_1.z.object({
    /**
     * Optional set of sized icons that the client can display in a user interface.
     *
     * Clients that support rendering icons MUST support at least the following MIME types:
     * - `image/png` - PNG images (safe, universal compatibility)
     * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
     *
     * Clients that support rendering icons SHOULD also support:
     * - `image/svg+xml` - SVG images (scalable but requires security precautions)
     * - `image/webp` - WebP images (modern, efficient format)
     */ icons: zod_1.z.array(exports.IconSchema).optional()
}).passthrough();
/**
 * Base metadata interface for common properties across resources, tools, prompts, and implementations.
 */ exports.BaseMetadataSchema = zod_1.z.object({
    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */ name: zod_1.z.string(),
    /**
     * Intended for UI and end-user contexts \u2014 optimized to be human-readable and easily understood,
     * even by those unfamiliar with domain-specific terminology.
     *
     * If not provided, the name should be used for display (except for Tool,
     * where `annotations.title` should be given precedence over using `name`,
     * if present).
     */ title: zod_1.z.optional(zod_1.z.string())
}).passthrough();
/* Initialization */ /**
 * Describes the name and version of an MCP implementation.
 */ exports.ImplementationSchema = exports.BaseMetadataSchema.extend({
    version: zod_1.z.string(),
    /**
     * An optional URL of the website for this implementation.
     */ websiteUrl: zod_1.z.optional(zod_1.z.string())
}).merge(exports.IconsSchema);
/**
 * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
 */ exports.ClientCapabilitiesSchema = zod_1.z.object({
    /**
     * Experimental, non-standard capabilities that the client supports.
     */ experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports sampling from an LLM.
     */ sampling: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports eliciting user input.
     */ elicitation: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports listing roots.
     */ roots: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough())
}).passthrough();
/**
 * This request is sent from the client to the server when it first connects, asking it to begin initialization.
 */ exports.InitializeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
         */ protocolVersion: zod_1.z.string(),
        capabilities: exports.ClientCapabilitiesSchema,
        clientInfo: exports.ImplementationSchema
    })
});
const isInitializeRequest = (value)=>exports.InitializeRequestSchema.safeParse(value).success;
exports.isInitializeRequest = isInitializeRequest;
/**
 * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
 */ exports.ServerCapabilitiesSchema = zod_1.z.object({
    /**
     * Experimental, non-standard capabilities that the server supports.
     */ experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server supports sending log messages to the client.
     */ logging: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server supports sending completions to the client.
     */ completions: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server offers any prompt templates.
     */ prompts: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any resources to read.
     */ resources: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports clients subscribing to resource updates.
         */ subscribe: zod_1.z.optional(zod_1.z.boolean()),
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any tools to call.
     */ tools: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough())
}).passthrough();
/**
 * After receiving an initialize request from the client, the server sends this response.
 */ exports.InitializeResultSchema = exports.ResultSchema.extend({
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */ protocolVersion: zod_1.z.string(),
    capabilities: exports.ServerCapabilitiesSchema,
    serverInfo: exports.ImplementationSchema,
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */ instructions: zod_1.z.optional(zod_1.z.string())
});
/**
 * This notification is sent from the client to the server after initialization has finished.
 */ exports.InitializedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/initialized")
});
const isInitializedNotification = (value)=>exports.InitializedNotificationSchema.safeParse(value).success;
exports.isInitializedNotification = isInitializedNotification;
/* Ping */ /**
 * A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
 */ exports.PingRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("ping")
});
/* Progress notifications */ exports.ProgressSchema = zod_1.z.object({
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */ progress: zod_1.z.number(),
    /**
     * Total number of items to process (or total progress required), if known.
     */ total: zod_1.z.optional(zod_1.z.number()),
    /**
     * An optional message describing the current progress.
     */ message: zod_1.z.optional(zod_1.z.string())
}).passthrough();
/**
 * An out-of-band notification used to inform the receiver of a progress update for a long-running request.
 */ exports.ProgressNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(exports.ProgressSchema).extend({
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */ progressToken: exports.ProgressTokenSchema
    })
});
/* Pagination */ exports.PaginatedRequestSchema = exports.RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
        /**
         * An opaque token representing the current pagination position.
         * If provided, the server should return results starting after this cursor.
         */ cursor: zod_1.z.optional(exports.CursorSchema)
    }).optional()
});
exports.PaginatedResultSchema = exports.ResultSchema.extend({
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */ nextCursor: zod_1.z.optional(exports.CursorSchema)
});
/* Resources */ /**
 * The contents of a specific resource or sub-resource.
 */ exports.ResourceContentsSchema = zod_1.z.object({
    /**
     * The URI of this resource.
     */ uri: zod_1.z.string(),
    /**
     * The MIME type of this resource, if known.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
exports.TextResourceContentsSchema = exports.ResourceContentsSchema.extend({
    /**
     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
     */ text: zod_1.z.string()
});
/**
 * A Zod schema for validating Base64 strings that is more performant and
 * robust for very large inputs than the default regex-based check. It avoids
 * stack overflows by using the native `atob` function for validation.
 */ const Base64Schema = zod_1.z.string().refine((val)=>{
    try {
        // atob throws a DOMException if the string contains characters
        // that are not part of the Base64 character set.
        atob(val);
        return true;
    } catch (_a) {
        return false;
    }
}, {
    message: "Invalid Base64 string"
});
exports.BlobResourceContentsSchema = exports.ResourceContentsSchema.extend({
    /**
     * A base64-encoded string representing the binary data of the item.
     */ blob: Base64Schema
});
/**
 * A known resource that the server is capable of reading.
 */ exports.ResourceSchema = exports.BaseMetadataSchema.extend({
    /**
     * The URI of this resource.
     */ uri: zod_1.z.string(),
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * The MIME type of this resource, if known.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * A template description for resources available on the server.
 */ exports.ResourceTemplateSchema = exports.BaseMetadataSchema.extend({
    /**
     * A URI template (according to RFC 6570) that can be used to construct resource URIs.
     */ uriTemplate: zod_1.z.string(),
    /**
     * A description of what this template is for.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of resources the server has.
 */ exports.ListResourcesRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("resources/list")
});
/**
 * The server's response to a resources/list request from the client.
 */ exports.ListResourcesResultSchema = exports.PaginatedResultSchema.extend({
    resources: zod_1.z.array(exports.ResourceSchema)
});
/**
 * Sent from the client to request a list of resource templates the server has.
 */ exports.ListResourceTemplatesRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("resources/templates/list")
});
/**
 * The server's response to a resources/templates/list request from the client.
 */ exports.ListResourceTemplatesResultSchema = exports.PaginatedResultSchema.extend({
    resourceTemplates: zod_1.z.array(exports.ResourceTemplateSchema)
});
/**
 * Sent from the client to the server, to read a specific resource URI.
 */ exports.ReadResourceRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
         */ uri: zod_1.z.string()
    })
});
/**
 * The server's response to a resources/read request from the client.
 */ exports.ReadResourceResultSchema = exports.ResultSchema.extend({
    contents: zod_1.z.array(zod_1.z.union([
        exports.TextResourceContentsSchema,
        exports.BlobResourceContentsSchema
    ]))
});
/**
 * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.ResourceListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/resources/list_changed")
});
/**
 * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
 */ exports.SubscribeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
         */ uri: zod_1.z.string()
    })
});
/**
 * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
 */ exports.UnsubscribeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to unsubscribe from.
         */ uri: zod_1.z.string()
    })
});
/**
 * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
 */ exports.ResourceUpdatedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */ uri: zod_1.z.string()
    })
});
/* Prompts */ /**
 * Describes an argument that a prompt can accept.
 */ exports.PromptArgumentSchema = zod_1.z.object({
    /**
     * The name of the argument.
     */ name: zod_1.z.string(),
    /**
     * A human-readable description of the argument.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * Whether this argument must be provided.
     */ required: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * A prompt or prompt template that the server offers.
 */ exports.PromptSchema = exports.BaseMetadataSchema.extend({
    /**
     * An optional description of what this prompt provides
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * A list of arguments to use for templating the prompt.
     */ arguments: zod_1.z.optional(zod_1.z.array(exports.PromptArgumentSchema)),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of prompts and prompt templates the server has.
 */ exports.ListPromptsRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("prompts/list")
});
/**
 * The server's response to a prompts/list request from the client.
 */ exports.ListPromptsResultSchema = exports.PaginatedResultSchema.extend({
    prompts: zod_1.z.array(exports.PromptSchema)
});
/**
 * Used by the client to get a prompt provided by the server.
 */ exports.GetPromptRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The name of the prompt or prompt template.
         */ name: zod_1.z.string(),
        /**
         * Arguments to use for templating the prompt.
         */ arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
    })
});
/**
 * Text provided to or from an LLM.
 */ exports.TextContentSchema = zod_1.z.object({
    type: zod_1.z.literal("text"),
    /**
     * The text content of the message.
     */ text: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * An image provided to or from an LLM.
 */ exports.ImageContentSchema = zod_1.z.object({
    type: zod_1.z.literal("image"),
    /**
     * The base64-encoded image data.
     */ data: Base64Schema,
    /**
     * The MIME type of the image. Different providers may support different image types.
     */ mimeType: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * An Audio provided to or from an LLM.
 */ exports.AudioContentSchema = zod_1.z.object({
    type: zod_1.z.literal("audio"),
    /**
     * The base64-encoded audio data.
     */ data: Base64Schema,
    /**
     * The MIME type of the audio. Different providers may support different audio types.
     */ mimeType: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * The contents of a resource, embedded into a prompt or tool call result.
 */ exports.EmbeddedResourceSchema = zod_1.z.object({
    type: zod_1.z.literal("resource"),
    resource: zod_1.z.union([
        exports.TextResourceContentsSchema,
        exports.BlobResourceContentsSchema
    ]),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * A resource that the server is capable of reading, included in a prompt or tool call result.
 *
 * Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
 */ exports.ResourceLinkSchema = exports.ResourceSchema.extend({
    type: zod_1.z.literal("resource_link")
});
/**
 * A content block that can be used in prompts and tool results.
 */ exports.ContentBlockSchema = zod_1.z.union([
    exports.TextContentSchema,
    exports.ImageContentSchema,
    exports.AudioContentSchema,
    exports.ResourceLinkSchema,
    exports.EmbeddedResourceSchema
]);
/**
 * Describes a message returned as part of a prompt.
 */ exports.PromptMessageSchema = zod_1.z.object({
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: exports.ContentBlockSchema
}).passthrough();
/**
 * The server's response to a prompts/get request from the client.
 */ exports.GetPromptResultSchema = exports.ResultSchema.extend({
    /**
     * An optional description for the prompt.
     */ description: zod_1.z.optional(zod_1.z.string()),
    messages: zod_1.z.array(exports.PromptMessageSchema)
});
/**
 * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.PromptListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/prompts/list_changed")
});
/* Tools */ /**
 * Additional properties describing a Tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */ exports.ToolAnnotationsSchema = zod_1.z.object({
    /**
     * A human-readable title for the tool.
     */ title: zod_1.z.optional(zod_1.z.string()),
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */ readOnlyHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: true
     */ destructiveHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on the its environment.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: false
     */ idempotentHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */ openWorldHint: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * Definition for a tool the client can call.
 */ exports.ToolSchema = exports.BaseMetadataSchema.extend({
    /**
     * A human-readable description of the tool.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * A JSON Schema object defining the expected parameters for the tool.
     */ inputSchema: zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough(),
    /**
     * An optional JSON Schema object defining the structure of the tool's output returned in
     * the structuredContent field of a CallToolResult.
     */ outputSchema: zod_1.z.optional(zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough()),
    /**
     * Optional additional tool information.
     */ annotations: zod_1.z.optional(exports.ToolAnnotationsSchema),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of tools the server has.
 */ exports.ListToolsRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("tools/list")
});
/**
 * The server's response to a tools/list request from the client.
 */ exports.ListToolsResultSchema = exports.PaginatedResultSchema.extend({
    tools: zod_1.z.array(exports.ToolSchema)
});
/**
 * The server's response to a tool call.
 */ exports.CallToolResultSchema = exports.ResultSchema.extend({
    /**
     * A list of content objects that represent the result of the tool call.
     *
     * If the Tool does not define an outputSchema, this field MUST be present in the result.
     * For backwards compatibility, this field is always present, but it may be empty.
     */ content: zod_1.z.array(exports.ContentBlockSchema).default([]),
    /**
     * An object containing structured tool output.
     *
     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
     */ structuredContent: zod_1.z.object({}).passthrough().optional(),
    /**
     * Whether the tool call ended in an error.
     *
     * If not set, this is assumed to be false (the call was successful).
     *
     * Any errors that originate from the tool SHOULD be reported inside the result
     * object, with `isError` set to true, _not_ as an MCP protocol-level error
     * response. Otherwise, the LLM would not be able to see that an error occurred
     * and self-correct.
     *
     * However, any errors in _finding_ the tool, an error indicating that the
     * server does not support tool calls, or any other exceptional conditions,
     * should be reported as an MCP error response.
     */ isError: zod_1.z.optional(zod_1.z.boolean())
});
/**
 * CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.
 */ exports.CompatibilityCallToolResultSchema = exports.CallToolResultSchema.or(exports.ResultSchema.extend({
    toolResult: zod_1.z.unknown()
}));
/**
 * Used by the client to invoke a tool provided by the server.
 */ exports.CallToolRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
        name: zod_1.z.string(),
        arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.unknown()))
    })
});
/**
 * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.ToolListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/tools/list_changed")
});
/* Logging */ /**
 * The severity of a log message.
 */ exports.LoggingLevelSchema = zod_1.z.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
]);
/**
 * A request from the client to the server, to enable or adjust logging.
 */ exports.SetLevelRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
         */ level: exports.LoggingLevelSchema
    })
});
/**
 * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
 */ exports.LoggingMessageNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The severity of this log message.
         */ level: exports.LoggingLevelSchema,
        /**
         * An optional name of the logger issuing this message.
         */ logger: zod_1.z.optional(zod_1.z.string()),
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */ data: zod_1.z.unknown()
    })
});
/* Sampling */ /**
 * Hints to use for model selection.
 */ exports.ModelHintSchema = zod_1.z.object({
    /**
     * A hint for a model name.
     */ name: zod_1.z.string().optional()
}).passthrough();
/**
 * The server's preferences for model selection, requested of the client during sampling.
 */ exports.ModelPreferencesSchema = zod_1.z.object({
    /**
     * Optional hints to use for model selection.
     */ hints: zod_1.z.optional(zod_1.z.array(exports.ModelHintSchema)),
    /**
     * How much to prioritize cost when selecting a model.
     */ costPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
    /**
     * How much to prioritize sampling speed (latency) when selecting a model.
     */ speedPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
    /**
     * How much to prioritize intelligence and capabilities when selecting a model.
     */ intelligencePriority: zod_1.z.optional(zod_1.z.number().min(0).max(1))
}).passthrough();
/**
 * Describes a message issued to or received from an LLM API.
 */ exports.SamplingMessageSchema = zod_1.z.object({
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: zod_1.z.union([
        exports.TextContentSchema,
        exports.ImageContentSchema,
        exports.AudioContentSchema
    ])
}).passthrough();
/**
 * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
 */ exports.CreateMessageRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
        messages: zod_1.z.array(exports.SamplingMessageSchema),
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */ systemPrompt: zod_1.z.optional(zod_1.z.string()),
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */ includeContext: zod_1.z.optional(zod_1.z.enum([
            "none",
            "thisServer",
            "allServers"
        ])),
        temperature: zod_1.z.optional(zod_1.z.number()),
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */ maxTokens: zod_1.z.number().int(),
        stopSequences: zod_1.z.optional(zod_1.z.array(zod_1.z.string())),
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */ metadata: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        /**
         * The server's preferences for which model to select.
         */ modelPreferences: zod_1.z.optional(exports.ModelPreferencesSchema)
    })
});
/**
 * The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.
 */ exports.CreateMessageResultSchema = exports.ResultSchema.extend({
    /**
     * The name of the model that generated the message.
     */ model: zod_1.z.string(),
    /**
     * The reason why sampling stopped.
     */ stopReason: zod_1.z.optional(zod_1.z.enum([
        "endTurn",
        "stopSequence",
        "maxTokens"
    ]).or(zod_1.z.string())),
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: zod_1.z.discriminatedUnion("type", [
        exports.TextContentSchema,
        exports.ImageContentSchema,
        exports.AudioContentSchema
    ])
});
/* Elicitation */ /**
 * Primitive schema definition for boolean fields.
 */ exports.BooleanSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("boolean"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    default: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * Primitive schema definition for string fields.
 */ exports.StringSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("string"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    minLength: zod_1.z.optional(zod_1.z.number()),
    maxLength: zod_1.z.optional(zod_1.z.number()),
    format: zod_1.z.optional(zod_1.z.enum([
        "email",
        "uri",
        "date",
        "date-time"
    ]))
}).passthrough();
/**
 * Primitive schema definition for number fields.
 */ exports.NumberSchemaSchema = zod_1.z.object({
    type: zod_1.z.enum([
        "number",
        "integer"
    ]),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    minimum: zod_1.z.optional(zod_1.z.number()),
    maximum: zod_1.z.optional(zod_1.z.number())
}).passthrough();
/**
 * Primitive schema definition for enum fields.
 */ exports.EnumSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("string"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    enum: zod_1.z.array(zod_1.z.string()),
    enumNames: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
}).passthrough();
/**
 * Union of all primitive schema definitions.
 */ exports.PrimitiveSchemaDefinitionSchema = zod_1.z.union([
    exports.BooleanSchemaSchema,
    exports.StringSchemaSchema,
    exports.NumberSchemaSchema,
    exports.EnumSchemaSchema
]);
/**
 * A request from the server to elicit user input via the client.
 * The client should present the message and form fields to the user.
 */ exports.ElicitRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("elicitation/create"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The message to present to the user.
         */ message: zod_1.z.string(),
        /**
         * The schema for the requested user input.
         */ requestedSchema: zod_1.z.object({
            type: zod_1.z.literal("object"),
            properties: zod_1.z.record(zod_1.z.string(), exports.PrimitiveSchemaDefinitionSchema),
            required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
        }).passthrough()
    })
});
/**
 * The client's response to an elicitation/create request from the server.
 */ exports.ElicitResultSchema = exports.ResultSchema.extend({
    /**
     * The user's response action.
     */ action: zod_1.z.enum([
        "accept",
        "decline",
        "cancel"
    ]),
    /**
     * The collected user input content (only present if action is "accept").
     */ content: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()))
});
/* Autocomplete */ /**
 * A reference to a resource or resource template definition.
 */ exports.ResourceTemplateReferenceSchema = zod_1.z.object({
    type: zod_1.z.literal("ref/resource"),
    /**
     * The URI or URI template of the resource.
     */ uri: zod_1.z.string()
}).passthrough();
/**
 * @deprecated Use ResourceTemplateReferenceSchema instead
 */ exports.ResourceReferenceSchema = exports.ResourceTemplateReferenceSchema;
/**
 * Identifies a prompt.
 */ exports.PromptReferenceSchema = zod_1.z.object({
    type: zod_1.z.literal("ref/prompt"),
    /**
     * The name of the prompt or prompt template
     */ name: zod_1.z.string()
}).passthrough();
/**
 * A request from the client to the server, to ask for completion options.
 */ exports.CompleteRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
        ref: zod_1.z.union([
            exports.PromptReferenceSchema,
            exports.ResourceTemplateReferenceSchema
        ]),
        /**
         * The argument's information
         */ argument: zod_1.z.object({
            /**
             * The name of the argument
             */ name: zod_1.z.string(),
            /**
             * The value of the argument to use for completion matching.
             */ value: zod_1.z.string()
        }).passthrough(),
        context: zod_1.z.optional(zod_1.z.object({
            /**
             * Previously-resolved variables in a URI template or prompt.
             */ arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.string()))
        }))
    })
});
/**
 * The server's response to a completion/complete request
 */ exports.CompleteResultSchema = exports.ResultSchema.extend({
    completion: zod_1.z.object({
        /**
         * An array of completion values. Must not exceed 100 items.
         */ values: zod_1.z.array(zod_1.z.string()).max(100),
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */ total: zod_1.z.optional(zod_1.z.number().int()),
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */ hasMore: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()
});
/* Roots */ /**
 * Represents a root directory or file that the server can operate on.
 */ exports.RootSchema = zod_1.z.object({
    /**
     * The URI identifying the root. This *must* start with file:// for now.
     */ uri: zod_1.z.string().startsWith("file://"),
    /**
     * An optional name for the root.
     */ name: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * Sent from the server to request a list of root URIs from the client.
 */ exports.ListRootsRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("roots/list")
});
/**
 * The client's response to a roots/list request from the server.
 */ exports.ListRootsResultSchema = exports.ResultSchema.extend({
    roots: zod_1.z.array(exports.RootSchema)
});
/**
 * A notification from the client to the server, informing it that the list of roots has changed.
 */ exports.RootsListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/roots/list_changed")
});
/* Client messages */ exports.ClientRequestSchema = zod_1.z.union([
    exports.PingRequestSchema,
    exports.InitializeRequestSchema,
    exports.CompleteRequestSchema,
    exports.SetLevelRequestSchema,
    exports.GetPromptRequestSchema,
    exports.ListPromptsRequestSchema,
    exports.ListResourcesRequestSchema,
    exports.ListResourceTemplatesRequestSchema,
    exports.ReadResourceRequestSchema,
    exports.SubscribeRequestSchema,
    exports.UnsubscribeRequestSchema,
    exports.CallToolRequestSchema,
    exports.ListToolsRequestSchema
]);
exports.ClientNotificationSchema = zod_1.z.union([
    exports.CancelledNotificationSchema,
    exports.ProgressNotificationSchema,
    exports.InitializedNotificationSchema,
    exports.RootsListChangedNotificationSchema
]);
exports.ClientResultSchema = zod_1.z.union([
    exports.EmptyResultSchema,
    exports.CreateMessageResultSchema,
    exports.ElicitResultSchema,
    exports.ListRootsResultSchema
]);
/* Server messages */ exports.ServerRequestSchema = zod_1.z.union([
    exports.PingRequestSchema,
    exports.CreateMessageRequestSchema,
    exports.ElicitRequestSchema,
    exports.ListRootsRequestSchema
]);
exports.ServerNotificationSchema = zod_1.z.union([
    exports.CancelledNotificationSchema,
    exports.ProgressNotificationSchema,
    exports.LoggingMessageNotificationSchema,
    exports.ResourceUpdatedNotificationSchema,
    exports.ResourceListChangedNotificationSchema,
    exports.ToolListChangedNotificationSchema,
    exports.PromptListChangedNotificationSchema
]);
exports.ServerResultSchema = zod_1.z.union([
    exports.EmptyResultSchema,
    exports.InitializeResultSchema,
    exports.CompleteResultSchema,
    exports.GetPromptResultSchema,
    exports.ListPromptsResultSchema,
    exports.ListResourcesResultSchema,
    exports.ListResourceTemplatesResultSchema,
    exports.ReadResourceResultSchema,
    exports.CallToolResultSchema,
    exports.ListToolsResultSchema
]);
class McpError extends Error {
    constructor(code, message, data){
        super(`MCP error ${code}: ${message}`);
        this.code = code;
        this.data = data;
        this.name = "McpError";
    }
}
exports.McpError = McpError;

},{"10ab419ef9be205a":"hP52C"}],"hP52C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "z", ()=>_externalJs);
var _externalJs = require("./v3/external.js");
parcelHelpers.exportAll(_externalJs, exports);
exports.default = _externalJs;

},{"./v3/external.js":"bNeQ6","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bNeQ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("./errors.js");
parcelHelpers.exportAll(_errorsJs, exports);
var _parseUtilJs = require("./helpers/parseUtil.js");
parcelHelpers.exportAll(_parseUtilJs, exports);
var _typeAliasesJs = require("./helpers/typeAliases.js");
parcelHelpers.exportAll(_typeAliasesJs, exports);
var _utilJs = require("./helpers/util.js");
parcelHelpers.exportAll(_utilJs, exports);
var _typesJs = require("./types.js");
parcelHelpers.exportAll(_typesJs, exports);
var _zodErrorJs = require("./ZodError.js");
parcelHelpers.exportAll(_zodErrorJs, exports);

},{"./errors.js":"9JtgG","./helpers/parseUtil.js":"dRtcR","./helpers/typeAliases.js":"gdiUn","./helpers/util.js":"eVgjV","./types.js":"1sKQ4","./ZodError.js":"bChKR","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"9JtgG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultErrorMap", ()=>(0, _enJsDefault.default));
parcelHelpers.export(exports, "setErrorMap", ()=>setErrorMap);
parcelHelpers.export(exports, "getErrorMap", ()=>getErrorMap);
var _enJs = require("./locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
let overrideErrorMap = (0, _enJsDefault.default);
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

},{"./locales/en.js":"5ZU2p","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"5ZU2p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _zodErrorJs = require("../ZodError.js");
var _utilJs = require("../helpers/util.js");
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case (0, _zodErrorJs.ZodIssueCode).invalid_type:
            if (issue.received === (0, _utilJs.ZodParsedType).undefined) message = "Required";
            else message = `Expected ${issue.expected}, received ${issue.received}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, (0, _utilJs.util).jsonStringifyReplacer)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).unrecognized_keys:
            message = `Unrecognized key(s) in object: ${(0, _utilJs.util).joinValues(issue.keys, ", ")}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${(0, _utilJs.util).joinValues(issue.options)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_enum_value:
            message = `Invalid enum value. Expected ${(0, _utilJs.util).joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_return_type:
            message = `Invalid function return type`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_date:
            message = `Invalid date`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                else (0, _utilJs.util).assertNever(issue.validation);
            } else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
            else message = "Invalid";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "bigint") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).custom:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            (0, _utilJs.util).assertNever(issue);
    }
    return {
        message
    };
};
exports.default = errorMap;

},{"../ZodError.js":"bChKR","../helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bChKR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodIssueCode", ()=>ZodIssueCode);
parcelHelpers.export(exports, "quotelessJson", ()=>quotelessJson);
parcelHelpers.export(exports, "ZodError", ()=>ZodError);
var _utilJs = require("./helpers/util.js");
const ZodIssueCode = (0, _utilJs.util).arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
const quotelessJson = (obj)=>{
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        this.issues = [];
        this.addIssue = (sub)=>{
            this.issues = [
                ...this.issues,
                sub
            ];
        };
        this.addIssues = (subs = [])=>{
            this.issues = [
                ...this.issues,
                ...subs
            ];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) // eslint-disable-next-line ban/ban
        Object.setPrototypeOf(this, actualProto);
        else this.__proto__ = actualProto;
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") issue.unionErrors.map(processError);
                else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
                else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
                else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) curr[el] = curr[el] || {
                            _errors: []
                        };
                        else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, (0, _utilJs.util).jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues)if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
        } else formErrors.push(mapper(sub));
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues)=>{
    const error = new ZodError(issues);
    return error;
};

},{"./helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"eVgjV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "util", ()=>util);
parcelHelpers.export(exports, "objectUtil", ()=>objectUtil);
parcelHelpers.export(exports, "ZodParsedType", ()=>ZodParsedType);
parcelHelpers.export(exports, "getParsedType", ()=>getParsedType);
var util;
(function(util) {
    util.assertEqual = (_)=>{};
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items)obj[item] = item;
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys)filtered[k] = obj[k];
        return util.objectValues(filtered);
    };
    util.objectValues = (obj)=>{
        return util.objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban
     : (object)=>{
        const keys = [];
        for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban
     : (val)=>typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value)=>{
        if (typeof value === "bigint") return value.toString();
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) return ZodParsedType.array;
            if (data === null) return ZodParsedType.null;
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
            if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
            if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
            if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"5G9Z5":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"dRtcR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeIssue", ()=>makeIssue);
parcelHelpers.export(exports, "EMPTY_PATH", ()=>EMPTY_PATH);
parcelHelpers.export(exports, "addIssueToContext", ()=>addIssueToContext);
parcelHelpers.export(exports, "ParseStatus", ()=>ParseStatus);
parcelHelpers.export(exports, "INVALID", ()=>INVALID);
parcelHelpers.export(exports, "DIRTY", ()=>DIRTY);
parcelHelpers.export(exports, "OK", ()=>OK);
parcelHelpers.export(exports, "isAborted", ()=>isAborted);
parcelHelpers.export(exports, "isDirty", ()=>isDirty);
parcelHelpers.export(exports, "isValid", ()=>isValid);
parcelHelpers.export(exports, "isAsync", ()=>isAsync);
var _errorsJs = require("../errors.js");
var _enJs = require("../locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    if (issueData.message !== undefined) return {
        ...issueData,
        path: fullPath,
        message: issueData.message
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps)errorMessage = map(fullIssue, {
        data,
        defaultError: errorMessage
    }).message;
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = (0, _errorsJs.getErrorMap)();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === (0, _enJsDefault.default) ? undefined : (0, _enJsDefault.default)
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value } = pair;
            if (key.status === "aborted") return INVALID;
            if (value.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
const INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value)=>({
        status: "dirty",
        value
    });
const OK = (value)=>({
        status: "valid",
        value
    });
const isAborted = (x)=>x.status === "aborted";
const isDirty = (x)=>x.status === "dirty";
const isValid = (x)=>x.status === "valid";
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;

},{"../errors.js":"9JtgG","../locales/en.js":"5ZU2p","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"gdiUn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"1sKQ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodType", ()=>ZodType);
// Adapted from https://stackoverflow.com/a/3143231
parcelHelpers.export(exports, "datetimeRegex", ()=>datetimeRegex);
parcelHelpers.export(exports, "ZodString", ()=>ZodString);
parcelHelpers.export(exports, "ZodNumber", ()=>ZodNumber);
parcelHelpers.export(exports, "ZodBigInt", ()=>ZodBigInt);
parcelHelpers.export(exports, "ZodBoolean", ()=>ZodBoolean);
parcelHelpers.export(exports, "ZodDate", ()=>ZodDate);
parcelHelpers.export(exports, "ZodSymbol", ()=>ZodSymbol);
parcelHelpers.export(exports, "ZodUndefined", ()=>ZodUndefined);
parcelHelpers.export(exports, "ZodNull", ()=>ZodNull);
parcelHelpers.export(exports, "ZodAny", ()=>ZodAny);
parcelHelpers.export(exports, "ZodUnknown", ()=>ZodUnknown);
parcelHelpers.export(exports, "ZodNever", ()=>ZodNever);
parcelHelpers.export(exports, "ZodVoid", ()=>ZodVoid);
parcelHelpers.export(exports, "ZodArray", ()=>ZodArray);
parcelHelpers.export(exports, "ZodObject", ()=>ZodObject);
parcelHelpers.export(exports, "ZodUnion", ()=>ZodUnion);
parcelHelpers.export(exports, "ZodDiscriminatedUnion", ()=>ZodDiscriminatedUnion);
parcelHelpers.export(exports, "ZodIntersection", ()=>ZodIntersection);
// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
parcelHelpers.export(exports, "ZodTuple", ()=>ZodTuple);
parcelHelpers.export(exports, "ZodRecord", ()=>ZodRecord);
parcelHelpers.export(exports, "ZodMap", ()=>ZodMap);
parcelHelpers.export(exports, "ZodSet", ()=>ZodSet);
parcelHelpers.export(exports, "ZodFunction", ()=>ZodFunction);
parcelHelpers.export(exports, "ZodLazy", ()=>ZodLazy);
parcelHelpers.export(exports, "ZodLiteral", ()=>ZodLiteral);
parcelHelpers.export(exports, "ZodEnum", ()=>ZodEnum);
parcelHelpers.export(exports, "ZodNativeEnum", ()=>ZodNativeEnum);
parcelHelpers.export(exports, "ZodPromise", ()=>ZodPromise);
parcelHelpers.export(exports, "ZodEffects", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodTransformer", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodOptional", ()=>ZodOptional);
parcelHelpers.export(exports, "ZodNullable", ()=>ZodNullable);
parcelHelpers.export(exports, "ZodDefault", ()=>ZodDefault);
parcelHelpers.export(exports, "ZodCatch", ()=>ZodCatch);
parcelHelpers.export(exports, "ZodNaN", ()=>ZodNaN);
parcelHelpers.export(exports, "BRAND", ()=>BRAND);
parcelHelpers.export(exports, "ZodBranded", ()=>ZodBranded);
parcelHelpers.export(exports, "ZodPipeline", ()=>ZodPipeline);
parcelHelpers.export(exports, "ZodReadonly", ()=>ZodReadonly);
parcelHelpers.export(exports, "custom", ()=>custom);
parcelHelpers.export(exports, "Schema", ()=>ZodType);
parcelHelpers.export(exports, "ZodSchema", ()=>ZodType);
parcelHelpers.export(exports, "late", ()=>late);
parcelHelpers.export(exports, "ZodFirstPartyTypeKind", ()=>ZodFirstPartyTypeKind);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "any", ()=>anyType);
parcelHelpers.export(exports, "array", ()=>arrayType);
parcelHelpers.export(exports, "bigint", ()=>bigIntType);
parcelHelpers.export(exports, "boolean", ()=>booleanType);
parcelHelpers.export(exports, "date", ()=>dateType);
parcelHelpers.export(exports, "discriminatedUnion", ()=>discriminatedUnionType);
parcelHelpers.export(exports, "effect", ()=>effectsType);
parcelHelpers.export(exports, "enum", ()=>enumType);
parcelHelpers.export(exports, "function", ()=>functionType);
parcelHelpers.export(exports, "instanceof", ()=>instanceOfType);
parcelHelpers.export(exports, "intersection", ()=>intersectionType);
parcelHelpers.export(exports, "lazy", ()=>lazyType);
parcelHelpers.export(exports, "literal", ()=>literalType);
parcelHelpers.export(exports, "map", ()=>mapType);
parcelHelpers.export(exports, "nan", ()=>nanType);
parcelHelpers.export(exports, "nativeEnum", ()=>nativeEnumType);
parcelHelpers.export(exports, "never", ()=>neverType);
parcelHelpers.export(exports, "null", ()=>nullType);
parcelHelpers.export(exports, "nullable", ()=>nullableType);
parcelHelpers.export(exports, "number", ()=>numberType);
parcelHelpers.export(exports, "object", ()=>objectType);
parcelHelpers.export(exports, "oboolean", ()=>oboolean);
parcelHelpers.export(exports, "onumber", ()=>onumber);
parcelHelpers.export(exports, "optional", ()=>optionalType);
parcelHelpers.export(exports, "ostring", ()=>ostring);
parcelHelpers.export(exports, "pipeline", ()=>pipelineType);
parcelHelpers.export(exports, "preprocess", ()=>preprocessType);
parcelHelpers.export(exports, "promise", ()=>promiseType);
parcelHelpers.export(exports, "record", ()=>recordType);
parcelHelpers.export(exports, "set", ()=>setType);
parcelHelpers.export(exports, "strictObject", ()=>strictObjectType);
parcelHelpers.export(exports, "string", ()=>stringType);
parcelHelpers.export(exports, "symbol", ()=>symbolType);
parcelHelpers.export(exports, "transformer", ()=>effectsType);
parcelHelpers.export(exports, "tuple", ()=>tupleType);
parcelHelpers.export(exports, "undefined", ()=>undefinedType);
parcelHelpers.export(exports, "union", ()=>unionType);
parcelHelpers.export(exports, "unknown", ()=>unknownType);
parcelHelpers.export(exports, "void", ()=>voidType);
parcelHelpers.export(exports, "NEVER", ()=>NEVER);
var _zodErrorJs = require("./ZodError.js");
var _errorsJs = require("./errors.js");
var _errorUtilJs = require("./helpers/errorUtil.js");
var _parseUtilJs = require("./helpers/parseUtil.js");
var _utilJs = require("./helpers/util.js");
class ParseInputLazyPath {
    constructor(parent, value, path, key){
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if ((0, _parseUtilJs.isValid)(result)) return {
        success: true,
        data: result.value
    };
    else {
        if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new (0, _zodErrorJs.ZodError)(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        const { message } = params;
        if (iss.code === "invalid_enum_value") return {
            message: message ?? ctx.defaultError
        };
        if (typeof ctx.data === "undefined") return {
            message: message ?? required_error ?? ctx.defaultError
        };
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        return {
            message: message ?? invalid_type_error ?? ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, _utilJs.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, _utilJs.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new (0, _parseUtilJs.ParseStatus)(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, _utilJs.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, _parseUtilJs.isAsync)(result)) throw new Error("Synchronous parse encountered promise.");
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        if (!this["~standard"].async) try {
            const result = this._parseSync({
                data,
                path: [],
                parent: ctx
            });
            return (0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            };
        } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
            ctx.common = {
                issues: [],
                async: true
            };
        }
        return this._parseAsync({
            data,
            path: [],
            parent: ctx
        }).then((result)=>(0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await ((0, _parseUtilJs.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val)=>{
            if (typeof message === "string" || typeof message === "undefined") return {
                message
            };
            else if (typeof message === "function") return message(val);
            else return message;
        };
        return this._refinement((val, ctx)=>{
            const result = check(val);
            const setError = ()=>ctx.addIssue({
                    code: (0, _zodErrorJs.ZodIssueCode).custom,
                    ...getIssueProperties(val)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data)=>{
                if (!data) {
                    setError();
                    return false;
                } else return true;
            });
            if (!result) {
                setError();
                return false;
            } else return true;
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx)=>{
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else return true;
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data)=>this["~validate"](data)
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) return true;
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt)) return false;
    try {
        const [header] = jwt.split(".");
        if (!header) return false;
        // Convert base64url to base64
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null) return false;
        if ("typ" in decoded && decoded?.typ !== "JWT") return false;
        if (!decoded.alg) return false;
        if (alg && decoded.alg !== alg) return false;
        return true;
    } catch  {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return true;
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = String(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).string) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).string,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    else if (tooSmall) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "email",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "nanoid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") try {
                new URL(input.data);
            } catch  {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    validation: "url",
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                    message: check.message
                });
                status.dirty();
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") input.data = input.data.trim();
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
            else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "duration",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "jwt",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cidr",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64url",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex(regex, validation, message) {
        return this.refinement((data)=>regex.test(data), {
            validation,
            code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    nanoid(message) {
        return this._addCheck({
            kind: "nanoid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64(message) {
        return this._addCheck({
            kind: "base64",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    jwt(options) {
        return this._addCheck({
            kind: "jwt",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    cidr(options) {
        return this._addCheck({
            kind: "cidr",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    datetime(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
        });
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    date(message) {
        return this._addCheck({
            kind: "date",
            message
        });
    }
    time(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "time",
            precision: null,
            message: options
        });
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    duration(message) {
        return this._addCheck({
            kind: "duration",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    /**
     * Equivalent to `.min(1)`
     */ nonempty(message) {
        return this.min(1, (0, _errorUtilJs.errorUtil).errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch)=>ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch)=>ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch)=>ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch)=>ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch)=>ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch)=>ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params)=>{
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) input.data = Number(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).number) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).number,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!(0, _utilJs.util).isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && (0, _utilJs.util).isInteger(ch.value));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
            else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params)=>{
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodBigInt extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) try {
            input.data = BigInt(input.data);
        } catch  {
            return this._getInvalidInput(input);
        }
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).bigint) return this._getInvalidInput(input);
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).bigint,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params)=>{
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = Boolean(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).boolean,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodBoolean.create = (params)=>{
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = new Date(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).date) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).date,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_date
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params)=>{
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).symbol,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodSymbol.create = (params)=>{
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).undefined,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUndefined.create = (params)=>{
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).null) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).null,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodNull.create = (params)=>{
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
    });
};
class ZodAny extends ZodType {
    constructor(){
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodAny.create = (params)=>{
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
    });
};
class ZodUnknown extends ZodType {
    constructor(){
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUnknown.create = (params)=>{
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).never,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
}
ZodNever.create = (params)=>{
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).void,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodVoid.create = (params)=>{
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: tooBig ? (0, _zodErrorJs.ZodIssueCode).too_big : (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) return Promise.all([
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
        });
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params)=>{
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
    });
    else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    else return schema;
}
class ZodObject extends ZodType {
    constructor(){
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */ this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */ this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = (0, _utilJs.util).objectKeys(shape);
        this._cached = {
            shape,
            keys
        };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).object) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") for (const key of extraKeys)pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: {
                    status: "valid",
                    value: ctx.data[key]
                }
            });
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") ;
            else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        } else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) return Promise.resolve().then(async ()=>{
            const syncPairs = [];
            for (const pair of pairs){
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                    key,
                    value,
                    alwaysSet: pair.alwaysSet
                });
            }
            return syncPairs;
        }).then((syncPairs)=>{
            return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, syncPairs);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        (0, _errorUtilJs.errorUtil).errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: (0, _errorUtilJs.errorUtil).errToObj(message).message ?? defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */ merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    /**
     * @deprecated
     */ deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape)){
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) newShape[key] = fieldSchema;
            else newShape[key] = fieldSchema.optional();
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
        else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while(newField instanceof ZodOptional)newField = newField._def.innerType;
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum((0, _utilJs.util).objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.strictCreate = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.lazycreate = (shape, params)=>{
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results){
                if (result.result.status === "valid") return result.result;
            }
            for (const result of results)if (result.result.status === "dirty") {
                // add issues from dirty option
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
            }
            // return invalid
            const unionErrors = results.map((result)=>new (0, _zodErrorJs.ZodError)(result.ctx.common.issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return Promise.all(options.map(async (option)=>{
            const childCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                }),
                ctx: childCtx
            };
        })).then(handleResults);
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") return result;
                else if (result.status === "dirty" && !dirty) dirty = {
                    result,
                    ctx: childCtx
                };
                if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new (0, _zodErrorJs.ZodError)(issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params)=>{
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) return getDiscriminator(type.schema);
    else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
    else if (type instanceof ZodLiteral) return [
        type.value
    ];
    else if (type instanceof ZodEnum) return type.options;
    else if (type instanceof ZodNativeEnum) // eslint-disable-next-line ban/ban
    return (0, _utilJs.util).objectValues(type.enum);
    else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
    else if (type instanceof ZodUndefined) return [
        undefined
    ];
    else if (type instanceof ZodNull) return [
        null
    ];
    else if (type instanceof ZodOptional) return [
        undefined,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodNullable) return [
        null,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
    else return [];
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
        else return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */ static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            for (const value of discriminatorValues){
                if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
function mergeValues(a, b) {
    const aType = (0, _utilJs.getParsedType)(a);
    const bType = (0, _utilJs.getParsedType)(b);
    if (a === b) return {
        valid: true,
        data: a
    };
    else if (aType === (0, _utilJs.ZodParsedType).object && bType === (0, _utilJs.ZodParsedType).object) {
        const bKeys = (0, _utilJs.util).objectKeys(b);
        const sharedKeys = (0, _utilJs.util).objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) return {
                valid: false
            };
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === (0, _utilJs.ZodParsedType).array && bType === (0, _utilJs.ZodParsedType).array) {
        if (a.length !== b.length) return {
            valid: false
        };
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) return {
                valid: false
            };
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === (0, _utilJs.ZodParsedType).date && bType === (0, _utilJs.ZodParsedType).date && +a === +b) return {
        valid: true,
        data: a
    };
    else return {
        valid: false
    };
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if ((0, _parseUtilJs.isAborted)(parsedLeft) || (0, _parseUtilJs.isAborted)(parsedRight)) return 0, _parseUtilJs.INVALID;
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types
                });
                return 0, _parseUtilJs.INVALID;
            }
            if ((0, _parseUtilJs.isDirty)(parsedLeft) || (0, _parseUtilJs.isDirty)(parsedRight)) status.dirty();
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) return Promise.all([
            this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }),
            this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            })
        ]).then(([left, right])=>handleParsed(left, right));
        else return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }));
    }
}
ZodIntersection.create = (left, right, params)=>{
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return 0, _parseUtilJs.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x); // filter nulls
        if (ctx.common.async) return Promise.all(items).then((results)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, results);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeArray(status, items);
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
}
ZodTuple.create = (schemas, params)=>{
    if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data)pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
        });
        if (ctx.common.async) return (0, _parseUtilJs.ParseStatus).mergeObjectAsync(status, pairs);
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
        });
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).map) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).map,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                    if (key.status === "dirty" || value.status === "dirty") status.dirty();
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (key.status === "dirty" || value.status === "dirty") status.dirty();
                finalMap.set(key.value, value.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
}
ZodMap.create = (keyType, valueType, params)=>{
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).set) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).set,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
        else return finalizeSet(elements);
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params)=>{
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
    });
};
class ZodFunction extends ZodType {
    constructor(){
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).function) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).function,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(async function(...args) {
                const error = new (0, _zodErrorJs.ZodError)([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(function(...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) throw new (0, _zodErrorJs.ZodError)([
                    makeArgsIssue(args, parsedArgs.error)
                ]);
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) throw new (0, _zodErrorJs.ZodError)([
                    makeReturnsIssue(result, parsedReturns.error)
                ]);
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
}
ZodLazy.create = (getter, params)=>{
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_literal,
                expected: this._def.value
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params)=>{
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
            ...this._def,
            ...newDef
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = (0, _utilJs.util).getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).string && ctx.parsedType !== (0, _utilJs.ZodParsedType).number) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set((0, _utilJs.util).getValidEnumValues(this._def.values));
        if (!this._cache.has(input.data)) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params)=>{
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).promise && ctx.common.async === false) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).promise,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const promisified = ctx.parsedType === (0, _utilJs.ZodParsedType).promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, _parseUtilJs.OK)(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
}
ZodPromise.create = (schema, params)=>{
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg)=>{
                (0, _parseUtilJs.addIssueToContext)(ctx, arg);
                if (arg.fatal) status.abort();
                else status.dirty();
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = await this._def.schema._parseAsync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            });
            else {
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) return Promise.resolve(result);
                if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((inner)=>{
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                return executeRefinement(inner.value).then(()=>{
                    return {
                        status: status.value,
                        value: inner.value
                    };
                });
            });
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                return {
                    status: status.value,
                    value: result
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((base)=>{
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                        status: status.value,
                        value: result
                    }));
            });
        }
        (0, _utilJs.util).assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params)=>{
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
    return new ZodEffects({
        schema,
        effect: {
            type: "preprocess",
            transform: preprocess
        },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).undefined) return (0, _parseUtilJs.OK)(undefined);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params)=>{
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).null) return (0, _parseUtilJs.OK)(null);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params)=>{
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === (0, _utilJs.ZodParsedType).undefined) data = this._def.defaultValue();
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params)=>{
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
        ...processCreateParams(params)
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if ((0, _parseUtilJs.isAsync)(result)) return result.then((result)=>{
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        });
        else return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
                get error () {
                    return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                },
                input: newCtx.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params)=>{
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
        ...processCreateParams(params)
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).nan,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
}
ZodNaN.create = (params)=>{
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, _parseUtilJs.DIRTY)(inResult.value);
                } else return this._def.out._parseAsync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data)=>{
            if ((0, _parseUtilJs.isValid)(data)) data.value = Object.freeze(data.value);
            return data;
        };
        return (0, _parseUtilJs.isAsync)(result) ? result.then((data)=>freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params)=>{
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
        message: params
    } : params;
    const p2 = typeof p === "string" ? {
        message: p
    } : p;
    return p2;
}
function custom(check, _params = {}, /**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */ fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx)=>{
        const r = check(data);
        if (r instanceof Promise) return r.then((r)=>{
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({
                    code: "custom",
                    ...params,
                    fatal: _fatal
                });
            }
        });
        if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({
                code: "custom",
                ...params,
                fatal: _fatal
            });
        }
        return;
    });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._){}
}
const instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`
})=>custom((data)=>data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = ()=>stringType().optional();
const onumber = ()=>numberType().optional();
const oboolean = ()=>booleanType().optional();
const coerce = {
    string: (arg)=>ZodString.create({
            ...arg,
            coerce: true
        }),
    number: (arg)=>ZodNumber.create({
            ...arg,
            coerce: true
        }),
    boolean: (arg)=>ZodBoolean.create({
            ...arg,
            coerce: true
        }),
    bigint: (arg)=>ZodBigInt.create({
            ...arg,
            coerce: true
        }),
    date: (arg)=>ZodDate.create({
            ...arg,
            coerce: true
        })
};
const NEVER = (0, _parseUtilJs.INVALID);

},{"./ZodError.js":"bChKR","./errors.js":"9JtgG","./helpers/errorUtil.js":"kove1","./helpers/parseUtil.js":"dRtcR","./helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"kove1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorUtil", ()=>errorUtil);
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message)=>typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"fIIXC":[function(require,module,exports) {
"use strict";
var compileSchema = require("f7dd346044c34c6"), resolve = require("7a9956f372715dcc"), Cache = require("5169c4eac89c863f"), SchemaObject = require("9f1d640a8f9c4afc"), stableStringify = require("4d82020015b3afe8"), formats = require("1432f29152da5daf"), rules = require("914f694b4009365d"), $dataMetaSchema = require("4687edf7dbe4b29d"), util = require("292cd9db142892b3");
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require("93a7b3072f6d309");
var customKeyword = require("fb2e4f3d81c5111a");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = require("b6ec3ec3248ee9fb");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
var META_IGNORE_OPTIONS = [
    "removeAdditional",
    "useDefaults",
    "coerceTypes",
    "strictDefaults"
];
var META_SUPPORT_DATA = [
    "/properties"
];
/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */ function Ajv(opts) {
    if (!(this instanceof Ajv)) return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache;
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
    if (opts.serialize === undefined) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
    if (opts.nullable) this.addKeyword("nullable", {
        metaSchema: {
            type: "boolean"
        }
    });
    addInitialSchemas(this);
}
/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */ function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true) this.errors = v.errors;
    return valid;
}
/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */ function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, undefined, _meta);
    return schemaObj.validate || this._compile(schemaObj);
}
/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */ function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
        for(var i = 0; i < schema.length; i++)this.addSchema(schema[i], undefined, _skipValidation, _meta);
        return this;
    }
    var id = this._getId(schema);
    if (id !== undefined && typeof id != "string") throw new Error("schema id must be string");
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
}
/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */ function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
}
/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */ function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== undefined && typeof $schema != "string") throw new Error("$schema must be a string");
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(message);
        else throw new Error(message);
    }
    return valid;
}
function defaultMeta(self) {
    var meta = self._opts.meta;
    self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
    return self._opts.defaultMeta;
}
/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */ function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch(typeof schemaObj){
        case "object":
            return schemaObj.validate || this._compile(schemaObj);
        case "string":
            return this.getSchema(schemaObj);
        case "undefined":
            return _getSchemaFragment(this, keyRef);
    }
}
function _getSchemaFragment(self, ref) {
    var res = resolve.schema.call(self, {
        schema: {}
    }, ref);
    if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, undefined, baseId);
        self._fragments[ref] = new SchemaObject({
            ref: ref,
            fragment: true,
            schema: schema,
            root: root,
            baseId: baseId,
            validate: v
        });
        return v;
    }
}
function _getSchemaObj(self, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */ function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
    }
    switch(typeof schemaKeyRef){
        case "undefined":
            _removeAllSchemas(this, this._schemas);
            _removeAllSchemas(this, this._refs);
            this._cache.clear();
            return this;
        case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            if (schemaObj) this._cache.del(schemaObj.cacheKey);
            delete this._schemas[schemaKeyRef];
            delete this._refs[schemaKeyRef];
            return this;
        case "object":
            var serialize = this._opts.serialize;
            var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            if (id) {
                id = resolve.normalizeId(id);
                delete this._schemas[id];
                delete this._refs[id];
            }
    }
    return this;
}
function _removeAllSchemas(self, schemas, regex) {
    for(var keyRef in schemas){
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
            self._cache.del(schemaObj.cacheKey);
            delete schemas[keyRef];
        }
    }
}
/* @this   Ajv */ function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean") throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached) return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema) checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
        id: id,
        schema: schema,
        localRefs: localRefs,
        cacheKey: cacheKey,
        meta: meta
    });
    if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
}
/* @this   Ajv */ function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true) callValidate.$async = true;
        return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
    }
    var v;
    try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
        delete schemaObj.validate;
        throw e;
    } finally{
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    /* @this   {*} - custom context, see passContext option */ function callValidate() {
        /* jshint validthis: true */ var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
    }
}
function chooseGetId(opts) {
    switch(opts.schemaId){
        case "auto":
            return _get$IdOrId;
        case "id":
            return _getId;
        default:
            return _get$Id;
    }
}
/* @this   Ajv */ function _getId(schema) {
    if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
}
/* @this   Ajv */ function _get$Id(schema) {
    if (schema.id) this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
}
function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id) throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
}
/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */ function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors) return "No errors";
    options = options || {};
    var separator = options.separator === undefined ? ", " : options.separator;
    var dataVar = options.dataVar === undefined ? "data" : options.dataVar;
    var text = "";
    for(var i = 0; i < errors.length; i++){
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
}
/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */ function addFormat(name, format) {
    if (typeof format == "string") format = new RegExp(format);
    this._formats[name] = format;
    return this;
}
function addDefaultMetaSchema(self) {
    var $dataSchema;
    if (self._opts.$data) {
        $dataSchema = require("9bfbe520330691f6");
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self._opts.meta === false) return;
    var metaSchema = require("5772ffc00882093d");
    if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
    var optsSchemas = self._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
    else for(var key in optsSchemas)self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
    for(var name in self._opts.formats){
        var format = self._opts.formats[name];
        self.addFormat(name, format);
    }
}
function addInitialKeywords(self) {
    for(var name in self._opts.keywords){
        var keyword = self._opts.keywords[name];
        self.addKeyword(name, keyword);
    }
}
function checkUnique(self, id) {
    if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self) {
    var metaOpts = util.copy(self._opts);
    for(var i = 0; i < META_IGNORE_OPTIONS.length; i++)delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
}
function setLogger(self) {
    var logger = self._opts.logger;
    if (logger === false) self.logger = {
        log: noop,
        warn: noop,
        error: noop
    };
    else {
        if (logger === undefined) logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error)) throw new Error("logger must implement log, warn and error methods");
        self.logger = logger;
    }
}
function noop() {}

},{"f7dd346044c34c6":"kyFAJ","7a9956f372715dcc":"4DPrg","5169c4eac89c863f":"6QdJ9","9f1d640a8f9c4afc":"bGI5K","4d82020015b3afe8":"l5BCD","1432f29152da5daf":"bJBRk","914f694b4009365d":"bZh8w","4687edf7dbe4b29d":"brIE5","292cd9db142892b3":"bXWQH","93a7b3072f6d309":"6gt4e","fb2e4f3d81c5111a":"bUesF","b6ec3ec3248ee9fb":"2CCBr","9bfbe520330691f6":"8zgol","5772ffc00882093d":"66Yv9"}],"kyFAJ":[function(require,module,exports) {
"use strict";
var resolve = require("b589f22f51e17623"), util = require("a05853e7143a65f5"), errorClasses = require("7d0b6873cca90c67"), stableStringify = require("d698a727cccd50d6");
var validateGenerator = require("1bb2bd76cac2de13");
/**
 * Functions below are used inside compiled validations function
 */ var ucs2length = util.ucs2length;
var equal = require("c3d7d0741df3ddff");
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */ function compile(schema, root, localRefs, baseId) {
    /* jshint validthis: true, evil: true */ /* eslint no-shadow: 0 */ var self = this, opts = this._opts, refVal = [
        undefined
    ], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root = root || {
        schema: schema,
        refVal: refVal,
        refs: refs
    };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling) return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
            cv.schema = v.schema;
            cv.errors = null;
            cv.refs = v.refs;
            cv.refVal = v.refVal;
            cv.root = v.root;
            cv.$async = v.$async;
            if (opts.sourceCode) cv.source = v.source;
        }
        return v;
    } finally{
        endCompiling.call(this, schema, root, baseId);
    }
    /* @this   {*} - custom context, see passContext option */ function callValidate() {
        /* jshint validthis: true */ var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
    }
    function localCompile(_schema, _root, localRefs, baseId) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
            isTop: true,
            schema: _schema,
            isRoot: isRoot,
            baseId: baseId,
            root: _root,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            MissingRefError: errorClasses.MissingRef,
            RULES: RULES,
            validate: validateGenerator,
            util: util,
            resolve: resolve,
            resolveRef: resolveRef,
            usePattern: usePattern,
            useDefault: useDefault,
            useCustomRule: useCustomRule,
            opts: opts,
            formats: formats,
            logger: self.logger,
            self: self
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
        var validate;
        try {
            var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
            validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
            refVal[0] = validate;
        } catch (e) {
            self.logger.error("Error compiling schema, function code:", sourceCode);
            throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) validate.source = {
            code: sourceCode,
            patterns: patterns,
            defaults: defaults
        };
        return validate;
    }
    function resolveRef(baseId, ref, isRoot) {
        ref = resolve.url(baseId, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== undefined) {
            _refVal = refVal[refIndex];
            refCode = "refVal[" + refIndex + "]";
            return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
            var rootRefId = root.refs[ref];
            if (rootRefId !== undefined) {
                _refVal = root.refVal[rootRefId];
                refCode = addLocalRef(ref, _refVal);
                return resolvedRef(_refVal, refCode);
            }
        }
        refCode = addLocalRef(ref);
        var v = resolve.call(self, localCompile, root, ref);
        if (v === undefined) {
            var localSchema = localRefs && localRefs[ref];
            if (localSchema) v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId);
        }
        if (v === undefined) removeLocalRef(ref);
        else {
            replaceLocalRef(ref, v);
            return resolvedRef(v, refCode);
        }
    }
    function addLocalRef(ref, v) {
        var refId = refVal.length;
        refVal[refId] = v;
        refs[ref] = refId;
        return "refVal" + refId;
    }
    function removeLocalRef(ref) {
        delete refs[ref];
    }
    function replaceLocalRef(ref, v) {
        var refId = refs[ref];
        refVal[refId] = v;
    }
    function resolvedRef(refVal, code) {
        return typeof refVal == "object" || typeof refVal == "boolean" ? {
            code: code,
            schema: refVal,
            inline: true
        } : {
            code: code,
            $async: refVal && !!refVal.$async
        };
    }
    function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === undefined) {
            index = patternsHash[regexStr] = patterns.length;
            patterns[index] = regexStr;
        }
        return "pattern" + index;
    }
    function useDefault(value) {
        switch(typeof value){
            case "boolean":
            case "number":
                return "" + value;
            case "string":
                return util.toQuotedString(value);
            case "object":
                if (value === null) return "null";
                var valueStr = stableStringify(value);
                var index = defaultsHash[valueStr];
                if (index === undefined) {
                    index = defaultsHash[valueStr] = defaults.length;
                    defaults[index] = value;
                }
                return "default" + index;
        }
    }
    function useCustomRule(rule, schema, parentSchema, it) {
        if (self._opts.validateSchema !== false) {
            var deps = rule.definition.dependencies;
            if (deps && !deps.every(function(keyword) {
                return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
            })) throw new Error("parent schema must have all required keywords: " + deps.join(","));
            var validateSchema = rule.definition.validateSchema;
            if (validateSchema) {
                var valid = validateSchema(schema);
                if (!valid) {
                    var message = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
                    if (self._opts.validateSchema == "log") self.logger.error(message);
                    else throw new Error(message);
                }
            }
        }
        var compile = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile) validate = compile.call(self, schema, parentSchema, it);
        else if (macro) {
            validate = macro.call(self, schema, parentSchema, it);
            if (opts.validateSchema !== false) self.validateSchema(validate, true);
        } else if (inline) validate = inline.call(self, it, rule.keyword, schema, parentSchema);
        else {
            validate = rule.definition.validate;
            if (!validate) return;
        }
        if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
            code: "customRule" + index,
            validate: validate
        };
    }
}
/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */ function checkCompiling(schema, root, baseId) {
    /* jshint validthis: true */ var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0) return {
        index: index,
        compiling: true
    };
    index = this._compilations.length;
    this._compilations[index] = {
        schema: schema,
        root: root,
        baseId: baseId
    };
    return {
        index: index,
        compiling: false
    };
}
/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */ function endCompiling(schema, root, baseId) {
    /* jshint validthis: true */ var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0) this._compilations.splice(i, 1);
}
/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */ function compIndex(schema, root, baseId) {
    /* jshint validthis: true */ for(var i = 0; i < this._compilations.length; i++){
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
    }
    return -1;
}
function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
}
function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
}
function refValCode(i, refVal) {
    return refVal[i] === undefined ? "" : "var refVal" + i + " = refVal[" + i + "];";
}
function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
}
function vars(arr, statement) {
    if (!arr.length) return "";
    var code = "";
    for(var i = 0; i < arr.length; i++)code += statement(i, arr);
    return code;
}

},{"b589f22f51e17623":"4DPrg","a05853e7143a65f5":"bXWQH","7d0b6873cca90c67":"2CCBr","d698a727cccd50d6":"l5BCD","1bb2bd76cac2de13":"9i9eI","c3d7d0741df3ddff":"jtux3"}],"4DPrg":[function(require,module,exports) {
"use strict";
var URI = require("9cd31ea3887257c9"), equal = require("db717c6b6196b116"), util = require("2c84dcea76bf50ab"), SchemaObject = require("e62d6335d482eb3f"), traverse = require("16cd7b7b84452e6c");
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */ function resolve(compile, root, ref) {
    /* jshint validthis: true */ var refVal = this._refs[ref];
    if (typeof refVal == "string") {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    var res = resolveSchema.call(this, root, ref);
    var schema, v, baseId;
    if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
    else if (schema !== undefined) v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
    return v;
}
/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */ function resolveSchema(root, ref) {
    /* jshint validthis: true */ var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") return resolveRecursive.call(this, root, refVal, p);
        else if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            root = refVal;
        } else {
            refVal = this._schemas[id];
            if (refVal instanceof SchemaObject) {
                if (!refVal.validate) this._compile(refVal);
                if (id == normalizeId(ref)) return {
                    schema: refVal,
                    root: root,
                    baseId: baseId
                };
                root = refVal;
            } else return;
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */ function resolveRecursive(root, ref, parsedRef) {
    /* jshint validthis: true */ var res = resolveSchema.call(this, root, ref);
    if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
}
var PREVENT_SCOPE_CHANGE = util.toHash([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
]);
/* @this Ajv */ function getJsonPointer(parsedRef, baseId, schema, root) {
    /* jshint validthis: true */ parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/") return;
    var parts = parsedRef.fragment.split("/");
    for(var i = 1; i < parts.length; i++){
        var part = parts[i];
        if (part) {
            part = util.unescapeFragment(part);
            schema = schema[part];
            if (schema === undefined) break;
            var id;
            if (!PREVENT_SCOPE_CHANGE[part]) {
                id = this._getId(schema);
                if (id) baseId = resolveUrl(baseId, id);
                if (schema.$ref) {
                    var $ref = resolveUrl(baseId, schema.$ref);
                    var res = resolveSchema.call(this, root, $ref);
                    if (res) {
                        schema = res.schema;
                        root = res.root;
                        baseId = res.baseId;
                    }
                }
            }
        }
    }
    if (schema !== undefined && schema !== root.schema) return {
        schema: schema,
        root: root,
        baseId: baseId
    };
}
var SIMPLE_INLINED = util.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
]);
function inlineRef(schema, limit) {
    if (limit === false) return false;
    if (limit === undefined || limit === true) return checkNoRef(schema);
    else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) for(var i = 0; i < schema.length; i++){
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item)) return false;
    }
    else for(var key in schema){
        if (key == "$ref") return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item)) return false;
    }
    return true;
}
function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) for(var i = 0; i < schema.length; i++){
        item = schema[i];
        if (typeof item == "object") count += countKeys(item);
        if (count == Infinity) return Infinity;
    }
    else for(var key in schema){
        if (key == "$ref") return Infinity;
        if (SIMPLE_INLINED[key]) count++;
        else {
            item = schema[key];
            if (typeof item == "object") count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
        }
    }
    return count;
}
function getFullPath(id, normalize) {
    if (normalize !== false) id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
}
function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
}
/* @this Ajv */ function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = {
        "": schemaId
    };
    var fullPaths = {
        "": getFullPath(schemaId, false)
    };
    var localRefs = {};
    var self = this;
    traverse(schema, {
        allKeys: true
    }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "") return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== undefined) fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
            id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
            var refVal = self._refs[id];
            if (typeof refVal == "string") refVal = self._refs[refVal];
            if (refVal && refVal.schema) {
                if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
            } else if (id != normalizeId(fullPath)) {
                if (id[0] == "#") {
                    if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
                    localRefs[id] = sch;
                } else self._refs[id] = fullPath;
            }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
}

},{"9cd31ea3887257c9":"vmPB9","db717c6b6196b116":"jtux3","2c84dcea76bf50ab":"bXWQH","e62d6335d482eb3f":"bGI5K","16cd7b7b84452e6c":"dOV7I"}],"vmPB9":[function(require,module,exports) {
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {
    factory(exports);
})(this, function(exports1) {
    "use strict";
    function merge() {
        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++)sets[_key] = arguments[_key];
        if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for(var x = 1; x < xl; ++x)sets[x] = sets[x].slice(1, -1);
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
        } else return sets[0];
    }
    function subexp(str) {
        return "(?:" + str + ")";
    }
    function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
        return str.toUpperCase();
    }
    function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [
            obj
        ] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
        var obj = target;
        if (source) for(var key in source)obj[key] = source[key];
        return obj;
    }
    function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), //case-insensitive
        LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), //expanded
        GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", //subset, excludes bidi control characters
        IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", //subset
        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), //relaxed parsing rules
        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), //                           6( h16 ":" ) ls32
        IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), //                      "::" 5( h16 ":" ) ls32
        IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), //[               h16 ] "::" 4( h16 ":" ) ls32
        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), //[ *4( h16 ":" ) h16 ] "::"              ls32
        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), //[ *5( h16 ":" ) h16 ] "::"              h16
        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), //[ *6( h16 ":" ) h16 ] "::"
        IPV6ADDRESS$ = subexp([
            IPV6ADDRESS1$,
            IPV6ADDRESS2$,
            IPV6ADDRESS3$,
            IPV6ADDRESS4$,
            IPV6ADDRESS5$,
            IPV6ADDRESS6$,
            IPV6ADDRESS7$,
            IPV6ADDRESS8$,
            IPV6ADDRESS9$
        ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), //RFC 6874
        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), //RFC 6874
        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), //RFC 6874, with relaxed parsing rules
        IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), //RFC 6874
        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), //simplified
        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified
        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified
        PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;
            try {
                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr;
            else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
            else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
            return arr2;
        } else return Array.from(arr);
    };
    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
    /** Bootstring parameters */ var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = "-"; // '\x2D'
    /** Regular expressions */ var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
    /** Error messages */ var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
    };
    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    /*--------------------------------------------------------------------------*/ /**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */ function error$1(type) {
        throw new RangeError(errors[type]);
    }
    /**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */ function map(array, fn) {
        var result = [];
        var length = array.length;
        while(length--)result[length] = fn(array[length]);
        return result;
    }
    /**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */ function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + "@";
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
    }
    /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */ function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while(counter < length){
            var value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // It's a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) // Low surrogate.
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                else {
                    // It's an unmatched surrogate; only append this code unit, in case the
                    // next code unit is the high surrogate of a surrogate pair.
                    output.push(value);
                    counter--;
                }
            } else output.push(value);
        }
        return output;
    }
    /**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */ var ucs2encode = function ucs2encode(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    /**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */ var basicToDigit = function basicToDigit(codePoint) {
        if (codePoint - 0x30 < 0x0A) return codePoint - 0x16;
        if (codePoint - 0x41 < 0x1A) return codePoint - 0x41;
        if (codePoint - 0x61 < 0x1A) return codePoint - 0x61;
        return base;
    };
    /**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */ var digitToBasic = function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    /**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */ var adapt = function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    /**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */ var decode = function decode(input) {
        // Don't use UCS-2.
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) basic = 0;
        for(var j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) error$1("not-basic");
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i;
            for(var w = 1, k = base;; k += base){
                if (index >= inputLength) error$1("invalid-input");
                var digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) error$1("overflow");
                i += digit * w;
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) break;
                var baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) error$1("overflow");
                w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) error$1("overflow");
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
    };
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */ var encode = function encode(input) {
        var output = [];
        // Convert the input in UCS-2 to an array of Unicode code points.
        input = ucs2decode(input);
        // Cache the length.
        var inputLength = input.length;
        // Initialize the state.
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        // Handle the basic code points.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _currentValue2 = _step.value;
                if (_currentValue2 < 0x80) output.push(stringFromCharCode(_currentValue2));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
            } finally{
                if (_didIteratorError) throw _iteratorError;
            }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string with a delimiter unless it's empty.
        if (basicLength) output.push(delimiter);
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;
            try {
                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var currentValue = _step2.value;
                    if (currentValue >= n && currentValue < m) m = currentValue;
                }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow.
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
                } finally{
                    if (_didIteratorError2) throw _iteratorError2;
                }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error$1("overflow");
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;
            try {
                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                    var _currentValue = _step3.value;
                    if (_currentValue < n && ++delta > maxInt) error$1("overflow");
                    if (_currentValue == n) {
                        // Represent delta as a generalized variable-length integer.
                        var q = delta;
                        for(var k = base;; k += base){
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) break;
                            var qMinusT = q - t;
                            var baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) _iterator3.return();
                } finally{
                    if (_didIteratorError3) throw _iteratorError3;
                }
            }
            ++delta;
            ++n;
        }
        return output.join("");
    };
    /**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */ var toUnicode = function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    };
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */ var toASCII = function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
    };
    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {
        /**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */ "version": "2.1.0",
        /**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */ "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
    };
    /**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */ /**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */ var SCHEMES = {};
    function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
    }
    function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while(i < il){
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
            } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                } else newStr += str.substr(i, 6);
                i += 6;
            } else if (c >= 224) {
                if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                } else newStr += str.substr(i, 9);
                i += 9;
            } else {
                newStr += str.substr(i, 3);
                i += 3;
            }
        }
        return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
    }
    function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) return address.split(".").map(_stripLeadingZeros).join(".");
        else return host;
    }
    function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for(var x = 0; x < fieldCount; ++x)fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
            if (isLastFieldIPv4Address) fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            var allZeroFields = fields.reduce(function(acc, field, index) {
                if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (lastLongest && lastLongest.index + lastLongest.length === index) lastLongest.length++;
                    else acc.push({
                        index: index,
                        length: 1
                    });
                }
                return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
                return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else newHost = fields.join(":");
            if (zone) newHost += "%" + zone;
            return newHost;
        } else return host;
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) components.port = matches[5];
            } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
            if (components.host) //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            //determine reference type
            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) components.reference = "same-document";
            else if (components.scheme === undefined) components.reference = "relative";
            else if (components.fragment === undefined) components.reference = "absolute";
            else components.reference = "uri";
            //check for reference errors
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) components.error = components.error || "URI is not a " + options.reference + " reference.";
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //check if scheme can't handle IRIs
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else //normalize encodings
            _normalizeComponentEncoding(components, protocol);
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) schemeHandler.parse(components, options);
        } else components.error = components.error || "URI can not be parsed.";
        return components;
    }
    function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
        }
        if (components.host !== undefined) //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
        if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
        var output = [];
        while(input.length){
            if (input.match(RDS1)) input = input.replace(RDS1, "");
            else if (input.match(RDS2)) input = input.replace(RDS2, "/");
            else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
            } else if (input === "." || input === "..") input = "";
            else {
                var im = input.match(RDS5);
                if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else throw new Error("Unexpected dot segment condition");
            }
        }
        return output.join("");
    }
    function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) ;
            else if (options.domainHost || schemeHandler && schemeHandler.domainHost) //convert IDN via punycode
            try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
            if (options.reference !== "suffix") uriTokens.push("//");
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") uriTokens.push("/");
        }
        if (components.path !== undefined) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
            if (authority === undefined) s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
            uriTokens.push(s);
        }
        if (components.query !== undefined) {
            uriTokens.push("?");
            uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
    }
    function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
            base = parse(serialize(base, options), options); //normalize base components
            relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
            } else {
                if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) target.query = relative.query;
                    else target.query = base.query;
                } else {
                    if (relative.path.charAt(0) === "/") target.path = removeDotSegments(relative.path);
                    else {
                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) target.path = "/" + relative.path;
                        else if (!base.path) target.path = relative.path;
                        else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                        target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
            }
            target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
    }
    function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({
            scheme: "null"
        }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
        if (typeof uri === "string") uri = serialize(parse(uri, options), options);
        else if (typeOf(uri) === "object") uri = parse(serialize(uri, options), options);
        return uri;
    }
    function equal(uriA, uriB, options) {
        if (typeof uriA === "string") uriA = serialize(parse(uriA, options), options);
        else if (typeOf(uriA) === "object") uriA = serialize(uriA, options);
        if (typeof uriB === "string") uriB = serialize(parse(uriB, options), options);
        else if (typeOf(uriB) === "object") uriB = serialize(uriB, options);
        return uriA === uriB;
    }
    function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
            //report missing host
            if (!components.host) components.error = components.error || "HTTP URIs must have a host.";
            return components;
        },
        serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            //normalize the default port
            if (components.port === (secure ? 443 : 80) || components.port === "") components.port = undefined;
            //normalize the empty path
            if (!components.path) components.path = "/";
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components;
        }
    };
    var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
    };
    function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    //RFC 6455
    var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse(components, options) {
            var wsComponents = components;
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents);
            //construct resouce name
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = undefined;
            wsComponents.query = undefined;
            return wsComponents;
        },
        serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") wsComponents.port = undefined;
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === "boolean") {
                wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
                wsComponents.secure = undefined;
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                wsComponents.path = path && path !== "/" ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
            }
            //forbid fragment component
            wsComponents.fragment = undefined;
            return wsComponents;
        }
    };
    var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    //RFC 3986
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
    //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
    //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
    //const VCHAR$$ = "[\\x21-\\x7E]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
    //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
    //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
    //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = undefined;
            if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for(var x = 0, xl = hfields.length; x < xl; ++x){
                    var hfield = hfields[x].split("=");
                    switch(hfield[0]){
                        case "to":
                            var toAddrs = hfield[1].split(",");
                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x)to.push(toAddrs[_x]);
                            break;
                        case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;
                        case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;
                        default:
                            unknownHeaders = true;
                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            break;
                    }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = undefined;
            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
                else addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                to[_x2] = addr.join("@");
            }
            return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
                for(var x = 0, xl = to.length; x < xl; ++x){
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1);
                    //convert IDN via punycode
                    try {
                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                    } catch (e) {
                        components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                    to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for(var name in headers)if (headers[name] !== O[name]) fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            if (fields.length) components.query = fields.join("&");
            return components;
        }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    //RFC 2141
    var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) urnComponents = schemeHandler.parse(urnComponents, options);
            } else urnComponents.error = urnComponents.error || "URN can not be parsed.";
            return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) urnComponents = schemeHandler.serialize(urnComponents, options);
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
        }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    //RFC 4122
    var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = undefined;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents;
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
        }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports1.SCHEMES = SCHEMES;
    exports1.pctEncChar = pctEncChar;
    exports1.pctDecChars = pctDecChars;
    exports1.parse = parse;
    exports1.removeDotSegments = removeDotSegments;
    exports1.serialize = serialize;
    exports1.resolveComponents = resolveComponents;
    exports1.resolve = resolve;
    exports1.normalize = normalize;
    exports1.equal = equal;
    exports1.escapeComponent = escapeComponent;
    exports1.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});

},{}],"jtux3":[function(require,module,exports) {
"use strict";
// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};

},{}],"bXWQH":[function(require,module,exports) {
"use strict";
module.exports = {
    copy: copy,
    checkDataType: checkDataType,
    checkDataTypes: checkDataTypes,
    coerceToTypes: coerceToTypes,
    toHash: toHash,
    getProperty: getProperty,
    escapeQuotes: escapeQuotes,
    equal: require("6e2c918aa5d5ba8a"),
    ucs2length: require("6ee8393837aee5ca"),
    varOccurences: varOccurences,
    varReplace: varReplace,
    schemaHasRules: schemaHasRules,
    schemaHasRulesExcept: schemaHasRulesExcept,
    schemaUnknownRules: schemaUnknownRules,
    toQuotedString: toQuotedString,
    getPathExpr: getPathExpr,
    getPath: getPath,
    getData: getData,
    unescapeFragment: unescapeFragment,
    unescapeJsonPointer: unescapeJsonPointer,
    escapeFragment: escapeFragment,
    escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
    to = to || {};
    for(var key in o)to[key] = o[key];
    return to;
}
function checkDataType(dataType, data, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch(dataType){
        case "null":
            return data + EQUAL + "null";
        case "array":
            return OK + "Array.isArray(" + data + ")";
        case "object":
            return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
            return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
            return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
            return "typeof " + data + EQUAL + '"' + dataType + '"';
    }
}
function checkDataTypes(dataTypes, data, strictNumbers) {
    switch(dataTypes.length){
        case 1:
            return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
            var code = "";
            var types = toHash(dataTypes);
            if (types.array && types.object) {
                code = types.null ? "(" : "(!" + data + " || ";
                code += "typeof " + data + ' !== "object")';
                delete types.null;
                delete types.array;
                delete types.object;
            }
            if (types.number) delete types.integer;
            for(var t in types)code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
            return code;
    }
}
var COERCE_TO_TYPES = toHash([
    "string",
    "number",
    "integer",
    "boolean",
    "null"
]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
        var types = [];
        for(var i = 0; i < dataTypes.length; i++){
            var t = dataTypes[i];
            if (COERCE_TO_TYPES[t]) types[types.length] = t;
            else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
        }
        if (types.length) return types;
    } else if (COERCE_TO_TYPES[dataTypes]) return [
        dataTypes
    ];
    else if (optionCoerceTypes === "array" && dataTypes === "array") return [
        "array"
    ];
}
function toHash(arr) {
    var hash = {};
    for(var i = 0; i < arr.length; i++)hash[arr[i]] = true;
    return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
}
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean") return !schema;
    for(var key in schema)if (rules[key]) return true;
}
function schemaHasRulesExcept(schema, rules, exceptKeyword) {
    if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
    for(var key in schema)if (key != exceptKeyword && rules[key]) return true;
}
function schemaUnknownRules(schema, rules) {
    if (typeof schema == "boolean") return;
    for(var key in schema)if (!rules[key]) return key;
}
function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers // false by default
     ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers // false by default
     ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
}
var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === "") return "rootData";
    if ($data[0] == "/") {
        if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
    } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
            if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
            return paths[lvl - up];
        }
        if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer) return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for(var i = 0; i < segments.length; i++){
        var segment = segments[i];
        if (segment) {
            data += getProperty(unescapeJsonPointer(segment));
            expr += " && " + data;
        }
    }
    return expr;
}
function joinPaths(a, b) {
    if (a == '""') return b;
    return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
}
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}

},{"6e2c918aa5d5ba8a":"jtux3","6ee8393837aee5ca":"f0Moj"}],"f0Moj":[function(require,module,exports) {
"use strict";
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
    var length = 0, len = str.length, pos = 0, value;
    while(pos < len){
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
        }
    }
    return length;
};

},{}],"bGI5K":[function(require,module,exports) {
"use strict";
var util = require("864288866c3cff07");
module.exports = SchemaObject;
function SchemaObject(obj) {
    util.copy(obj, this);
}

},{"864288866c3cff07":"bXWQH"}],"dOV7I":[function(require,module,exports) {
"use strict";
var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == "function") {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == "object") for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}

},{}],"2CCBr":[function(require,module,exports) {
"use strict";
var resolve = require("91e7fc61203c0143");
module.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
}
MissingRefError.message = function(baseId, ref) {
    return "can't resolve reference " + ref + " from id " + baseId;
};
function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
}

},{"91e7fc61203c0143":"4DPrg"}],"l5BCD":[function(require,module,exports) {
"use strict";
module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") node = node.toJSON();
        if (node === undefined) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = "[";
            for(i = 0; i < node.length; i++){
                if (i) out += ",";
                out += stringify(node[i]) || "null";
            }
            return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
    }(data);
};

},{}],"9i9eI":[function(require,module,exports) {
"use strict";
module.exports = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
            var $keywordsMsg = "unknown keyword: " + $unknownKwd;
            if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
            else throw new Error($keywordsMsg);
        }
    }
    if (it.isTop) {
        out += " var validate = ";
        if ($async) {
            it.async = true;
            out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) out += " " + ("/*# sourceURL=" + $id + " */") + " ";
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
            if (it.isTop) $breakOnError = true;
            else out += " var " + $valid + " = false; ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ""; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
                if (it.opts.messages !== false) out += " , message: 'boolean schema is false' ";
                if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                else out += " validate.errors = [" + __err + "]; return false; ";
            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        } else if (it.isTop) {
            if ($async) out += " return data; ";
            else out += " validate.errors = null; return true; ";
        } else out += " var " + $valid + " = true; ";
        if (it.isTop) out += " }; return validate; ";
        return out;
    }
    if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [
            ""
        ];
        if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
            var $defaultMsg = "default is ignored in the schema root";
            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
            else throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
    } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
            if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
            $typeSchema = [
                $typeSchema,
                "null"
            ];
            $typeIsArray = true;
        }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        else if (it.opts.extendRefs !== true) {
            $refKeywords = false;
            it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
    }
    if (it.schema.$comment && it.opts.$comment) out += " " + it.RULES.all.$comment.code(it, "$comment");
    if ($typeSchema) {
        if (it.opts.coerceTypes) var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
            out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
            if ($coerceToTypes) {
                var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
                out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
                if (it.opts.coerceTypes == "array") out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
                out += " if (" + $coerced + " !== undefined) ; ";
                var arr1 = $coerceToTypes;
                if (arr1) {
                    var $type, $i = -1, l1 = arr1.length - 1;
                    while($i < l1){
                        $type = arr1[$i += 1];
                        if ($type == "string") out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                        else if ($type == "number" || $type == "integer") {
                            out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                            if ($type == "integer") out += " && !(" + $data + " % 1)";
                            out += ")) " + $coerced + " = +" + $data + "; ";
                        } else if ($type == "boolean") out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                        else if ($type == "null") out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                        else if (it.opts.coerceTypes == "array" && $type == "array") out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                    }
                }
                out += " else {   ";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                    else out += "" + $typeSchema;
                    out += "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) out += "" + $typeSchema.join(",");
                        else out += "" + $typeSchema;
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } if (" + $coerced + " !== undefined) {  ";
                var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
                out += " " + $data + " = " + $coerced + "; ";
                if (!$dataLvl) out += "if (" + $parentData + " !== undefined)";
                out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
            } else {
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                    else out += "" + $typeSchema;
                    out += "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) out += "" + $typeSchema.join(",");
                        else out += "" + $typeSchema;
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
        }
    }
    if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
            out += " } if (errors === ";
            if ($top) out += "0";
            else out += "errs_" + $lvl;
            out += ") { ";
            $closingBraces2 += "}";
        }
    } else {
        var arr2 = it.RULES;
        if (arr2) {
            var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
            while(i2 < l2){
                $rulesGroup = arr2[i2 += 1];
                if ($shouldUseGroup($rulesGroup)) {
                    if ($rulesGroup.type) out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
                    if (it.opts.useDefaults) {
                        if ($rulesGroup.type == "object" && it.schema.properties) {
                            var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                            var arr3 = $schemaKeys;
                            if (arr3) {
                                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                                while(i3 < l3){
                                    $propertyKey = arr3[i3 += 1];
                                    var $sch = $schema[$propertyKey];
                                    if ($sch.default !== undefined) {
                                        var $passData = $data + it.util.getProperty($propertyKey);
                                        if (it.compositeRule) {
                                            if (it.opts.strictDefaults) {
                                                var $defaultMsg = "default is ignored for: " + $passData;
                                                if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                                                else throw new Error($defaultMsg);
                                            }
                                        } else {
                                            out += " if (" + $passData + " === undefined ";
                                            if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
                                            out += " ) " + $passData + " = ";
                                            if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
                                            else out += " " + JSON.stringify($sch.default) + " ";
                                            out += "; ";
                                        }
                                    }
                                }
                            }
                        } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                            var arr4 = it.schema.items;
                            if (arr4) {
                                var $sch, $i = -1, l4 = arr4.length - 1;
                                while($i < l4){
                                    $sch = arr4[$i += 1];
                                    if ($sch.default !== undefined) {
                                        var $passData = $data + "[" + $i + "]";
                                        if (it.compositeRule) {
                                            if (it.opts.strictDefaults) {
                                                var $defaultMsg = "default is ignored for: " + $passData;
                                                if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                                                else throw new Error($defaultMsg);
                                            }
                                        } else {
                                            out += " if (" + $passData + " === undefined ";
                                            if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
                                            out += " ) " + $passData + " = ";
                                            if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
                                            else out += " " + JSON.stringify($sch.default) + " ";
                                            out += "; ";
                                        }
                                    }
                                }
                            }
                        }
                    }
                    var arr5 = $rulesGroup.rules;
                    if (arr5) {
                        var $rule, i5 = -1, l5 = arr5.length - 1;
                        while(i5 < l5){
                            $rule = arr5[i5 += 1];
                            if ($shouldUseRule($rule)) {
                                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                                if ($code) {
                                    out += " " + $code + " ";
                                    if ($breakOnError) $closingBraces1 += "}";
                                }
                            }
                        }
                    }
                    if ($breakOnError) {
                        out += " " + $closingBraces1 + " ";
                        $closingBraces1 = "";
                    }
                    if ($rulesGroup.type) {
                        out += " } ";
                        if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                            out += " else { ";
                            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ""; /* istanbul ignore else */ 
                            if (it.createErrors !== false) {
                                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                                if ($typeIsArray) out += "" + $typeSchema.join(",");
                                else out += "" + $typeSchema;
                                out += "' } ";
                                if (it.opts.messages !== false) {
                                    out += " , message: 'should be ";
                                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                                    else out += "" + $typeSchema;
                                    out += "' ";
                                }
                                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                                out += " } ";
                            } else out += " {} ";
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                                else out += " validate.errors = [" + __err + "]; return false; ";
                            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                            out += " } ";
                        }
                    }
                    if ($breakOnError) {
                        out += " if (errors === ";
                        if ($top) out += "0";
                        else out += "errs_" + $lvl;
                        out += ") { ";
                        $closingBraces2 += "}";
                    }
                }
            }
        }
    }
    if ($breakOnError) out += " " + $closingBraces2 + " ";
    if ($top) {
        if ($async) {
            out += " if (errors === 0) return data;           ";
            out += " else throw new ValidationError(vErrors); ";
        } else {
            out += " validate.errors = vErrors; ";
            out += " return errors === 0;       ";
        }
        out += " }; return validate;";
    } else out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    function $shouldUseGroup($rulesGroup) {
        var rules = $rulesGroup.rules;
        for(var i = 0; i < rules.length; i++)if ($shouldUseRule(rules[i])) return true;
    }
    function $shouldUseRule($rule) {
        return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
    }
    function $ruleImplementsSomeKeyword($rule) {
        var impl = $rule.implements;
        for(var i = 0; i < impl.length; i++)if (it.schema[impl[i]] !== undefined) return true;
    }
    return out;
};

},{}],"6QdJ9":[function(require,module,exports) {
"use strict";
var Cache = module.exports = function Cache() {
    this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
};

},{}],"bJBRk":[function(require,module,exports) {
"use strict";
var util = require("a2faed526b64ac6");
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [
    0,
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util.copy(formats[mode]);
}
formats.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: UUID,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": RELATIVE_JSON_POINTER
};
formats.full = {
    date: date,
    time: time,
    "date-time": date_time,
    uri: uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
        new RegExp(str);
        return true;
    } catch (e) {
        return false;
    }
}

},{"a2faed526b64ac6":"bXWQH"}],"bZh8w":[function(require,module,exports) {
"use strict";
var ruleModules = require("320fad79ae8493c7"), toHash = require("8ce0e99024dd72ae").toHash;
module.exports = function rules() {
    var RULES = [
        {
            type: "number",
            rules: [
                {
                    "maximum": [
                        "exclusiveMaximum"
                    ]
                },
                {
                    "minimum": [
                        "exclusiveMinimum"
                    ]
                },
                "multipleOf",
                "format"
            ]
        },
        {
            type: "string",
            rules: [
                "maxLength",
                "minLength",
                "pattern",
                "format"
            ]
        },
        {
            type: "array",
            rules: [
                "maxItems",
                "minItems",
                "items",
                "contains",
                "uniqueItems"
            ]
        },
        {
            type: "object",
            rules: [
                "maxProperties",
                "minProperties",
                "required",
                "dependencies",
                "propertyNames",
                {
                    "properties": [
                        "additionalProperties",
                        "patternProperties"
                    ]
                }
            ]
        },
        {
            rules: [
                "$ref",
                "const",
                "enum",
                "not",
                "anyOf",
                "oneOf",
                "allOf",
                "if"
            ]
        }
    ];
    var ALL = [
        "type",
        "$comment"
    ];
    var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
    ];
    var TYPES = [
        "number",
        "integer",
        "string",
        "array",
        "object",
        "boolean",
        "null"
    ];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
            var implKeywords;
            if (typeof keyword == "object") {
                var key = Object.keys(keyword)[0];
                implKeywords = keyword[key];
                keyword = key;
                implKeywords.forEach(function(k) {
                    ALL.push(k);
                    RULES.all[k] = true;
                });
            }
            ALL.push(keyword);
            var rule = RULES.all[keyword] = {
                keyword: keyword,
                code: ruleModules[keyword],
                implements: implKeywords
            };
            return rule;
        });
        RULES.all.$comment = {
            keyword: "$comment",
            code: ruleModules.$comment
        };
        if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
};

},{"320fad79ae8493c7":"hNsm7","8ce0e99024dd72ae":"bXWQH"}],"hNsm7":[function(require,module,exports) {
"use strict";
//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
    "$ref": require("b78d457e7afd64bb"),
    allOf: require("48b34d085e3ec99e"),
    anyOf: require("391b436b4af2f7be"),
    "$comment": require("cf4e7ee5e0296fb8"),
    const: require("4d4c491d625674ab"),
    contains: require("88a4b137152f067d"),
    dependencies: require("74b02ee6cab2c47e"),
    "enum": require("be60ff2180bfa23"),
    format: require("8c9714d616d1ed0a"),
    "if": require("5adbc4b502609522"),
    items: require("c7646594fda72068"),
    maximum: require("38a39307400a1be1"),
    minimum: require("38a39307400a1be1"),
    maxItems: require("bc10152125d4a5ad"),
    minItems: require("bc10152125d4a5ad"),
    maxLength: require("7c37752877e496f4"),
    minLength: require("7c37752877e496f4"),
    maxProperties: require("b93ee89a9995ea2e"),
    minProperties: require("b93ee89a9995ea2e"),
    multipleOf: require("22b153b53f98c24a"),
    not: require("7b5c836b893a7a0d"),
    oneOf: require("753ea2f532bfe6f9"),
    pattern: require("339cd9d78fdcc133"),
    properties: require("5528eda3a7169306"),
    propertyNames: require("9b21f26c2748ece9"),
    required: require("6d833c3f730abbb0"),
    uniqueItems: require("db1334fb636c8b52"),
    validate: require("75546f50e533d308")
};

},{"b78d457e7afd64bb":"9UHvA","48b34d085e3ec99e":"2HcQW","391b436b4af2f7be":"81lnt","cf4e7ee5e0296fb8":"95g0Y","4d4c491d625674ab":"2uSzM","88a4b137152f067d":"3YULK","74b02ee6cab2c47e":"XM7QB","be60ff2180bfa23":"feBdm","8c9714d616d1ed0a":"jBKEp","5adbc4b502609522":"ibGkV","c7646594fda72068":"eM8X9","38a39307400a1be1":"g43aN","bc10152125d4a5ad":"23KTc","7c37752877e496f4":"8mb3k","b93ee89a9995ea2e":"e7j0q","22b153b53f98c24a":"4UMFT","7b5c836b893a7a0d":"2tc1f","753ea2f532bfe6f9":"E1aup","339cd9d78fdcc133":"3ISsR","5528eda3a7169306":"jkeTR","9b21f26c2748ece9":"6jF0e","6d833c3f730abbb0":"bbInV","db1334fb636c8b52":"1fSfs","75546f50e533d308":"9i9eI"}],"9UHvA":[function(require,module,exports) {
"use strict";
module.exports = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
            $async = it.async;
            $refCode = "validate";
        } else {
            $async = it.root.schema.$async === true;
            $refCode = "root.refVal[0]";
        }
    } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === undefined) {
            var $message = it.MissingRefError.message(it.baseId, $schema);
            if (it.opts.missingRefs == "fail") {
                it.logger.error($message);
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
                    if (it.opts.messages !== false) out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
                    if (it.opts.verbose) out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                if ($breakOnError) out += " if (false) { ";
            } else if (it.opts.missingRefs == "ignore") {
                it.logger.warn($message);
                if ($breakOnError) out += " if (true) { ";
            } else throw new it.MissingRefError(it.baseId, $schema, $message);
        } else if ($refVal.inline) {
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            $it.schema = $refVal.schema;
            $it.schemaPath = "";
            $it.errSchemaPath = $schema;
            var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
            out += " " + $code + " ";
            if ($breakOnError) out += " if (" + $nextValid + ") { ";
        } else {
            $async = $refVal.$async === true || it.async && $refVal.$async !== false;
            $refCode = $refVal.code;
        }
    }
    if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) out += " " + $refCode + ".call(this, ";
        else out += " " + $refCode + "( ";
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') out += " + " + it.errorPath;
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
            if (!it.async) throw new Error("async schema referenced by sync schema");
            if ($breakOnError) out += " var " + $valid + "; ";
            out += " try { await " + __callValidate + "; ";
            if ($breakOnError) out += " " + $valid + " = true; ";
            out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
            if ($breakOnError) out += " " + $valid + " = false; ";
            out += " } ";
            if ($breakOnError) out += " if (" + $valid + ") { ";
        } else {
            out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
            if ($breakOnError) out += " else { ";
        }
    }
    return out;
};

},{}],"2HcQW":[function(require,module,exports) {
"use strict";
module.exports = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while($i < l1){
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $allSchemasEmpty = false;
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                }
            }
        }
    }
    if ($breakOnError) {
        if ($allSchemasEmpty) out += " if (true) { ";
        else out += " " + $closingBraces.slice(0, -1) + " ";
    }
    return out;
};

},{}],"81lnt":[function(require,module,exports) {
"use strict";
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema.every(function($sch) {
        return it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all);
    });
    if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while($i < l1){
                $sch = arr1[$i += 1];
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
                $closingBraces += "}";
            }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should match some schema in anyOf' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) out += " } ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"95g0Y":[function(require,module,exports) {
"use strict";
module.exports = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema);
    if (it.opts.$comment === true) out += " console.log(" + $comment + ");";
    else if (typeof it.opts.$comment == "function") out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    return out;
};

},{}],"2uSzM":[function(require,module,exports) {
"use strict";
module.exports = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!$isData) out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) out += " , message: 'should be equal to constant' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " }";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"3YULK":[function(require,module,exports) {
"use strict";
module.exports = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else out += " if (" + $data + ".length == 0) {";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) out += " , message: 'should contain a valid item' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } else { ";
    if ($nonEmptySchema) out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) out += " } ";
    return out;
};

},{}],"XM7QB":[function(require,module,exports) {
"use strict";
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for($property in $schema){
        if ($property == "__proto__") continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for(var $property in $propertyDeps){
        $deps = $propertyDeps[$property];
        if ($deps.length) {
            out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            if ($breakOnError) {
                out += " && ( ";
                var arr1 = $deps;
                if (arr1) {
                    var $propertyKey, $i = -1, l1 = arr1.length - 1;
                    while($i < l1){
                        $propertyKey = arr1[$i += 1];
                        if ($i) out += " || ";
                        var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                        out += " ( ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                    }
                }
                out += ")) {  ";
                var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should have ";
                        if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
                        else out += "properties " + it.util.escapeQuotes($deps.join(", "));
                        out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            } else {
                out += " ) { ";
                var arr2 = $deps;
                if (arr2) {
                    var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                    while(i2 < l2){
                        $propertyKey = arr2[i2 += 1];
                        var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                        if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                        out += " if ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") {  var err =   "; /* istanbul ignore else */ 
                        if (it.createErrors !== false) {
                            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                            if (it.opts.messages !== false) {
                                out += " , message: 'should have ";
                                if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
                                else out += "properties " + it.util.escapeQuotes($deps.join(", "));
                                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                            }
                            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                            out += " } ";
                        } else out += " {} ";
                        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                    }
                }
            }
            out += " }   ";
            if ($breakOnError) {
                $closingBraces += "}";
                out += " else { ";
            }
        }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for(var $property in $schemaDeps){
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            out += ") { ";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + it.util.getProperty($property);
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " }  ";
            if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
            }
        }
    }
    if ($breakOnError) out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"feBdm":[function(require,module,exports) {
"use strict";
module.exports = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    out += "var " + $valid + ";";
    if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) out += "  }  ";
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) out += " , message: 'should be equal to one of the allowed values' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " }";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"jBKEp":[function(require,module,exports) {
"use strict";
module.exports = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
        if ($breakOnError) out += " if (true) { ";
        return out;
    }
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) out += " var async" + $lvl + " = " + $format + ".async; ";
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        out += " (";
        if ($unknownFormats != "ignore") {
            out += " (" + $schemaValue + " && !" + $format + " ";
            if ($allowUnknown) out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
            out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        else out += " " + $format + "(" + $data + ") ";
        out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
        var $format = it.formats[$schema];
        if (!$format) {
            if ($unknownFormats == "ignore") {
                it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
                if ($breakOnError) out += " if (true) { ";
                return out;
            } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
                if ($breakOnError) out += " if (true) { ";
                return out;
            } else throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
            var $async = $format.async === true;
            $format = $format.validate;
        }
        if ($formatType != $ruleType) {
            if ($breakOnError) out += " if (true) { ";
            return out;
        }
        if ($async) {
            if (!it.async) throw new Error("async format in sync schema");
            var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
            out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
            out += " if (! ";
            var $formatRef = "formats" + it.util.getProperty($schema);
            if ($isObject) $formatRef += ".validate";
            if (typeof $format == "function") out += " " + $formatRef + "(" + $data + ") ";
            else out += " " + $formatRef + ".test(" + $data + ") ";
            out += ") { ";
        }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) out += "" + $schemaValue;
        else out += "" + it.util.toQuotedString($schema);
        out += "  } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should match format \"";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + it.util.escapeQuotes($schema);
            out += "\"' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + it.util.toQuotedString($schema);
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"ibGkV":[function(require,module,exports) {
"use strict";
module.exports = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
            out += " if (" + $nextValid + ") {  ";
            $it.schema = it.schema["then"];
            $it.schemaPath = it.schemaPath + ".then";
            $it.errSchemaPath = it.errSchemaPath + "/then";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
                $ifClause = "ifClause" + $lvl;
                out += " var " + $ifClause + " = 'then'; ";
            } else $ifClause = "'then'";
            out += " } ";
            if ($elsePresent) out += " else { ";
        } else out += " if (!" + $nextValid + ") { ";
        if ($elsePresent) {
            $it.schema = it.schema["else"];
            $it.schemaPath = it.schemaPath + ".else";
            $it.errSchemaPath = it.errSchemaPath + "/else";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
                $ifClause = "ifClause" + $lvl;
                out += " var " + $ifClause + " = 'else'; ";
            } else $ifClause = "'else'";
            out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
            if (it.opts.messages !== false) out += " , message: 'should match \"' + " + $ifClause + " + '\" schema' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        out += " }   ";
        if ($breakOnError) out += " else { ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"eM8X9":[function(require,module,exports) {
"use strict";
module.exports = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
            out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ""; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
                if (it.opts.messages !== false) out += " , message: 'should NOT have more than " + $schema.length + " items' ";
                if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                else out += " validate.errors = [" + __err + "]; return false; ";
            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            out += " } ";
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
                $closingBraces += "}";
                out += " else { ";
            }
        }
        var arr1 = $schema;
        if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while($i < l1){
                $sch = arr1[$i += 1];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
                    var $passData = $data + "[" + $i + "]";
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + "[" + $i + "]";
                    $it.errSchemaPath = $errSchemaPath + "/" + $i;
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                    $it.dataPathArr[$dataNxt] = $i;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    out += " }  ";
                    if ($breakOnError) {
                        out += " if (" + $nextValid + ") { ";
                        $closingBraces += "}";
                    }
                }
            }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
            $it.schema = $additionalItems;
            $it.schemaPath = it.schemaPath + ".additionalItems";
            $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
            var $passData = $data + "[" + $idx + "]";
            $it.dataPathArr[$dataNxt] = $idx;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
            out += " } }  ";
            if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
            }
        }
    } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
        out += " }";
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"g43aN":[function(require,module,exports) {
"use strict";
module.exports = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = undefined;
    if (!($isData || typeof $schema == "number" || $schema === undefined)) throw new Error($keyword + " must be number");
    if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) throw new Error($exclusiveKeyword + " must be number or boolean");
    if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } else if ( ";
        if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === undefined) {
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaValueExcl;
            $isData = $isDataExcl;
        }
    } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
            if ($exclIsNumber && $schema === undefined) {
                $exclusive = true;
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                $schemaValue = $schemaExcl;
                $notOp += "=";
            } else {
                if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
                if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                    $exclusive = true;
                    $errorKeyword = $exclusiveKeyword;
                    $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                    $notOp += "=";
                } else {
                    $exclusive = false;
                    $opStr += "=";
                }
            }
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should be " + $opStr + " ";
            if ($isData) out += "' + " + $schemaValue;
            else out += "" + $schemaValue + "'";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"23KTc":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxItems") out += "more";
            else out += "fewer";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " items' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"8mb3k":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    if (it.opts.unicode === false) out += " " + $data + ".length ";
    else out += " ucs2length(" + $data + ") ";
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT be ";
            if ($keyword == "maxLength") out += "longer";
            else out += "shorter";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " characters' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"e7j0q":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxProperties") out += "more";
            else out += "fewer";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " properties' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"4UMFT":[function(require,module,exports) {
"use strict";
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    out += "var division" + $lvl + ";if (";
    if ($isData) out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    else out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    out += " ) ";
    if ($isData) out += "  )  ";
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should be multiple of ";
            if ($isData) out += "' + " + $schemaValue;
            else out += "" + $schemaValue + "'";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"2tc1f":[function(require,module,exports) {
"use strict";
module.exports = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
            $allErrorsOption = $it.opts.allErrors;
            $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) out += " } ";
    } else {
        out += "  var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) out += " if (false) { ";
    }
    return out;
};

},{}],"E1aup":[function(require,module,exports) {
"use strict";
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while($i < l1){
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
            } else out += " var " + $nextValid + " = true; ";
            if ($i) {
                out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
                $closingBraces += "}";
            }
            out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) out += " , message: 'should match exactly one schema in oneOf' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
        else out += " validate.errors = vErrors; return false; ";
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) out += " } ";
    return out;
};

},{}],"3ISsR":[function(require,module,exports) {
"use strict";
module.exports = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) out += "" + $schemaValue;
        else out += "" + it.util.toQuotedString($schema);
        out += "  } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should match pattern \"";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + it.util.escapeQuotes($schema);
            out += "\"' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + it.util.toQuotedString($schema);
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"jkeTR":[function(require,module,exports) {
"use strict";
module.exports = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
    function notProto(p) {
        return p !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) out += " var " + $dataProperties + " = undefined;";
    if ($checkAdditional) {
        if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        else out += " for (var " + $key + " in " + $data + ") { ";
        if ($someProperties) {
            out += " var isAdditional" + $lvl + " = !(false ";
            if ($schemaKeys.length) {
                if ($schemaKeys.length > 8) out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
                else {
                    var arr1 = $schemaKeys;
                    if (arr1) {
                        var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                        while(i1 < l1){
                            $propertyKey = arr1[i1 += 1];
                            out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                        }
                    }
                }
            }
            if ($pPropertyKeys.length) {
                var arr2 = $pPropertyKeys;
                if (arr2) {
                    var $pProperty, $i = -1, l2 = arr2.length - 1;
                    while($i < l2){
                        $pProperty = arr2[$i += 1];
                        out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
                    }
                }
            }
            out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") out += " delete " + $data + "[" + $key + "]; ";
        else {
            var $currentErrorPath = it.errorPath;
            var $additionalProperty = "' + " + $key + " + '";
            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            if ($noAdditional) {
                if ($removeAdditional) out += " delete " + $data + "[" + $key + "]; ";
                else {
                    out += " " + $nextValid + " = false; ";
                    var $currErrSchemaPath = $errSchemaPath;
                    $errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ""; /* istanbul ignore else */ 
                    if (it.createErrors !== false) {
                        out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                        if (it.opts.messages !== false) {
                            out += " , message: '";
                            if (it.opts._errorDataPathProperty) out += "is an invalid additional property";
                            else out += "should NOT have additional properties";
                            out += "' ";
                        }
                        if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                        out += " } ";
                    } else out += " {} ";
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                        else out += " validate.errors = [" + __err + "]; return false; ";
                    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    $errSchemaPath = $currErrSchemaPath;
                    if ($breakOnError) out += " break; ";
                }
            } else if ($additionalIsSchema) {
                if ($removeAdditional == "failing") {
                    out += " var " + $errs + " = errors;  ";
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
                    it.compositeRule = $it.compositeRule = $wasComposite;
                } else {
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
                }
            }
            it.errorPath = $currentErrorPath;
        }
        if ($someProperties) out += " } ";
        out += " }  ";
        if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
        }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while(i3 < l3){
                $propertyKey = arr3[i3 += 1];
                var $sch = $schema[$propertyKey];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== undefined;
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + $prop;
                    $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
                    $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                    $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                        $code = it.util.varReplace($code, $nextData, $passData);
                        var $useData = $passData;
                    } else {
                        var $useData = $nextData;
                        out += " var " + $nextData + " = " + $passData + "; ";
                    }
                    if ($hasDefault) out += " " + $code + " ";
                    else {
                        if ($requiredHash && $requiredHash[$propertyKey]) {
                            out += " if ( " + $useData + " === undefined ";
                            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += ") { " + $nextValid + " = false; ";
                            var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                            $errSchemaPath = it.errSchemaPath + "/required";
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ""; /* istanbul ignore else */ 
                            if (it.createErrors !== false) {
                                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                                if (it.opts.messages !== false) {
                                    out += " , message: '";
                                    if (it.opts._errorDataPathProperty) out += "is a required property";
                                    else out += "should have required property \\'" + $missingProperty + "\\'";
                                    out += "' ";
                                }
                                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                                out += " } ";
                            } else out += " {} ";
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                                else out += " validate.errors = [" + __err + "]; return false; ";
                            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                            $errSchemaPath = $currErrSchemaPath;
                            it.errorPath = $currentErrorPath;
                            out += " } else { ";
                        } else if ($breakOnError) {
                            out += " if ( " + $useData + " === undefined ";
                            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += ") { " + $nextValid + " = true; } else { ";
                        } else {
                            out += " if (" + $useData + " !== undefined ";
                            if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += " ) { ";
                        }
                        out += " " + $code + " } ";
                    }
                }
                if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                }
            }
        }
    }
    if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
            var $pProperty, i4 = -1, l4 = arr4.length - 1;
            while(i4 < l4){
                $pProperty = arr4[i4 += 1];
                var $sch = $pProperties[$pProperty];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    $it.schema = $sch;
                    $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
                    $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
                    if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
                    else out += " for (var " + $key + " in " + $data + ") { ";
                    out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
                    out += " } ";
                    if ($breakOnError) out += " else " + $nextValid + " = true; ";
                    out += " }  ";
                    if ($breakOnError) {
                        out += " if (" + $nextValid + ") { ";
                        $closingBraces += "}";
                    }
                }
            }
        }
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"6jF0e":[function(require,module,exports) {
"use strict";
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) out += " var " + $dataProperties + " = undefined; ";
        if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        else out += " for (var " + $key + " in " + $data + ") { ";
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
            if (it.opts.messages !== false) out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        if ($breakOnError) out += " break; ";
        out += " } }";
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"bbInV":[function(require,module,exports) {
"use strict";
module.exports = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
            var $required = [];
            var arr1 = $schema;
            if (arr1) {
                var $property, i1 = -1, l1 = arr1.length - 1;
                while(i1 < l1){
                    $property = arr1[i1 += 1];
                    var $propertySch = it.schema.properties[$property];
                    if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) $required[$required.length] = $property;
                }
            }
        } else var $required = $schema;
    }
    if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
            out += " var missing" + $lvl + "; ";
            if ($loopRequired) {
                if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
                var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                out += " var " + $valid + " = true; ";
                if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
                out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
                if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
                out += "; if (!" + $valid + ") break; } ";
                if ($isData) out += "  }  ";
                out += "  if (!" + $valid + ") {   ";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } else { ";
            } else {
                out += " if ( ";
                var arr2 = $required;
                if (arr2) {
                    var $propertyKey, $i = -1, l2 = arr2.length - 1;
                    while($i < l2){
                        $propertyKey = arr2[$i += 1];
                        if ($i) out += " || ";
                        var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                        out += " ( ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                    }
                }
                out += ") {  ";
                var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } else { ";
            }
        } else if ($loopRequired) {
            if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            if ($isData) {
                out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   "; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            out += ") {  var err =   "; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) out += "is a required property";
                    else out += "should have required property \\'" + $missingProperty + "\\'";
                    out += "' ";
                }
                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) out += "  }  ";
        } else {
            var arr3 = $required;
            if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while(i3 < l3){
                    $propertyKey = arr3[i3 += 1];
                    var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                    if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    out += ") {  var err =   "; /* istanbul ignore else */ 
                    if (it.createErrors !== false) {
                        out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                        if (it.opts.messages !== false) {
                            out += " , message: '";
                            if (it.opts._errorDataPathProperty) out += "is a required property";
                            else out += "should have required property \\'" + $missingProperty + "\\'";
                            out += "' ";
                        }
                        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                        out += " } ";
                    } else out += " {} ";
                    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
            }
        }
        it.errorPath = $currentErrorPath;
    } else if ($breakOnError) out += " if (true) {";
    return out;
};

},{}],"1fSfs":[function(require,module,exports) {
"use strict";
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        else {
            out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
            var $method = "checkDataType" + ($typeIsArray ? "s" : "");
            out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
            if ($typeIsArray) out += " if (typeof item == 'string') item = '\"' + item; ";
            out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) out += "  }  ";
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
            if (it.opts.messages !== false) out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
            if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) out += "validate.schema" + $schemaPath;
                else out += "" + $schema;
                out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } ";
        if ($breakOnError) out += " else { ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"brIE5":[function(require,module,exports) {
"use strict";
var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
];
module.exports = function(metaSchema, keywordsJsonPointers) {
    for(var i = 0; i < keywordsJsonPointers.length; i++){
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for(j = 1; j < segments.length; j++)keywords = keywords[segments[j]];
        for(j = 0; j < KEYWORDS.length; j++){
            var key = KEYWORDS[j];
            var schema = keywords[key];
            if (schema) keywords[key] = {
                anyOf: [
                    schema,
                    {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }
                ]
            };
        }
    }
    return metaSchema;
};

},{}],"6gt4e":[function(require,module,exports) {
"use strict";
var MissingRefError = require("a18ea71e70251293").MissingRef;
module.exports = compileAsync;
/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */ function compileAsync(schema, meta, callback) {
    /* eslint no-shadow: 0 */ /* global Promise */ /* jshint validthis: true */ var self = this;
    if (typeof this._opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
        callback = meta;
        meta = undefined;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self._addSchema(schema, undefined, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) p.then(function(v) {
        callback(null, v);
    }, callback);
    return p;
    function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema) ? compileAsync.call(self, {
            $ref: $schema
        }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
        try {
            return self._compile(schemaObj);
        } catch (e) {
            if (e instanceof MissingRefError) return loadMissingSchema(e);
            throw e;
        }
        function loadMissingSchema(e) {
            var ref = e.missingSchema;
            if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
            var schemaPromise = self._loadingSchemas[ref];
            if (!schemaPromise) {
                schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
                schemaPromise.then(removePromise, removePromise);
            }
            return schemaPromise.then(function(sch) {
                if (!added(ref)) return loadMetaSchemaOf(sch).then(function() {
                    if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
                });
            }).then(function() {
                return _compileAsync(schemaObj);
            });
            function removePromise() {
                delete self._loadingSchemas[ref];
            }
            function added(ref) {
                return self._refs[ref] || self._schemas[ref];
            }
        }
    }
}

},{"a18ea71e70251293":"2CCBr"}],"bUesF":[function(require,module,exports) {
"use strict";
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require("2eb02720cefc34c7");
var definitionSchema = require("3e1481dcb7c8ff2f");
module.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
};
/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */ function addKeyword(keyword, definition) {
    /* jshint validthis: true */ /* eslint no-shadow: 0 */ var RULES = this.RULES;
    if (RULES.keywords[keyword]) throw new Error("Keyword " + keyword + " is already defined");
    if (!IDENTIFIER.test(keyword)) throw new Error("Keyword " + keyword + " is not a valid identifier");
    if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) for(var i = 0; i < dataType.length; i++)_addRule(keyword, dataType[i], definition);
        else _addRule(keyword, dataType, definition);
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
            if (definition.$data && this._opts.$data) metaSchema = {
                anyOf: [
                    metaSchema,
                    {
                        "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }
                ]
            };
            definition.validateSchema = this.compile(metaSchema, true);
        }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword, dataType, definition) {
        var ruleGroup;
        for(var i = 0; i < RULES.length; i++){
            var rg = RULES[i];
            if (rg.type == dataType) {
                ruleGroup = rg;
                break;
            }
        }
        if (!ruleGroup) {
            ruleGroup = {
                type: dataType,
                rules: []
            };
            RULES.push(ruleGroup);
        }
        var rule = {
            keyword: keyword,
            definition: definition,
            custom: true,
            code: customRuleCode,
            implements: definition.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword] = rule;
    }
    return this;
}
/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */ function getKeyword(keyword) {
    /* jshint validthis: true */ var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */ function removeKeyword(keyword) {
    /* jshint validthis: true */ var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for(var i = 0; i < RULES.length; i++){
        var rules = RULES[i].rules;
        for(var j = 0; j < rules.length; j++)if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
        }
    }
    return this;
}
/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */ function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition)) return true;
    validateKeyword.errors = v.errors;
    if (throwError) throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else return false;
}

},{"2eb02720cefc34c7":"bEt8E","3e1481dcb7c8ff2f":"7qT17"}],"bEt8E":[function(require,module,exports) {
"use strict";
module.exports = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) out += "" + $ruleErrs + " = null;";
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
            $closingBraces += "}";
            out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
    }
    if ($inline) {
        if ($rDef.statements) out += " " + $ruleValidate.validate + " ";
        else out += " " + $valid + " = " + $ruleValidate.validate + "; ";
    } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
    } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) out += "this";
        else out += "self";
        if ($compile || $rDef.schema === false) out += " , " + $data + " ";
        else out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        out += " , (dataPath || '')";
        if (it.errorPath != '""') out += " + " + it.errorPath;
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
            out += " " + $valid + " = ";
            if ($asyncKeyword) out += "await ";
            out += "" + def_callRuleValidate + "; ";
        } else if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
    }
    if ($rDef.modifying) out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    out += "" + $closingBraces;
    if ($rDef.valid) {
        if ($breakOnError) out += " if (true) { ";
    } else {
        out += " if ( ";
        if ($rDef.valid === undefined) {
            out += " !";
            if ($macro) out += "" + $nextValid;
            else out += "" + $valid;
        } else out += " " + !$rDef.valid + " ";
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
            if ($rDef.errors) {
                if ($rDef.errors != "full") {
                    out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                    if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                    out += " } ";
                }
            } else if ($rDef.errors === false) out += " " + def_customError + " ";
            else {
                out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                out += " } } ";
            }
        } else if ($macro) {
            out += "   var err =   "; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
                if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
                else out += " validate.errors = vErrors; return false; ";
            }
        } else if ($rDef.errors === false) out += " " + def_customError + " ";
        else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            out += " } } else { " + def_customError + " } ";
        }
        out += " } ";
        if ($breakOnError) out += " else { ";
    }
    return out;
};

},{}],"7qT17":[function(require,module,exports) {
"use strict";
var metaSchema = require("56b1049aa06f7c21");
module.exports = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
        schema: [
            "validate"
        ],
        $data: [
            "validate"
        ],
        statements: [
            "inline"
        ],
        valid: {
            not: {
                required: [
                    "macro"
                ]
            }
        }
    },
    properties: {
        type: metaSchema.properties.type,
        schema: {
            type: "boolean"
        },
        statements: {
            type: "boolean"
        },
        dependencies: {
            type: "array",
            items: {
                type: "string"
            }
        },
        metaSchema: {
            type: "object"
        },
        modifying: {
            type: "boolean"
        },
        valid: {
            type: "boolean"
        },
        $data: {
            type: "boolean"
        },
        async: {
            type: "boolean"
        },
        errors: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    const: "full"
                }
            ]
        }
    }
};

},{"56b1049aa06f7c21":"66Yv9"}],"66Yv9":[function(require,module,exports) {
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

},{}],"8zgol":[function(require,module,exports) {
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

},{}],"630Jy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SSEClientTransport = exports.SseError = void 0;
const eventsource_1 = require("a061df00f9f5f87");
const types_js_1 = require("ead8e3b10b8466e6");
const auth_js_1 = require("64b720d250a30bca");
class SseError extends Error {
    constructor(code, message, event){
        super(`SSE error: ${message}`);
        this.code = code;
        this.event = event;
    }
}
exports.SseError = SseError;
/**
 * Client transport for SSE: this will connect to a server using Server-Sent Events for receiving
 * messages and make separate POST requests for sending messages.
 */ class SSEClientTransport {
    constructor(url, opts){
        this._url = url;
        this._resourceMetadataUrl = undefined;
        this._eventSourceInit = opts === null || opts === void 0 ? void 0 : opts.eventSourceInit;
        this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
        this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
        this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
    }
    async _authThenStart() {
        var _a;
        if (!this._authProvider) throw new auth_js_1.UnauthorizedError("No auth provider");
        let result;
        try {
            result = await (0, auth_js_1.auth)(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch
            });
        } catch (error) {
            (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
            throw error;
        }
        if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError();
        return await this._startOrAuth();
    }
    async _commonHeaders() {
        var _a;
        const headers = {};
        if (this._authProvider) {
            const tokens = await this._authProvider.tokens();
            if (tokens) headers["Authorization"] = `Bearer ${tokens.access_token}`;
        }
        if (this._protocolVersion) headers["mcp-protocol-version"] = this._protocolVersion;
        return new Headers({
            ...headers,
            ...(_a = this._requestInit) === null || _a === void 0 ? void 0 : _a.headers
        });
    }
    _startOrAuth() {
        var _a, _b, _c;
        const fetchImpl = (_c = (_b = (_a = this === null || this === void 0 ? void 0 : this._eventSourceInit) === null || _a === void 0 ? void 0 : _a.fetch) !== null && _b !== void 0 ? _b : this._fetch) !== null && _c !== void 0 ? _c : fetch;
        return new Promise((resolve, reject)=>{
            this._eventSource = new eventsource_1.EventSource(this._url.href, {
                ...this._eventSourceInit,
                fetch: async (url, init)=>{
                    const headers = await this._commonHeaders();
                    headers.set("Accept", "text/event-stream");
                    const response = await fetchImpl(url, {
                        ...init,
                        headers
                    });
                    if (response.status === 401 && response.headers.has("www-authenticate")) this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
                    return response;
                }
            });
            this._abortController = new AbortController();
            this._eventSource.onerror = (event)=>{
                var _a;
                if (event.code === 401 && this._authProvider) {
                    this._authThenStart().then(resolve, reject);
                    return;
                }
                const error = new SseError(event.code, event.message, event);
                reject(error);
                (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
            };
            this._eventSource.onopen = ()=>{
            // The connection is open, but we need to wait for the endpoint to be received.
            };
            this._eventSource.addEventListener("endpoint", (event)=>{
                var _a;
                const messageEvent = event;
                try {
                    this._endpoint = new URL(messageEvent.data, this._url);
                    if (this._endpoint.origin !== this._url.origin) throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
                } catch (error) {
                    reject(error);
                    (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
                    this.close();
                    return;
                }
                resolve();
            });
            this._eventSource.onmessage = (event)=>{
                var _a, _b;
                const messageEvent = event;
                let message;
                try {
                    message = types_js_1.JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
                } catch (error) {
                    (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
                    return;
                }
                (_b = this.onmessage) === null || _b === void 0 || _b.call(this, message);
            };
        });
    }
    async start() {
        if (this._eventSource) throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        return await this._startOrAuth();
    }
    /**
     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
     */ async finishAuth(authorizationCode) {
        if (!this._authProvider) throw new auth_js_1.UnauthorizedError("No auth provider");
        const result = await (0, auth_js_1.auth)(this._authProvider, {
            serverUrl: this._url,
            authorizationCode,
            resourceMetadataUrl: this._resourceMetadataUrl,
            fetchFn: this._fetch
        });
        if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError("Failed to authorize");
    }
    async close() {
        var _a, _b, _c;
        (_a = this._abortController) === null || _a === void 0 || _a.abort();
        (_b = this._eventSource) === null || _b === void 0 || _b.close();
        (_c = this.onclose) === null || _c === void 0 || _c.call(this);
    }
    async send(message) {
        var _a, _b, _c;
        if (!this._endpoint) throw new Error("Not connected");
        try {
            const headers = await this._commonHeaders();
            headers.set("content-type", "application/json");
            const init = {
                ...this._requestInit,
                method: "POST",
                headers,
                body: JSON.stringify(message),
                signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
            };
            const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._endpoint, init);
            if (!response.ok) {
                if (response.status === 401 && this._authProvider) {
                    this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
                    const result = await (0, auth_js_1.auth)(this._authProvider, {
                        serverUrl: this._url,
                        resourceMetadataUrl: this._resourceMetadataUrl,
                        fetchFn: this._fetch
                    });
                    if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError();
                    // Purposely _not_ awaited, so we don't call onerror twice
                    return this.send(message);
                }
                const text = await response.text().catch(()=>null);
                throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
            }
        } catch (error) {
            (_c = this.onerror) === null || _c === void 0 || _c.call(this, error);
            throw error;
        }
    }
    setProtocolVersion(version) {
        this._protocolVersion = version;
    }
}
exports.SSEClientTransport = SSEClientTransport;

},{"a061df00f9f5f87":"9furR","ead8e3b10b8466e6":"cqTxf","64b720d250a30bca":"3sJTi"}],"9furR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ErrorEvent", ()=>ErrorEvent);
parcelHelpers.export(exports, "EventSource", ()=>EventSource);
var _eventsourceParser = require("eventsource-parser");
class ErrorEvent extends Event {
    /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */ constructor(type, errorEventInitDict){
        var _a, _b;
        super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
    }
    /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */ [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        return inspect(inspectableError(this), options);
    }
    /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */ [Symbol.for("Deno.customInspect")](inspect, options) {
        return inspect(inspectableError(this), options);
    }
}
function syntaxError(message) {
    const DomException = globalThis.DOMException;
    return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
    return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
    return {
        type: err.type,
        message: err.message,
        code: err.code,
        defaultPrevented: err.defaultPrevented,
        cancelable: err.cancelable,
        timeStamp: err.timeStamp
    };
}
var __typeError = (msg)=>{
    throw TypeError(msg);
}, __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
class EventSource extends EventTarget {
    constructor(url, eventSourceInitDict){
        var _a, _b;
        super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response)=>{
            var _a2;
            __privateGet(this, _parser).reset();
            const { body, redirected, status, headers } = response;
            if (status === 204) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
                return;
            }
            if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
                return;
            }
            if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
                return;
            }
            if (__privateGet(this, _readyState) === this.CLOSED) return;
            __privateSet(this, _readyState, this.OPEN);
            const openEvent = new Event("open");
            if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
                return;
            }
            const decoder = new TextDecoder(), reader = body.getReader();
            let open = !0;
            do {
                const { done, value } = await reader.read();
                value && __privateGet(this, _parser).feed(decoder.decode(value, {
                    stream: !done
                })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
            }while (open);
        }), __privateAdd(this, _onFetchError, (err)=>{
            __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
        }), __privateAdd(this, _onEvent, (event)=>{
            typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
            const messageEvent = new MessageEvent(event.event || "message", {
                data: event.data,
                origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
                lastEventId: event.id || ""
            });
            __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
        }), __privateAdd(this, _onRetryChange, (value)=>{
            __privateSet(this, _reconnectInterval, value);
        }), __privateAdd(this, _reconnect, ()=>{
            __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
        });
        try {
            if (url instanceof URL) __privateSet(this, _url, url);
            else if (typeof url == "string") __privateSet(this, _url, new URL(url, getBaseURL()));
            else throw new Error("Invalid URL");
        } catch  {
            throw syntaxError("An invalid or illegal string was specified");
        }
        __privateSet(this, _parser, (0, _eventsourceParser.createParser)({
            onEvent: __privateGet(this, _onEvent),
            onRetry: __privateGet(this, _onRetryChange)
        })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */ get readyState() {
        return __privateGet(this, _readyState);
    }
    /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */ get url() {
        return __privateGet(this, _url).href;
    }
    /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */ get withCredentials() {
        return __privateGet(this, _withCredentials);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */ get onerror() {
        return __privateGet(this, _onError);
    }
    set onerror(value) {
        __privateSet(this, _onError, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */ get onmessage() {
        return __privateGet(this, _onMessage);
    }
    set onmessage(value) {
        __privateSet(this, _onMessage, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */ get onopen() {
        return __privateGet(this, _onOpen);
    }
    set onopen(value) {
        __privateSet(this, _onOpen, value);
    }
    addEventListener(type, listener, options) {
        const listen = listener;
        super.addEventListener(type, listen, options);
    }
    removeEventListener(type, listener, options) {
        const listen = listener;
        super.removeEventListener(type, listen, options);
    }
    /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */ close() {
        __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
    }
}
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/ connect_fn = function() {
    __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/ getRequestOptions_fn = function() {
    var _a;
    const init = {
        // [spec] Let `corsAttributeState` be `Anonymous`\u2026
        // [spec] \u2026will have their mode set to "cors"\u2026
        mode: "cors",
        redirect: "follow",
        headers: {
            Accept: "text/event-stream",
            ...__privateGet(this, _lastEventId) ? {
                "Last-Event-ID": __privateGet(this, _lastEventId)
            } : void 0
        },
        cache: "no-store",
        signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal
    };
    return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ failConnection_fn = function(message, code) {
    var _a;
    __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ scheduleReconnect_fn = function(message, code) {
    var _a;
    if (__privateGet(this, _readyState) === this.CLOSED) return;
    __privateSet(this, _readyState, this.CONNECTING);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/ EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/ EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/ EventSource.CLOSED = 2;
function getBaseURL() {
    const doc = "document" in globalThis ? globalThis.document : void 0;
    return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}

},{"eventsource-parser":"4FXrw","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"4FXrw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ParseError", ()=>ParseError);
parcelHelpers.export(exports, "createParser", ()=>createParser);
class ParseError extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
}
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = !1;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\x00") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"3sJTi":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnauthorizedError = void 0;
exports.parseErrorResponse = parseErrorResponse;
exports.auth = auth;
exports.selectResourceURL = selectResourceURL;
exports.extractResourceMetadataUrl = extractResourceMetadataUrl;
exports.discoverOAuthProtectedResourceMetadata = discoverOAuthProtectedResourceMetadata;
exports.discoverOAuthMetadata = discoverOAuthMetadata;
exports.buildDiscoveryUrls = buildDiscoveryUrls;
exports.discoverAuthorizationServerMetadata = discoverAuthorizationServerMetadata;
exports.startAuthorization = startAuthorization;
exports.exchangeAuthorization = exchangeAuthorization;
exports.refreshAuthorization = refreshAuthorization;
exports.registerClient = registerClient;
const pkce_challenge_1 = __importDefault(require("577f380df1a9847c"));
const types_js_1 = require("d1137141d2c4e193");
const auth_js_1 = require("e7f1ee2964d2231b");
const auth_js_2 = require("e7f1ee2964d2231b");
const auth_utils_js_1 = require("aebeafd3a3b920d0");
const errors_js_1 = require("404492e758091926");
class UnauthorizedError extends Error {
    constructor(message){
        super(message !== null && message !== void 0 ? message : "Unauthorized");
    }
}
exports.UnauthorizedError = UnauthorizedError;
const AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
const AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
/**
 * Determines the best client authentication method to use based on server support and client configuration.
 *
 * Priority order (highest to lowest):
 * 1. client_secret_basic (if client secret is available)
 * 2. client_secret_post (if client secret is available)
 * 3. none (for public clients)
 *
 * @param clientInformation - OAuth client information containing credentials
 * @param supportedMethods - Authentication methods supported by the authorization server
 * @returns The selected authentication method
 */ function selectClientAuthMethod(clientInformation, supportedMethods) {
    const hasClientSecret = clientInformation.client_secret !== undefined;
    // If server doesn't specify supported methods, use RFC 6749 defaults
    if (supportedMethods.length === 0) return hasClientSecret ? "client_secret_post" : "none";
    // Try methods in priority order (most secure first)
    if (hasClientSecret && supportedMethods.includes("client_secret_basic")) return "client_secret_basic";
    if (hasClientSecret && supportedMethods.includes("client_secret_post")) return "client_secret_post";
    if (supportedMethods.includes("none")) return "none";
    // Fallback: use what we have
    return hasClientSecret ? "client_secret_post" : "none";
}
/**
 * Applies client authentication to the request based on the specified method.
 *
 * Implements OAuth 2.1 client authentication methods:
 * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)
 * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)
 * - none: Public client authentication (RFC 6749 Section 2.1)
 *
 * @param method - The authentication method to use
 * @param clientInformation - OAuth client information containing credentials
 * @param headers - HTTP headers object to modify
 * @param params - URL search parameters to modify
 * @throws {Error} When required credentials are missing
 */ function applyClientAuthentication(method, clientInformation, headers, params) {
    const { client_id, client_secret } = clientInformation;
    switch(method){
        case "client_secret_basic":
            applyBasicAuth(client_id, client_secret, headers);
            return;
        case "client_secret_post":
            applyPostAuth(client_id, client_secret, params);
            return;
        case "none":
            applyPublicAuth(client_id, params);
            return;
        default:
            throw new Error(`Unsupported client authentication method: ${method}`);
    }
}
/**
 * Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)
 */ function applyBasicAuth(clientId, clientSecret, headers) {
    if (!clientSecret) throw new Error("client_secret_basic authentication requires a client_secret");
    const credentials = btoa(`${clientId}:${clientSecret}`);
    headers.set("Authorization", `Basic ${credentials}`);
}
/**
 * Applies POST body authentication (RFC 6749 Section 2.3.1)
 */ function applyPostAuth(clientId, clientSecret, params) {
    params.set("client_id", clientId);
    if (clientSecret) params.set("client_secret", clientSecret);
}
/**
 * Applies public client authentication (RFC 6749 Section 2.1)
 */ function applyPublicAuth(clientId, params) {
    params.set("client_id", clientId);
}
/**
 * Parses an OAuth error response from a string or Response object.
 *
 * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec
 * and an instance of the appropriate OAuthError subclass will be returned.
 * If parsing fails, it falls back to a generic ServerError that includes
 * the response status (if available) and original content.
 *
 * @param input - A Response object or string containing the error response
 * @returns A Promise that resolves to an OAuthError instance
 */ async function parseErrorResponse(input) {
    const statusCode = input instanceof Response ? input.status : undefined;
    const body = input instanceof Response ? await input.text() : input;
    try {
        const result = auth_js_1.OAuthErrorResponseSchema.parse(JSON.parse(body));
        const { error, error_description, error_uri } = result;
        const errorClass = errors_js_1.OAUTH_ERRORS[error] || errors_js_1.ServerError;
        return new errorClass(error_description || "", error_uri);
    } catch (error) {
        // Not a valid OAuth error response, but try to inform the user of the raw data anyway
        const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
        return new errors_js_1.ServerError(errorMessage);
    }
}
/**
 * Orchestrates the full auth flow with a server.
 *
 * This can be used as a single entry point for all authorization functionality,
 * instead of linking together the other lower-level functions in this module.
 */ async function auth(provider, options) {
    var _a, _b;
    try {
        return await authInternal(provider, options);
    } catch (error) {
        // Handle recoverable error types by invalidating credentials and retrying
        if (error instanceof errors_js_1.InvalidClientError || error instanceof errors_js_1.UnauthorizedClientError) {
            await ((_a = provider.invalidateCredentials) === null || _a === void 0 ? void 0 : _a.call(provider, "all"));
            return await authInternal(provider, options);
        } else if (error instanceof errors_js_1.InvalidGrantError) {
            await ((_b = provider.invalidateCredentials) === null || _b === void 0 ? void 0 : _b.call(provider, "tokens"));
            return await authInternal(provider, options);
        }
        // Throw otherwise
        throw error;
    }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
    let resourceMetadata;
    let authorizationServerUrl;
    try {
        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, {
            resourceMetadataUrl
        }, fetchFn);
        if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) authorizationServerUrl = resourceMetadata.authorization_servers[0];
    } catch (_a) {
    // Ignore errors and fall back to /.well-known/oauth-authorization-server
    }
    /**
     * If we don't get a valid authorization server metadata from protected resource metadata,
     * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server acts as the Authorization server.
     */ if (!authorizationServerUrl) authorizationServerUrl = serverUrl;
    const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
    const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
        fetchFn
    });
    // Handle client registration if needed
    let clientInformation = await Promise.resolve(provider.clientInformation());
    if (!clientInformation) {
        if (authorizationCode !== undefined) throw new Error("Existing OAuth client information is required when exchanging an authorization code");
        if (!provider.saveClientInformation) throw new Error("OAuth client information must be saveable for dynamic registration");
        const fullInformation = await registerClient(authorizationServerUrl, {
            metadata,
            clientMetadata: provider.clientMetadata,
            fetchFn
        });
        await provider.saveClientInformation(fullInformation);
        clientInformation = fullInformation;
    }
    // Exchange authorization code for tokens
    if (authorizationCode !== undefined) {
        const codeVerifier = await provider.codeVerifier();
        const tokens = await exchangeAuthorization(authorizationServerUrl, {
            metadata,
            clientInformation,
            authorizationCode,
            codeVerifier,
            redirectUri: provider.redirectUrl,
            resource,
            addClientAuthentication: provider.addClientAuthentication,
            fetchFn: fetchFn
        });
        await provider.saveTokens(tokens);
        return "AUTHORIZED";
    }
    const tokens = await provider.tokens();
    // Handle token refresh or new authorization
    if (tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token) try {
        // Attempt to refresh the token
        const newTokens = await refreshAuthorization(authorizationServerUrl, {
            metadata,
            clientInformation,
            refreshToken: tokens.refresh_token,
            resource,
            addClientAuthentication: provider.addClientAuthentication,
            fetchFn
        });
        await provider.saveTokens(newTokens);
        return "AUTHORIZED";
    } catch (error) {
        // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.
        if (!(error instanceof errors_js_1.OAuthError) || error instanceof errors_js_1.ServerError) ;
        else // Refresh failed for another reason, re-throw
        throw error;
    }
    const state = provider.state ? await provider.state() : undefined;
    // Start new authorization flow
    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        state,
        redirectUrl: provider.redirectUrl,
        scope: scope || provider.clientMetadata.scope,
        resource
    });
    await provider.saveCodeVerifier(codeVerifier);
    await provider.redirectToAuthorization(authorizationUrl);
    return "REDIRECT";
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
    const defaultResource = (0, auth_utils_js_1.resourceUrlFromServerUrl)(serverUrl);
    // If provider has custom validation, delegate to it
    if (provider.validateResourceURL) return await provider.validateResourceURL(defaultResource, resourceMetadata === null || resourceMetadata === void 0 ? void 0 : resourceMetadata.resource);
    // Only include resource parameter when Protected Resource Metadata is present
    if (!resourceMetadata) return undefined;
    // Validate that the metadata's resource is compatible with our request
    if (!(0, auth_utils_js_1.checkResourceAllowed)({
        requestedResource: defaultResource,
        configuredResource: resourceMetadata.resource
    })) throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
    // Prefer the resource from metadata since it's what the server is telling us to request
    return new URL(resourceMetadata.resource);
}
/**
 * Extract resource_metadata from response header.
 */ function extractResourceMetadataUrl(res) {
    const authenticateHeader = res.headers.get("WWW-Authenticate");
    if (!authenticateHeader) return undefined;
    const [type, scheme] = authenticateHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !scheme) return undefined;
    const regex = /resource_metadata="([^"]*)"/;
    const match = regex.exec(authenticateHeader);
    if (!match) return undefined;
    try {
        return new URL(match[1]);
    } catch (_a) {
        return undefined;
    }
}
/**
 * Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.
 *
 * If the server returns a 404 for the well-known endpoint, this function will
 * return `undefined`. Any other errors will be thrown as exceptions.
 */ async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
    const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
        protocolVersion: opts === null || opts === void 0 ? void 0 : opts.protocolVersion,
        metadataUrl: opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl
    });
    if (!response || response.status === 404) throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
    if (!response.ok) throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
    return auth_js_2.OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
/**
 * Helper function to handle fetch with CORS retry logic
 */ async function fetchWithCorsRetry(url, headers, fetchFn = fetch) {
    try {
        return await fetchFn(url, {
            headers
        });
    } catch (error) {
        if (error instanceof TypeError) {
            if (headers) // CORS errors come back as TypeError, retry without headers
            return fetchWithCorsRetry(url, undefined, fetchFn);
            else // We're getting CORS errors on retry too, return undefined
            return undefined;
        }
        throw error;
    }
}
/**
 * Constructs the well-known path for auth-related metadata discovery
 */ function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
    // Strip trailing slash from pathname to avoid double slashes
    if (pathname.endsWith("/")) pathname = pathname.slice(0, -1);
    return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
/**
 * Tries to discover OAuth metadata at a specific URL
 */ async function tryMetadataDiscovery(url, protocolVersion, fetchFn = fetch) {
    const headers = {
        "MCP-Protocol-Version": protocolVersion
    };
    return await fetchWithCorsRetry(url, headers, fetchFn);
}
/**
 * Determines if fallback to root discovery should be attempted
 */ function shouldAttemptFallback(response, pathname) {
    return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
/**
 * Generic function for discovering OAuth metadata with fallback support
 */ async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
    var _a, _b;
    const issuer = new URL(serverUrl);
    const protocolVersion = (_a = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a !== void 0 ? _a : types_js_1.LATEST_PROTOCOL_VERSION;
    let url;
    if (opts === null || opts === void 0 ? void 0 : opts.metadataUrl) url = new URL(opts.metadataUrl);
    else {
        // Try path-aware discovery first
        const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
        url = new URL(wellKnownPath, (_b = opts === null || opts === void 0 ? void 0 : opts.metadataServerUrl) !== null && _b !== void 0 ? _b : issuer);
        url.search = issuer.search;
    }
    let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);
    // If path-aware discovery fails with 404 and we're not already at root, try fallback to root discovery
    if (!(opts === null || opts === void 0 ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {
        const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
        response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
    }
    return response;
}
/**
 * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.
 *
 * If the server returns a 404 for the well-known endpoint, this function will
 * return `undefined`. Any other errors will be thrown as exceptions.
 *
 * @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.
 */ async function discoverOAuthMetadata(issuer, { authorizationServerUrl, protocolVersion } = {}, fetchFn = fetch) {
    if (typeof issuer === "string") issuer = new URL(issuer);
    if (!authorizationServerUrl) authorizationServerUrl = issuer;
    if (typeof authorizationServerUrl === "string") authorizationServerUrl = new URL(authorizationServerUrl);
    protocolVersion !== null && protocolVersion !== void 0 ? protocolVersion : protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION;
    const response = await discoverMetadataWithFallback(authorizationServerUrl, "oauth-authorization-server", fetchFn, {
        protocolVersion,
        metadataServerUrl: authorizationServerUrl
    });
    if (!response || response.status === 404) return undefined;
    if (!response.ok) throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
    return auth_js_2.OAuthMetadataSchema.parse(await response.json());
}
/**
 * Builds a list of discovery URLs to try for authorization server metadata.
 * URLs are returned in priority order:
 * 1. OAuth metadata at the given URL
 * 2. OAuth metadata at root (if URL has path)
 * 3. OIDC metadata endpoints
 */ function buildDiscoveryUrls(authorizationServerUrl) {
    const url = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
    const hasPath = url.pathname !== "/";
    const urlsToTry = [];
    if (!hasPath) {
        // Root path: https://example.com/.well-known/oauth-authorization-server
        urlsToTry.push({
            url: new URL("/.well-known/oauth-authorization-server", url.origin),
            type: "oauth"
        });
        // OIDC: https://example.com/.well-known/openid-configuration
        urlsToTry.push({
            url: new URL(`/.well-known/openid-configuration`, url.origin),
            type: "oidc"
        });
        return urlsToTry;
    }
    // Strip trailing slash from pathname to avoid double slashes
    let pathname = url.pathname;
    if (pathname.endsWith("/")) pathname = pathname.slice(0, -1);
    // 1. OAuth metadata at the given URL
    // Insert well-known before the path: https://example.com/.well-known/oauth-authorization-server/tenant1
    urlsToTry.push({
        url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),
        type: "oauth"
    });
    // Root path: https://example.com/.well-known/oauth-authorization-server
    urlsToTry.push({
        url: new URL("/.well-known/oauth-authorization-server", url.origin),
        type: "oauth"
    });
    // 3. OIDC metadata endpoints
    // RFC 8414 style: Insert /.well-known/openid-configuration before the path
    urlsToTry.push({
        url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),
        type: "oidc"
    });
    // OIDC Discovery 1.0 style: Append /.well-known/openid-configuration after the path
    urlsToTry.push({
        url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),
        type: "oidc"
    });
    return urlsToTry;
}
/**
 * Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata
 * and OpenID Connect Discovery 1.0 specifications.
 *
 * This function implements a fallback strategy for authorization server discovery:
 * 1. Attempts RFC 8414 OAuth metadata discovery first
 * 2. If OAuth discovery fails, falls back to OpenID Connect Discovery
 *
 * @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's
 *                                 protected resource metadata, or the MCP server's URL if the
 *                                 metadata was not found.
 * @param options - Configuration options
 * @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch
 * @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION
 * @returns Promise resolving to authorization server metadata, or undefined if discovery fails
 */ async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION } = {}) {
    const headers = {
        "MCP-Protocol-Version": protocolVersion
    };
    // Get the list of URLs to try
    const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
    // Try each URL in order
    for (const { url: endpointUrl, type } of urlsToTry){
        const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
        if (!response) continue;
        if (!response.ok) {
            // Continue looking for any 4xx response code.
            if (response.status >= 400 && response.status < 500) continue; // Try next URL
            throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
        }
        // Parse and validate based on type
        if (type === "oauth") return auth_js_2.OAuthMetadataSchema.parse(await response.json());
        else return auth_js_1.OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
    return undefined;
}
/**
 * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.
 */ async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
    let authorizationUrl;
    if (metadata) {
        authorizationUrl = new URL(metadata.authorization_endpoint);
        if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
        if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    } else authorizationUrl = new URL("/authorize", authorizationServerUrl);
    // Generate PKCE challenge
    const challenge = await (0, pkce_challenge_1.default)();
    const codeVerifier = challenge.code_verifier;
    const codeChallenge = challenge.code_challenge;
    authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
    authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
    authorizationUrl.searchParams.set("code_challenge", codeChallenge);
    authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
    authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
    if (state) authorizationUrl.searchParams.set("state", state);
    if (scope) authorizationUrl.searchParams.set("scope", scope);
    if (scope === null || scope === void 0 ? void 0 : scope.includes("offline_access")) // if the request includes the OIDC-only "offline_access" scope,
    // we need to set the prompt to "consent" to ensure the user is prompted to grant offline access
    // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess
    authorizationUrl.searchParams.append("prompt", "consent");
    if (resource) authorizationUrl.searchParams.set("resource", resource.href);
    return {
        authorizationUrl,
        codeVerifier
    };
}
/**
 * Exchanges an authorization code for an access token with the given server.
 *
 * Supports multiple client authentication methods as specified in OAuth 2.1:
 * - Automatically selects the best authentication method based on server support
 * - Falls back to appropriate defaults when server metadata is unavailable
 *
 * @param authorizationServerUrl - The authorization server's base URL
 * @param options - Configuration object containing client info, auth code, etc.
 * @returns Promise resolving to OAuth tokens
 * @throws {Error} When token exchange fails or authentication is invalid
 */ async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
    var _a;
    const grantType = "authorization_code";
    const tokenUrl = (metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
    if ((metadata === null || metadata === void 0 ? void 0 : metadata.grant_types_supported) && !metadata.grant_types_supported.includes(grantType)) throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
    // Exchange code for tokens
    const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded",
        Accept: "application/json"
    });
    const params = new URLSearchParams({
        grant_type: grantType,
        code: authorizationCode,
        code_verifier: codeVerifier,
        redirect_uri: String(redirectUri)
    });
    if (addClientAuthentication) addClientAuthentication(headers, params, authorizationServerUrl, metadata);
    else {
        // Determine and apply client authentication method
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
    }
    if (resource) params.set("resource", resource.href);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthTokensSchema.parse(await response.json());
}
/**
 * Exchange a refresh token for an updated access token.
 *
 * Supports multiple client authentication methods as specified in OAuth 2.1:
 * - Automatically selects the best authentication method based on server support
 * - Preserves the original refresh token if a new one is not returned
 *
 * @param authorizationServerUrl - The authorization server's base URL
 * @param options - Configuration object containing client info, refresh token, etc.
 * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)
 * @throws {Error} When token refresh fails or authentication is invalid
 */ async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
    var _a;
    const grantType = "refresh_token";
    let tokenUrl;
    if (metadata) {
        tokenUrl = new URL(metadata.token_endpoint);
        if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
    } else tokenUrl = new URL("/token", authorizationServerUrl);
    // Exchange refresh token
    const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded"
    });
    const params = new URLSearchParams({
        grant_type: grantType,
        refresh_token: refreshToken
    });
    if (addClientAuthentication) addClientAuthentication(headers, params, authorizationServerUrl, metadata);
    else {
        // Determine and apply client authentication method
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
    }
    if (resource) params.set("resource", resource.href);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthTokensSchema.parse({
        refresh_token: refreshToken,
        ...await response.json()
    });
}
/**
 * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.
 */ async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
    let registrationUrl;
    if (metadata) {
        if (!metadata.registration_endpoint) throw new Error("Incompatible auth server: does not support dynamic client registration");
        registrationUrl = new URL(metadata.registration_endpoint);
    } else registrationUrl = new URL("/register", authorizationServerUrl);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(registrationUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(clientMetadata)
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthClientInformationFullSchema.parse(await response.json());
}

},{"577f380df1a9847c":"8hncT","d1137141d2c4e193":"cqTxf","e7f1ee2964d2231b":"a0kYt","aebeafd3a3b920d0":"wRvBb","404492e758091926":"3sNJj"}],"8hncT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Generate a PKCE code challenge from a code verifier
 * @param code_verifier
 * @returns The base64 url encoded code challenge
 */ parcelHelpers.export(exports, "generateChallenge", ()=>generateChallenge);
parcelHelpers.export(exports, "default", ()=>pkceChallenge);
/** Verify that a code_verifier produces the expected code challenge
 * @param code_verifier
 * @param expectedChallenge The code challenge to verify
 * @returns True if challenges are equal. False otherwise.
 */ parcelHelpers.export(exports, "verifyChallenge", ()=>verifyChallenge);
let crypto;
crypto = globalThis.crypto; // web browsers
/**
 * Creates an array of length `size` of random bytes
 * @param size
 * @returns Array of random ints (0 to 255)
 */ async function getRandomValues(size) {
    return (await crypto).getRandomValues(new Uint8Array(size));
}
/** Generate cryptographically strong random string
 * @param size The desired length of the string
 * @returns The random string
 */ async function random(size) {
    const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let result = "";
    const randomUints = await getRandomValues(size);
    for(let i = 0; i < size; i++){
        // cap the value of the randomIndex to mask.length - 1
        const randomIndex = randomUints[i] % mask.length;
        result += mask[randomIndex];
    }
    return result;
}
/** Generate a PKCE challenge verifier
 * @param length Length of the verifier
 * @returns A random verifier `length` characters long
 */ async function generateVerifier(length) {
    return await random(length);
}
async function generateChallenge(code_verifier) {
    const buffer = await (await crypto).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
    // Generate base64url string
    // btoa is deprecated in Node.js but is used here for web browser compatibility
    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)
    return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
    if (!length) length = 43;
    if (length < 43 || length > 128) throw `Expected a length between 43 and 128. Received ${length}.`;
    const verifier = await generateVerifier(length);
    const challenge = await generateChallenge(verifier);
    return {
        code_verifier: verifier,
        code_challenge: challenge
    };
}
async function verifyChallenge(code_verifier, expectedChallenge) {
    const actualChallenge = await generateChallenge(code_verifier);
    return actualChallenge === expectedChallenge;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"a0kYt":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthTokenRevocationRequestSchema = exports.OAuthClientRegistrationErrorSchema = exports.OAuthClientInformationFullSchema = exports.OAuthClientInformationSchema = exports.OAuthClientMetadataSchema = exports.OAuthErrorResponseSchema = exports.OAuthTokensSchema = exports.OpenIdProviderDiscoveryMetadataSchema = exports.OpenIdProviderMetadataSchema = exports.OAuthMetadataSchema = exports.OAuthProtectedResourceMetadataSchema = exports.SafeUrlSchema = void 0;
const zod_1 = require("cc196583bd0bcc1e");
/**
 * Reusable URL validation that disallows javascript: scheme
 */ exports.SafeUrlSchema = zod_1.z.string().url().superRefine((val, ctx)=>{
    if (!URL.canParse(val)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: "URL must be parseable",
            fatal: true
        });
        return zod_1.z.NEVER;
    }
}).refine((url)=>{
    const u = new URL(url);
    return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
}, {
    message: "URL cannot use javascript:, data:, or vbscript: scheme"
});
/**
 * RFC 9728 OAuth Protected Resource Metadata
 */ exports.OAuthProtectedResourceMetadataSchema = zod_1.z.object({
    resource: zod_1.z.string().url(),
    authorization_servers: zod_1.z.array(exports.SafeUrlSchema).optional(),
    jwks_uri: zod_1.z.string().url().optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    bearer_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    resource_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    resource_name: zod_1.z.string().optional(),
    resource_documentation: zod_1.z.string().optional(),
    resource_policy_uri: zod_1.z.string().url().optional(),
    resource_tos_uri: zod_1.z.string().url().optional(),
    tls_client_certificate_bound_access_tokens: zod_1.z.boolean().optional(),
    authorization_details_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    dpop_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    dpop_bound_access_tokens_required: zod_1.z.boolean().optional()
}).passthrough();
/**
 * RFC 8414 OAuth 2.0 Authorization Server Metadata
 */ exports.OAuthMetadataSchema = zod_1.z.object({
    issuer: zod_1.z.string(),
    authorization_endpoint: exports.SafeUrlSchema,
    token_endpoint: exports.SafeUrlSchema,
    registration_endpoint: exports.SafeUrlSchema.optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    service_documentation: exports.SafeUrlSchema.optional(),
    revocation_endpoint: exports.SafeUrlSchema.optional(),
    revocation_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    revocation_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    introspection_endpoint: zod_1.z.string().optional(),
    introspection_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    introspection_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    code_challenge_methods_supported: zod_1.z.array(zod_1.z.string()).optional()
}).passthrough();
/**
 * OpenID Connect Discovery 1.0 Provider Metadata
 * see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
 */ exports.OpenIdProviderMetadataSchema = zod_1.z.object({
    issuer: zod_1.z.string(),
    authorization_endpoint: exports.SafeUrlSchema,
    token_endpoint: exports.SafeUrlSchema,
    userinfo_endpoint: exports.SafeUrlSchema.optional(),
    jwks_uri: exports.SafeUrlSchema,
    registration_endpoint: exports.SafeUrlSchema.optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    acr_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    subject_types_supported: zod_1.z.array(zod_1.z.string()),
    id_token_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()),
    id_token_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    id_token_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    display_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claim_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_supported: zod_1.z.array(zod_1.z.string()).optional(),
    service_documentation: zod_1.z.string().optional(),
    claims_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    ui_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_parameter_supported: zod_1.z.boolean().optional(),
    request_parameter_supported: zod_1.z.boolean().optional(),
    request_uri_parameter_supported: zod_1.z.boolean().optional(),
    require_request_uri_registration: zod_1.z.boolean().optional(),
    op_policy_uri: exports.SafeUrlSchema.optional(),
    op_tos_uri: exports.SafeUrlSchema.optional()
}).passthrough();
/**
 * OpenID Connect Discovery metadata that may include OAuth 2.0 fields
 * This schema represents the real-world scenario where OIDC providers
 * return a mix of OpenID Connect and OAuth 2.0 metadata fields
 */ exports.OpenIdProviderDiscoveryMetadataSchema = exports.OpenIdProviderMetadataSchema.merge(exports.OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
}));
/**
 * OAuth 2.1 token response
 */ exports.OAuthTokensSchema = zod_1.z.object({
    access_token: zod_1.z.string(),
    id_token: zod_1.z.string().optional(),
    token_type: zod_1.z.string(),
    expires_in: zod_1.z.number().optional(),
    scope: zod_1.z.string().optional(),
    refresh_token: zod_1.z.string().optional()
}).strip();
/**
 * OAuth 2.1 error response
 */ exports.OAuthErrorResponseSchema = zod_1.z.object({
    error: zod_1.z.string(),
    error_description: zod_1.z.string().optional(),
    error_uri: zod_1.z.string().optional()
});
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration metadata
 */ exports.OAuthClientMetadataSchema = zod_1.z.object({
    redirect_uris: zod_1.z.array(exports.SafeUrlSchema),
    token_endpoint_auth_method: zod_1.z.string().optional(),
    grant_types: zod_1.z.array(zod_1.z.string()).optional(),
    response_types: zod_1.z.array(zod_1.z.string()).optional(),
    client_name: zod_1.z.string().optional(),
    client_uri: exports.SafeUrlSchema.optional(),
    logo_uri: exports.SafeUrlSchema.optional(),
    scope: zod_1.z.string().optional(),
    contacts: zod_1.z.array(zod_1.z.string()).optional(),
    tos_uri: exports.SafeUrlSchema.optional(),
    policy_uri: zod_1.z.string().optional(),
    jwks_uri: exports.SafeUrlSchema.optional(),
    jwks: zod_1.z.any().optional(),
    software_id: zod_1.z.string().optional(),
    software_version: zod_1.z.string().optional(),
    software_statement: zod_1.z.string().optional()
}).strip();
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration client information
 */ exports.OAuthClientInformationSchema = zod_1.z.object({
    client_id: zod_1.z.string(),
    client_secret: zod_1.z.string().optional(),
    client_id_issued_at: zod_1.z.number().optional(),
    client_secret_expires_at: zod_1.z.number().optional()
}).strip();
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata)
 */ exports.OAuthClientInformationFullSchema = exports.OAuthClientMetadataSchema.merge(exports.OAuthClientInformationSchema);
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration error response
 */ exports.OAuthClientRegistrationErrorSchema = zod_1.z.object({
    error: zod_1.z.string(),
    error_description: zod_1.z.string().optional()
}).strip();
/**
 * RFC 7009 OAuth 2.0 Token Revocation request
 */ exports.OAuthTokenRevocationRequestSchema = zod_1.z.object({
    token: zod_1.z.string(),
    token_type_hint: zod_1.z.string().optional()
}).strip();

},{"cc196583bd0bcc1e":"hP52C"}],"wRvBb":[function(require,module,exports) {
"use strict";
/**
 * Utilities for handling OAuth resource URIs.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resourceUrlFromServerUrl = resourceUrlFromServerUrl;
exports.checkResourceAllowed = checkResourceAllowed;
/**
 * Converts a server URL to a resource URL by removing the fragment.
 * RFC 8707 section 2 states that resource URIs "MUST NOT include a fragment component".
 * Keeps everything else unchanged (scheme, domain, port, path, query).
 */ function resourceUrlFromServerUrl(url) {
    const resourceURL = typeof url === "string" ? new URL(url) : new URL(url.href);
    resourceURL.hash = ""; // Remove fragment
    return resourceURL;
}
/**
 * Checks if a requested resource URL matches a configured resource URL.
 * A requested resource matches if it has the same scheme, domain, port,
 * and its path starts with the configured resource's path.
 *
 * @param requestedResource The resource URL being requested
 * @param configuredResource The resource URL that has been configured
 * @returns true if the requested resource matches the configured resource, false otherwise
 */ function checkResourceAllowed({ requestedResource, configuredResource }) {
    const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
    const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
    // Compare the origin (scheme, domain, and port)
    if (requested.origin !== configured.origin) return false;
    // Handle cases like requested=/foo and configured=/foo/
    if (requested.pathname.length < configured.pathname.length) return false;
    // Check if the requested path starts with the configured path
    // Ensure both paths end with / for proper comparison
    // This ensures that if we have paths like "/api" and "/api/users",
    // we properly detect that "/api/users" is a subpath of "/api"
    // By adding a trailing slash if missing, we avoid false positives
    // where paths like "/api123" would incorrectly match "/api"
    const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
    const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
    return requestedPath.startsWith(configuredPath);
}

},{}],"3sNJj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAUTH_ERRORS = exports.CustomOAuthError = exports.InsufficientScopeError = exports.InvalidClientMetadataError = exports.TooManyRequestsError = exports.MethodNotAllowedError = exports.InvalidTokenError = exports.UnsupportedTokenTypeError = exports.UnsupportedResponseTypeError = exports.TemporarilyUnavailableError = exports.ServerError = exports.AccessDeniedError = exports.InvalidScopeError = exports.UnsupportedGrantTypeError = exports.UnauthorizedClientError = exports.InvalidGrantError = exports.InvalidClientError = exports.InvalidRequestError = exports.OAuthError = void 0;
/**
 * Base class for all OAuth errors
 */ class OAuthError extends Error {
    constructor(message, errorUri){
        super(message);
        this.errorUri = errorUri;
        this.name = this.constructor.name;
    }
    /**
     * Converts the error to a standard OAuth error response object
     */ toResponseObject() {
        const response = {
            error: this.errorCode,
            error_description: this.message
        };
        if (this.errorUri) response.error_uri = this.errorUri;
        return response;
    }
    get errorCode() {
        return this.constructor.errorCode;
    }
}
exports.OAuthError = OAuthError;
/**
 * Invalid request error - The request is missing a required parameter,
 * includes an invalid parameter value, includes a parameter more than once,
 * or is otherwise malformed.
 */ class InvalidRequestError extends OAuthError {
}
exports.InvalidRequestError = InvalidRequestError;
InvalidRequestError.errorCode = "invalid_request";
/**
 * Invalid client error - Client authentication failed (e.g., unknown client, no client
 * authentication included, or unsupported authentication method).
 */ class InvalidClientError extends OAuthError {
}
exports.InvalidClientError = InvalidClientError;
InvalidClientError.errorCode = "invalid_client";
/**
 * Invalid grant error - The provided authorization grant or refresh token is
 * invalid, expired, revoked, does not match the redirection URI used in the
 * authorization request, or was issued to another client.
 */ class InvalidGrantError extends OAuthError {
}
exports.InvalidGrantError = InvalidGrantError;
InvalidGrantError.errorCode = "invalid_grant";
/**
 * Unauthorized client error - The authenticated client is not authorized to use
 * this authorization grant type.
 */ class UnauthorizedClientError extends OAuthError {
}
exports.UnauthorizedClientError = UnauthorizedClientError;
UnauthorizedClientError.errorCode = "unauthorized_client";
/**
 * Unsupported grant type error - The authorization grant type is not supported
 * by the authorization server.
 */ class UnsupportedGrantTypeError extends OAuthError {
}
exports.UnsupportedGrantTypeError = UnsupportedGrantTypeError;
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
/**
 * Invalid scope error - The requested scope is invalid, unknown, malformed, or
 * exceeds the scope granted by the resource owner.
 */ class InvalidScopeError extends OAuthError {
}
exports.InvalidScopeError = InvalidScopeError;
InvalidScopeError.errorCode = "invalid_scope";
/**
 * Access denied error - The resource owner or authorization server denied the request.
 */ class AccessDeniedError extends OAuthError {
}
exports.AccessDeniedError = AccessDeniedError;
AccessDeniedError.errorCode = "access_denied";
/**
 * Server error - The authorization server encountered an unexpected condition
 * that prevented it from fulfilling the request.
 */ class ServerError extends OAuthError {
}
exports.ServerError = ServerError;
ServerError.errorCode = "server_error";
/**
 * Temporarily unavailable error - The authorization server is currently unable to
 * handle the request due to a temporary overloading or maintenance of the server.
 */ class TemporarilyUnavailableError extends OAuthError {
}
exports.TemporarilyUnavailableError = TemporarilyUnavailableError;
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
/**
 * Unsupported response type error - The authorization server does not support
 * obtaining an authorization code using this method.
 */ class UnsupportedResponseTypeError extends OAuthError {
}
exports.UnsupportedResponseTypeError = UnsupportedResponseTypeError;
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
/**
 * Unsupported token type error - The authorization server does not support
 * the requested token type.
 */ class UnsupportedTokenTypeError extends OAuthError {
}
exports.UnsupportedTokenTypeError = UnsupportedTokenTypeError;
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
/**
 * Invalid token error - The access token provided is expired, revoked, malformed,
 * or invalid for other reasons.
 */ class InvalidTokenError extends OAuthError {
}
exports.InvalidTokenError = InvalidTokenError;
InvalidTokenError.errorCode = "invalid_token";
/**
 * Method not allowed error - The HTTP method used is not allowed for this endpoint.
 * (Custom, non-standard error)
 */ class MethodNotAllowedError extends OAuthError {
}
exports.MethodNotAllowedError = MethodNotAllowedError;
MethodNotAllowedError.errorCode = "method_not_allowed";
/**
 * Too many requests error - Rate limit exceeded.
 * (Custom, non-standard error based on RFC 6585)
 */ class TooManyRequestsError extends OAuthError {
}
exports.TooManyRequestsError = TooManyRequestsError;
TooManyRequestsError.errorCode = "too_many_requests";
/**
 * Invalid client metadata error - The client metadata is invalid.
 * (Custom error for dynamic client registration - RFC 7591)
 */ class InvalidClientMetadataError extends OAuthError {
}
exports.InvalidClientMetadataError = InvalidClientMetadataError;
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
/**
 * Insufficient scope error - The request requires higher privileges than provided by the access token.
 */ class InsufficientScopeError extends OAuthError {
}
exports.InsufficientScopeError = InsufficientScopeError;
InsufficientScopeError.errorCode = "insufficient_scope";
/**
 * A utility class for defining one-off error codes
 */ class CustomOAuthError extends OAuthError {
    constructor(customErrorCode, message, errorUri){
        super(message, errorUri);
        this.customErrorCode = customErrorCode;
    }
    get errorCode() {
        return this.customErrorCode;
    }
}
exports.CustomOAuthError = CustomOAuthError;
/**
 * A full list of all OAuthErrors, enabling parsing from error responses
 */ exports.OAUTH_ERRORS = {
    [InvalidRequestError.errorCode]: InvalidRequestError,
    [InvalidClientError.errorCode]: InvalidClientError,
    [InvalidGrantError.errorCode]: InvalidGrantError,
    [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
    [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
    [InvalidScopeError.errorCode]: InvalidScopeError,
    [AccessDeniedError.errorCode]: AccessDeniedError,
    [ServerError.errorCode]: ServerError,
    [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
    [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
    [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
    [InvalidTokenError.errorCode]: InvalidTokenError,
    [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
    [TooManyRequestsError.errorCode]: TooManyRequestsError,
    [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
    [InsufficientScopeError.errorCode]: InsufficientScopeError
};

},{}],"apA8I":[function(require,module,exports) {
/**
 * Notion MCP SSE Client
 * Handles Server-Sent Events connection to Notion's hosted MCP server
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "McpSSEClient", ()=>McpSSEClient);
var _constants = require("../constants");
/**
 * EventSource-like interface for SSE in extension context
 * Chrome extensions need special handling for SSE
 */ class McpSSEClient {
    constructor(sseUrl, accessToken, callbacks){
        this.sessionId = null // MCP session ID from initialization
        ;
        this.sseSessionId = null // SSE stream session ID for resumability
        ;
        this.messageEndpoint = null // POST endpoint from SSE 'endpoint' event
        ;
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.reconnectTimeout = null;
        this.messageId = 0;
        this.pendingRequests = new Map();
        this.currentStatus = {
            state: "disconnected"
        };
        this.sseUrl = sseUrl;
        this.accessToken = accessToken;
        this.onStatusChange = callbacks.onStatusChange;
        this.onMessage = callbacks.onMessage;
    }
    /**
     * Connect to the SSE endpoint
     */ async connect() {
        this.updateStatus("connecting");
        try {
            // For MV3 extensions, we need to use fetch with ReadableStream
            // instead of EventSource due to CSP restrictions
            await this.connectWithFetch();
        } catch (error) {
            console.error("[NotionMCP] Connection error:", error);
            this.updateStatus("error", error instanceof Error ? error.message : "Connection failed");
            this.scheduleReconnect();
        }
    }
    /**
     * Connect using fetch and ReadableStream (MV3 compatible)
     */ async connectWithFetch() {
        console.log("[NotionMCP] Connecting to SSE endpoint:", this.sseUrl);
        console.log("[NotionMCP] Using access token (first 20 chars):", this.accessToken.substring(0, 20) + "...");
        const response = await fetch(this.sseUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${this.accessToken}`,
                "Accept": "text/event-stream, application/json",
                "Cache-Control": "no-cache",
                "MCP-Protocol-Version": "2025-06-18"
            }
        });
        console.log("[NotionMCP] SSE response status:", response.status);
        console.log("[NotionMCP] SSE response headers:", Object.fromEntries(response.headers.entries()));
        if (!response.ok) {
            const errorText = await response.text();
            console.error("[NotionMCP] SSE connection failed:", response.status, errorText);
            if (response.status === 401) {
                // Parse error to distinguish between format and expiry issues
                let errorData;
                try {
                    errorData = JSON.parse(errorText);
                } catch  {
                    errorData = {
                        error: "unknown",
                        error_description: errorText
                    };
                }
                if (errorData.error === "invalid_token" && errorData.error_description?.includes("Invalid token format")) {
                    // Token format is wrong - don't try to refresh, need re-auth
                    this.updateStatus("invalid-token", "Invalid token format - please re-authenticate");
                    throw new Error(`Invalid token format: ${errorData.error_description}`);
                } else {
                    // Token expired or other auth issue - might be refreshable
                    this.updateStatus("needs-auth", "Token expired or invalid");
                    throw new Error(`Authentication required: ${errorText}`);
                }
            }
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        if (!response.body) throw new Error("Response body is null");
        this.reconnectAttempts = 0;
        this.updateStatus("connected");
        // Process the stream in the background (don't await)
        this.processStream(response.body);
    // Note: MCP session ID comes from initialization response headers,
    // not from the SSE stream. The SSE endpoint event provides a separate
    // session ID for stream resumability.
    }
    /**
     * Process the SSE stream in the background
     */ async processStream(body) {
        const reader = body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let currentEvent = null;
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    console.log("[NotionMCP] Stream ended");
                    break;
                }
                buffer += decoder.decode(value, {
                    stream: true
                });
                const lines = buffer.split("\n");
                buffer = lines.pop() || "";
                for (const line of lines){
                    if (line.startsWith("event: ")) {
                        // Handle SSE event types (e.g., "event: endpoint", "event: message")
                        currentEvent = line.slice(7).trim();
                        console.log("[NotionMCP] SSE event type:", currentEvent);
                        continue;
                    }
                    if (line.startsWith("data: ")) {
                        const data = line.slice(6).trim();
                        if (data === "[DONE]") continue;
                        // Handle endpoint event - extract message endpoint for POST requests
                        if (currentEvent === "endpoint") {
                            // Per MCP spec: server sends endpoint URI for client to use for POST requests
                            // data format: /sse/message?sessionId=... (relative URI)
                            this.messageEndpoint = data;
                            // Extract session ID if present
                            const match = data.match(/sessionId=([a-f0-9-]+)/);
                            if (match) this.sseSessionId = match[1];
                            console.log("[NotionMCP] Message endpoint received:", this.messageEndpoint);
                            console.log("[NotionMCP] SSE Session ID:", this.sseSessionId);
                            currentEvent = null;
                            continue;
                        }
                        // Skip empty data or non-JSON data
                        if (!data || !data.startsWith("{") && !data.startsWith("[")) {
                            console.log("[NotionMCP] Non-JSON SSE data:", data);
                            currentEvent = null;
                            continue;
                        }
                        try {
                            const message = JSON.parse(data);
                            this.handleMessage(message);
                        } catch (err) {
                            console.error("[NotionMCP] Failed to parse message:", err, "Data:", data);
                        }
                        currentEvent = null;
                    }
                }
            }
        } catch (error) {
            console.error("[NotionMCP] Stream error:", error);
        } finally{
            reader.releaseLock();
            // Connection closed, attempt reconnect
            this.scheduleReconnect();
        }
    }
    /**
     * Handle incoming SSE message
     */ handleMessage(message) {
        this.onMessage(message);
        // Handle responses to our requests
        if (message.id && this.pendingRequests.has(message.id)) {
            const pending = this.pendingRequests.get(message.id);
            this.pendingRequests.delete(message.id);
            if (message.error) pending.reject(new Error(message.error.message));
            else pending.resolve(message.result);
        }
    }
    /**
     * Get the full POST endpoint URL
     */ getPostUrl() {
        if (!this.messageEndpoint) throw new Error("Message endpoint not available. SSE connection may not be established.");
        // If endpoint is relative, construct full URL
        if (this.messageEndpoint.startsWith("/")) {
            const url = new URL(this.sseUrl);
            return `${url.origin}${this.messageEndpoint}`;
        }
        // If endpoint is already absolute, use it as-is
        return this.messageEndpoint;
    }
    /**
     * Send a notification (no response expected)
     */ async sendNotification(method, params) {
        const message = {
            jsonrpc: "2.0",
            method,
            params
        };
        // Build headers
        const headers = {
            "Authorization": `Bearer ${this.accessToken}`,
            "Content-Type": "application/json",
            "Accept": "application/json, text/event-stream",
            "MCP-Protocol-Version": "2025-06-18"
        };
        // Include session ID if available
        if (this.sessionId) headers["Mcp-Session-Id"] = this.sessionId;
        // Per MCP spec: use the endpoint from SSE 'endpoint' event for POST requests
        const postUrl = this.getPostUrl();
        console.log("[NotionMCP] Sending notification to:", postUrl);
        // Send notification - no response expected (should return 202 Accepted)
        const response = await fetch(postUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(message)
        });
        if (!response.ok) {
            const errorText = await response.text();
            console.error("[NotionMCP] Notification failed:", response.status, errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        console.log("[NotionMCP] Notification sent:", method);
    }
    /**
     * Send a request over SSE (via POST to endpoint from SSE 'endpoint' event)
     * Per MCP spec: SSE for receiving, POST to endpoint provided by server for sending
     */ async sendRequest(method, params, options) {
        const id = ++this.messageId;
        const message = {
            jsonrpc: "2.0",
            id,
            method,
            params
        };
        return new Promise((resolve, reject)=>{
            this.pendingRequests.set(id, {
                resolve,
                reject
            });
            // Build headers
            const headers = {
                "Authorization": `Bearer ${this.accessToken}`,
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream",
                "MCP-Protocol-Version": "2025-06-18"
            };
            // Include session ID if available
            const isInitialize = method === "initialize";
            if (!isInitialize && this.sessionId) headers["Mcp-Session-Id"] = this.sessionId;
            // Per MCP spec: use the endpoint from SSE 'endpoint' event for POST requests
            const postUrl = this.getPostUrl();
            console.log("[NotionMCP] Sending request to:", postUrl, "Method:", method);
            // Send via POST to the message endpoint (from SSE endpoint event)
            fetch(postUrl, {
                method: "POST",
                headers,
                body: JSON.stringify(message)
            }).then(async (response)=>{
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("[NotionMCP] Request failed:", response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                // Extract session ID from response headers if this is initialization
                if (isInitialize) {
                    const sessionIdHeader = response.headers.get("Mcp-Session-Id");
                    if (sessionIdHeader) {
                        this.sessionId = sessionIdHeader;
                        console.log("[NotionMCP] Session ID from init response:", this.sessionId);
                    }
                }
                // Check content type to determine how to parse
                const contentType = response.headers.get("content-type") || "";
                if (contentType.includes("text/event-stream")) {
                    // Response is SSE format - parse it
                    const text = await response.text();
                    const lines = text.split("\n");
                    for (const line of lines)if (line.startsWith("data: ")) {
                        const data = line.slice(6).trim();
                        if (data && (data.startsWith("{") || data.startsWith("["))) try {
                            const result = JSON.parse(data);
                            if (result.id === id) {
                                this.handleMessage(result);
                                return;
                            }
                        } catch (err) {
                            console.error("[NotionMCP] Failed to parse SSE data:", err);
                        }
                    }
                } else if (contentType.includes("application/json")) {
                    // Response is JSON - parse directly
                    const result = await response.json();
                    if (result.id === id) this.handleMessage(result);
                } else throw new Error(`Unexpected content type: ${contentType}`);
            }).catch((error)=>{
                this.pendingRequests.delete(id);
                reject(error);
            });
            // Timeout after 30 seconds
            setTimeout(()=>{
                if (this.pendingRequests.has(id)) {
                    this.pendingRequests.delete(id);
                    reject(new Error("Request timeout"));
                }
            }, 30000);
        });
    }
    /**
     * Wait for message endpoint to be available
     */ async waitForEndpoint(timeoutMs = 10000) {
        const startTime = Date.now();
        while(!this.messageEndpoint){
            if (Date.now() - startTime > timeoutMs) throw new Error("Timeout waiting for message endpoint from SSE");
            await new Promise((resolve)=>setTimeout(resolve, 100));
        }
    }
    /**
     * Initialize the MCP connection
     * Must be called AFTER SSE connection is established and endpoint event is received
     */ async initialize() {
        // Per MCP spec: Wait for SSE 'endpoint' event before sending requests
        console.log("[NotionMCP] Waiting for message endpoint from SSE...");
        await this.waitForEndpoint();
        console.log("[NotionMCP] Message endpoint ready, sending initialize request");
        const params = {
            protocolVersion: "2025-06-18",
            capabilities: {
                experimental: {},
                roots: {
                    listChanged: true
                }
            },
            clientInfo: {
                name: "chrome-ai-extension",
                version: "0.0.1"
            }
        };
        // Send initialize request
        // Session ID will be extracted from response headers
        const result = await this.sendRequest("initialize", params);
        console.log("[NotionMCP] Initialized:", result);
        // Verify session ID was received (if server uses sessions)
        if (this.sessionId) console.log("[NotionMCP] Session established:", this.sessionId);
        else console.log("[NotionMCP] Server does not use session management");
        // After initialization, send initialized notification (no response expected)
        await this.sendNotification("notifications/initialized");
        // Fetch available tools
        await this.fetchTools();
    }
    /**
     * Fetch available tools from MCP server
     */ async fetchTools() {
        try {
            const result = await this.sendRequest("tools/list");
            this.currentStatus.tools = result.tools;
            this.onStatusChange(this.currentStatus);
            console.log("[NotionMCP] Tools:", result.tools);
        } catch (error) {
            console.error("[NotionMCP] Failed to fetch tools:", error);
        }
    }
    /**
     * Call a tool
     */ async callTool(name, args) {
        return this.sendRequest("tools/call", {
            name,
            arguments: args
        });
    }
    /**
     * Update connection status
     */ updateStatus(state, error) {
        this.currentStatus = {
            ...this.currentStatus,
            state,
            error,
            lastConnected: state === "connected" ? Date.now() : this.currentStatus.lastConnected
        };
        this.onStatusChange(this.currentStatus);
    }
    /**
     * Schedule reconnection with exponential backoff
     */ scheduleReconnect() {
        if (this.reconnectTimeout) return;
        const delay = Math.min((0, _constants.NOTION_CONFIG).RECONNECT_MIN_DELAY * Math.pow((0, _constants.NOTION_CONFIG).RECONNECT_MULTIPLIER, this.reconnectAttempts), (0, _constants.NOTION_CONFIG).RECONNECT_MAX_DELAY);
        this.reconnectAttempts++;
        this.updateStatus("connecting", `Reconnecting in ${Math.round(delay / 1000)}s...`);
        this.reconnectTimeout = window.setTimeout(()=>{
            this.reconnectTimeout = null;
            this.connect();
        }, delay);
    }
    /**
     * Disconnect and cleanup
     */ disconnect() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        // Reject all pending requests
        for (const [id, pending] of this.pendingRequests)pending.reject(new Error("Disconnected"));
        this.pendingRequests.clear();
        this.updateStatus("disconnected");
    }
    /**
     * Get current status
     */ getStatus() {
        return this.currentStatus;
    }
}

},{"../constants":"aZX5f","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"aZX5f":[function(require,module,exports) {
/**
 * Configuration constants for the extension
 */ // Chrome Built-in AI (Gemini Nano) limits
// Based on Chrome AI documentation and community reports
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHROME_AI_LIMITS", ()=>CHROME_AI_LIMITS);
parcelHelpers.export(exports, "COPILOT_RUNTIME_URL", ()=>COPILOT_RUNTIME_URL);
parcelHelpers.export(exports, "COPILOT_RUNTIME_URL_DEFAULT", ()=>COPILOT_RUNTIME_URL_DEFAULT);
parcelHelpers.export(exports, "NOTION_CONFIG", ()=>NOTION_CONFIG);
const CHROME_AI_LIMITS = {
    /** Maximum tokens per single prompt to Gemini Nano (on-device model) */ MAX_TOKENS_PER_PROMPT: 1024,
    /** Maximum tokens for session retention (sliding window) */ MAX_TOKENS_PER_SESSION: 4096,
    /** Recommended chunk size for text processing to stay well under prompt limit */ RECOMMENDED_CHUNK_TOKENS: 800,
    /** Maximum output tokens per response */ MAX_OUTPUT_TOKENS: 1024
};
const COPILOT_RUNTIME_URL = " http://localhost:3000/api"; // TODO: Edit this URL
const COPILOT_RUNTIME_URL_DEFAULT = " http://localhost:3000/";
const NOTION_CONFIG = {
    /** OAuth redirect URI - Chrome extension identity redirect */ OAUTH_REDIRECT_URI: "https://finfnkhchelfofloocidpepacfbajmlh.chromiumapp.org/",
    /** OAuth dynamic client registration endpoint */ OAUTH_REGISTER_URL: "https://mcp.notion.com/register",
    /** OAuth authorization endpoint - Standard Notion OAuth */ OAUTH_AUTH_URL: "https://mcp.notion.com/authorize",
    /** OAuth token endpoint - Standard Notion OAuth */ OAUTH_TOKEN_URL: "https://mcp.notion.com/token",
    /** OAuth token introspection endpoint */ OAUTH_INTROSPECT_URL: "https://api.notion.com/v1/oauth/introspect",
    /** MCP resource identifier for OAuth scope */ MCP_RESOURCE: "https://mcp.notion.com/",
    /** Notion MCP SSE endpoint (for establishing SSE connection and receiving events) */ MCP_SSE_URL: "https://mcp.notion.com/sse",
    /** Token storage key prefix */ STORAGE_KEY_PREFIX: "oauth.notion.mcp",
    /** Reconnection settings */ RECONNECT_MIN_DELAY: 500,
    RECONNECT_MAX_DELAY: 30000,
    RECONNECT_MULTIPLIER: 2
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bEC4Y":[function(require,module,exports) {
/**
 * OAuth utilities for Notion MCP authentication
 * Implements OAuth 2.0 PKCE (Proof Key for Code Exchange) flow
 * for Notion's hosted MCP server (no client secret)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerDynamicClient", ()=>registerDynamicClient);
parcelHelpers.export(exports, "generateState", ()=>generateState);
parcelHelpers.export(exports, "createCodeVerifier", ()=>createCodeVerifier);
parcelHelpers.export(exports, "createCodeChallenge", ()=>createCodeChallenge);
parcelHelpers.export(exports, "buildAuthUrl", ()=>buildAuthUrl);
parcelHelpers.export(exports, "exchangeCodeForTokens", ()=>exchangeCodeForTokens);
parcelHelpers.export(exports, "refreshAccessToken", ()=>refreshAccessToken);
parcelHelpers.export(exports, "isTokenExpired", ()=>isTokenExpired);
parcelHelpers.export(exports, "storeTokens", ()=>storeTokens);
parcelHelpers.export(exports, "getStoredTokens", ()=>getStoredTokens);
parcelHelpers.export(exports, "clearTokens", ()=>clearTokens);
parcelHelpers.export(exports, "storeClientCredentials", ()=>storeClientCredentials);
parcelHelpers.export(exports, "getStoredClientCredentials", ()=>getStoredClientCredentials);
parcelHelpers.export(exports, "clearClientCredentials", ()=>clearClientCredentials);
var _constants = require("../constants");
var Buffer = require("8593971f56fb0efb").Buffer;
/**
 * Register a dynamic client with Notion MCP OAuth server
 * This is called before starting the OAuth flow
 */ async function registerDynamicClient(redirectUri) {
    const registrationPayload = {
        client_name: "Chrome AI Extension - Notion MCP",
        redirect_uris: [
            redirectUri
        ],
        grant_types: [
            "authorization_code",
            "refresh_token"
        ],
        response_types: [
            "code"
        ],
        scope: "read write",
        token_endpoint_auth_method: "client_secret_basic"
    };
    console.log("[OAuth] Registering dynamic client with payload:", registrationPayload);
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_REGISTER_URL, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(registrationPayload)
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Client registration failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    console.log("[OAuth] Client registered successfully:", {
        client_id: data.client_id,
        redirect_uris: data.redirect_uris
    });
    return {
        client_id: data.client_id,
        client_secret: data.client_secret,
        redirect_uris: data.redirect_uris,
        client_name: data.client_name,
        grant_types: data.grant_types,
        response_types: data.response_types,
        token_endpoint_auth_method: data.token_endpoint_auth_method,
        registration_client_uri: data.registration_client_uri,
        client_id_issued_at: data.client_id_issued_at,
        created_at: Date.now()
    };
}
/**
 * Generate a random string for state parameter (CSRF protection)
 */ function generateRandomString(length) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, (byte)=>byte.toString(16).padStart(2, "0")).join("");
}
/**
 * Generate state parameter for CSRF protection
 */ function generateState() {
    return generateRandomString(16);
}
/**
 * Create a code verifier for PKCE (43-128 characters, base64url)
 */ function createCodeVerifier() {
    const array = new Uint8Array(32); // 32 bytes = 43 chars in base64url
    crypto.getRandomValues(array);
    return base64UrlEncode(array);
}
/**
 * Create a code challenge from a verifier (SHA-256 hash, base64url encoded)
 */ async function createCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return base64UrlEncode(new Uint8Array(hash));
}
/**
 * Base64URL encode (without padding)
 */ function base64UrlEncode(buffer) {
    const base64 = btoa(String.fromCharCode(...buffer));
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
/**
 * Build Notion MCP OAuth authorization URL (standard OAuth, no PKCE)
 */ function buildAuthUrl(clientId, redirectUri, state) {
    const params = new URLSearchParams({
        response_type: "code",
        client_id: clientId,
        redirect_uri: redirectUri,
        owner: "user",
        state: state
    });
    return `${(0, _constants.NOTION_CONFIG).OAUTH_AUTH_URL}?${params.toString()}`;
}
/**
 * Exchange authorization code for tokens using dynamic client credentials
 */ async function exchangeCodeForTokens(code, clientId, clientSecret, redirectUri) {
    const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
    console.log("[OAuth] Exchange code for tokens with client:", clientId);
    // Create x-www-form-urlencoded body for OAuth token exchange
    const params = new URLSearchParams({
        grant_type: "authorization_code",
        code: code,
        redirect_uri: redirectUri
    });
    console.log("[OAuth] Exchange code for tokens body (urlencoded):", params.toString());
    console.log("[OAuth] Exchange code for tokens URL:", (0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL);
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL, {
        method: "POST",
        headers: {
            "Authorization": `Basic ${credentials}`,
            "Content-Type": "application/x-www-form-urlencoded",
            "Notion-Version": "2022-06-28"
        },
        body: params.toString()
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Token exchange failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    // Calculate expiration timestamp
    const expiresIn = data.expires_in || 3600; // Default 1 hour if not provided
    const expiresAt = Date.now() + expiresIn * 1000;
    return {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "Bearer",
        expires_at: expiresAt,
        workspace_id: data.workspace_id,
        workspace_name: data.workspace_name,
        workspace_icon: data.workspace_icon,
        owner: data.owner,
        bot_id: data.bot_id,
        duplicated_template_id: data.duplicated_template_id,
        created_at: Date.now()
    };
}
/**
 * Refresh access token using refresh token and dynamic client credentials
 */ async function refreshAccessToken(refreshToken, clientId, clientSecret) {
    const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
    const params = new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken
    });
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL, {
        method: "POST",
        headers: {
            "Authorization": `Basic ${credentials}`,
            "Content-Type": "application/x-www-form-urlencoded",
            "Notion-Version": "2022-06-28"
        },
        body: params.toString()
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Token refresh failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    const expiresIn = data.expires_in || 3600;
    const expiresAt = Date.now() + expiresIn * 1000;
    return {
        access_token: data.access_token,
        refresh_token: data.refresh_token || refreshToken,
        token_type: data.token_type || "Bearer",
        expires_at: expiresAt,
        workspace_id: data.workspace_id,
        workspace_name: data.workspace_name,
        workspace_icon: data.workspace_icon,
        owner: data.owner,
        created_at: Date.now()
    };
}
/**
 * Check if token is expired or about to expire (within 5 minutes)
 */ function isTokenExpired(tokens) {
    const now = Date.now();
    const bufferTime = 300000; // 5 minutes
    return tokens.expires_at <= now + bufferTime;
}
/**
 * Store tokens in chrome.storage.local
 */ async function storeTokens(tokens) {
    await chrome.storage.local.set({
        [`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`]: tokens
    });
}
/**
 * Retrieve tokens from chrome.storage.local
 */ async function getStoredTokens() {
    const result = await chrome.storage.local.get(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`);
    return result[`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`] || null;
}
/**
 * Clear stored tokens
 */ async function clearTokens() {
    await chrome.storage.local.remove(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`);
}
/**
 * Store dynamic client credentials in chrome.storage.local
 */ async function storeClientCredentials(credentials) {
    await chrome.storage.local.set({
        [`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`]: credentials
    });
}
/**
 * Retrieve dynamic client credentials from chrome.storage.local
 */ async function getStoredClientCredentials() {
    const result = await chrome.storage.local.get(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`);
    return result[`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`] || null;
}
/**
 * Clear stored client credentials
 */ async function clearClientCredentials() {
    await chrome.storage.local.remove(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`);
}

},{"8593971f56fb0efb":"4qdzc","../constants":"aZX5f","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"4qdzc":[function(require,module,exports) {
var Er = Object.create;
var N = Object.defineProperty;
var dr = Object.getOwnPropertyDescriptor;
var gr = Object.getOwnPropertyNames;
var mr = Object.getPrototypeOf, Ir = Object.prototype.hasOwnProperty;
var $ = (i, r)=>()=>(r || i((r = {
            exports: {}
        }).exports, r), r.exports), Fr = (i, r)=>{
    for(var t in r)N(i, t, {
        get: r[t],
        enumerable: !0
    });
}, L = (i, r, t, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of gr(r))!Ir.call(i, e) && e !== t && N(i, e, {
        get: ()=>r[e],
        enumerable: !(n = dr(r, e)) || n.enumerable
    });
    return i;
}, S = (i, r, t)=>(L(i, r, "default"), t && L(t, r, "default")), J = (i, r, t)=>(t = i != null ? Er(mr(i)) : {}, L(r || !i || !i.__esModule ? N(t, "default", {
        value: i,
        enumerable: !0
    }) : t, i)), Ar = (i)=>L(N({}, "__esModule", {
        value: !0
    }), i);
var Q = $((M)=>{
    "use strict";
    M.byteLength = Rr;
    M.toByteArray = Cr;
    M.fromByteArray = Lr;
    var B = [], w = [], Ur = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(m = 0, K = P.length; m < K; ++m)B[m] = P[m], w[P.charCodeAt(m)] = m;
    var m, K;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function Z(i) {
        var r = i.length;
        if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = i.indexOf("=");
        t === -1 && (t = r);
        var n = t === r ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    function Rr(i) {
        var r = Z(i), t = r[0], n = r[1];
        return (t + n) * 3 / 4 - n;
    }
    function Tr(i, r, t) {
        return (r + t) * 3 / 4 - t;
    }
    function Cr(i) {
        var r, t = Z(i), n = t[0], e = t[1], o = new Ur(Tr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
        for(c = 0; c < f; c += 4)r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
        return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Sr(i) {
        return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function _r(i, r, t) {
        for(var n, e = [], o = r; o < t; o += 3)n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Sr(n));
        return e.join("");
    }
    function Lr(i) {
        for(var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)e.push(_r(i, u, u + o > f ? f : u + o));
        return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
});
var v = $((O)=>{
    O.read = function(i, r, t, n, e) {
        var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
        for(p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8);
        for(u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8);
        if (o === 0) o = 1 - l;
        else {
            if (o === c) return u ? NaN : (x ? -1 : 1) * (1 / 0);
            u = u + Math.pow(2, n), o = o - l;
        }
        return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    O.write = function(i, r, t, n, e, o) {
        var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, b = n ? 1 : -1, Br = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for(r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += b, f /= 256, e -= 8);
        for(u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += b, u /= 256, l -= 8);
        i[t + x - b] |= Br * 128;
    };
});
var z = $((T)=>{
    "use strict";
    var G = Q(), U = v(), rr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    T.Buffer = h;
    T.SlowBuffer = $r;
    T.INSPECT_MAX_BYTES = 50;
    var k = 2147483647;
    T.kMaxLength = k;
    h.TYPED_ARRAY_SUPPORT = Nr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Nr() {
        try {
            let i = new Uint8Array(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
        } catch (i) {
            return !1;
        }
    }
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.buffer;
        }
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.byteOffset;
        }
    });
    function d(i) {
        if (i > k) throw new RangeError('The value "' + i + '" is invalid for option "size"');
        let r = new Uint8Array(i);
        return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
        if (typeof i == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return j(i);
        }
        return er(i, r, t);
    }
    h.poolSize = 8192;
    function er(i, r, t) {
        if (typeof i == "string") return kr(i, r);
        if (ArrayBuffer.isView(i)) return Dr(i);
        if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
        if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer))) return q(i, r, t);
        if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = i.valueOf && i.valueOf();
        if (n != null && n !== i) return h.from(n, r, t);
        let e = br(i);
        if (e) return e;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return h.from(i[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
        return er(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function or(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
        if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function Mr(i, r, t) {
        return or(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
        return Mr(i, r, t);
    };
    function j(i) {
        return or(i), d(i < 0 ? 0 : H(i) | 0);
    }
    h.allocUnsafe = function(i) {
        return j(i);
    };
    h.allocUnsafeSlow = function(i) {
        return j(i);
    };
    function kr(i, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        let t = ur(i, r) | 0, n = d(t), e = n.write(i, r);
        return e !== t && (n = n.slice(0, e)), n;
    }
    function Y(i) {
        let r = i.length < 0 ? 0 : H(i.length) | 0, t = d(r);
        for(let n = 0; n < r; n += 1)t[n] = i[n] & 255;
        return t;
    }
    function Dr(i) {
        if (E(i, Uint8Array)) {
            let r = new Uint8Array(i);
            return q(r.buffer, r.byteOffset, r.byteLength);
        }
        return Y(i);
    }
    function q(i, r, t) {
        if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function br(i) {
        if (h.isBuffer(i)) {
            let r = H(i.length) | 0, t = d(r);
            return t.length === 0 || i.copy(t, 0, 0, r), t;
        }
        if (i.length !== void 0) return typeof i.length != "number" || X(i.length) ? d(0) : Y(i);
        if (i.type === "Buffer" && Array.isArray(i.data)) return Y(i.data);
    }
    function H(i) {
        if (i >= k) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + k.toString(16) + " bytes");
        return i | 0;
    }
    function $r(i) {
        return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== h.prototype;
    };
    h.compare = function(r, t) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let n = r.length, e = t.length;
        for(let o = 0, u = Math.min(n, e); o < u; ++o)if (r[o] !== t[o]) {
            n = r[o], e = t[o];
            break;
        }
        return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    };
    h.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < r.length; ++n)t += r[n].length;
        let e = h.allocUnsafe(t), o = 0;
        for(n = 0; n < r.length; ++n){
            let u = r[n];
            if (E(u, Uint8Array)) o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
            else if (h.isBuffer(u)) u.copy(e, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += u.length;
        }
        return e;
    };
    function ur(i, r) {
        if (h.isBuffer(i)) return i.length;
        if (ArrayBuffer.isView(i) || E(i, ArrayBuffer)) return i.byteLength;
        if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
        let t = i.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return W(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return wr(i).length;
            default:
                if (e) return n ? -1 : W(i).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    h.byteLength = ur;
    function Pr(i, r, t) {
        let n = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(i || (i = "utf8");;)switch(i){
            case "hex":
                return zr(this, r, t);
            case "utf8":
            case "utf-8":
                return fr(this, r, t);
            case "ascii":
                return Vr(this, r, t);
            case "latin1":
            case "binary":
                return Xr(this, r, t);
            case "base64":
                return jr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Jr(this, r, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), n = !0;
        }
    }
    h.prototype._isBuffer = !0;
    function I(i, r, t) {
        let n = i[r];
        i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
        let r = this.length;
        if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)I(this, t, t + 1);
        return this;
    };
    h.prototype.swap32 = function() {
        let r = this.length;
        if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)I(this, t, t + 3), I(this, t + 1, t + 2);
        return this;
    };
    h.prototype.swap64 = function() {
        let r = this.length;
        if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
        return this;
    };
    h.prototype.toString = function() {
        let r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? fr(this, 0, r) : Pr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
        if (!h.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
        let r = "", t = T.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    rr && (h.prototype[rr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length) throw new RangeError("out of range index");
        if (e >= o && t >= n) return 0;
        if (e >= o) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r) return 0;
        let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
        for(let p = 0; p < c; ++p)if (l[p] !== s[p]) {
            u = l[p], f = s[p];
            break;
        }
        return u < f ? -1 : f < u ? 1 : 0;
    };
    function hr(i, r, t, n, e) {
        if (i.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
            if (e) return -1;
            t = i.length - 1;
        } else if (t < 0) {
            if (e) t = 0;
            else return -1;
        }
        if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r)) return r.length === 0 ? -1 : tr(i, r, t, n, e);
        if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : tr(i, [
            r
        ], t, n, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function tr(i, r, t, n, e) {
        let o = 1, u = i.length, f = r.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, u /= 2, f /= 2, t /= 2;
        }
        function c(s, p) {
            return o === 1 ? s[p] : s.readUInt16BE(p * o);
        }
        let l;
        if (e) {
            let s = -1;
            for(l = t; l < u; l++)if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
                if (s === -1 && (s = l), l - s + 1 === f) return s * o;
            } else s !== -1 && (l -= l - s), s = -1;
        } else for(t + f > u && (t = u - f), l = t; l >= 0; l--){
            let s = !0;
            for(let p = 0; p < f; p++)if (c(i, l + p) !== c(r, p)) {
                s = !1;
                break;
            }
            if (s) return l;
        }
        return -1;
    }
    h.prototype.includes = function(r, t, n) {
        return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
        return hr(this, r, t, n, !0);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
        return hr(this, r, t, n, !1);
    };
    function Or(i, r, t, n) {
        t = Number(t) || 0;
        let e = i.length - t;
        n ? (n = Number(n), n > e && (n = e)) : n = e;
        let o = r.length;
        n > o / 2 && (n = o / 2);
        let u;
        for(u = 0; u < n; ++u){
            let f = parseInt(r.substr(u * 2, 2), 16);
            if (X(f)) return u;
            i[t + u] = f;
        }
        return u;
    }
    function Gr(i, r, t, n) {
        return D(W(r, i.length - t), i, t, n);
    }
    function Yr(i, r, t, n) {
        return D(vr(r), i, t, n);
    }
    function qr(i, r, t, n) {
        return D(wr(r), i, t, n);
    }
    function Wr(i, r, t, n) {
        return D(rt(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
        if (t === void 0) e = "utf8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") e = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t;
        if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let u = !1;
        for(;;)switch(e){
            case "hex":
                return Or(this, r, t, n);
            case "utf8":
            case "utf-8":
                return Gr(this, r, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return Yr(this, r, t, n);
            case "base64":
                return qr(this, r, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Wr(this, r, t, n);
            default:
                if (u) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), u = !0;
        }
    };
    h.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function jr(i, r, t) {
        return r === 0 && t === i.length ? G.fromByteArray(i) : G.fromByteArray(i.slice(r, t));
    }
    function fr(i, r, t) {
        t = Math.min(i.length, t);
        let n = [], e = r;
        for(; e < t;){
            let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (e + f <= t) {
                let c, l, s, p;
                switch(f){
                    case 1:
                        o < 128 && (u = o);
                        break;
                    case 2:
                        c = i[e + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
                        break;
                    case 3:
                        c = i[e + 1], l = i[e + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
                        break;
                    case 4:
                        c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
                }
            }
            u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
        }
        return Hr(n);
    }
    var ir = 4096;
    function Hr(i) {
        let r = i.length;
        if (r <= ir) return String.fromCharCode.apply(String, i);
        let t = "", n = 0;
        for(; n < r;)t += String.fromCharCode.apply(String, i.slice(n, n += ir));
        return t;
    }
    function Vr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e] & 127);
        return n;
    }
    function Xr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e]);
        return n;
    }
    function zr(i, r, t) {
        let n = i.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
        let e = "";
        for(let o = r; o < t; ++o)e += tt[i[o]];
        return e;
    }
    function Jr(i, r, t) {
        let n = i.slice(r, t), e = "";
        for(let o = 0; o < n.length - 1; o += 2)e += String.fromCharCode(n[o] + n[o + 1] * 256);
        return e;
    }
    h.prototype.slice = function(r, t) {
        let n = this.length;
        r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
        let e = this.subarray(r, t);
        return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
        if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r + --t], o = 1;
        for(; t > 0 && (o *= 256);)e += this[r + --t] * o;
        return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 256 + this[++r] * 2 ** 16 + n * 2 ** 24;
        return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n;
        return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = t, o = 1, u = this[r + --e];
        for(; e > 0 && (o *= 256);)u += this[r + --e] * o;
        return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r] | this[r + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r + 1] | this[r] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = this[r + 4] + this[r + 5] * 256 + this[r + 6] * 2 ** 16 + (n << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !0, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !1, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !0, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !1, 52, 8);
    };
    function y(i, r, t, n, e, o) {
        if (!h.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < o) throw new RangeError('"value" argument is out of bounds');
        if (t + n > i.length) throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = 1, u = 0;
        for(this[t] = r & 255; ++u < n && (o *= 256);)this[t + u] = r / o & 255;
        return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = n - 1, u = 1;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)this[t + o] = r / u & 255;
        return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function cr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function pr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = 0, u = 1, f = 0;
        for(this[t] = r & 255; ++o < n && (u *= 256);)r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = n - 1, u = 1, f = 0;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function sr(i, r, t, n, e, o) {
        if (t + n > i.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function lr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 4, 34028234663852886e22, -340282346638528860000000000000000000000), U.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
        return lr(this, r, t, !0, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
        return lr(this, r, t, !1, n);
    };
    function ar(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 8, 17976931348623157e292, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), U.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
        return ar(this, r, t, !0, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
        return ar(this, r, t, !1, n);
    };
    h.prototype.copy = function(r, t, n, e) {
        if (!h.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
        let o = e - n;
        return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                let u = r.charCodeAt(0);
                (e === "utf8" && u < 128 || e === "latin1") && (r = u);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
        let o;
        if (typeof r == "number") for(o = t; o < n; ++o)this[o] = r;
        else {
            let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
            if (f === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(o = 0; o < n - t; ++o)this[o + t] = u[o % f];
        }
        return this;
    };
    var A = {};
    function V(i, r, t) {
        A[i] = class extends t {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = "".concat(this.name, " [").concat(i, "]"), this.stack, delete this.name;
            }
            get code() {
                return i;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return "".concat(this.name, " [").concat(i, "]: ").concat(this.message);
            }
        };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
        return i ? "".concat(i, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i, r) {
        return 'The "'.concat(i, '" argument must be of type number. Received type ').concat(typeof r);
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i, r, t) {
        let n = 'The value of "'.concat(i, '" is out of range.'), e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = nr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = nr(e)), e += "n"), n += " It must be ".concat(r, ". Received ").concat(e), n;
    }, RangeError);
    function nr(i) {
        let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)r = "_".concat(i.slice(t - 3, t)).concat(r);
        return "".concat(i.slice(0, t)).concat(r);
    }
    function Kr(i, r, t) {
        R(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && _(r, i.length - (t + 1));
    }
    function yr(i, r, t, n, e, o) {
        if (i > t || i < r) {
            let u = typeof r == "bigint" ? "n" : "", f;
            throw o > 3 ? r === 0 || r === BigInt(0) ? f = ">= 0".concat(u, " and < 2").concat(u, " ** ").concat((o + 1) * 8).concat(u) : f = ">= -(2".concat(u, " ** ").concat((o + 1) * 8 - 1).concat(u, ") and < 2 ** ") + "".concat((o + 1) * 8 - 1).concat(u) : f = ">= ".concat(r).concat(u, " and <= ").concat(t).concat(u), new A.ERR_OUT_OF_RANGE("value", f, i);
        }
        Kr(n, e, o);
    }
    function R(i, r) {
        if (typeof i != "number") throw new A.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function _(i, r, t) {
        throw Math.floor(i) !== i ? (R(i, t), new A.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS : new A.ERR_OUT_OF_RANGE(t || "offset", ">= ".concat(t ? 1 : 0, " and <= ").concat(r), i);
    }
    var Zr = /[^+/0-9A-Za-z-_]/g;
    function Qr(i) {
        if (i = i.split("=")[0], i = i.trim().replace(Zr, ""), i.length < 2) return "";
        for(; i.length % 4 !== 0;)i = i + "=";
        return i;
    }
    function W(i, r) {
        r = r || 1 / 0;
        let t, n = i.length, e = null, o = [];
        for(let u = 0; u < n; ++u){
            if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (u + 1 === n) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && o.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                o.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                o.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    function vr(i) {
        let r = [];
        for(let t = 0; t < i.length; ++t)r.push(i.charCodeAt(t) & 255);
        return r;
    }
    function rt(i, r) {
        let t, n, e, o = [];
        for(let u = 0; u < i.length && !((r -= 2) < 0); ++u)t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
        return o;
    }
    function wr(i) {
        return G.toByteArray(Qr(i));
    }
    function D(i, r, t, n) {
        let e;
        for(e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)r[e + t] = i[e];
        return e;
    }
    function E(i, r) {
        return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function X(i) {
        return i !== i;
    }
    var tt = function() {
        let i = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let e = 0; e < 16; ++e)r[n + e] = i[t] + i[e];
        }
        return r;
    }();
    function g(i) {
        return typeof BigInt > "u" ? it : i;
    }
    function it() {
        throw new Error("BigInt not supported");
    }
});
var C = {};
Fr(C, {
    default: ()=>nt
});
module.exports = Ar(C);
var xr = J(z());
S(C, J(z()), module.exports);
var nt = xr.default; /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/ 

},{}]},["8LKeO","8oeFb"], "8oeFb", "parcelRequirec096")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUksSUFBRSxXQUFXLFNBQVMsUUFBTSxFQUFFO0FBQUMsSUFBSSxJQUFFLElBQUksV0FBVyxTQUFTLE9BQUssQ0FBQztBQUFFLElBQUksSUFBRSxJQUFJLElBQUksSUFBRyxJQUFFLENBQUEsSUFBRyxFQUFFLElBQUksSUFBRyxJQUFFLEVBQUUsT0FBTyxDQUFBLElBQUcsRUFBRSxXQUFXLFNBQU8sRUFBRSxTQUFTLE1BQU0sSUFBSSxDQUFBLElBQUcsRUFBRSxNQUFNLE1BQU0sT0FBTyxDQUFDLEdBQUUsQ0FBQyxHQUFFLEVBQUUsR0FBSSxDQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUMsR0FBRSxDQUFBLEdBQUcsQ0FBQztBQUFHLElBQUksSUFBRSxFQUFFLGNBQWEsSUFBRSxJQUFJLEVBQUUsZ0JBQWMsSUFBSSxZQUFVLFFBQU8sSUFBRTtBQUFJLElBQUksSUFBRSxDQUFDLElBQUUsRUFBRSxFQUFDLEdBQUcsSUFBSSxRQUFRLElBQUksRUFBRSxPQUFPLElBQUcsUUFBTztBQUFHLElBQUksSUFBRSxDQUFDLEdBQUcsSUFBSSxRQUFRLE1BQU0scUJBQWtCLE9BQU8sSUFBRyxRQUFPLElBQUcsSUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLHdCQUFvQixJQUFHLElBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSx3QkFBb0IsSUFBRyxJQUFFLEdBQUUsSUFBRSxDQUFDLEdBQUcsSUFBSSxPQUFLLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUk7QUFBRyxJQUFJLElBQUU7SUFBSyxJQUFJLElBQUUsV0FBVyxTQUFTLFdBQVMsV0FBVyxRQUFRLFNBQVEsSUFBRSxJQUFJLFlBQVksRUFBRSxpQkFBZ0I7SUFBTSxFQUFFLFVBQVUsWUFBWSxJQUFHO0FBQUc7QUFBRSxJQUFJLElBQUU7SUFBQyxtQkFBa0I7SUFBTSxnQkFBZTtJQUFLLFdBQVU7SUFBTSxZQUFXO1FBQUM7S0FBNkI7SUFBQyxRQUFPO0lBQVksUUFBTztJQUFNLGlCQUFnQjtJQUFzRixZQUFXO0lBQW1CLFdBQVU7SUFBbUIsV0FBVTtJQUFRLFVBQVM7SUFBTSxjQUFhO0FBQUs7QUFBRSxPQUFPLE9BQU8sZ0JBQWMsRUFBRTtBQUFTLFdBQVcsVUFBUTtJQUFDLE1BQUssRUFBRTtJQUFDLEtBQUk7UUFBQyxTQUFRLEVBQUU7SUFBTztBQUFDO0FBQUUsSUFBSSxJQUFFLE9BQU8sT0FBTztBQUFPLFNBQVMsRUFBRSxDQUFDO0lBQUUsRUFBRSxLQUFLLElBQUksRUFBQyxJQUFHLElBQUksQ0FBQyxNQUFJO1FBQUMsTUFBSyxPQUFPLE9BQU8sT0FBTyxDQUFDLEVBQUU7UUFBQyxrQkFBaUIsRUFBRTtRQUFDLG1CQUFrQixFQUFFO1FBQUMsUUFBTyxTQUFTLENBQUM7WUFBRSxJQUFJLENBQUMsaUJBQWlCLEtBQUssS0FBRyxZQUFXO1FBQUU7UUFBRSxTQUFRLFNBQVMsQ0FBQztZQUFFLElBQUksQ0FBQyxrQkFBa0IsS0FBSztRQUFFO0lBQUMsR0FBRSxPQUFPLE9BQU8sT0FBTyxDQUFDLEVBQUUsR0FBQyxLQUFLO0FBQUM7QUFBQyxPQUFPLE9BQU8sU0FBTztBQUFFLE9BQU8sT0FBTyxVQUFRLENBQUM7QUFBRSxJQUFJLElBQUUsV0FBVyxXQUFTLFdBQVcsVUFBUTtBQUFLLFNBQVM7SUFBSSxPQUFNLENBQUMsRUFBRSxRQUFNLEVBQUUsU0FBTyxZQUFVLFNBQVMsU0FBUyxRQUFRLFlBQVUsSUFBRSxTQUFTLFdBQVMsY0FBWSxFQUFFO0FBQUk7QUFBQyxTQUFTO0lBQUksT0FBTSxDQUFDLEVBQUUsUUFBTSxFQUFFLFNBQU8sWUFBVSxjQUFZLEVBQUU7QUFBSTtBQUFDLFNBQVM7SUFBSSxPQUFPLEVBQUUsUUFBTSxTQUFTO0FBQUk7QUFBQyxJQUFJLElBQUUsMEJBQXlCLElBQUU7QUFBMkIsSUFBSSxJQUFFLENBQUMsRUFBRSxFQUFFLFNBQU8sVUFBUSxPQUFPLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUFDLGVBQWUsRUFBRSxJQUFFLElBQUk7SUFBRSxPQUFPLElBQUc7UUFBQyxNQUFNLE1BQU07UUFBRztJQUFLLEVBQUMsT0FBSztRQUFDLE1BQU0sSUFBSSxRQUFRLENBQUEsSUFBRyxXQUFXLEdBQUU7SUFBRztBQUFDO0FBQUMsSUFBRyxFQUFFLFFBQVEsY0FBYyxxQkFBbUIsR0FBRTtJQUFDLElBQUksSUFBRSxFQUFFLFFBQVEsT0FBTztJQUE4QixXQUFXLGlCQUFpQixTQUFRLFNBQVMsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFLFFBQVE7UUFBSSxJQUFHLEVBQUUsV0FBVyxJQUFHO1lBQUMsSUFBSSxJQUFFLElBQUksSUFBSSxtQkFBbUIsRUFBRSxNQUFNLEVBQUU7WUFBVSxFQUFFLGFBQVcsRUFBRSxRQUFNLEVBQUUsU0FBTyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsR0FBRSxDQUFBLEVBQUUsYUFBYSxJQUFJLEtBQUksS0FBSyxNQUFNLGFBQVksRUFBRSxZQUFZLE1BQU0sR0FBRyxLQUFLLENBQUEsSUFBRyxJQUFJLFNBQVMsRUFBRSxNQUFLO29CQUFDLFNBQVE7d0JBQUMsZ0JBQWUsRUFBRSxRQUFRLElBQUksbUJBQWlCO29CQUFpQjtnQkFBQyxJQUFHLElBQUcsRUFBRSxZQUFZLElBQUksU0FBUyxjQUFhO2dCQUFDLFFBQU87Z0JBQUksWUFBVztZQUFTO1FBQUc7SUFBQztBQUFFO0FBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRyxFQUFDLFNBQVEsQ0FBQyxFQUFDLEdBQUM7SUFBRSxPQUFPLElBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQztBQUFDO0FBQUMsU0FBUyxFQUFFLElBQUUsR0FBRztJQUFFLElBQUksSUFBRTtJQUFJLE9BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBUSxTQUFTLGFBQVcsWUFBVSxDQUFDLDhCQUE4QixLQUFLLEtBQUcsUUFBTSxLQUFLLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUFBO0FBQUMsU0FBUyxFQUFFLENBQUM7SUFBRSxPQUFPLEVBQUUsV0FBUyxZQUFVLEVBQUUsOEJBQTRCLEVBQUU7QUFBUTtBQUFDLFNBQVMsRUFBRSxDQUFDO0lBQUUsSUFBRyxPQUFPLFdBQVcsWUFBVSxLQUFJO0lBQU8sSUFBSSxJQUFFLElBQUksVUFBVSxFQUFFLE9BQU8sT0FBSztJQUFJLE9BQU8sRUFBRSxpQkFBaUIsV0FBVSxlQUFlLENBQUM7UUFBRSxJQUFJLElBQUUsS0FBSyxNQUFNLEVBQUU7UUFBTSxNQUFNLEVBQUU7SUFBRSxJQUFHLEVBQUUsaUJBQWlCLFNBQVEsSUFBRztBQUFDO0FBQUMsU0FBUyxFQUFFLENBQUM7SUFBRSxJQUFHLE9BQU8sV0FBVyxZQUFVLEtBQUk7SUFBTyxJQUFJLElBQUUsSUFBSSxVQUFVO0lBQUssT0FBTyxFQUFFLGlCQUFpQixXQUFVLGVBQWUsQ0FBQztRQUFFLElBQUksSUFBRSxLQUFLLE1BQU0sRUFBRTtRQUFNLElBQUcsRUFBRSxTQUFPLFlBQVUsTUFBTSxFQUFFLEVBQUUsU0FBUSxFQUFFLFNBQU8sU0FBUSxLQUFJLElBQUksS0FBSyxFQUFFLFlBQVksS0FBSztZQUFDLElBQUksSUFBRSxFQUFFLGFBQVcsRUFBRTtZQUFNLEVBQUUsOEJBQTRCLEVBQUUsVUFBUSxDQUFDO0FBQzN0RyxDQUFDLEdBQUMsSUFBRSxDQUFDOztBQUVMLENBQUMsR0FBQyxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBQ2hCLENBQUM7UUFBRTtJQUFDLElBQUcsRUFBRSxpQkFBaUIsU0FBUSxJQUFHLEVBQUUsaUJBQWlCLFFBQU87UUFBSyxFQUFFLENBQUMscURBQXFELEVBQUUsRUFBRSxjQUFjLENBQUM7SUFBQyxJQUFHLEVBQUUsaUJBQWlCLFNBQVE7UUFBSyxFQUFFLENBQUMsb0VBQW9FLEVBQUUsRUFBRSxjQUFjLENBQUM7SUFBQyxJQUFHO0FBQUM7QUFBQyxJQUFJLElBQUUsT0FBTyxPQUFPLFFBQU8sSUFBRTtJQUFDLFlBQVcsQ0FBQztJQUFFLFdBQVUsQ0FBQztJQUFFLFdBQVUsQ0FBQztJQUFFLGFBQVksQ0FBQztJQUFFLGFBQVksSUFBSTtJQUFJLFdBQVUsSUFBSTtBQUFHO0FBQUUsZUFBZSxFQUFFLElBQUUsQ0FBQyxDQUFDO0lBQUUsSUFBRyxLQUFHLEVBQUUsY0FBWSxFQUFFLGFBQVk7UUFBQyxFQUFFO1FBQWlDLEtBQUksSUFBSSxLQUFLLEVBQUUsVUFBVSxFQUFFLFlBQVk7SUFBSztJQUFDLElBQUcsS0FBRyxFQUFFLGNBQWEsQ0FBQSxFQUFFLGFBQVcsRUFBRSxTQUFRLEdBQUc7UUFBQyxFQUFFO1FBQStCLElBQUksSUFBRSxNQUFNLEdBQUcsS0FBSyxNQUFNO1lBQUMsUUFBTyxDQUFDO1FBQUM7UUFBRyxLQUFJLElBQUksS0FBSyxFQUFFLFlBQVk7WUFBQyxJQUFJLElBQUUsRUFBRSxLQUFLLENBQUEsSUFBRyxFQUFFLE9BQUssRUFBRSxPQUFPLEtBQUs7WUFBSSxFQUFFLFlBQVk7Z0JBQUMsMEJBQXlCO1lBQUM7UUFBRTtRQUFDLEVBQUUsUUFBUTtJQUFRO0FBQUM7QUFBQyxJQUFHLENBQUMsS0FBRyxDQUFDLEVBQUUsaUJBQWdCO0lBQUM7SUFBSSxJQUFJLElBQUUsRUFBRSxPQUFNO1FBQUksRUFBRSxpQ0FBZ0MsRUFBRSxjQUFZLEVBQUUsT0FBTyxDQUFBLElBQUcsRUFBRSxZQUFVLEVBQUUsU0FBUyxLQUFLLENBQUEsSUFBRyxFQUFFLE9BQU8sUUFBTyxFQUFFO1FBQUssSUFBSSxJQUFFLEVBQUUsS0FBSyxDQUFBLElBQUcsRUFBRSxTQUFPO1FBQVEsSUFBRyxHQUFFO1lBQUMsSUFBSSxJQUFFLElBQUksSUFBSSxFQUFFLElBQUksQ0FBQSxJQUFHLEVBQUUsTUFBSyxJQUFFLE9BQU8sT0FBTyxFQUFFLGNBQWMsSUFBSSxDQUFBLElBQUcsT0FBTyxPQUFPLElBQUk7WUFBTyxFQUFFLGNBQVksRUFBRSxNQUFNLENBQUEsSUFBRyxFQUFFLElBQUk7UUFBRztRQUFDO0lBQUc7SUFBRyxFQUFFLGlCQUFpQixRQUFPO1FBQUssSUFBSSxJQUFFLFlBQVksSUFBSSxFQUFFLEtBQUssU0FBUTtRQUFNLEVBQUUsaUJBQWlCLFNBQVEsSUFBSSxjQUFjO0lBQUcsSUFBRyxFQUFFLGlCQUFpQixTQUFRO1FBQVUsTUFBTSxLQUFJLEVBQUUsQ0FBQztJQUFFO0FBQUU7QUFBQyxFQUFFLE9BQU07SUFBSSxPQUFPLEVBQUUsdUNBQXNDLEVBQUU7UUFBTSxLQUFJO1lBQWUsRUFBRSxlQUFhLENBQUMsR0FBRTtZQUFJO1FBQU0sS0FBSTtZQUFjLEVBQUUsY0FBWSxDQUFDLEdBQUU7WUFBSTtJQUFNO0FBQUM7QUFBRyxFQUFFLFFBQVEsVUFBVSxZQUFZLFNBQVMsQ0FBQztJQUFFLElBQUksSUFBRSxFQUFFLEtBQUssV0FBVyxJQUFHLElBQUUsRUFBRSxLQUFLLFdBQVc7SUFBRyxJQUFHLEtBQUcsR0FBRTtRQUFDLElBQUksSUFBRSxJQUFFLEVBQUUsWUFBVSxFQUFFO1FBQVksRUFBRSxJQUFJLElBQUcsRUFBRSxhQUFhLFlBQVk7WUFBSyxFQUFFLE9BQU87UUFBRSxJQUFHLEVBQUUsVUFBVSxZQUFZLFNBQVMsQ0FBQztZQUFFLEVBQUUsb0NBQW1DLElBQUcsRUFBRSx5QkFBd0IsQ0FBQSxFQUFFLGNBQVksQ0FBQyxDQUFBLEdBQUcsRUFBRSwyQkFBMEIsQ0FBQSxFQUFFLGdCQUFjLENBQUMsQ0FBQSxHQUFHO1FBQUc7SUFBRTtBQUFDO0FBQUcsRUFBRSxRQUFRLFVBQVUsWUFBWSxTQUFTLENBQUM7SUFBRSxPQUFPLEVBQUUsMEJBQXlCLENBQUEsRUFBRSw2Q0FBNEMsR0FBRSxHQUFHLENBQUM7QUFBQzs7O0FDSmw3RDs7O0FDQUE7Ozs7Ozs7Q0FPQyxHQUVEO0FBQ0E7QUFDQTtBQUNBO0FBd0JBO0FBRUEsK0VBQStFO0FBQy9FLG1CQUFtQjtBQUNuQiwrRUFBK0U7QUFFL0UsSUFBSSxrQkFBdUM7QUFDM0MsSUFBSSxlQUF5QztBQUM3QyxJQUFJLDBCQUEyRDtBQUMvRCxJQUFJLGFBQWdDO0FBQ3BDLElBQUksZUFBZ0M7SUFBRSxPQUFPO0FBQWU7QUFDNUQsSUFBSSxZQUFZO0FBSWhCOztDQUVDLEdBQ0QsZUFBZTtJQUNYLElBQUk7UUFDQSxRQUFRLElBQUk7UUFFWixvQ0FBb0M7UUFDcEMsUUFBUSxJQUFJO1FBQ1osZUFBZTtZQUFFLE9BQU87UUFBYztRQUN0QztRQUVBLE1BQU0sb0JBQW9CLE1BQU0sQ0FBQSxHQUFBLDRCQUFvQixFQUFFLENBQUEsR0FBQSx3QkFBWSxFQUFFO1FBRXBFLDJCQUEyQjtRQUMzQiwwQkFBMEI7UUFDMUIsTUFBTSxDQUFBLEdBQUEsNkJBQXFCLEVBQUU7UUFFN0IsUUFBUSxJQUFJLDJDQUEyQyxrQkFBa0I7UUFFekUsNkNBQTZDO1FBQzdDLE1BQU0sUUFBUSxDQUFBLEdBQUEsb0JBQVk7UUFFMUIseUNBQXlDO1FBQ3pDLGFBQWE7WUFDVDtZQUNBLGNBQWM7WUFDZCxZQUFZLEtBQUs7UUFDckI7UUFFQSw4REFBOEQ7UUFDOUQsTUFBTSxVQUFVLENBQUEsR0FBQSxtQkFBVyxFQUN2QixrQkFBa0IsV0FDbEIsQ0FBQSxHQUFBLHdCQUFZLEVBQUUsb0JBQ2Q7UUFHSixRQUFRLElBQUksMENBQTBDO1FBRXRELGdCQUFnQjtRQUNoQixlQUFlO1lBQUUsT0FBTztRQUFjO1FBQ3RDO1FBRUEsc0RBQXNEO1FBQ3RELE1BQU0sY0FBYyxNQUFNLE9BQU8sU0FBUyxrQkFBa0I7WUFDeEQsS0FBSztZQUNMLGFBQWE7UUFDakI7UUFFQSxJQUFJLENBQUMsYUFDRCxNQUFNLElBQUksTUFBTTtRQUdwQixRQUFRLElBQUksb0NBQW9DO1FBRWhELG1EQUFtRDtRQUNuRCxNQUFNLE1BQU0sSUFBSSxJQUFJO1FBQ3BCLE1BQU0sT0FBTyxJQUFJLGFBQWEsSUFBSTtRQUNsQyxNQUFNLGdCQUFnQixJQUFJLGFBQWEsSUFBSTtRQUUzQyxJQUFJLENBQUMsTUFDRCxNQUFNLElBQUksTUFBTTtRQUdwQixlQUFlO1FBQ2YsSUFBSSxDQUFDLGNBQWMsa0JBQWtCLFdBQVcsT0FDNUMsTUFBTSxJQUFJLE1BQU07UUFHcEIsUUFBUSxJQUFJO1FBRVosb0VBQW9FO1FBQ3BFLE1BQU0sU0FBUyxNQUFNLENBQUEsR0FBQSw0QkFBb0IsRUFDckMsTUFDQSxrQkFBa0IsV0FDbEIsa0JBQWtCLGVBQ2xCLENBQUEsR0FBQSx3QkFBWSxFQUFFO1FBR2xCLGVBQWU7UUFDZixlQUFlO1FBQ2YsTUFBTSxDQUFBLEdBQUEsa0JBQVUsRUFBRTtRQUVsQixRQUFRLElBQUk7UUFFWixnQkFBZ0I7UUFDaEIsZUFBZTtZQUFFLE9BQU87UUFBZ0I7UUFDeEM7UUFFQSxRQUFRLElBQUk7UUFFWixPQUFPO1lBQUUsU0FBUztZQUFNLE1BQU07Z0JBQUUsT0FBTztZQUFnQjtRQUFFO0lBQzdELEVBQUUsT0FBTyxPQUFPO1FBQ1osUUFBUSxNQUFNLHdDQUF3QztRQUN0RCxlQUFlO1lBQ1gsT0FBTztZQUNQLE9BQU8saUJBQWlCLFFBQVEsTUFBTSxVQUFVO1FBQ3BEO1FBQ0E7UUFDQSxPQUFPO1lBQ0gsU0FBUztZQUNULE9BQU8saUJBQWlCLFFBQVEsTUFBTSxVQUFVO1FBQ3BEO0lBQ0osU0FBVTtRQUNOLGFBQWE7SUFDakI7QUFDSjtBQUVBOztDQUVDLEdBQ0QsZUFBZTtJQUNYLElBQUksQ0FBQyxjQUFjLGVBQWU7UUFDOUIsUUFBUSxNQUFNO1FBQ2QsZUFBZTtZQUFFLE9BQU87WUFBYyxPQUFPO1FBQW1CO1FBQ2hFO1FBQ0EsT0FBTztJQUNYO0lBRUEsMkNBQTJDO0lBQzNDLElBQUksQ0FBQyx5QkFDRCwwQkFBMEIsTUFBTSxDQUFBLEdBQUEsaUNBQXlCO0lBRzdELElBQUksQ0FBQyx5QkFBeUI7UUFDMUIsUUFBUSxNQUFNO1FBQ2QsZUFBZTtZQUFFLE9BQU87WUFBYyxPQUFPO1FBQXdCO1FBQ3JFO1FBQ0EsT0FBTztJQUNYO0lBRUEsSUFBSTtRQUNBLFFBQVEsSUFBSTtRQUNaLGVBQWU7WUFBRSxPQUFPO1FBQWdCO1FBQ3hDO1FBRUEsTUFBTSxZQUFZLE1BQU0sQ0FBQSxHQUFBLHlCQUFpQixFQUNyQyxhQUFhLGVBQ2Isd0JBQXdCLFdBQ3hCLHdCQUF3QjtRQUU1QixlQUFlO1FBQ2YsTUFBTSxDQUFBLEdBQUEsa0JBQVUsRUFBRTtRQUVsQixlQUFlO1lBQUUsT0FBTztRQUFnQjtRQUN4QztRQUVBLFFBQVEsSUFBSTtRQUNaLE9BQU87SUFDWCxFQUFFLE9BQU8sT0FBTztRQUNaLFFBQVEsTUFBTSxzQ0FBc0M7UUFDcEQsdUJBQXVCO1FBQ3ZCLE1BQU0sQ0FBQSxHQUFBLGtCQUFVO1FBQ2hCLGVBQWU7UUFDZixlQUFlO1lBQ1gsT0FBTztZQUNQLE9BQU87UUFDWDtRQUNBO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELGVBQWU7SUFDWCxJQUFJLENBQUMsY0FDRCwyQkFBMkI7SUFDM0IsZUFBZSxNQUFNLENBQUEsR0FBQSxzQkFBYztJQUd2QyxJQUFJLENBQUMsY0FDRCxPQUFPO0lBSVAsQ0FBQSxHQUFBLHFCQUFhLEVBQUU7SUFPbkIsT0FBTyxhQUFhO0FBQ3hCO0FBRUEsK0VBQStFO0FBQy9FLGtDQUFrQztBQUNsQywrRUFBK0U7QUFFL0U7O0NBRUMsR0FDRCxlQUFlO0lBQ1gsSUFBSTtRQUNBLFFBQVEsSUFBSTtRQUVaLE1BQU0sY0FBYyxNQUFNO1FBQzFCLElBQUksQ0FBQyxhQUNELE9BQU87WUFDSCxTQUFTO1lBQ1QsT0FBTztRQUNYO1FBR0osb0JBQW9CO1FBQ3BCLGtCQUFrQixJQUFJLENBQUEsR0FBQSwwQkFBVyxFQUM3QixDQUFBLEdBQUEsd0JBQVksRUFBRSxhQUNkLGFBQ0E7WUFDSSxnQkFBZ0IsQ0FBQztnQkFDYixlQUFlO2dCQUNmO2dCQUVBLDhDQUE4QztnQkFDOUMsSUFBSSxPQUFPLFVBQVU7cUJBRVYsT0FBTztZQUl0QjtZQUNBLFdBQVcsQ0FBQztnQkFDUixRQUFRLElBQUksNkJBQTZCO1lBQzdDO1FBQ0o7UUFHSixVQUFVO1FBQ1YsTUFBTSxnQkFBZ0I7UUFFdEIsMEJBQTBCO1FBQzFCLE1BQU0sZ0JBQWdCO1FBRXRCLE9BQU87WUFBRSxTQUFTO1lBQU0sTUFBTSxnQkFBZ0I7UUFBWTtJQUM5RCxFQUFFLE9BQU8sT0FBTztRQUNaLFFBQVEsTUFBTSw2Q0FBNkM7UUFDM0QsT0FBTztZQUNILFNBQVM7WUFDVCxPQUFPLGlCQUFpQixRQUFRLE1BQU0sVUFBVTtRQUNwRDtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELFNBQVM7SUFDTCxJQUFJLGlCQUFpQjtRQUNqQixnQkFBZ0I7UUFDaEIsa0JBQWtCO0lBQ3RCO0lBQ0EsZUFBZTtRQUFFLE9BQU87SUFBZ0I7SUFDeEM7QUFDSjtBQUVBOztDQUVDLEdBQ0QsZUFBZTtJQUNYLFFBQVEsSUFBSTtJQUVaLDRCQUE0QjtJQUM1QixJQUFJLGlCQUFpQjtRQUNqQixnQkFBZ0I7UUFDaEIsa0JBQWtCO0lBQ3RCO0lBRUEsaUJBQWlCO0lBQ2pCLE1BQU0sWUFBWSxNQUFNO0lBRXhCLDhDQUE4QztJQUM5QyxJQUFJLGFBQWEsV0FDYixNQUFNO0FBRWQ7QUFFQTs7Q0FFQyxHQUNELGVBQWU7SUFDWCxRQUFRLElBQUk7SUFFWiw0QkFBNEI7SUFDNUIsSUFBSSxpQkFBaUI7UUFDakIsZ0JBQWdCO1FBQ2hCLGtCQUFrQjtJQUN0QjtJQUVBLHFFQUFxRTtJQUNyRSxNQUFNLENBQUEsR0FBQSxrQkFBVTtJQUNoQixNQUFNLENBQUEsR0FBQSw2QkFBcUI7SUFDM0IsZUFBZTtJQUNmLDBCQUEwQjtJQUMxQixlQUFlO1FBQ1gsT0FBTztRQUNQLE9BQU87SUFDWDtJQUNBLFlBQVk7SUFDWixNQUFNLE9BQU8sUUFBUSxNQUFNLElBQUk7UUFBRSxzQkFBc0I7SUFBTTtJQUM3RDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlO0lBQ1gsWUFBWTtJQUVaLHNCQUFzQjtJQUN0QixNQUFNLE9BQU8sUUFBUSxNQUFNLElBQUk7UUFBRSxzQkFBc0I7SUFBSztJQUU1RCw2Q0FBNkM7SUFDN0MsSUFBSSxtQkFBbUIsYUFBYSxVQUFVLGFBQWE7UUFDdkQsUUFBUSxJQUFJO1FBQ1osTUFBTSxjQUFjLE1BQU07UUFFMUIsSUFBSSxZQUFZLFNBQ1osT0FBTztZQUFFLFNBQVM7WUFBTSxNQUFNO1FBQWE7YUFDeEM7WUFDSCxRQUFRLEtBQUsscURBQXFELFlBQVk7WUFDOUUsd0NBQXdDO1lBQ3hDO1FBQ0o7SUFDSjtJQUVBLDRCQUE0QjtJQUM1QixJQUFJLGdCQUFnQixNQUFNLENBQUEsR0FBQSxzQkFBYyxLQUFLO1FBQ3pDLE1BQU0sZ0JBQWdCLE1BQU07UUFFNUIsaURBQWlEO1FBQ2pELElBQUksY0FBYyxXQUFXLGlCQUFpQjtZQUMxQyxRQUFRLElBQUk7WUFDWixNQUFNLGNBQWMsTUFBTTtZQUUxQixJQUFJLENBQUMsWUFBWSxTQUFTO2dCQUN0QixRQUFRLEtBQUssc0RBQXNELFlBQVk7Z0JBQy9FLGVBQWU7b0JBQ1gsR0FBRyxZQUFZO29CQUNmLE9BQU8sQ0FBQyxtQ0FBbUMsRUFBRSxZQUFZLE1BQU0sQ0FBQztnQkFDcEU7Z0JBQ0E7WUFDSixPQUNJLFFBQVEsSUFBSSxxQ0FBcUMsWUFBWTtRQUVyRTtRQUVBLE9BQU87SUFDWDtJQUVBLHVCQUF1QjtJQUN2QixPQUFPO1FBQ0gsU0FBUztRQUNULE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlO0lBQ1gsWUFBWTtJQUNaLE1BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSTtRQUFFLHNCQUFzQjtJQUFNO0lBQzdEO0lBQ0EsT0FBTztRQUFFLFNBQVM7SUFBSztBQUMzQjtBQUVBOztDQUVDLEdBQ0QsZUFBZTtJQUNYO0lBQ0EsTUFBTSxDQUFBLEdBQUEsa0JBQVU7SUFDaEIsTUFBTSxDQUFBLEdBQUEsNkJBQXFCO0lBQzNCLGVBQWU7SUFDZiwwQkFBMEI7SUFDMUIsZUFBZTtRQUFFLE9BQU87SUFBZTtJQUN2QyxZQUFZO0lBQ1osTUFBTSxPQUFPLFFBQVEsTUFBTSxJQUFJO1FBQUUsc0JBQXNCO0lBQU07SUFDN0Q7SUFDQSxPQUFPO1FBQUUsU0FBUztJQUFLO0FBQzNCO0FBRUE7O0NBRUMsR0FDRCxTQUFTO0lBQ0wsT0FBTztBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELGVBQWU7SUFDWCxJQUFJLFNBQTZCO0lBRWpDLElBQUk7UUFDQSxRQUFRLElBQUk7UUFFWixtQkFBbUI7UUFDbkIsTUFBTSxjQUFjLE1BQU07UUFDMUIsSUFBSSxDQUFDLGFBQ0QsT0FBTztZQUNILFNBQVM7WUFDVCxPQUFPO1FBQ1g7UUFHSixNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUEsR0FBQSx3QkFBWSxFQUFFO1FBRWxDLElBQUk7WUFDQSxvQkFBb0I7WUFDcEIsU0FBUyxJQUFJLENBQUEsR0FBQSxlQUFLLEVBQUU7Z0JBQ2hCLE1BQU07Z0JBQ04sU0FBUztZQUNiLEdBQUc7Z0JBQ0MsY0FBYztvQkFDVixPQUFPO3dCQUFFLGFBQWE7b0JBQUs7Z0JBQy9CO1lBQ0o7WUFFQSxRQUFRLElBQUk7WUFFWiwwQ0FBMEM7WUFDMUMsK0RBQStEO1lBQy9ELE1BQU0sWUFBWSxJQUFJLENBQUEsR0FBQSx5QkFBaUIsRUFBRSxLQUFLO2dCQUMxQyxhQUFhO29CQUNULFNBQVM7d0JBQ0wsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQzt3QkFDeEMsVUFBVTtvQkFDZDtnQkFDSjtnQkFDQSxpRUFBaUU7Z0JBQ2pFLE9BQU8sT0FBTyxPQUFPO29CQUNqQixNQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU07b0JBQ2xDLFFBQVEsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDO29CQUNwRCxRQUFRLElBQUksVUFBVTtvQkFFdEIsT0FBTyxNQUFNLE9BQU87d0JBQ2hCLEdBQUcsSUFBSTt3QkFDUDtvQkFDSjtnQkFDSjtZQUNKO1lBRUEsd0JBQXdCO1lBQ3hCLE1BQU0sT0FBTyxRQUFRO1lBQ3JCLFFBQVEsSUFBSTtZQUVaLHNDQUFzQztZQUN0QyxNQUFNLGdCQUFnQixNQUFNLE9BQU87WUFDbkMsUUFBUSxJQUFJLGdDQUFnQztZQUU1QyxpQ0FBaUM7WUFDakMsTUFBTSxPQUFPO1lBRWIsSUFBSSxpQkFBaUIsY0FBYyxPQUFPO2dCQUN0QyxNQUFNLFlBQVksY0FBYyxNQUFNO2dCQUN0QyxRQUFRLElBQUksc0RBQXNEO2dCQUVsRSxPQUFPO29CQUNILFNBQVM7b0JBQ1QsTUFBTTt3QkFDRixPQUFPO3dCQUNQLE9BQU8sY0FBYyxNQUFNLElBQUksQ0FBQSxPQUFTLENBQUE7Z0NBQ3BDLE1BQU0sS0FBSztnQ0FDWCxhQUFhLEtBQUs7Z0NBQ2xCLGFBQWEsS0FBSzs0QkFDdEIsQ0FBQTt3QkFDQSxXQUFXO29CQUNmO2dCQUNKO1lBQ0osT0FDSSxPQUFPO2dCQUNILFNBQVM7Z0JBQ1QsT0FBTztZQUNYO1FBRVIsRUFBRSxPQUFPLGdCQUFnQjtZQUNyQixRQUFRLE1BQU0scUNBQXFDO1lBRW5ELDRCQUE0QjtZQUM1QixJQUFJLFFBQ0EsSUFBSTtnQkFDQSxNQUFNLE9BQU87WUFDakIsRUFBRSxPQUFPLFlBQVk7Z0JBQ2pCLFFBQVEsTUFBTSxzQ0FBc0M7WUFDeEQ7WUFHSixPQUFPO2dCQUNILFNBQVM7Z0JBQ1QsT0FBTywwQkFBMEIsUUFBUSxlQUFlLFVBQVU7WUFDdEU7UUFDSjtJQUNKLEVBQUUsT0FBTyxPQUFPO1FBQ1osUUFBUSxNQUFNLG9DQUFvQztRQUVsRCw0QkFBNEI7UUFDNUIsSUFBSSxRQUNBLElBQUk7WUFDQSxNQUFNLE9BQU87UUFDakIsRUFBRSxPQUFPLFlBQVk7WUFDakIsUUFBUSxNQUFNLHNDQUFzQztRQUN4RDtRQUdKLE9BQU87WUFDSCxTQUFTO1lBQ1QsT0FBTyxpQkFBaUIsUUFBUSxNQUFNLFVBQVU7UUFDcEQ7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlLGVBQWUsSUFBWSxFQUFFLElBQTBCO0lBQ2xFLElBQUksQ0FBQyxpQkFDRCxPQUFPO1FBQUUsU0FBUztRQUFPLE9BQU87SUFBZ0I7SUFHcEQsSUFBSTtRQUNBLE1BQU0sU0FBUyxNQUFNLGdCQUFnQixTQUFTLE1BQU07UUFDcEQsT0FBTztZQUFFLFNBQVM7WUFBTSxNQUFNO1FBQU87SUFDekMsRUFBRSxPQUFPLE9BQU87UUFDWixRQUFRLE1BQU0saUNBQWlDO1FBQy9DLE9BQU87WUFDSCxTQUFTO1lBQ1QsT0FBTyxpQkFBaUIsUUFBUSxNQUFNLFVBQVU7UUFDcEQ7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTO0lBQ0wsT0FBTyxRQUFRLFlBQVk7UUFDdkIsTUFBTTtRQUNOLFNBQVM7SUFDYixHQUFHLE1BQU07SUFDTCxnQ0FBZ0M7SUFDcEM7QUFDSjtBQUVBLCtFQUErRTtBQUMvRSxrQkFBa0I7QUFDbEIsK0VBQStFO0FBRS9FLE9BQU8sUUFBUSxVQUFVLFlBQVksQ0FBQyxTQUEyQixRQUFRO0lBQ3JFLDZCQUE2QjtJQUM3QixJQUFJLFFBQVEsTUFBTSxXQUFXLGdCQUFnQjtRQUN4QyxDQUFBO1lBQ0csSUFBSTtZQUVKLE9BQVEsUUFBUTtnQkFDWixLQUFLO29CQUNELFdBQVcsTUFBTTtvQkFDakI7Z0JBRUosS0FBSztvQkFDRCxXQUFXLE1BQU07b0JBQ2pCO2dCQUVKLEtBQUs7b0JBQ0QsV0FBVyxNQUFNO29CQUNqQjtnQkFFSixLQUFLO29CQUNELFdBQVcsTUFBTTtvQkFDakI7Z0JBRUosS0FBSztvQkFDRCxXQUFXO3dCQUFFLFNBQVM7d0JBQU0sTUFBTTtvQkFBa0I7b0JBQ3BEO2dCQUVKLEtBQUs7b0JBQ0QsV0FBVyxNQUFNLGVBQ2IsUUFBUSxTQUFTLE1BQ2pCLFFBQVEsU0FBUztvQkFFckI7Z0JBRUosS0FBSztvQkFDRCxXQUFXLE1BQU07b0JBQ2pCO2dCQUVKO29CQUNJLFdBQVc7d0JBQUUsU0FBUzt3QkFBTyxPQUFPO29CQUF1QjtZQUNuRTtZQUVBLGFBQWE7UUFDakIsQ0FBQTtRQUVBLE9BQU8sTUFBTSw4QkFBOEI7SUFDL0M7QUFDSjtBQUVBLCtFQUErRTtBQUMvRSxvQkFBb0I7QUFDcEIsK0VBQStFO0FBRS9FLGtEQUFrRDtBQUNsRCxPQUFPLGNBQWMsVUFBVSxZQUFZLE9BQU87SUFDOUMsSUFBSTtRQUNBLElBQUksQ0FBQyxlQUFlLFdBQVcsY0FDM0I7UUFHSixNQUFNLEtBQUssZUFBZSxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ3ZDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxPQUFPLFFBQVEsTUFBTSxJQUFJO1FBQzFELE1BQU0sV0FBaUMsU0FBUyxDQUFDLEdBQUc7UUFFcEQsSUFBSSxVQUFVLEtBQ1YsTUFBTSxPQUFPLEtBQUssT0FBTztZQUFFLEtBQUssU0FBUztRQUFJO1FBR2pELGtEQUFrRDtRQUNsRCxJQUFJLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDZixPQUFPLFNBQVMsQ0FBQyxHQUFHO1lBQ3BCLE1BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSTtnQkFBRTtZQUFVO1FBQy9DO1FBRUEsT0FBTyxjQUFjLE1BQU07SUFDL0IsRUFBRSxPQUFPLE9BQU87UUFDWixRQUFRLE1BQU0sbURBQW1EO0lBQ3JFO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELE9BQU8sUUFBUSxZQUFZLFlBQVksT0FBTztJQUMxQyxRQUFRLElBQUksNkJBQTZCLFFBQVE7SUFFakQsSUFBSTtRQUNBLHlDQUF5QztRQUN6QyxJQUFJLE9BQU8sV0FDUCxPQUFPLFVBQVUsaUJBQWlCO1lBQUUsd0JBQXdCO1FBQUssR0FBRyxNQUFNLFFBQVE7UUFHdEYsbUJBQW1CO1FBQ25CLE1BQU0sU0FBUyxNQUFNLE9BQU8sUUFBUSxNQUFNLElBQUk7WUFBQztTQUFxQjtRQUNwRSxZQUFZLE1BQU0sQ0FBQyxxQkFBcUIsSUFBSTtRQUU1Qyx3Q0FBd0M7UUFDeEMsSUFBSSxXQUFXO1lBQ1gsTUFBTSxTQUFTLE1BQU0sQ0FBQSxHQUFBLHNCQUFjO1lBQ25DLE1BQU0sY0FBYyxNQUFNLENBQUEsR0FBQSxpQ0FBeUI7WUFDbkQsSUFBSSxVQUFVLGFBQWE7Z0JBQ3ZCLGVBQWU7Z0JBQ2YsMEJBQTBCO2dCQUMxQixNQUFNO1lBQ1Y7UUFDSjtRQUVBLFFBQVEsSUFBSTtJQUNoQixFQUFFLE9BQU8sT0FBTztRQUNaLFFBQVEsTUFBTSxtQ0FBbUM7SUFDckQ7QUFDSjtBQUVBOztDQUVDLEdBQ0QsT0FBTyxRQUFRLFVBQVUsWUFBWTtJQUNqQyxRQUFRLElBQUk7SUFFWixtQkFBbUI7SUFDbkIsTUFBTSxTQUFTLE1BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSTtRQUFDO0tBQXFCO0lBQ3BFLFlBQVksTUFBTSxDQUFDLHFCQUFxQixJQUFJO0lBRTVDLHdDQUF3QztJQUN4QyxJQUFJLFdBQVc7UUFDWCxNQUFNLFNBQVMsTUFBTSxDQUFBLEdBQUEsc0JBQWM7UUFDbkMsTUFBTSxjQUFjLE1BQU0sQ0FBQSxHQUFBLGlDQUF5QjtRQUNuRCxJQUFJLFVBQVUsYUFBYTtZQUN2QixlQUFlO1lBQ2YsMEJBQTBCO1lBQzFCLE1BQU07UUFDVjtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELElBQUksT0FBTyxRQUNQLE9BQU8sT0FBTyxVQUFVLFlBQVksT0FBTztJQUN2QyxJQUFJLE9BQU8sYUFBYSxJQUFJLElBQ3hCLElBQUk7UUFDQSxNQUFNLE9BQU8sVUFBVSxLQUFLO1lBQUUsT0FBTyxJQUFJO1FBQUc7SUFDaEQsRUFBRSxPQUFPLE9BQU87UUFDWixRQUFRLE1BQU0sMENBQTBDO0lBQzVEO0FBRVI7QUFJSix5Q0FBeUM7QUFDekMsT0FBTyxPQUFPLE9BQU8sNEJBQTRCO0lBQzdDLGlCQUFpQjtBQUNyQjtBQWdCQTs7Q0FFQyxHQUNELE9BQU8sT0FBTyxRQUFRLFlBQVksT0FBTztJQUNyQyw4QkFBOEI7SUFDOUIsSUFBSSxDQUFDLE1BQU0sS0FBSyxXQUFXLGNBQ3ZCO0lBR0osTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ25DLFFBQVEsSUFBSSxzQ0FBc0M7SUFFbEQsSUFBSTtRQUNBLGdDQUFnQztRQUNoQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUMsRUFBRSxHQUFHLE1BQU0sT0FBTyxRQUFRLE1BQU0sSUFBSTtRQUMxRCxNQUFNLFdBQWlDLFNBQVMsQ0FBQyxHQUFHO1FBRXBELElBQUksQ0FBQyxVQUFVO1lBQ1gsUUFBUSxLQUFLLG9DQUFvQztZQUNqRDtRQUNKO1FBRUEsOEVBQThFO1FBQzlFLE1BQU0sYUFBYTtRQUVuQixNQUFNLG9CQUFvQixTQUFTLGtCQUFrQjtRQUNyRCxNQUFNLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTO1FBRXRFLDREQUE0RDtRQUM1RCxPQUFPLGNBQWMsT0FBTyxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUMxQyxNQUFNO1lBQ04sU0FBUztZQUNULE9BQU87WUFDUCxTQUFTO1lBQ1QsVUFBVTtZQUNWLG9CQUFvQjtRQUN4QjtRQUVBLFFBQVEsSUFBSSwrQ0FBK0M7WUFDdkQsT0FBTztZQUNQLFNBQVM7UUFDYjtJQUVBLG9FQUFvRTtJQUNwRSxxRUFBcUU7SUFDckUsd0RBQXdEO0lBQzVELEVBQUUsT0FBTyxPQUFPO1FBQ1osUUFBUSxNQUFNLCtDQUErQztJQUNqRTtBQUNKO0FBRUEsK0VBQStFO0FBQy9FLGlCQUFpQjtBQUNqQiwrRUFBK0U7QUFFL0UsUUFBUSxJQUFJO0FBQ1osUUFBUSxJQUFJO0FBRVosK0VBQStFO0FBQy9FLHdDQUF3QztBQUN4QywrRUFBK0U7QUFFL0UsNENBQTRDO0FBQzVDLGVBQWU7SUFDWCxJQUFJO1FBQ0EsK0NBQStDO1FBQy9DLHNEQUFzRDtRQUN0RCxNQUFNLFNBQWtCLE9BQU8sT0FBTyxXQUFXLGdCQUFnQixhQUMzRCxNQUFNLE9BQU8sVUFBVSxnQkFDdkI7UUFFTixJQUFJLENBQUMsUUFBUTtZQUNULE1BQU0sT0FBTyxVQUFVLGVBQWU7Z0JBQ2xDLEtBQUs7Z0JBQ0wsdUVBQXVFO2dCQUN2RSxTQUFTO29CQUFDLE9BQU8sVUFBVSxPQUFPO2lCQUFpQjtnQkFDbkQsZUFBZTtZQUNuQjtZQUNBLFFBQVEsSUFBSTtRQUNoQjtJQUNKLEVBQUUsT0FBTyxPQUFPO1FBQ1osMERBQTBEO1FBQzFELFFBQVEsS0FBSyxpREFBaUQ7SUFDbEU7QUFDSjtBQWtCQSxtRUFBbUU7QUFDbkUsT0FBTyxRQUFRLFVBQVUsWUFBWSxDQUFDLFNBQWMsU0FBUztJQUN6RCxJQUFJLFNBQVMsU0FBUywwQkFBMEI7UUFDM0MsQ0FBQTtZQUNHLE1BQU07WUFDTixJQUFJO2dCQUNBLE1BQU0sTUFBTSxNQUFNLE9BQU8sUUFBUSxZQUFZO29CQUFFLE1BQU07Z0JBQW1DO2dCQUN4RixhQUFhO1lBQ2pCLEVBQUUsT0FBTyxPQUFPO2dCQUNaLGFBQWE7b0JBQUUsSUFBSTtvQkFBTyxNQUFNO29CQUFTLFNBQVMsaUJBQWlCLFFBQVEsTUFBTSxVQUFVO2dCQUFVO1lBQ3pHO1FBQ0osQ0FBQTtRQUNBLE9BQU87SUFDWDtJQUVBLElBQUksU0FBUyxTQUFTLHFCQUFxQjtRQUN0QyxDQUFBO1lBQ0csTUFBTSxNQUFNO1lBQ1osTUFBTTtZQUNOLElBQUk7Z0JBQ0EsTUFBTSxNQUFNLE1BQU0sT0FBTyxRQUFRLFlBQVk7b0JBQ3pDLE1BQU07b0JBQ04sU0FBUyxJQUFJO2dCQUNqQjtnQkFDQSxhQUFhO1lBQ2pCLEVBQUUsT0FBTyxPQUFPO2dCQUNaLGFBQWE7b0JBQUUsSUFBSTtvQkFBTyxNQUFNO29CQUFTLFNBQVMsaUJBQWlCLFFBQVEsTUFBTSxVQUFVO2dCQUFVO1lBQ3pHO1FBQ0osQ0FBQTtRQUNBLE9BQU87SUFDWDtBQUNKOzs7QTtBLEksa0IsQSxJLEksSSxDLG1CLFMsRztJLE8sQSxPLEksYSxNO1EsVztJO0E7QSxPLGUsUyxjO0ksTztBO0EsUSxTLEs7QUUzNEJBLE1BQUEsZ0JBQUEsUUFBQTtBQUVBLE1BQUEsYUFBQSxRQUFBO0FBc0NBLE1BQUEsUUFBQSxnQkFBQSxRQUFBO0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCRyxHQUNILE1BQWEsZUFJSCxjQUFBO0lBUU47O0tBRUcsR0FDSCxZQUNZLFdBQTJCLEVBQ25DLE9BQXVCLENBRjNCO1EsSTtRQUlJLEtBQUssQ0FBQztRQUhFLElBQUEsQ0FBQSxjQUFBO1FBUEosSUFBQSxDQUFBLDhCQUE2RCxJQUFJO1FBV3JFLElBQUksQ0FBQyxnQkFBZ0IsQUFBQSxDQUFBLEtBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLFlBQUEsTUFBWSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUksQ0FBQTtRQUM5QyxJQUFJLENBQUMsT0FBTyxJQUFJLE1BQUE7SUFDcEI7SUFFQTs7OztLQUlHLEdBQ0kscUJBQXFCLFlBQWdDLEVBQXJEO1FBQ0gsSUFBSSxJQUFJLENBQUMsV0FDTCxNQUFNLElBQUksTUFBTTtRQUdwQixJQUFJLENBQUMsZ0JBQWdCLEFBQUEsQ0FBQSxHQUFBLGNBQUEsaUJBQUEsRUFBa0IsSUFBSSxDQUFDLGVBQWU7SUFDL0Q7SUFFVSxpQkFBaUIsVUFBb0MsRUFBRSxNQUFjLEVBQXJFO1EsSTtRQUNOLElBQUksQ0FBQyxDQUFBLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxtQkFBQSxNQUFtQixRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxFQUFBLENBQUcsV0FBVyxBQUFELEdBQ3RDLE1BQU0sSUFBSSxNQUFNLENBQUEsd0JBQUEsRUFBMkIsV0FBVSxlQUFBLEVBQWtCLE9BQU0sQ0FBQSxDQUFHO0lBRXhGO0lBRVMsTUFBTSxRQUFRLFNBQW9CLEVBQUUsT0FBd0IsRUFBNUQ7UUFDTCxNQUFNLEtBQUssQ0FBQyxRQUFRO1FBQ3BCLGlGQUFpRjtRQUNqRixrREFBa0Q7UUFDbEQsSUFBSSxVQUFVLGNBQWMsV0FDeEI7UUFFSixJQUFJO1lBQ0EsTUFBTSxTQUFTLE1BQU0sSUFBSSxDQUFDLFFBQ3RCO2dCQUNJLFFBQVE7Z0JBQ1IsUUFBUTtvQkFDSixpQkFBaUIsV0FBQTtvQkFDakIsY0FBYyxJQUFJLENBQUM7b0JBQ25CLFlBQVksSUFBSSxDQUFDO2dCQUNwQjtZQUNKLEdBQ0QsV0FBQSx3QkFDQTtZQUdKLElBQUksV0FBVyxXQUNYLE1BQU0sSUFBSSxNQUFNLENBQUEsdUNBQUEsRUFBMEMsT0FBTSxDQUFFO1lBR3RFLElBQUksQ0FBQyxXQUFBLDRCQUE0QixTQUFTLE9BQU8sa0JBQzdDLE1BQU0sSUFBSSxNQUFNLENBQUEsNENBQUEsRUFBK0MsT0FBTyxnQkFBZSxDQUFFO1lBRzNGLElBQUksQ0FBQyxzQkFBc0IsT0FBTztZQUNsQyxJQUFJLENBQUMsaUJBQWlCLE9BQU87WUFDN0IscUZBQXFGO1lBQ3JGLElBQUksVUFBVSxvQkFDVixVQUFVLG1CQUFtQixPQUFPO1lBR3hDLElBQUksQ0FBQyxnQkFBZ0IsT0FBTztZQUU1QixNQUFNLElBQUksQ0FBQyxhQUFhO2dCQUNwQixRQUFRO1lBQ1g7UUFDTCxFQUFFLE9BQU8sT0FBTztZQUVQLElBQUksQ0FBQztZQUNWLE1BQU07UUFDVjtJQUNKO0lBRUE7O0tBRUcsR0FDSCx3QkFBQTtRQUNJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCO0lBRUE7O0tBRUcsR0FDSCxtQkFBQTtRQUNJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCO0lBRUE7O0tBRUcsR0FDSCxrQkFBQTtRQUNJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCO0lBRVUsMEJBQTBCLE1BQTBCLEVBQXBEO1EsSSxJLEksSSxJO1FBQ04sT0FBUTtZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDLENBQUEsQUFBQSxDQUFBLEtBQUEsSUFBSSxDQUFDLG1CQUFBLE1BQW1CLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUUsT0FBQSxHQUMzQixNQUFNLElBQUksTUFBTSxDQUFBLDhDQUFBLEVBQWlELE9BQU0sQ0FBQSxDQUFHO2dCQUU5RTtZQUVKLEtBQUs7WUFDTCxLQUFLO2dCQUNELElBQUksQ0FBQyxDQUFBLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxtQkFBQSxNQUFtQixRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLE9BQUEsR0FDM0IsTUFBTSxJQUFJLE1BQU0sQ0FBQSw4Q0FBQSxFQUFpRCxPQUFNLENBQUEsQ0FBRztnQkFFOUU7WUFFSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLENBQUMsQ0FBQSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsbUJBQUEsTUFBbUIsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxTQUFBLEdBQzNCLE1BQU0sSUFBSSxNQUFNLENBQUEsZ0RBQUEsRUFBbUQsT0FBTSxDQUFBLENBQUc7Z0JBR2hGLElBQUksV0FBVyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLFVBQVUsV0FDeEUsTUFBTSxJQUFJLE1BQU0sQ0FBQSw2REFBQSxFQUFnRSxPQUFNLENBQUEsQ0FBRztnQkFHN0Y7WUFFSixLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLENBQUMsQ0FBQSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsbUJBQUEsTUFBbUIsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxLQUFBLEdBQzNCLE1BQU0sSUFBSSxNQUFNLENBQUEsNENBQUEsRUFBK0MsT0FBTSxDQUFBLENBQUc7Z0JBRTVFO1lBRUosS0FBSztnQkFDRCxJQUFJLENBQUMsQ0FBQSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsbUJBQUEsTUFBbUIsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxXQUFBLEdBQzNCLE1BQU0sSUFBSSxNQUFNLENBQUEsa0RBQUEsRUFBcUQsT0FBTSxDQUFBLENBQUc7Z0JBRWxGO1lBRUosS0FBSztnQkFFRDtZQUVKLEtBQUs7Z0JBRUQ7UUFDUjtJQUNKO0lBRVUsNkJBQTZCLE1BQStCLEVBQTVEO1EsSTtRQUNOLE9BQVE7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQyxDQUFBLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxjQUFjLEtBQUEsTUFBSyxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFdBQUEsR0FDM0IsTUFBTSxJQUFJLE1BQU0sQ0FBQSx1RUFBQSxFQUEwRSxPQUFNLENBQUEsQ0FBRztnQkFFdkc7WUFFSixLQUFLO2dCQUVEO1lBRUosS0FBSztnQkFFRDtZQUVKLEtBQUs7Z0JBRUQ7UUFDUjtJQUNKO0lBRVUsK0JBQStCLE1BQWMsRUFBN0M7UUFDTixPQUFRO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsVUFDcEIsTUFBTSxJQUFJLE1BQU0sQ0FBQSwwREFBQSxFQUE2RCxPQUFNLENBQUEsQ0FBRztnQkFFMUY7WUFFSixLQUFLO2dCQUNELElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxhQUNwQixNQUFNLElBQUksTUFBTSxDQUFBLDZEQUFBLEVBQWdFLE9BQU0sQ0FBQSxDQUFHO2dCQUU3RjtZQUVKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLE9BQ3BCLE1BQU0sSUFBSSxNQUFNLENBQUEsdURBQUEsRUFBMEQsT0FBTSxDQUFBLENBQUc7Z0JBRXZGO1lBRUosS0FBSztnQkFFRDtRQUNSO0lBQ0o7SUFFQSxNQUFNLEtBQUssT0FBd0IsRUFBbkM7UUFDSSxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtRQUFNLEdBQUksV0FBQSxtQkFBbUI7SUFDL0Q7SUFFQSxNQUFNLFNBQVMsTUFBaUMsRUFBRSxPQUF3QixFQUExRTtRQUNJLE9BQU8sSUFBSSxDQUFDLFFBQVE7WUFBRSxRQUFRO1lBQXVCO1FBQU0sR0FBSSxXQUFBLHNCQUFzQjtJQUN6RjtJQUVBLE1BQU0sZ0JBQWdCLEtBQW1CLEVBQUUsT0FBd0IsRUFBbkU7UUFDSSxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtZQUFvQixRQUFRO2dCQUFFO1lBQUs7UUFBRSxHQUFJLFdBQUEsbUJBQW1CO0lBQzlGO0lBRUEsTUFBTSxVQUFVLE1BQWtDLEVBQUUsT0FBd0IsRUFBNUU7UUFDSSxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtZQUFlO1FBQU0sR0FBSSxXQUFBLHVCQUF1QjtJQUNsRjtJQUVBLE1BQU0sWUFBWSxNQUFxQyxFQUFFLE9BQXdCLEVBQWpGO1FBQ0ksT0FBTyxJQUFJLENBQUMsUUFBUTtZQUFFLFFBQVE7WUFBZ0I7UUFBTSxHQUFJLFdBQUEseUJBQXlCO0lBQ3JGO0lBRUEsTUFBTSxjQUFjLE1BQXVDLEVBQUUsT0FBd0IsRUFBckY7UUFDSSxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtZQUFrQjtRQUFNLEdBQUksV0FBQSwyQkFBMkI7SUFDekY7SUFFQSxNQUFNLHNCQUFzQixNQUErQyxFQUFFLE9BQXdCLEVBQXJHO1FBQ0ksT0FBTyxJQUFJLENBQUMsUUFBUTtZQUFFLFFBQVE7WUFBNEI7UUFBTSxHQUFJLFdBQUEsbUNBQW1DO0lBQzNHO0lBRUEsTUFBTSxhQUFhLE1BQXFDLEVBQUUsT0FBd0IsRUFBbEY7UUFDSSxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtZQUFrQjtRQUFNLEdBQUksV0FBQSwwQkFBMEI7SUFDeEY7SUFFQSxNQUFNLGtCQUFrQixNQUFrQyxFQUFFLE9BQXdCLEVBQXBGO1FBQ0ksT0FBTyxJQUFJLENBQUMsUUFBUTtZQUFFLFFBQVE7WUFBdUI7UUFBTSxHQUFJLFdBQUEsbUJBQW1CO0lBQ3RGO0lBRUEsTUFBTSxvQkFBb0IsTUFBb0MsRUFBRSxPQUF3QixFQUF4RjtRQUNJLE9BQU8sSUFBSSxDQUFDLFFBQVE7WUFBRSxRQUFRO1lBQXlCO1FBQU0sR0FBSSxXQUFBLG1CQUFtQjtJQUN4RjtJQUVBLE1BQU0sU0FDRixNQUFpQyxFQUNqQyxlQUF1RixXQUFBLG9CQUFvQixFQUMzRyxPQUF3QixFQUg1QjtRQUtJLE1BQU0sU0FBUyxNQUFNLElBQUksQ0FBQyxRQUFRO1lBQUUsUUFBUTtZQUFjO1FBQU0sR0FBSSxjQUFjO1FBRWxGLHdDQUF3QztRQUN4QyxNQUFNLFlBQVksSUFBSSxDQUFDLHVCQUF1QixPQUFPO1FBQ3JELElBQUksV0FBVztZQUNYLG9GQUFvRjtZQUNwRixJQUFJLENBQUMsT0FBTyxxQkFBcUIsQ0FBQyxPQUFPLFNBQ3JDLE1BQU0sSUFBSSxXQUFBLFNBQ04sV0FBQSxVQUFVLGdCQUNWLENBQUEsS0FBQSxFQUFRLE9BQU8sS0FBSSwyREFBQSxDQUE2RDtZQUl4RiwwRUFBMEU7WUFDMUUsSUFBSSxPQUFPLG1CQUNQLElBQUk7Z0JBQ0Esa0ZBQWtGO2dCQUNsRixNQUFNLFVBQVUsVUFBVSxPQUFPO2dCQUVqQyxJQUFJLENBQUMsU0FDRCxNQUFNLElBQUksV0FBQSxTQUNOLFdBQUEsVUFBVSxlQUNWLENBQUEsNERBQUEsRUFBK0QsSUFBSSxDQUFDLEtBQUssV0FBVyxVQUFVLFFBQU8sQ0FBRTtZQUduSCxFQUFFLE9BQU8sT0FBTztnQkFDWixJQUFJLGlCQUFpQixXQUFBLFVBQ2pCLE1BQU07Z0JBRVYsTUFBTSxJQUFJLFdBQUEsU0FDTixXQUFBLFVBQVUsZUFDVixDQUFBLHVDQUFBLEVBQTBDLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxPQUFPLE9BQU0sQ0FBRTtZQUUxRztRQUVSO1FBRUEsT0FBTztJQUNYO0lBRVEsdUJBQXVCLEtBQWEsRUFBcEM7UUFDSixJQUFJLENBQUMsNEJBQTRCO1FBRWpDLEtBQUssTUFBTSxRQUFRLE1BQU87WUFDdEIsc0VBQXNFO1lBQ3RFLElBQUksS0FBSyxjQUNMLElBQUk7Z0JBQ0EsTUFBTSxZQUFZLElBQUksQ0FBQyxLQUFLLFFBQVEsS0FBSztnQkFDekMsSUFBSSxDQUFDLDRCQUE0QixJQUFJLEtBQUssTUFBTTtZQUNwRCxFQUFFLE9BQUEsSUFBTTtZQUNKLG1DQUFtQztZQUN2QztRQUVSO0lBQ0o7SUFFUSx1QkFBdUIsUUFBZ0IsRUFBdkM7UUFDSixPQUFPLElBQUksQ0FBQyw0QkFBNEIsSUFBSTtJQUNoRDtJQUVBLE1BQU0sVUFBVSxNQUFtQyxFQUFFLE9BQXdCLEVBQTdFO1FBQ0ksTUFBTSxTQUFTLE1BQU0sSUFBSSxDQUFDLFFBQVE7WUFBRSxRQUFRO1lBQWM7UUFBTSxHQUFJLFdBQUEsdUJBQXVCO1FBRTNGLGlFQUFpRTtRQUNqRSxJQUFJLENBQUMsdUJBQXVCLE9BQU87UUFFbkMsT0FBTztJQUNYO0lBRUEsTUFBTSx1QkFBTjtRQUNJLE9BQU8sSUFBSSxDQUFDLGFBQWE7WUFBRSxRQUFRO1FBQWtDO0lBQ3pFO0FBQ0g7QUExVUQsUUFBQSxTQUFBOzs7QTtBLE8sZSxTLGM7SSxPO0E7QSxRLFcsUSwrQixLO0FFNG1CQSxRQUFBLG9CQUFBO0FBdHJCQSxNQUFBLGFBQUEsUUFBQTtBQXVEQTs7Q0FFRyxHQUNVLFFBQUEsK0JBQStCO0FBOEc1Qzs7O0NBR0csR0FDSCxNQUFzQjtJQXNDbEIsWUFBb0IsUUFBMEIsQ0FBOUM7UUFBb0IsSUFBQSxDQUFBLFdBQUE7UUFwQ1osSUFBQSxDQUFBLG9CQUFvQjtRQUNwQixJQUFBLENBQUEsbUJBR0osSUFBSTtRQUNBLElBQUEsQ0FBQSxrQ0FBbUUsSUFBSTtRQUN2RSxJQUFBLENBQUEsd0JBQTJGLElBQUk7UUFDL0YsSUFBQSxDQUFBLG9CQUE4RSxJQUFJO1FBQ2xGLElBQUEsQ0FBQSxvQkFBbUQsSUFBSTtRQUN2RCxJQUFBLENBQUEsZUFBeUMsSUFBSTtRQUM3QyxJQUFBLENBQUEsaUNBQWlDLElBQUk7UUEyQnpDLElBQUksQ0FBQyx1QkFBdUIsV0FBQSw2QkFBNkIsQ0FBQTtZQUNyRCxNQUFNLGFBQWEsSUFBSSxDQUFDLGdDQUFnQyxJQUFJLGFBQWEsT0FBTztZQUNoRixlQUFVLFFBQVYsZUFBVSxLQUFBLEtBQVYsV0FBWSxNQUFNLGFBQWEsT0FBTztRQUMxQztRQUVBLElBQUksQ0FBQyx1QkFBdUIsV0FBQSw0QkFBNEIsQ0FBQTtZQUNwRCxJQUFJLENBQUMsWUFBWTtRQUNyQjtRQUVBLElBQUksQ0FBQyxrQkFDRCxXQUFBLG1CQUNBLDZCQUE2QjtRQUM3QixDQUFBLFdBQWEsQ0FBQSxDQUFBLENBQUE7SUFFckI7SUFFUSxjQUNKLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixlQUFtQyxFQUNuQyxTQUFxQixFQUNyQix5QkFBa0MsS0FBSyxFQUxuQztRQU9KLElBQUksQ0FBQyxhQUFhLElBQUksV0FBVztZQUM3QixXQUFXLFdBQVcsV0FBVztZQUNqQyxXQUFXLEtBQUs7WUFDaEI7WUFDQTtZQUNBO1lBQ0E7UUFDSDtJQUNMO0lBRVEsY0FBYyxTQUFpQixFQUEvQjtRQUNKLE1BQU0sT0FBTyxJQUFJLENBQUMsYUFBYSxJQUFJO1FBQ25DLElBQUksQ0FBQyxNQUFNLE9BQU87UUFFbEIsTUFBTSxlQUFlLEtBQUssUUFBUSxLQUFLO1FBQ3ZDLElBQUksS0FBSyxtQkFBbUIsZ0JBQWdCLEtBQUssaUJBQWlCO1lBQzlELElBQUksQ0FBQyxhQUFhLE9BQU87WUFDekIsTUFBTSxJQUFJLFdBQUEsU0FBUyxXQUFBLFVBQVUsZ0JBQWdCLGtDQUFrQztnQkFDM0UsaUJBQWlCLEtBQUs7Z0JBQ3RCO1lBQ0g7UUFDTDtRQUVBLGFBQWEsS0FBSztRQUNsQixLQUFLLFlBQVksV0FBVyxLQUFLLFdBQVcsS0FBSztRQUNqRCxPQUFPO0lBQ1g7SUFFUSxnQkFBZ0IsU0FBaUIsRUFBakM7UUFDSixNQUFNLE9BQU8sSUFBSSxDQUFDLGFBQWEsSUFBSTtRQUNuQyxJQUFJLE1BQU07WUFDTixhQUFhLEtBQUs7WUFDbEIsSUFBSSxDQUFDLGFBQWEsT0FBTztRQUM3QjtJQUNKO0lBRUE7Ozs7S0FJRyxHQUNILE1BQU0sUUFBUSxTQUFvQixFQUFsQztRLEksSSxJO1FBQ0ksSUFBSSxDQUFDLGFBQWE7UUFDbEIsTUFBTSxXQUFXLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxTQUFBLE1BQVMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtRQUNqQyxJQUFJLENBQUMsV0FBVyxVQUFVO1lBQ3RCLGFBQVEsUUFBUixhQUFRLEtBQUEsS0FBUjtZQUNBLElBQUksQ0FBQztRQUNUO1FBRUEsTUFBTSxXQUFXLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxTQUFBLE1BQVMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRTtRQUNqQyxJQUFJLENBQUMsV0FBVyxVQUFVLENBQUM7WUFDdkIsYUFBUSxRQUFSLGFBQVEsS0FBQSxLQUFSLFNBQVc7WUFDWCxJQUFJLENBQUMsU0FBUztRQUNsQjtRQUVBLE1BQU0sYUFBYSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsVUFBQSxNQUFVLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7UUFDcEMsSUFBSSxDQUFDLFdBQVcsWUFBWSxDQUFDLFNBQVM7WUFDbEMsZUFBVSxRQUFWLGVBQVUsS0FBQSxLQUFWLFdBQWEsU0FBUztZQUN0QixJQUFJLEFBQUEsQ0FBQSxHQUFBLFdBQUEsaUJBQUEsRUFBa0IsWUFBWSxBQUFBLENBQUEsR0FBQSxXQUFBLGNBQUEsRUFBZSxVQUM3QyxJQUFJLENBQUMsWUFBWTtpQkFDZCxJQUFJLEFBQUEsQ0FBQSxHQUFBLFdBQUEsZ0JBQUEsRUFBaUIsVUFDeEIsSUFBSSxDQUFDLFdBQVcsU0FBUztpQkFDdEIsSUFBSSxBQUFBLENBQUEsR0FBQSxXQUFBLHFCQUFBLEVBQXNCLFVBQzdCLElBQUksQ0FBQyxnQkFBZ0I7aUJBRXJCLElBQUksQ0FBQyxTQUFTLElBQUksTUFBTSxDQUFBLHNCQUFBLEVBQXlCLEtBQUssVUFBVSxTQUFRLENBQUU7UUFFbEY7UUFFQSxNQUFNLElBQUksQ0FBQyxXQUFXO0lBQzFCO0lBRVEsV0FBQTtRLEk7UUFDSixNQUFNLG1CQUFtQixJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDLG9CQUFvQixJQUFJO1FBQzdCLElBQUksQ0FBQyxrQkFBa0I7UUFDdkIsSUFBSSxDQUFDLCtCQUErQjtRQUNwQyxJQUFJLENBQUMsYUFBYTtRQUNsQixDQUFBLEtBQUEsSUFBSSxDQUFDLE9BQUEsTUFBTyxRQUFBLE9BQUEsS0FBQSxLQUFBLEdBQUEsS0FBQSxJQUFBO1FBRVosTUFBTSxRQUFRLElBQUksV0FBQSxTQUFTLFdBQUEsVUFBVSxrQkFBa0I7UUFDdkQsS0FBSyxNQUFNLFdBQVcsaUJBQWlCLFNBQ25DLFFBQVE7SUFFaEI7SUFFUSxTQUFTLEtBQVksRUFBckI7USxJO1FBQ0osQ0FBQSxLQUFBLElBQUksQ0FBQyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsS0FBQSxHQUFBLEtBQUEsSUFBQSxFQUFHO0lBQ25CO0lBRVEsZ0JBQWdCLFlBQWlDLEVBQWpEO1EsSTtRQUNKLE1BQU0sVUFBVSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsc0JBQXNCLElBQUksYUFBYSxPQUFNLE1BQUMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLElBQUksQ0FBQztRQUU1RSxnREFBZ0Q7UUFDaEQsSUFBSSxZQUFZLFdBQ1o7UUFHSixzRkFBc0Y7UUFDdEYsUUFBUSxVQUNILEtBQUssSUFBTSxRQUFRLGVBQ25CLE1BQU0sQ0FBQSxRQUFTLElBQUksQ0FBQyxTQUFTLElBQUksTUFBTSxDQUFBLHdDQUFBLEVBQTJDLE1BQUssQ0FBRTtJQUNsRztJQUVRLFdBQVcsT0FBdUIsRUFBRSxLQUF3QixFQUE1RDtRLEksSTtRQUNKLE1BQU0sVUFBVSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsaUJBQWlCLElBQUksUUFBUSxPQUFNLE1BQUMsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLElBQUksQ0FBQztRQUVsRSw2RkFBNkY7UUFDN0YsTUFBTSxvQkFBb0IsSUFBSSxDQUFDO1FBRS9CLElBQUksWUFBWSxXQUFXO1lBQ3ZCLHNCQUFpQixRQUFqQixzQkFBaUIsS0FBQSxLQUFqQixrQkFDTSxLQUFLO2dCQUNILFNBQVM7Z0JBQ1QsSUFBSSxRQUFRO2dCQUNaLE9BQU87b0JBQ0gsTUFBTSxXQUFBLFVBQVU7b0JBQ2hCLFNBQVM7Z0JBQ1o7WUFDSixHQUNBLE1BQU0sQ0FBQSxRQUFTLElBQUksQ0FBQyxTQUFTLElBQUksTUFBTSxDQUFBLGtDQUFBLEVBQXFDLE1BQUssQ0FBRTtZQUN4RjtRQUNKO1FBRUEsTUFBTSxrQkFBa0IsSUFBSTtRQUM1QixJQUFJLENBQUMsZ0NBQWdDLElBQUksUUFBUSxJQUFJO1FBRXJELE1BQU0sWUFBa0U7WUFDcEUsUUFBUSxnQkFBZ0I7WUFDeEIsV0FBVyxzQkFBaUIsUUFBakIsc0JBQWlCLEtBQUEsSUFBQSxLQUFBLElBQWpCLGtCQUFtQjtZQUM5QixPQUFPLEFBQUEsQ0FBQSxLQUFBLFFBQVEsTUFBQSxNQUFNLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUU7WUFDdkIsa0JBQWtCLENBQUEsZUFBZ0IsSUFBSSxDQUFDLGFBQWEsY0FBYztvQkFBRSxrQkFBa0IsUUFBUTtnQkFBRTtZQUNoRyxhQUFhLENBQUMsR0FBRyxjQUFjLFVBQWEsSUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFjO29CQUFFLEdBQUcsT0FBTztvQkFBRSxrQkFBa0IsUUFBUTtnQkFBRTtZQUNwSCxVQUFVLFVBQUssUUFBTCxVQUFLLEtBQUEsSUFBQSxLQUFBLElBQUwsTUFBTztZQUNqQixXQUFXLFFBQVE7WUFDbkIsYUFBYSxVQUFLLFFBQUwsVUFBSyxLQUFBLElBQUEsS0FBQSxJQUFMLE1BQU87UUFDdkI7UUFFRCxzRkFBc0Y7UUFDdEYsUUFBUSxVQUNILEtBQUssSUFBTSxRQUFRLFNBQVMsWUFDNUIsS0FDRyxDQUFBO1lBQ0ksSUFBSSxnQkFBZ0IsT0FBTyxTQUN2QjtZQUdKLE9BQU8sc0JBQWlCLFFBQWpCLHNCQUFpQixLQUFBLElBQUEsS0FBQSxJQUFqQixrQkFBbUIsS0FBSztnQkFDM0I7Z0JBQ0EsU0FBUztnQkFDVCxJQUFJLFFBQVE7WUFDZjtRQUNMLEdBQ0EsQ0FBQTtZLEk7WUFDSSxJQUFJLGdCQUFnQixPQUFPLFNBQ3ZCO1lBR0osT0FBTyxzQkFBaUIsUUFBakIsc0JBQWlCLEtBQUEsSUFBQSxLQUFBLElBQWpCLGtCQUFtQixLQUFLO2dCQUMzQixTQUFTO2dCQUNULElBQUksUUFBUTtnQkFDWixPQUFPO29CQUNILE1BQU0sT0FBTyxjQUFjLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sR0FBRyxXQUFBLFVBQVU7b0JBQ3RFLFNBQVMsQUFBQSxDQUFBLEtBQUEsTUFBTSxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO2dCQUM3QjtZQUNKO1FBQ0wsR0FFSCxNQUFNLENBQUEsUUFBUyxJQUFJLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQSx5QkFBQSxFQUE0QixNQUFLLENBQUUsSUFDMUUsUUFBUTtZQUNMLElBQUksQ0FBQyxnQ0FBZ0MsT0FBTyxRQUFRO1FBQ3hEO0lBQ1I7SUFFUSxZQUFZLFlBQWtDLEVBQTlDO1FBQ0osTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLFFBQVEsR0FBRyxhQUFhO1FBQ2xELE1BQU0sWUFBWSxPQUFPO1FBRXpCLE1BQU0sVUFBVSxJQUFJLENBQUMsa0JBQWtCLElBQUk7UUFDM0MsSUFBSSxDQUFDLFNBQVM7WUFDVixJQUFJLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQSx1REFBQSxFQUEwRCxLQUFLLFVBQVUsY0FBYSxDQUFFO1lBQ2hIO1FBQ0o7UUFFQSxNQUFNLGtCQUFrQixJQUFJLENBQUMsa0JBQWtCLElBQUk7UUFDbkQsTUFBTSxjQUFjLElBQUksQ0FBQyxhQUFhLElBQUk7UUFFMUMsSUFBSSxlQUFlLG1CQUFtQixZQUFZLHdCQUM5QyxJQUFJO1lBQ0EsSUFBSSxDQUFDLGNBQWM7UUFDdkIsRUFBRSxPQUFPLE9BQU87WUFDWixnQkFBZ0I7WUFDaEI7UUFDSjtRQUdKLFFBQVE7SUFDWjtJQUVRLFlBQVksUUFBd0MsRUFBcEQ7UUFDSixNQUFNLFlBQVksT0FBTyxTQUFTO1FBQ2xDLE1BQU0sVUFBVSxJQUFJLENBQUMsa0JBQWtCLElBQUk7UUFDM0MsSUFBSSxZQUFZLFdBQVc7WUFDdkIsSUFBSSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUEsK0NBQUEsRUFBa0QsS0FBSyxVQUFVLFVBQVMsQ0FBRTtZQUNwRztRQUNKO1FBRUEsSUFBSSxDQUFDLGtCQUFrQixPQUFPO1FBQzlCLElBQUksQ0FBQyxrQkFBa0IsT0FBTztRQUM5QixJQUFJLENBQUMsZ0JBQWdCO1FBRXJCLElBQUksQUFBQSxDQUFBLEdBQUEsV0FBQSxpQkFBQSxFQUFrQixXQUNsQixRQUFRO2FBQ0w7WUFDSCxNQUFNLFFBQVEsSUFBSSxXQUFBLFNBQVMsU0FBUyxNQUFNLE1BQU0sU0FBUyxNQUFNLFNBQVMsU0FBUyxNQUFNO1lBQ3ZGLFFBQVE7UUFDWjtJQUNKO0lBRUEsSUFBSSxZQUFKO1FBQ0ksT0FBTyxJQUFJLENBQUM7SUFDaEI7SUFFQTs7S0FFRyxHQUNILE1BQU0sUUFBTjtRLEk7UUFDSSxNQUFNLENBQUEsQUFBQSxDQUFBLEtBQUEsSUFBSSxDQUFDLFVBQUEsTUFBVSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLE9BQUs7SUFDaEM7SUF1QkE7Ozs7S0FJRyxHQUNILFFBQW1DLE9BQXFCLEVBQUUsWUFBZSxFQUFFLE9BQXdCLEVBQW5HO1FBQ0ksTUFBTSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxHQUFHLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBUCxVQUFXLENBQUE7UUFFNUUsT0FBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTO1ksSSxJLEksSSxJLEk7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZO2dCQUNsQixPQUFPLElBQUksTUFBTTtnQkFDakI7WUFDSjtZQUVBLElBQUksQUFBQSxDQUFBLEFBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQyxRQUFBLE1BQVEsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSx5QkFBQSxNQUE4QixNQUM3QyxJQUFJLENBQUMsMEJBQTBCLFFBQVE7WUFHM0MsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxNQUFBLE1BQU0sUUFBQSxPQUFBLEtBQUEsS0FBQSxHQUFFO1lBRWpCLE1BQU0sWUFBWSxJQUFJLENBQUM7WUFDdkIsTUFBTSxpQkFBaUM7Z0JBQ25DLEdBQUcsT0FBTztnQkFDVixTQUFTO2dCQUNULElBQUk7WUFDUDtZQUVELElBQUksWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLFlBQVk7Z0JBQ3JCLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxXQUFXLFFBQVE7Z0JBQzlDLGVBQWUsU0FBUztvQkFDcEIsR0FBRyxRQUFRLE1BQU07b0JBQ2pCLE9BQU87d0JBQ0gsR0FBSSxBQUFBLENBQUEsQUFBQSxDQUFBLEtBQUEsUUFBUSxNQUFBLE1BQU0sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsR0FBRSxLQUFBLEtBQVMsQ0FBQSxDQUFFO3dCQUMvQixlQUFlO29CQUNsQjtnQkFDSjtZQUNMO1lBRUEsTUFBTSxTQUFTLENBQUM7Z0IsSTtnQkFDWixJQUFJLENBQUMsa0JBQWtCLE9BQU87Z0JBQzlCLElBQUksQ0FBQyxrQkFBa0IsT0FBTztnQkFDOUIsSUFBSSxDQUFDLGdCQUFnQjtnQkFFckIsQ0FBQSxLQUFBLElBQUksQ0FBQyxVQUFBLE1BQVUsUUFBQSxPQUFBLEtBQUEsS0FBQSxHQUNULEtBQ0U7b0JBQ0ksU0FBUztvQkFDVCxRQUFRO29CQUNSLFFBQVE7d0JBQ0osV0FBVzt3QkFDWCxRQUFRLE9BQU87b0JBQ2xCO2dCQUNKLEdBQ0Q7b0JBQUU7b0JBQWtCO29CQUFpQjtnQkFBaUIsR0FFekQsTUFBTSxDQUFBLFFBQVMsSUFBSSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUEsNkJBQUEsRUFBZ0MsTUFBSyxDQUFFO2dCQUVuRixPQUFPO1lBQ1g7WUFFQSxJQUFJLENBQUMsa0JBQWtCLElBQUksV0FBVyxDQUFBO2dCLEk7Z0JBQ2xDLElBQUksQUFBQSxDQUFBLEtBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLE1BQUEsTUFBTSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFLFNBQ2pCO2dCQUdKLElBQUksb0JBQW9CLE9BQ3BCLE9BQU8sT0FBTztnQkFHbEIsSUFBSTtvQkFDQSxNQUFNLFNBQVMsYUFBYSxNQUFNLFNBQVM7b0JBQzNDLFFBQVE7Z0JBQ1osRUFBRSxPQUFPLE9BQU87b0JBQ1osT0FBTztnQkFDWDtZQUNKO1lBRUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxNQUFBLE1BQU0sUUFBQSxPQUFBLEtBQUEsS0FBQSxHQUFFLGlCQUFpQixTQUFTO2dCLEk7Z0JBQ3ZDLE9BQU8sQUFBQSxDQUFBLEtBQUEsWUFBTyxRQUFQLFlBQU8sS0FBQSxJQUFBLEtBQUEsSUFBUCxRQUFTLE1BQUEsTUFBTSxRQUFBLE9BQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxHQUFFO1lBQzVCO1lBRUEsTUFBTSxVQUFVLEFBQUEsQ0FBQSxLQUFBLFlBQU8sUUFBUCxZQUFPLEtBQUEsSUFBQSxLQUFBLElBQVAsUUFBUyxPQUFBLE1BQU8sUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLFFBQUE7WUFDcEMsTUFBTSxpQkFBaUIsSUFBTSxPQUFPLElBQUksV0FBQSxTQUFTLFdBQUEsVUFBVSxnQkFBZ0IscUJBQXFCO29CQUFFO2dCQUFPO1lBRXpHLElBQUksQ0FBQyxjQUFjLFdBQVcsU0FBUyxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsaUJBQWlCLGdCQUFnQixBQUFBLENBQUEsS0FBQSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsc0JBQUEsTUFBc0IsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJO1lBRXBILElBQUksQ0FBQyxXQUFXLEtBQUssZ0JBQWdCO2dCQUFFO2dCQUFrQjtnQkFBaUI7WUFBaUIsR0FBSSxNQUFNLENBQUE7Z0JBQ2pHLElBQUksQ0FBQyxnQkFBZ0I7Z0JBQ3JCLE9BQU87WUFDWDtRQUNKO0lBQ0o7SUFFQTs7S0FFRyxHQUNILE1BQU0sYUFBYSxZQUErQixFQUFFLE9BQTZCLEVBQWpGO1EsSSxJO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUNOLE1BQU0sSUFBSSxNQUFNO1FBR3BCLElBQUksQ0FBQyw2QkFBNkIsYUFBYTtRQUUvQyxNQUFNLG1CQUFtQixBQUFBLENBQUEsS0FBQSxBQUFBLENBQUEsS0FBQSxJQUFJLENBQUMsUUFBQSxNQUFRLFFBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxJQUFBLEdBQUUsNEJBQUEsTUFBNEIsUUFBQSxPQUFBLEtBQUEsSUFBQSxLQUFJLEVBQUU7UUFDMUUsNkVBQTZFO1FBQzdFLDBFQUEwRTtRQUMxRSxNQUFNLGNBQWMsaUJBQWlCLFNBQVMsYUFBYSxXQUFXLENBQUMsYUFBYSxVQUFVLENBQUMsQ0FBQSxZQUFPLFFBQVAsWUFBTyxLQUFBLElBQUEsS0FBQSxJQUFQLFFBQVMsZ0JBQUE7UUFFeEcsSUFBSSxhQUFhO1lBQ2IsbUVBQW1FO1lBQ25FLElBQUksSUFBSSxDQUFDLCtCQUErQixJQUFJLGFBQWEsU0FDckQ7WUFHSiwwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDLCtCQUErQixJQUFJLGFBQWE7WUFFckQsNERBQTREO1lBQzVELG9GQUFvRjtZQUNwRixRQUFRLFVBQVUsS0FBSztnQixJO2dCQUNuQiw2REFBNkQ7Z0JBQzdELElBQUksQ0FBQywrQkFBK0IsT0FBTyxhQUFhO2dCQUV4RCw0RUFBNEU7Z0JBQzVFLElBQUksQ0FBQyxJQUFJLENBQUMsWUFDTjtnQkFHSixNQUFNLHNCQUEyQztvQkFDN0MsR0FBRyxZQUFZO29CQUNmLFNBQVM7Z0JBQ1o7Z0JBQ0Qsb0VBQW9FO2dCQUNwRSwyQ0FBMkM7Z0JBQzNDLENBQUEsS0FBQSxJQUFJLENBQUMsVUFBQSxNQUFVLFFBQUEsT0FBQSxLQUFBLEtBQUEsR0FBRSxLQUFLLHFCQUFxQixTQUFTLE1BQU0sQ0FBQSxRQUFTLElBQUksQ0FBQyxTQUFTO1lBQ3JGO1lBRUEsc0JBQXNCO1lBQ3RCO1FBQ0o7UUFFQSxNQUFNLHNCQUEyQztZQUM3QyxHQUFHLFlBQVk7WUFDZixTQUFTO1FBQ1o7UUFFRCxNQUFNLElBQUksQ0FBQyxXQUFXLEtBQUsscUJBQXFCO0lBQ3BEO0lBRUE7Ozs7S0FJRyxHQUNILGtCQUtJLGFBQWdCLEVBQ2hCLE9BQWlJLEVBTnJJO1FBUUksTUFBTSxTQUFTLGNBQWMsTUFBTSxPQUFPO1FBQzFDLElBQUksQ0FBQywrQkFBK0I7UUFFcEMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLFFBQVEsQ0FBQyxTQUFTO1lBQ3hDLE9BQU8sUUFBUSxRQUFRLFFBQVEsY0FBYyxNQUFNLFVBQVU7UUFDakU7SUFDSjtJQUVBOztLQUVHLEdBQ0gscUJBQXFCLE1BQWMsRUFBbkM7UUFDSSxJQUFJLENBQUMsaUJBQWlCLE9BQU87SUFDakM7SUFFQTs7S0FFRyxHQUNILDJCQUEyQixNQUFjLEVBQXpDO1FBQ0ksSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUksU0FDMUIsTUFBTSxJQUFJLE1BQU0sQ0FBQSxzQkFBQSxFQUF5QixPQUFNLDBDQUFBLENBQTRDO0lBRW5HO0lBRUE7Ozs7S0FJRyxHQUNILHVCQUlFLGtCQUFxQixFQUFFLE9BQTJELEVBSnBGO1FBS0ksSUFBSSxDQUFDLHNCQUFzQixJQUFJLG1CQUFtQixNQUFNLE9BQU8sT0FBTyxDQUFBLGVBQ2xFLFFBQVEsUUFBUSxRQUFRLG1CQUFtQixNQUFNO0lBRXpEO0lBRUE7O0tBRUcsR0FDSCwwQkFBMEIsTUFBYyxFQUF4QztRQUNJLElBQUksQ0FBQyxzQkFBc0IsT0FBTztJQUN0QztBQUNIO0FBeGdCRCxRQUFBLFdBQUE7QUEwZ0JBLFNBQWdCLGtCQUFxRSxJQUFPLEVBQUUsVUFBYTtJQUN2RyxPQUFPLE9BQU8sUUFBUSxZQUFZLE9BQzlCLENBQUMsS0FBSyxDQUFDLEtBQUssTUFBTTtRQUNkLElBQUksU0FBUyxPQUFPLFVBQVUsVUFDMUIsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHO1lBQUUsR0FBRyxHQUFHLENBQUMsSUFBSTtZQUFFLEdBQUcsS0FBSztRQUFBLElBQUs7YUFFbEQsR0FBRyxDQUFDLElBQUksR0FBRztRQUVmLE9BQU87SUFDWCxHQUNBO1FBQUUsR0FBRyxJQUFJO0lBQUE7QUFFakI7OztBO0EsTyxlLFMsYztJLE87QTtBLFEsd0MsUSwyQixRLDRCLFEsb0MsUSxxQyxRLDRCLFEsNkIsUSx5QixRLGlCLFEsNkIsUSw2QixRLHlCLFEsd0IsUSx5QixRLDZCLFEsaUIsUSxvQixRLDRCLFEsZ0MsUSx5QixRLDJCLFEsc0IsUSwwQixRLDJCLFEsdUIsUSxxQixRLGMsUSxhLFEsOEIsUSxvQixRLHVCLFEsaUIsUSxxQixRLFksUSxvQixRLHdCLFEsd0IsUSw0QixRLG1CLFEsdUIsUSxrQixRLGUsUSxxQixRLGdCLFEsZSxRLHNCLFEsa0IsUSw4QixRLHNDLFEsMEIsSztBLFEsc0IsUSxxQyxRLHdCLFEseUIsUSxhLFEsdUIsUSx3QixRLHdCLFEsMEIsUSxrQyxRLHFCLFEsc0IsUSxrQyxRLG1CLFEscUIsUSxxQixRLHNCLFEsNEIsUSw2QixRLHdCLFEseUIsUSxrQixRLG1DLFEsd0IsUSxxQixRLG9DLFEsd0IsUSxvQyxRLHVCLFEsd0IsUSx5QixRLGEsUSx3QixRLHNDLFEsd0IsUSxzQixRLHFCLFEscUIsUSx5QixRLHFCLFEscUIsUSxvQixRLHlCLFEsMEIsUSwyQixRLGUsUSx1QixRLG9DLFEsMkIsUSx5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LFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsU0FBUyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxVQUFVLFNBQVM7WUFDbkIsR0FBRyxDQUFBLEdBQUEsc0JBQVEsRUFBRSxTQUFTLFNBQVMsUUFBUTtRQUMzQztJQUNKO0lBQ0EsV0FBVyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsU0FBUyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsSUFBSSxTQUFTLEVBQUUsT0FBTyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsSUFBSSxTQUFTLEVBQUUsT0FBTyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsT0FBTyxHQUFHLEVBQUUsT0FBTyxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTLE9BQU8sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFBLEdBQUEsc0JBQVEsRUFBRSxT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Y3NMLGVBQWU7WUFDeEQsbUJBQUEsSUFBSXhMLE9BQU9DLE1BQU0sZ0JBQWdCQyxjQUFjc0wsZUFBZTtZQUN0RSxXQUFBLElBQUl4TCxPQUFPQyxNQUFNLFVBQVVDLGNBQWNzTCxjQUFjLGtCQUFrQkMsYUFBYTtZQUNuRixjQUFBLElBQUl6TCxPQUFPQyxNQUFNLFVBQVVDLGNBQWNzTCxjQUFjLG1CQUFtQjtZQUNoRixRQUFBLElBQUl4TCxPQUFPQyxNQUFNLE9BQU9DLGNBQWNzTCxlQUFlO1lBQ2pELFlBQUEsSUFBSXhMLE9BQU9FLGNBQWM7WUFDeEIsYUFBQSxJQUFJRixPQUFPQyxNQUFNLFVBQVVDLGNBQWNxTCxhQUFhO1lBQ3RELGFBQUEsSUFBSXZMLE9BQU9NLGNBQWM7WUFDekIsYUFBQSxJQUFJTixPQUFPLE9BQU9zTCxlQUFlO1lBQ2pDLGFBQUEsSUFBSXRMLE9BQU8sV0FBV29MLGVBQWUsTUFBTTVLLE9BQU9BLE9BQU8saUJBQWlCQyxXQUFXLFVBQVUsTUFBTTRLLFVBQVUsT0FBTyxVQUF0SCxzQ0FBQTtRQWJmO0k7SUFpQkQsSUFBQSxlQUFlRixVQUFVO0lEckZ6QixJQUFBLGVBQWVBLFVBQVU7SSxJLGdCO1EsUyxjLEcsRSxDO1ksSSxPLEU7WSxJLEs7WSxJLEs7WSxJLEs7WSxJO2dCLEksSSxLLEcsQyxPLFMsSSxJLEMsQyxLLEEsQyxLLEcsTSxFLEksRyxLLEs7b0IsSyxLLEc7b0IsSSxLLEssVyxHO2dCO1ksRSxPLEs7Z0IsSztnQixLO1ksUztnQixJO29CLEksQyxNLEUsQyxTLEUsRSxDLFM7Z0IsUztvQixJLEksTTtnQjtZO1ksTztRO1EsTyxTLEcsRSxDO1ksSSxNLFEsTSxPO2lCLEksTyxZLE8sTSxPLGMsSztpQixNLEksVTtRO0k7SSxJLG9CLFMsRztRLEksTSxRLE07WSxJLEksSSxHLE8sTSxJLFMsSSxJLFEsSSxJLEMsRSxHLEcsQyxFO1ksTztRLE8sTyxNLEs7STtJRER6QiwrQ0FBQSxHQUNBLElBQU1wQyxTQUFTLFlBQWYsNEJBQUE7SSwwQixHQUdBLElBQU16RyxPQUFP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TSxPQUFPLENBQUMsRUFBRSxDQUFBLEdBQUEsd0JBQVksRUFBRSxtQkFBbUIsT0FBTyxDQUFDO0FBQ2xGOzs7QUMzU0EsSUFBSSxLQUFHLE9BQU87QUFBTyxJQUFJLElBQUUsT0FBTztBQUFlLElBQUksS0FBRyxPQUFPO0FBQXlCLElBQUksS0FBRyxPQUFPO0FBQW9CLElBQUksS0FBRyxPQUFPLGdCQUFlLEtBQUcsT0FBTyxVQUFVO0FBQWUsSUFBSSxJQUFFLENBQUMsR0FBRSxJQUFJLElBQUssQ0FBQSxLQUFHLEVBQUUsQUFBQyxDQUFBLElBQUU7WUFBQyxTQUFRLENBQUM7UUFBQyxDQUFBLEVBQUcsU0FBUSxJQUFHLEVBQUUsT0FBTSxHQUFHLEtBQUcsQ0FBQyxHQUFFO0lBQUssSUFBSSxJQUFJLEtBQUssRUFBRSxFQUFFLEdBQUUsR0FBRTtRQUFDLEtBQUksQ0FBQyxDQUFDLEVBQUU7UUFBQyxZQUFXLENBQUM7SUFBQztBQUFFLEdBQUUsSUFBRSxDQUFDLEdBQUUsR0FBRSxHQUFFO0lBQUssSUFBRyxLQUFHLE9BQU8sS0FBRyxZQUFVLE9BQU8sS0FBRyxZQUFXLEtBQUksSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFFLE1BQUksTUFBSSxLQUFHLEVBQUUsR0FBRSxHQUFFO1FBQUMsS0FBSSxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQUMsWUFBVyxDQUFFLENBQUEsSUFBRSxHQUFHLEdBQUUsRUFBQyxLQUFJLEVBQUU7SUFBVTtJQUFHLE9BQU87QUFBQyxHQUFFLElBQUUsQ0FBQyxHQUFFLEdBQUUsSUFBSyxDQUFBLEVBQUUsR0FBRSxHQUFFLFlBQVcsS0FBRyxFQUFFLEdBQUUsR0FBRSxVQUFTLEdBQUcsSUFBRSxDQUFDLEdBQUUsR0FBRSxJQUFLLENBQUEsSUFBRSxLQUFHLE9BQUssR0FBRyxHQUFHLE1BQUksQ0FBQyxHQUFFLEVBQUUsS0FBRyxDQUFDLEtBQUcsQ0FBQyxFQUFFLGFBQVcsRUFBRSxHQUFFLFdBQVU7UUFBQyxPQUFNO1FBQUUsWUFBVyxDQUFDO0lBQUMsS0FBRyxHQUFFLEVBQUMsR0FBRyxLQUFHLENBQUEsSUFBRyxFQUFFLEVBQUUsQ0FBQyxHQUFFLGNBQWE7UUFBQyxPQUFNLENBQUM7SUFBQyxJQUFHO0FBQUcsSUFBSSxJQUFFLEVBQUUsQ0FBQTtJQUFJO0lBQWEsRUFBRSxhQUFXO0lBQUcsRUFBRSxjQUFZO0lBQUcsRUFBRSxnQkFBYztJQUFHLElBQUksSUFBRSxFQUFFLEVBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxPQUFPLGFBQVcsTUFBSSxhQUFXLE9BQU0sSUFBRTtJQUFtRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxJQUFFLEdBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsR0FBQztJQUFFLElBQUksR0FBRTtJQUFFLENBQUMsQ0FBQyxJQUFJLFdBQVcsR0FBRyxHQUFDO0lBQUcsQ0FBQyxDQUFDLElBQUksV0FBVyxHQUFHLEdBQUM7SUFBRyxTQUFTLEVBQUUsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxJQUFFLElBQUUsR0FBRSxNQUFNLElBQUksTUFBTTtRQUFrRCxJQUFJLElBQUUsRUFBRSxRQUFRO1FBQUssTUFBSSxNQUFLLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLE1BQUksSUFBRSxJQUFFLElBQUUsSUFBRTtRQUFFLE9BQU07WUFBQztZQUFFO1NBQUU7SUFBQTtJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFFLEVBQUUsSUFBRyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLEdBQUUsSUFBRSxFQUFFLElBQUcsSUFBRSxDQUFDLENBQUMsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksR0FBRyxHQUFHLEdBQUUsR0FBRSxLQUFJLElBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUUsR0FBRTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsRUFBQyxDQUFDLENBQUMsSUFBSSxHQUFDLEtBQUcsS0FBRyxLQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUMsS0FBRyxJQUFFLEtBQUksQ0FBQyxDQUFDLElBQUksR0FBQyxJQUFFO1FBQUksT0FBTyxNQUFJLEtBQUksQ0FBQSxJQUFFLENBQUMsQ0FBQyxFQUFFLFdBQVcsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsSUFBRSxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsSUFBRSxHQUFFLEdBQUcsTUFBSSxLQUFJLENBQUEsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxLQUFHLElBQUUsS0FBSSxDQUFDLENBQUMsSUFBSSxHQUFDLElBQUUsR0FBRSxHQUFHO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLElBQUUsR0FBRztJQUFBO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBSSxHQUFFLElBQUUsRUFBRSxFQUFDLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxFQUFFLElBQUUsS0FBRyxRQUFPLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLElBQUUsSUFBRSxLQUFJLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxHQUFHLEVBQUUsS0FBSyxHQUFHO1FBQUksT0FBTyxFQUFFLEtBQUs7SUFBRztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFJLEdBQUUsSUFBRSxFQUFFLFFBQU8sSUFBRSxJQUFFLEdBQUUsSUFBRSxFQUFFLEVBQUMsSUFBRSxPQUFNLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBSSxPQUFPLE1BQUksSUFBRyxDQUFBLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsS0FBSSxJQUFHLE1BQUksS0FBSSxDQUFBLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxJQUFFLEVBQUUsSUFBRSxDQUFBLElBQUcsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsSUFBRyxHQUFHLEVBQUUsS0FBSztJQUFHO0FBQUM7QUFBRyxJQUFJLElBQUUsRUFBRSxDQUFBO0lBQUksRUFBRSxPQUFLLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLEdBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUcsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFO1FBQUMsSUFBSSxLQUFHLEdBQUUsSUFBRSxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUMsQ0FBQSxJQUFHLEdBQUUsTUFBSSxDQUFDLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsTUFBSSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxHQUFFLEtBQUc7UUFBRyxJQUFJLElBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFDLENBQUEsSUFBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFFLE1BQUksQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEtBQUcsR0FBRSxLQUFHO1FBQUcsSUFBRyxNQUFJLEdBQUUsSUFBRSxJQUFFO2FBQU07WUFBQyxJQUFHLE1BQUksR0FBRSxPQUFPLElBQUUsTUFBSSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBSSxDQUFBLElBQUUsQ0FBQTtZQUFHLElBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsSUFBRTtRQUFDO1FBQUMsT0FBTSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUU7SUFBRTtJQUFFLEVBQUUsUUFBTSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxNQUFJLEtBQUcsS0FBSyxJQUFJLEdBQUUsT0FBSyxLQUFLLElBQUksR0FBRSxPQUFLLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxJQUFFLElBQUcsS0FBRyxJQUFFLEtBQUcsTUFBSSxLQUFHLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBRSxJQUFJLElBQUUsS0FBSyxJQUFJLElBQUcsTUFBTSxNQUFJLE1BQUksSUFBRSxJQUFHLENBQUEsSUFBRSxNQUFNLEtBQUcsSUFBRSxHQUFFLElBQUUsQ0FBQSxJQUFJLENBQUEsSUFBRSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUcsS0FBSyxNQUFLLElBQUcsQ0FBQSxJQUFFLEtBQUssSUFBSSxHQUFFLENBQUMsRUFBQyxJQUFHLEtBQUksQ0FBQSxLQUFJLEtBQUcsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFFLEtBQUcsSUFBRSxJQUFFLEtBQUcsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLElBQUcsSUFBRSxLQUFHLEtBQUksQ0FBQSxLQUFJLEtBQUcsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFHLENBQUEsSUFBRSxHQUFFLElBQUUsQ0FBQSxJQUFHLElBQUUsS0FBRyxJQUFHLENBQUEsSUFBRSxBQUFDLENBQUEsSUFBRSxJQUFFLENBQUEsSUFBRyxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsSUFBRSxDQUFBLElBQUksQ0FBQSxJQUFFLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxDQUFBLENBQUMsR0FBRyxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxHQUFDLElBQUUsS0FBSSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7UUFBRyxJQUFJLElBQUUsS0FBRyxJQUFFLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLEtBQUcsR0FBRSxLQUFHLEtBQUks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SUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7UUFBSSxPQUFPO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUcsRUFBRSxHQUFFLGFBQVk7WUFBQyxJQUFJLElBQUUsSUFBSSxXQUFXO1lBQUcsT0FBTyxFQUFFLEVBQUUsUUFBTyxFQUFFLFlBQVcsRUFBRTtRQUFXO1FBQUMsT0FBTyxFQUFFO0lBQUU7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLEtBQUcsRUFBRSxhQUFXLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBd0MsSUFBRyxFQUFFLGFBQVcsSUFBRyxDQUFBLEtBQUcsQ0FBQSxHQUFHLE1BQU0sSUFBSSxXQUFXO1FBQXdDLElBQUk7UUFBRSxPQUFPLE1BQUksS0FBSyxLQUFHLE1BQUksS0FBSyxJQUFFLElBQUUsSUFBSSxXQUFXLEtBQUcsTUFBSSxLQUFLLElBQUUsSUFBRSxJQUFJLFdBQVcsR0FBRSxLQUFHLElBQUUsSUFBSSxXQUFXLEdBQUUsR0FBRSxJQUFHLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFHLEVBQUUsU0FBUyxJQUFHO1lBQUMsSUFBSSxJQUFFLEVBQUUsRUFBRSxVQUFRLEdBQUUsSUFBRSxFQUFFO1lBQUcsT0FBTyxFQUFFLFdBQVMsS0FBRyxFQUFFLEtBQUssR0FBRSxHQUFFLEdBQUUsSUFBRztRQUFDO1FBQUMsSUFBRyxFQUFFLFdBQVMsS0FBSyxHQUFFLE9BQU8sT0FBTyxFQUFFLFVBQVEsWUFBVSxFQUFFLEVBQUUsVUFBUSxFQUFFLEtBQUcsRUFBRTtRQUFHLElBQUcsRUFBRSxTQUFPLFlBQVUsTUFBTSxRQUFRLEVBQUUsT0FBTSxPQUFPLEVBQUUsRUFBRTtJQUFLO0lBQUMsU0FBUyxFQUFFLENBQUM7UUFBRSxJQUFHLEtBQUcsR0FBRSxNQUFNLElBQUksV0FBVyw0REFBMEQsRUFBRSxTQUFTLE1BQUk7UUFBVSxPQUFPLElBQUU7SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsT0FBTSxDQUFDLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLEVBQUUsTUFBTSxDQUFDO0lBQUU7SUFBQyxFQUFFLFdBQVMsU0FBUyxDQUFDO1FBQUUsT0FBTyxLQUFHLFFBQU0sRUFBRSxjQUFZLENBQUMsS0FBRyxNQUFJLEVBQUU7SUFBUztJQUFFLEVBQUUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLEdBQUUsZUFBYyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBRSxRQUFPLEVBQUUsV0FBVSxHQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsTUFBSSxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQXlFLElBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsR0FBRSxFQUFFLEVBQUUsSUFBRyxDQUFDLENBQUMsRUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7WUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtZQUFDO1FBQUs7UUFBQyxPQUFPLElBQUUsSUFBRSxLQUFHLElBQUUsSUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLGFBQVcsU0FBUyxDQUFDO1FBQUUsT0FBTyxPQUFPLEdBQUc7WUFBZSxLQUFJO1lBQU0sS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVEsS0FBSTtZQUFTLEtBQUk7WUFBUyxLQUFJO1lBQVMsS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVUsS0FBSTtnQkFBVyxPQUFNLENBQUM7WUFBRTtnQkFBUSxPQUFNLENBQUM7UUFBQztJQUFDO0lBQUUsRUFBRSxTQUFPLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLENBQUMsTUFBTSxRQUFRLElBQUcsTUFBTSxJQUFJLFVBQVU7UUFBK0MsSUFBRyxFQUFFLFdBQVMsR0FBRSxPQUFPLEVBQUUsTUFBTTtRQUFHLElBQUk7UUFBRSxJQUFHLE1BQUksS0FBSyxHQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQU8sSUFBSSxJQUFFLEVBQUUsWUFBWSxJQUFHLElBQUU7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUU7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7WUFBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLElBQUUsRUFBRSxTQUFPLEVBQUUsU0FBUSxDQUFBLEVBQUUsU0FBUyxNQUFLLENBQUEsSUFBRSxFQUFFLEtBQUssRUFBQyxHQUFHLEVBQUUsS0FBSyxHQUFFLEVBQUMsSUFBRyxXQUFXLFVBQVUsSUFBSSxLQUFLLEdBQUUsR0FBRTtpQkFBUSxJQUFHLEVBQUUsU0FBUyxJQUFHLEVBQUUsS0FBSyxHQUFFO2lCQUFRLE1BQU0sSUFBSSxVQUFVO1lBQStDLEtBQUcsRUFBRTtRQUFNO1FBQUMsT0FBTztJQUFDO0lBQUUsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLFNBQVMsSUFBRyxPQUFPLEVBQUU7UUFBTyxJQUFHLFlBQVksT0FBTyxNQUFJLEVBQUUsR0FBRSxjQUFhLE9BQU8sRUFBRTtRQUFXLElBQUcsT0FBTyxLQUFHLFVBQVMsTUFBTSxJQUFJLFVBQVUsNkZBQTJGLE9BQU87UUFBRyxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsVUFBVSxTQUFPLEtBQUcsU0FBUyxDQUFDLEVBQUUsS0FBRyxDQUFDO1FBQUUsSUFBRyxDQUFDLEtBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPO1lBQUUsS0FBSTtZQUFPLEtBQUk7Z0JBQVEsT0FBTyxFQUFFLEdBQUc7WUFBTyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sSUFBRTtZQUFFLEtBQUk7Z0JBQU0sT0FBTyxNQUFJO1lBQUUsS0FBSTtnQkFBUyxPQUFPLEdBQUcsR0FBRztZQUFPO2dCQUFRLElBQUcsR0FBRSxPQUFPLElBQUUsS0FBRyxFQUFFLEdBQUc7Z0JBQU8sSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxhQUFXO0lBQUcsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxJQUFFLElBQUksQ0FBQyxVQUFTLENBQUEsQUFBQyxDQUFBLE1BQUksS0FBSyxLQUFHLElBQUUsSUFBSSxDQUFDLE1BQUssS0FBSyxDQUFBLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxLQUFHLENBQUEsS0FBSyxDQUFBLE9BQUssR0FBRSxPQUFLLEdBQUUsS0FBRyxDQUFBLEdBQUcsT0FBTTtRQUFHLElBQUksS0FBSSxDQUFBLElBQUUsTUFBSyxJQUFLLE9BQU87WUFBRyxLQUFJO2dCQUFNLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7WUFBTyxLQUFJO2dCQUFRLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7Z0JBQVEsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtZQUFTLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHO2dCQUFRLElBQUcsR0FBRSxNQUFNLElBQUksVUFBVSx1QkFBcUI7Z0JBQUcsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFlBQVUsQ0FBQztJQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7UUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxJQUFHLElBQUUsTUFBSSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQTZDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFHLE9BQU8sSUFBSTtJQUFBO0lBQUUsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFLElBQUcsRUFBRSxJQUFJLEVBQUMsSUFBRSxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsSUFBSSxFQUFDLElBQUUsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsV0FBUztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxPQUFPLE1BQUksSUFBRSxLQUFHLFVBQVUsV0FBUyxJQUFFLEdBQUcsSUFBSSxFQUFDLEdBQUUsS0FBRyxHQUFHLE1BQU0sSUFBSSxFQUFDO0lBQVU7SUFBRSxFQUFFLFVBQVUsaUJBQWUsRUFBRSxVQUFVO0lBQVMsRUFBRSxVQUFVLFNBQU8sU0FBUyxDQUFDO1FBQUUsSUFBRyxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQTZCLE9BQU8sSUFBSSxLQUFHLElBQUUsQ0FBQyxJQUFFLEVBQUUsUUFBUSxJQUFJLEVBQUMsT0FBSztJQUFDO0lBQUUsRUFBRSxVQUFVLFVBQVE7UUFBVyxJQUFJLElBQUUsSUFBRyxJQUFFLEVBQUU7UUFBa0IsT0FBTyxJQUFFLElBQUksQ0FBQyxTQUFTLE9BQU0sR0FBRSxHQUFHLFFBQVEsV0FBVSxPQUFPLFFBQU8sSUFBSSxDQUFDLFNBQU8sS0FBSSxDQUFBLEtBQUcsT0FBTSxHQUFHLGFBQVcsSUFBRTtJQUFHO0lBQUUsTUFBSyxDQUFBLEVBQUUsU0FBUyxDQUFDLEdBQUcsR0FBQyxFQUFFLFVBQVUsT0FBTTtJQUFHLEVBQUUsVUFBVSxVQUFRLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVSxtRkFBaUYsT0FBTztRQUFHLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLENBQUEsR0FBRyxNQUFJLEtBQUssS0FBSSxDQUFBLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLE1BQUksS0FBSyxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLElBQUksQ0FBQyxNQUFLLEdBQUcsSUFBRSxLQUFHLElBQUUsRUFBRSxVQUFRLElBQUUsS0FBRyxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsS0FBRyxLQUFHLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBRyxLQUFHLEdBQUUsT0FBTTtRQUFHLElBQUcsS0FBRyxHQUFFLE9BQU87UUFBRSxJQUFHLE9BQUssR0FBRSxPQUFLLEdBQUUsT0FBSyxHQUFFLE9BQUssR0FBRSxJQUFJLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxJQUFJLENBQUMsTUFBTSxHQUFFLElBQUcsSUFBRSxFQUFFLE1BQU0sR0FBRTtRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxJQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztZQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFO1lBQUM7UUFBSztRQUFDLE9BQU8sSUFBRSxJQUFFLEtBQUcsSUFBRSxJQUFFLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsRUFBRSxXQUFTLEdBQUUsT0FBTTtRQUFHLElBQUcsT0FBTyxLQUFHLFdBQVUsQ0FBQSxJQUFFLEdBQUUsSUFBRSxDQUFBLElBQUcsSUFBRSxhQUFXLElBQUUsYUFBVyxJQUFFLGVBQWMsQ0FBQSxJQUFFLFdBQVUsR0FBRyxJQUFFLENBQUMsR0FBRSxFQUFFLE1BQUssQ0FBQSxJQUFFLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsRUFBRSxTQUFPLENBQUEsR0FBRyxLQUFHLEVBQUUsUUFBTztZQUFDLElBQUcsR0FBRSxPQUFNO1lBQUcsSUFBRSxFQUFFLFNBQU87UUFBQyxPQUFNLElBQUcsSUFBRTtZQUFFLElBQUcsR0FBRSxJQUFFO2lCQUFPLE9BQU07O1FBQUcsSUFBRyxPQUFPLEtBQUcsWUFBVyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBQyxHQUFHLEVBQUUsU0FBUyxJQUFHLE9BQU8sRUFBRSxXQUFTLElBQUUsS0FBRyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFHLE9BQU8sS0FBRyxVQUFTLE9BQU8sSUFBRSxJQUFFLEtBQUksT0FBTyxXQUFXLFVBQVUsV0FBUyxhQUFXLElBQUUsV0FBVyxVQUFVLFFBQVEsS0FBSyxHQUFFLEdBQUUsS0FBRyxXQUFXLFVBQVUsWUFBWSxLQUFLLEdBQUUsR0FBRSxLQUFHLEdBQUcsR0FBRTtZQUFDO1NBQUUsRUFBQyxHQUFFLEdBQUU7UUFBRyxNQUFNLElBQUksVUFBVTtJQUF1QztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE9BQU8sR0FBRyxlQUFjLE1BQUksVUFBUSxNQUFJLFdBQVMsTUFBSSxhQUFXLE1BQUksVUFBUyxHQUFHO1lBQUMsSUFBRyxFQUFFLFNBQU8sS0FBRyxFQUFFLFNBQU8sR0FBRSxPQUFNO1lBQUcsSUFBRSxHQUFFLEtBQUcsR0FBRSxLQUFHLEdBQUUsS0FBRztRQUFDO1FBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO1lBQUUsT0FBTyxNQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLGFBQWEsSUFBRTtRQUFFO1FBQUMsSUFBSTtRQUFFLElBQUcsR0FBRTtZQUFDLElBQUksSUFBRTtZQUFHLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFJLElBQUcsRUFBRSxHQUFFLE9BQUssRUFBRSxHQUFFLE1BQUksS0FBRyxJQUFFLElBQUUsSUFBRztnQkFBQyxJQUFHLE1BQUksTUFBSyxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUUsSUFBRSxNQUFJLEdBQUUsT0FBTyxJQUFFO1lBQUMsT0FBTSxNQUFJLE1BQUssQ0FBQSxLQUFHLElBQUUsQ0FBQSxHQUFHLElBQUU7UUFBRSxPQUFNLElBQUksSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQSxHQUFHLElBQUUsR0FBRSxLQUFHLEdBQUUsSUFBSTtZQUFDLElBQUksSUFBRSxDQUFDO1lBQUUsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBSSxJQUFHLEVBQUUsR0FBRSxJQUFFLE9BQUssRUFBRSxHQUFFLElBQUc7Z0JBQUMsSUFBRSxDQUFDO2dCQUFFO1lBQUs7WUFBQyxJQUFHLEdBQUUsT0FBTztRQUFDO1FBQUMsT0FBTTtJQUFFO0lBQUMsRUFBRSxVQUFVLFdBQVMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUksQ0FBQyxRQUFRLEdBQUUsR0FBRSxPQUFLO0lBQUU7SUFBRSxFQUFFLFVBQVUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsQ0FBQztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLENBQUM7SUFBRTtJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxPQUFPLE1BQUk7UUFBRSxJQUFJLElBQUUsRUFBRSxTQUFPO1FBQUUsSUFBRyxDQUFBLElBQUUsT0FBTyxJQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRTtRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQTtRQUFHLElBQUk7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFO1lBQUMsSUFBSSxJQUFFLFNBQVMsRUFBRSxPQUFPLElBQUUsR0FBRSxJQUFHO1lBQUksSUFBRyxFQUFFLElBQUcsT0FBTztZQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFDO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsRUFBRSxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsRUFBRSxVQUFVLFFBQU0sU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxNQUFJLEtBQUssR0FBRSxJQUFFLFFBQU8sSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxNQUFJLEtBQUssS0FBRyxPQUFPLEtBQUcsVUFBUyxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxTQUFTLElBQUcsSUFBRSxNQUFJLEdBQUUsU0FBUyxLQUFJLENBQUEsSUFBRSxNQUFJLEdBQUUsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE1BQUssQ0FBQyxJQUFJLENBQUEsSUFBRSxHQUFFLElBQUUsS0FBSyxDQUFBO2FBQVEsTUFBTSxJQUFJLE1BQU07UUFBMkUsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFPO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxFQUFFLFNBQU8sS0FBSSxDQUFBLElBQUUsS0FBRyxJQUFFLENBQUEsS0FBSSxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQTBDLEtBQUksQ0FBQSxJQUFFLE1BQUs7UUFBRyxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7Z0JBQU0sT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtnQkFBUSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFO1lBQUc7Z0JBQVEsSUFBRyxHQUFFLE1BQU0sSUFBSSxVQUFVLHVCQUFxQjtnQkFBRyxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUEsRUFBRyxlQUFjLElBQUUsQ0FBQztRQUFDO0lBQUM7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLE9BQU07WUFBQyxNQUFLO1lBQVMsTUFBSyxNQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFNLElBQUksRUFBQztRQUFFO0lBQUM7SUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxNQUFJLEtBQUcsTUFBSSxFQUFFLFNBQU8sRUFBRSxjQUFjLEtBQUcsRUFBRSxjQUFjLEVBQUUsTUFBTSxHQUFFO0lBQUc7SUFBQyxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxLQUFLLElBQUksRUFBRSxRQUFPO1FBQUcsSUFBSSxJQUFFLEVBQUUsRUFBQyxJQUFFO1FBQUUsTUFBSyxJQUFFLEdBQUc7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLE1BQUssSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRTtZQUFFLElBQUcsSUFBRSxLQUFHLEdBQUU7Z0JBQUMsSUFBSSxHQUFFLEdBQUUsR0FBRTtnQkFBRSxPQUFPO29CQUFHLEtBQUs7d0JBQUUsSUFBRSxPQUFNLENBQUEsSUFBRSxDQUFBO3dCQUFHO29CQUFNLEtBQUs7d0JBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsQUFBQyxDQUFBLElBQUUsR0FBRSxNQUFLLE9BQU0sQ0FBQSxJQUFFLEFBQUMsQ0FBQSxJQUFFLEVBQUMsS0FBSSxJQUFFLElBQUUsSUFBRyxJQUFFLE9BQU0sQ0FBQSxJQUFFLENBQUEsQ0FBQzt3QkFBRztvQkFBTSxLQUFLO3dCQUFFLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFLLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFNLENBQUEsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksS0FBRyxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksSUFBRSxJQUFFLElBQUcsSUFBRSxRQUFPLENBQUEsSUFBRSxTQUFPLElBQUUsS0FBSSxLQUFLLENBQUEsSUFBRSxDQUFBLENBQUM7d0JBQUc7b0JBQU0sS0FBSzt3QkFBRSxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBTSxDQUFBLElBQUUsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLElBQUUsSUFBRSxJQUFHLElBQUUsU0FBTyxJQUFFLFdBQVUsQ0FBQSxJQUFFLENBQUEsQ0FBQztnQkFBRTtZQUFDO1lBQUMsTUFBSSxPQUFNLENBQUEsSUFBRSxPQUFNLElBQUUsQ0FBQSxJQUFHLElBQUUsU0FBUSxDQUFBLEtBQUcsT0FBTSxFQUFFLEtBQUssTUFBSSxLQUFHLE9BQUssUUFBTyxJQUFFLFFBQU0sSUFBRSxJQUFHLEdBQUcsRUFBRSxLQUFLLElBQUcsS0FBRztRQUFDO1FBQUMsT0FBTyxHQUFHO0lBQUU7SUFBQyxJQUFJLEtBQUc7SUFBSyxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxLQUFHLElBQUcsT0FBTyxPQUFPLGFBQWEsTUFBTSxRQUFPO1FBQUcsSUFBSSxJQUFFLElBQUcsSUFBRTtRQUFFLE1BQUssSUFBRSxHQUFHLEtBQUcsT0FBTyxhQUFhLE1BQU0sUUFBTyxFQUFFLE1BQU0sR0FBRSxLQUFHO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRTtRQUFFLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFRLENBQUEsQ0FBQyxLQUFHLElBQUUsQ0FBQSxLQUFLLENBQUEsSUFBRSxDQUFBLEdBQUcsQUFBQyxDQUFBLENBQUMsS0FBRyxJQUFFLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUE7UUFBRyxJQUFJLElBQUU7UUFBRyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxFQUFFLEVBQUUsS0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUFDLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRSxNQUFNLEdBQUUsSUFBRyxJQUFFO1FBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsU0FBTyxHQUFFLEtBQUcsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFLLE9BQU87SUFBQztJQUFDLEVBQUUsVUFBVSxRQUFNLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRSxDQUFDLENBQUMsR0FBRSxJQUFFLE1BQUksS0FBSyxJQUFFLElBQUUsQ0FBQyxDQUFDLEdBQUUsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFTLEdBQUU7UUFBRyxPQUFPLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsSUFBRSxNQUFJLEtBQUcsSUFBRSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsSUFBRSxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7SUFBd0M7SUFBQyxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxHQUFFLElBQUU7UUFBRSxNQUFLLEVBQUUsSUFBRSxLQUFJLENBQUEsS0FBRyxHQUFFLEdBQUksS0FBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsRUFBRSxFQUFDLElBQUU7UUFBRSxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLElBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEFBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxFQUFDLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDO0lBQVE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsV0FBVSxDQUFBLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsQUFBRDtJQUFFO0lBQUUsRUFBRSxVQUFVLGtCQUFnQixFQUFFLFNBQVMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLEVBQUUsR0FBRTtRQUFVLElBQUksSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtRQUFFLENBQUEsTUFBSSxLQUFLLEtBQUcsTUFBSSxLQUFLLENBQUEsS0FBSSxFQUFFLEdBQUUsSUFBSSxDQUFDLFNBQU87UUFBRyxJQUFJLElBQUUsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLElBQUcsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFFLEtBQUc7UUFBRyxPQUFPLE9BQU8sS0FBSSxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUU7SUFBRTtJQUFHLEVBQUUsVUFBVSxrQkFBZ0IsRUFBRSxTQUFTLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxFQUFFLEdBQUU7UUFBVSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUU7UUFBRSxDQUFBLE1BQUksS0FBSyxLQUFHLE1BQUksS0FBSyxDQUFBLEtBQUksRUFBRSxHQUFFLElBQUksQ0FBQyxTQUFPO1FBQUcsSUFBSSxJQUFFLElBQUUsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLEtBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO1FBQUUsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU87SUFBRTtJQUFHLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFFLE1BQUssRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFFLE9BQU8sS0FBRyxLQUFJLEtBQUcsS0FBSSxDQUFBLEtBQUcsS0FBSyxJQUFJLEdBQUUsSUFBRSxFQUFDLEdBQUc7SUFBQztJQUFFLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEVBQUU7UUFBQyxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPLEtBQUcsS0FBSSxLQUFHLEtBQUksQ0FBQSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUUsRUFBQyxHQUFHO0lBQUM7SUFBRSxFQUFFLFVBQVUsV0FBUyxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxBQUFDLENBQUEsTUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUEsSUFBRyxLQUFHLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFJLENBQUMsSUFBRSxFQUFFLElBQUU7UUFBRSxPQUFPLElBQUUsUUFBTSxJQUFFLGFBQVc7SUFBQztJQUFFLEVBQUUsVUFBVSxjQUFZLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQztRQUFRLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsSUFBRTtRQUFFLE9BQU8sSUFBRSxRQUFNLElBQUUsYUFBVztJQUFDO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRTtJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtJQUFBO0lBQUUsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLEtBQUcsS0FBSSxDQUFBLEtBQUcsRUFBQztRQUFHLE9BQU0sQUFBQyxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUUsSUFBRyxPQUFPLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRztJQUFHO0lBQUcsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxBQUFDLENBQUEsS0FBRyxFQUFDLElBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQUMsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO0lBQUU7SUFBRyxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxFQUFFLEtBQUssSUFBSSxFQUFDLEdBQUUsQ0FBQyxHQUFFLElBQUc7SUFBRTtJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDLFNBQVEsRUFBRSxLQUFLLElBQUksRUFBQyxHQUFFLENBQUMsR0FBRSxJQUFHO0lBQUU7SUFBRSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVTtRQUErQyxJQUFHLElBQUUsS0FBRyxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBcUMsSUFBRyxJQUFFLElBQUUsRUFBRSxRQUFPLE1BQU0sSUFBSSxXQUFXO0lBQXFCO0lBQUMsRUFBRSxVQUFVLGNBQVksRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxLQUFHO1lBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRTtRQUFFO1FBQUMsSUFBSSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsY0FBWSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLEtBQUc7WUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUU7UUFBQyxJQUFJLElBQUUsSUFBRSxHQUFFLElBQUU7UUFBRSxJQUFJLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxLQUFHLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBRTtJQUFDO0lBQUUsRUFBRSxVQUFVLGdCQUFjLEVBQUUsVUFBVSxnQkFBYyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxPQUFNLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZ0JBQWMsRUFBRSxVQUFVLGdCQUFjLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sSUFBRyxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksSUFBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLEdBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUcsSUFBSSxJQUFFLE9BQU8sSUFBRSxPQUFPO1FBQWEsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQztRQUFFLElBQUksSUFBRSxPQUFPLEtBQUcsT0FBTyxNQUFJLE9BQU87UUFBYSxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsR0FBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFJLElBQUUsT0FBTyxJQUFFLE9BQU87UUFBYSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxJQUFJLElBQUUsT0FBTyxLQUFHLE9BQU8sTUFBSSxPQUFPO1FBQWEsT0FBTyxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsRUFBRSxHQUFDLEdBQUUsSUFBRTtJQUFDO0lBQUMsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLGFBQVcsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxJQUFFO1lBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsSUFBRSxHQUFFLENBQUM7UUFBRTtRQUFDLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFO1FBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLElBQUU7WUFBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxJQUFFLEdBQUUsQ0FBQztRQUFFO1FBQUMsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLEtBQUcsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLE9BQU0sSUFBRSxLQUFJLENBQUEsSUFBRSxNQUFJLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMs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QyxHQUFFO0lBQUU7SUFBRSxFQUFFLFVBQVUsT0FBSyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLENBQUMsRUFBRSxTQUFTLElBQUcsTUFBTSxJQUFJLFVBQVU7UUFBK0IsSUFBRyxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsQ0FBQyxLQUFHLE1BQUksS0FBSSxDQUFBLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxLQUFHLEVBQUUsVUFBUyxDQUFBLElBQUUsRUFBRSxNQUFLLEdBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFFLEtBQUksQ0FBQSxJQUFFLENBQUEsR0FBRyxNQUFJLEtBQUcsRUFBRSxXQUFTLEtBQUcsSUFBSSxDQUFDLFdBQVMsR0FBRSxPQUFPO1FBQUUsSUFBRyxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBNkIsSUFBRyxJQUFFLEtBQUcsS0FBRyxJQUFJLENBQUMsUUFBTyxNQUFNLElBQUksV0FBVztRQUFzQixJQUFHLElBQUUsR0FBRSxNQUFNLElBQUksV0FBVztRQUEyQixJQUFFLElBQUksQ0FBQyxVQUFTLENBQUEsSUFBRSxJQUFJLENBQUMsTUFBSyxHQUFHLEVBQUUsU0FBTyxJQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsRUFBRSxTQUFPLElBQUUsQ0FBQTtRQUFHLElBQUksSUFBRSxJQUFFO1FBQUUsT0FBTyxJQUFJLEtBQUcsS0FBRyxPQUFPLFdBQVcsVUFBVSxjQUFZLGFBQVcsSUFBSSxDQUFDLFdBQVcsR0FBRSxHQUFFLEtBQUcsV0FBVyxVQUFVLElBQUksS0FBSyxHQUFFLElBQUksQ0FBQyxTQUFTLEdBQUUsSUFBRyxJQUFHO0lBQUM7SUFBRSxFQUFFLFVBQVUsT0FBSyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLE9BQU8sS0FBRyxVQUFTO1lBQUMsSUFBRyxPQUFPLEtBQUcsV0FBVSxDQUFBLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsTUFBSyxJQUFHLE9BQU8sS0FBRyxZQUFXLENBQUEsSUFBRSxHQUFFLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxNQUFJLEtBQUssS0FBRyxPQUFPLEtBQUcsVUFBUyxNQUFNLElBQUksVUFBVTtZQUE2QixJQUFHLE9BQU8sS0FBRyxZQUFVLENBQUMsRUFBRSxXQUFXLElBQUcsTUFBTSxJQUFJLFVBQVUsdUJBQXFCO1lBQUcsSUFBRyxFQUFFLFdBQVMsR0FBRTtnQkFBQyxJQUFJLElBQUUsRUFBRSxXQUFXO2dCQUFJLENBQUEsTUFBSSxVQUFRLElBQUUsT0FBSyxNQUFJLFFBQU8sS0FBSyxDQUFBLElBQUUsQ0FBQTtZQUFFO1FBQUMsT0FBTSxPQUFPLEtBQUcsV0FBUyxJQUFFLElBQUUsTUFBSSxPQUFPLEtBQUcsYUFBWSxDQUFBLElBQUUsT0FBTyxFQUFDO1FBQUcsSUFBRyxJQUFFLEtBQUcsSUFBSSxDQUFDLFNBQU8sS0FBRyxJQUFJLENBQUMsU0FBTyxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsS0FBRyxHQUFFLE9BQU8sSUFBSTtRQUFDLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxLQUFLLElBQUUsSUFBSSxDQUFDLFNBQU8sTUFBSSxHQUFFLEtBQUksQ0FBQSxJQUFFLENBQUE7UUFBRyxJQUFJO1FBQUUsSUFBRyxPQUFPLEtBQUcsVUFBUyxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUM7YUFBTTtZQUFDLElBQUksSUFBRSxFQUFFLFNBQVMsS0FBRyxJQUFFLEVBQUUsS0FBSyxHQUFFLElBQUcsSUFBRSxFQUFFO1lBQU8sSUFBRyxNQUFJLEdBQUUsTUFBTSxJQUFJLFVBQVUsZ0JBQWMsSUFBRTtZQUFxQyxJQUFJLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUU7UUFBQTtRQUFDLE9BQU8sSUFBSTtJQUFBO0lBQUUsSUFBSSxJQUFFLENBQUM7SUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQyxjQUFjO1lBQUUsYUFBYTtnQkFBQyxLQUFLLElBQUcsT0FBTyxlQUFlLElBQUksRUFBQyxXQUFVO29CQUFDLE9BQU0sRUFBRSxNQUFNLElBQUksRUFBQztvQkFBVyxVQUFTLENBQUM7b0JBQUUsY0FBYSxDQUFDO2dCQUFDLElBQUcsSUFBSSxDQUFDLE9BQUssR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFLLE1BQU0sT0FBTyxHQUFFLE1BQUssSUFBSSxDQUFDLE9BQU0sT0FBTyxJQUFJLENBQUM7WUFBSTtZQUFDLElBQUksT0FBTTtnQkFBQyxPQUFPO1lBQUM7WUFBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO2dCQUFDLE9BQU8sZUFBZSxJQUFJLEVBQUMsUUFBTztvQkFBQyxjQUFhLENBQUM7b0JBQUUsWUFBVyxDQUFDO29CQUFFLE9BQU07b0JBQUUsVUFBUyxDQUFDO2dCQUFDO1lBQUU7WUFBQyxXQUFVO2dCQUFDLE9BQU0sR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFLLE1BQU0sT0FBTyxHQUFFLE9BQU8sT0FBTyxJQUFJLENBQUM7WUFBUTtRQUFDO0lBQUM7SUFBQyxFQUFFLDRCQUEyQixTQUFTLENBQUM7UUFBRSxPQUFPLElBQUUsR0FBRyxPQUFPLEdBQUUsa0NBQWdDO0lBQWdELEdBQUU7SUFBWSxFQUFFLHdCQUF1QixTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTSxRQUFRLE9BQU8sR0FBRSxxREFBcUQsT0FBTyxPQUFPO0lBQUUsR0FBRTtJQUFXLEVBQUUsb0JBQW1CLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBSSxJQUFFLGlCQUFpQixPQUFPLEdBQUUsdUJBQXNCLElBQUU7UUFBRSxPQUFPLE9BQU8sVUFBVSxNQUFJLEtBQUssSUFBSSxLQUFHLEtBQUcsS0FBRyxJQUFFLEdBQUcsT0FBTyxNQUFJLE9BQU8sS0FBRyxZQUFXLENBQUEsSUFBRSxPQUFPLElBQUcsQUFBQyxDQUFBLElBQUUsT0FBTyxNQUFJLE9BQU8sT0FBSyxJQUFFLENBQUUsQ0FBQSxPQUFPLE1BQUksT0FBTyxHQUFFLENBQUMsS0FBSyxDQUFBLElBQUUsR0FBRyxFQUFDLEdBQUcsS0FBRyxHQUFFLEdBQUcsS0FBRyxlQUFlLE9BQU8sR0FBRSxlQUFlLE9BQU8sSUFBRztJQUFDLEdBQUU7SUFBWSxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUksSUFBRSxJQUFHLElBQUUsRUFBRSxRQUFPLElBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBRyxNQUFJLElBQUU7UUFBRSxNQUFLLEtBQUcsSUFBRSxHQUFFLEtBQUcsRUFBRSxJQUFFLElBQUksT0FBTyxFQUFFLE1BQU0sSUFBRSxHQUFFLElBQUksT0FBTztRQUFHLE9BQU0sR0FBRyxPQUFPLEVBQUUsTUFBTSxHQUFFLElBQUksT0FBTztJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLEVBQUUsR0FBRSxXQUFVLEFBQUMsQ0FBQSxDQUFDLENBQUMsRUFBRSxLQUFHLEtBQUssS0FBRyxDQUFDLENBQUMsSUFBRSxFQUFFLEtBQUcsS0FBSyxDQUFBLEtBQUksRUFBRSxHQUFFLEVBQUUsU0FBUSxDQUFBLElBQUUsQ0FBQTtJQUFHO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsSUFBRSxLQUFHLElBQUUsR0FBRTtZQUFDLElBQUksSUFBRSxPQUFPLEtBQUcsV0FBUyxNQUFJLElBQUc7WUFBRSxNQUFNLElBQUUsSUFBRSxNQUFJLEtBQUcsTUFBSSxPQUFPLEtBQUcsSUFBRSxPQUFPLE9BQU8sR0FBRSxZQUFZLE9BQU8sR0FBRSxRQUFRLE9BQU8sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLEdBQUcsT0FBTyxLQUFHLElBQUUsU0FBUyxPQUFPLEdBQUUsUUFBUSxPQUFPLEFBQUMsQ0FBQSxJQUFFLENBQUEsSUFBRyxJQUFFLEdBQUcsT0FBTyxHQUFFLG1CQUFpQixHQUFHLE9BQU8sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsR0FBRyxPQUFPLEtBQUcsSUFBRSxNQUFNLE9BQU8sR0FBRyxPQUFPLEdBQUUsWUFBWSxPQUFPLEdBQUcsT0FBTyxJQUFHLElBQUksRUFBRSxpQkFBaUIsU0FBUSxHQUFFO1FBQUU7UUFBQyxHQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxPQUFPLEtBQUcsVUFBUyxNQUFNLElBQUksRUFBRSxxQkFBcUIsR0FBRSxVQUFTO0lBQUU7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsTUFBTSxLQUFLLE1BQU0sT0FBSyxJQUFHLENBQUEsRUFBRSxHQUFFLElBQUcsSUFBSSxFQUFFLGlCQUFpQixLQUFHLFVBQVMsY0FBYSxFQUFDLElBQUcsSUFBRSxJQUFFLElBQUksRUFBRSwyQkFBeUIsSUFBSSxFQUFFLGlCQUFpQixLQUFHLFVBQVMsTUFBTSxPQUFPLElBQUUsSUFBRSxHQUFFLFlBQVksT0FBTyxJQUFHO0lBQUU7SUFBQyxJQUFJLEtBQUc7SUFBb0IsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFHLElBQUUsRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxFQUFFLE9BQU8sUUFBUSxJQUFHLEtBQUksRUFBRSxTQUFPLEdBQUUsT0FBTTtRQUFHLE1BQUssRUFBRSxTQUFPLE1BQUksR0FBRyxJQUFFLElBQUU7UUFBSSxPQUFPO0lBQUM7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFFLEtBQUcsSUFBRTtRQUFFLElBQUksR0FBRSxJQUFFLEVBQUUsUUFBTyxJQUFFLE1BQUssSUFBRSxFQUFFO1FBQUMsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFO1lBQUMsSUFBRyxJQUFFLEVBQUUsV0FBVyxJQUFHLElBQUUsU0FBTyxJQUFFLE9BQU07Z0JBQUMsSUFBRyxDQUFDLEdBQUU7b0JBQUMsSUFBRyxJQUFFLE9BQU07d0JBQUUsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUk7d0JBQUs7b0JBQVEsT0FBTSxJQUFHLElBQUUsTUFBSSxHQUFFO3dCQUFFLENBQUEsS0FBRyxDQUFBLElBQUcsTUFBSSxFQUFFLEtBQUssS0FBSSxLQUFJO3dCQUFLO29CQUFRO29CQUFDLElBQUU7b0JBQUU7Z0JBQVE7Z0JBQUMsSUFBRyxJQUFFLE9BQU07b0JBQUUsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUksTUFBSyxJQUFFO29CQUFFO2dCQUFRO2dCQUFDLElBQUUsQUFBQyxDQUFBLElBQUUsU0FBTyxLQUFHLElBQUUsS0FBSSxJQUFHO1lBQUssT0FBTSxLQUFHLEFBQUMsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUk7WUFBSyxJQUFHLElBQUUsTUFBSyxJQUFFLEtBQUk7Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUs7WUFBRSxPQUFNLElBQUcsSUFBRSxNQUFLO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsSUFBRSxLQUFJLElBQUUsS0FBRztZQUFJLE9BQU0sSUFBRyxJQUFFLE9BQU07Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUssS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLElBQUcsSUFBRSxTQUFRO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsS0FBRyxLQUFJLEtBQUcsS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLE1BQU0sSUFBSSxNQUFNO1FBQXFCO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLFFBQU8sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLFdBQVcsS0FBRztRQUFLLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxFQUFFO1FBQUMsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsVUFBUSxDQUFFLENBQUEsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLENBQUEsR0FBRyxFQUFFLEVBQUUsSUFBRSxFQUFFLFdBQVcsSUFBRyxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUUsS0FBSSxFQUFFLEtBQUssSUFBRyxFQUFFLEtBQUs7UUFBRyxPQUFPO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sRUFBRSxZQUFZLEdBQUc7SUFBRztJQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBSTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsS0FBRyxDQUFFLENBQUEsSUFBRSxLQUFHLEVBQUUsVUFBUSxLQUFHLEVBQUUsTUFBSyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUU7UUFBQyxPQUFPO0lBQUM7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLGFBQWEsS0FBRyxLQUFHLFFBQU0sRUFBRSxlQUFhLFFBQU0sRUFBRSxZQUFZLFFBQU0sUUFBTSxFQUFFLFlBQVksU0FBTyxFQUFFO0lBQUk7SUFBQyxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sTUFBSTtJQUFDO0lBQUMsSUFBSSxLQUFHO1FBQVcsSUFBSSxJQUFFLG9CQUFtQixJQUFFLElBQUksTUFBTTtRQUFLLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsRUFBRTtZQUFDLElBQUksSUFBRSxJQUFFO1lBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLElBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPO0lBQUM7SUFBSSxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTyxTQUFPLE1BQUksS0FBRztJQUFDO0lBQUMsU0FBUztRQUFLLE1BQU0sSUFBSSxNQUFNO0lBQXVCO0FBQUM7QUFBRyxJQUFJLElBQUUsQ0FBQztBQUFFLEdBQUcsR0FBRTtJQUFDLFNBQVEsSUFBSTtBQUFFO0FBQUcsT0FBTyxVQUFRLEdBQUc7QUFBRyxJQUFJLEtBQUcsRUFBRTtBQUFLLEVBQUUsR0FBRSxFQUFFLE1BQUssT0FBTztBQUFTLElBQUksS0FBRyxHQUFHLFNBQzkwM0I7Ozs7Ozs7Ozs7OztBQVlBIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3BhcmNlbC1ydW50aW1lQDAuMjUuMi9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1ydW50aW1lL2Rpc3QvcnVudGltZS1kM2MyNzk5YjdhOTAxZjZjLmpzIiwiLnBsYXNtby9zdGF0aWMvYmFja2dyb3VuZC9pbmRleC50cyIsInNyYy9iYWNrZ3JvdW5kLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL2NsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvY2xpZW50L2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3NoYXJlZC9wcm90b2NvbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy90eXBlcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9sb2NhbGVzL2VuLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvWm9kRXJyb3IuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBhcmNlbCt0cmFuc2Zvcm1lci1qc0AyLjkuM19AcGFyY2VsK2NvcmVAMi45LjMvbm9kZV9tb2R1bGVzL0BwYXJjZWwvdHJhbnNmb3JtZXItanMvc3JjL2VzbW9kdWxlLWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3BhcnNlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdHlwZUFsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4tdXVpZC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4udHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvc3JjL3NjaGVtZXMvbWFpbHRvLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy93cy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy91cmkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy1pcmkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvc3JjL3JlZ2V4cHMtdXJpLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy91dGlsLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QtZGVlcC1lcXVhbEAzLjEuMy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91Y3MybGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9zY2hlbWFfb2JqLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2pzb24tc2NoZW1hLXRyYXZlcnNlQDAuNC4xL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvZXJyb3JfY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeUAyLjEuMC9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9mb3JtYXRzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcmVmLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvYWxsT2YuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbnlPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9jb25zdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZW51bS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2lmLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaXRlbXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL19saW1pdExlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL19saW1pdFByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tdWx0aXBsZU9mLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbm90LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvb25lT2YuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3Byb3BlcnR5TmFtZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3VuaXF1ZUl0ZW1zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9rZXl3b3JkLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvY3VzdG9tLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZGVmaW5pdGlvbl9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb24iLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2RhdGEuanNvbiIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9jbGllbnQvc3NlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9jbGllbnQvc3NlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9zcmMvZXJyb3JzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9zcmMvRXZlbnRTb3VyY2UudHMiLCJub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC42L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNvdXJjZS1wYXJzZXJAMy4wLjYvbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlLXBhcnNlci9zcmMvZXJyb3JzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlLXBhcnNlckAzLjAuNi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UtcGFyc2VyL3NyYy9wYXJzZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9jbGllbnQvYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvY2xpZW50L2F1dGgudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcGtjZS1jaGFsbGVuZ2VANS4wLjAvbm9kZV9tb2R1bGVzL3BrY2UtY2hhbGxlbmdlL2Rpc3QvaW5kZXguYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9zaGFyZWQvYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL2F1dGgudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQG1vZGVsY29udGV4dHByb3RvY29sK3Nka0AxLjIwLjAvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvZGlzdC9janMvc2hhcmVkL2F1dGgtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQG1vZGVsY29udGV4dHByb3RvY29sK3Nka0AxLjIwLjAvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NoYXJlZC9hdXRoLXV0aWxzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3NlcnZlci9hdXRoL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2VydmVyL2F1dGgvZXJyb3JzLnRzIiwic3JjL21jcC9ub3Rpb25DbGllbnQudHMiLCJzcmMvY29uc3RhbnRzLnRzIiwic3JjL21jcC9vYXV0aC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcGFyY2VsLXJlc29sdmVyQDAuMTQuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1yZXNvbHZlci9kaXN0L3BvbHlmaWxscy9idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHU9Z2xvYmFsVGhpcy5wcm9jZXNzPy5hcmd2fHxbXTt2YXIgaD0oKT0+Z2xvYmFsVGhpcy5wcm9jZXNzPy5lbnZ8fHt9O3ZhciBCPW5ldyBTZXQodSksXz1lPT5CLmhhcyhlKSxHPXUuZmlsdGVyKGU9PmUuc3RhcnRzV2l0aChcIi0tXCIpJiZlLmluY2x1ZGVzKFwiPVwiKSkubWFwKGU9PmUuc3BsaXQoXCI9XCIpKS5yZWR1Y2UoKGUsW3Qsb10pPT4oZVt0XT1vLGUpLHt9KTt2YXIgVT1fKFwiLS1kcnktcnVuXCIpLGc9KCk9Pl8oXCItLXZlcmJvc2VcIil8fGgoKS5WRVJCT1NFPT09XCJ0cnVlXCIsTj1nKCk7dmFyIG09KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIHk9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSx2PSguLi5lKT0+bShcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLGY9KC4uLmUpPT5tKFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksTT0wLGk9KC4uLmUpPT5nKCkmJm0oYFxcdXsxRjdFMX0gJHtNKyt9YCwuLi5lKTt2YXIgYj0oKT0+e2xldCBlPWdsb2JhbFRoaXMuYnJvd3Nlcj8ucnVudGltZXx8Z2xvYmFsVGhpcy5jaHJvbWU/LnJ1bnRpbWUsdD0oKT0+c2V0SW50ZXJ2YWwoZS5nZXRQbGF0Zm9ybUluZm8sMjRlMyk7ZS5vblN0YXJ0dXAuYWRkTGlzdGVuZXIodCksdCgpfTt2YXIgbj17XCJpc0NvbnRlbnRTY3JpcHRcIjpmYWxzZSxcImlzQmFja2dyb3VuZFwiOnRydWUsXCJpc1JlYWN0XCI6ZmFsc2UsXCJydW50aW1lc1wiOltcImJhY2tncm91bmQtc2VydmljZS1ydW50aW1lXCJdLFwiaG9zdFwiOlwibG9jYWxob3N0XCIsXCJwb3J0XCI6NTA5NjEsXCJlbnRyeUZpbGVQYXRoXCI6XCJDOlxcXFxVc2Vyc1xcXFxVc2VyXFxcXGNvZGVcXFxcaGFja2F0aG9uc1xcXFxjaHJvbWUtYWlcXFxcLnBsYXNtb1xcXFxzdGF0aWNcXFxcYmFja2dyb3VuZFxcXFxpbmRleC50c1wiLFwiYnVuZGxlSWRcIjpcImMzMzg5MDhlNzA0YzkxZjFcIixcImVudkhhc2hcIjpcImQ5OWE1ZmZhNTdhY2Q2MzhcIixcInZlcmJvc2VcIjpcImZhbHNlXCIsXCJzZWN1cmVcIjpmYWxzZSxcInNlcnZlclBvcnRcIjo1MDk2MH07bW9kdWxlLmJ1bmRsZS5ITVJfQlVORExFX0lEPW4uYnVuZGxlSWQ7Z2xvYmFsVGhpcy5wcm9jZXNzPXthcmd2OltdLGVudjp7VkVSQk9TRTpuLnZlcmJvc2V9fTt2YXIgRD1tb2R1bGUuYnVuZGxlLk1vZHVsZTtmdW5jdGlvbiBIKGUpe0QuY2FsbCh0aGlzLGUpLHRoaXMuaG90PXtkYXRhOm1vZHVsZS5idW5kbGUuaG90RGF0YVtlXSxfYWNjZXB0Q2FsbGJhY2tzOltdLF9kaXNwb3NlQ2FsbGJhY2tzOltdLGFjY2VwdDpmdW5jdGlvbih0KXt0aGlzLl9hY2NlcHRDYWxsYmFja3MucHVzaCh0fHxmdW5jdGlvbigpe30pfSxkaXNwb3NlOmZ1bmN0aW9uKHQpe3RoaXMuX2Rpc3Bvc2VDYWxsYmFja3MucHVzaCh0KX19LG1vZHVsZS5idW5kbGUuaG90RGF0YVtlXT12b2lkIDB9bW9kdWxlLmJ1bmRsZS5Nb2R1bGU9SDttb2R1bGUuYnVuZGxlLmhvdERhdGE9e307dmFyIGM9Z2xvYmFsVGhpcy5icm93c2VyfHxnbG9iYWxUaGlzLmNocm9tZXx8bnVsbDtmdW5jdGlvbiBSKCl7cmV0dXJuIW4uaG9zdHx8bi5ob3N0PT09XCIwLjAuMC4wXCI/bG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBcIik9PT0wP2xvY2F0aW9uLmhvc3RuYW1lOlwibG9jYWxob3N0XCI6bi5ob3N0fWZ1bmN0aW9uIHgoKXtyZXR1cm4hbi5ob3N0fHxuLmhvc3Q9PT1cIjAuMC4wLjBcIj9cImxvY2FsaG9zdFwiOm4uaG9zdH1mdW5jdGlvbiBkKCl7cmV0dXJuIG4ucG9ydHx8bG9jYXRpb24ucG9ydH12YXIgUD1cIl9fcGxhc21vX3J1bnRpbWVfcGFnZV9cIixTPVwiX19wbGFzbW9fcnVudGltZV9zY3JpcHRfXCI7dmFyIE89YCR7bi5zZWN1cmU/XCJodHRwc1wiOlwiaHR0cFwifTovLyR7UigpfToke2QoKX0vYDthc3luYyBmdW5jdGlvbiBrKGU9MTQ3MCl7Zm9yKDs7KXRyeXthd2FpdCBmZXRjaChPKTticmVha31jYXRjaHthd2FpdCBuZXcgUHJvbWlzZShvPT5zZXRUaW1lb3V0KG8sZSkpfX1pZihjLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS5tYW5pZmVzdF92ZXJzaW9uPT09Myl7bGV0IGU9Yy5ydW50aW1lLmdldFVSTChcIi9fX3BsYXNtb19obXJfcHJveHlfXz91cmw9XCIpO2dsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImZldGNoXCIsZnVuY3Rpb24odCl7bGV0IG89dC5yZXF1ZXN0LnVybDtpZihvLnN0YXJ0c1dpdGgoZSkpe2xldCBzPW5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KG8uc2xpY2UoZS5sZW5ndGgpKSk7cy5ob3N0bmFtZT09PW4uaG9zdCYmcy5wb3J0PT09YCR7bi5wb3J0fWA/KHMuc2VhcmNoUGFyYW1zLnNldChcInRcIixEYXRlLm5vdygpLnRvU3RyaW5nKCkpLHQucmVzcG9uZFdpdGgoZmV0Y2gocykudGhlbihyPT5uZXcgUmVzcG9uc2Uoci5ib2R5LHtoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOnIuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik/P1widGV4dC9qYXZhc2NyaXB0XCJ9fSkpKSk6dC5yZXNwb25kV2l0aChuZXcgUmVzcG9uc2UoXCJQbGFzbW8gSE1SXCIse3N0YXR1czoyMDAsc3RhdHVzVGV4dDpcIlRlc3RpbmdcIn0pKX19KX1mdW5jdGlvbiBFKGUsdCl7bGV0e21vZHVsZXM6b309ZTtyZXR1cm4gbz8hIW9bdF06ITF9ZnVuY3Rpb24gQyhlPWQoKSl7bGV0IHQ9eCgpO3JldHVybmAke24uc2VjdXJlfHxsb2NhdGlvbi5wcm90b2NvbD09PVwiaHR0cHM6XCImJiEvbG9jYWxob3N0fDEyNy4wLjAuMXwwLjAuMC4wLy50ZXN0KHQpP1wid3NzXCI6XCJ3c1wifTovLyR7dH06JHtlfS9gfWZ1bmN0aW9uIEwoZSl7dHlwZW9mIGUubWVzc2FnZT09XCJzdHJpbmdcIiYmeShcIltwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBcIitlLm1lc3NhZ2UpfWZ1bmN0aW9uIFQoZSl7aWYodHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0PlwidVwiKXJldHVybjtsZXQgdD1uZXcgV2ViU29ja2V0KEMoTnVtYmVyKGQoKSkrMSkpO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYXN5bmMgZnVuY3Rpb24obyl7bGV0IHM9SlNPTi5wYXJzZShvLmRhdGEpO2F3YWl0IGUocyl9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLEwpLHR9ZnVuY3Rpb24gQShlKXtpZih0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQ+XCJ1XCIpcmV0dXJuO2xldCB0PW5ldyBXZWJTb2NrZXQoQygpKTtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGFzeW5jIGZ1bmN0aW9uKG8pe2xldCBzPUpTT04ucGFyc2Uoby5kYXRhKTtpZihzLnR5cGU9PT1cInVwZGF0ZVwiJiZhd2FpdCBlKHMuYXNzZXRzKSxzLnR5cGU9PT1cImVycm9yXCIpZm9yKGxldCByIG9mIHMuZGlhZ25vc3RpY3MuYW5zaSl7bGV0IGw9ci5jb2RlZnJhbWV8fHIuc3RhY2s7ZihcIltwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBcIityLm1lc3NhZ2UrYFxuYCtsK2BcblxuYCtyLmhpbnRzLmpvaW4oYFxuYCkpfX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsTCksdC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCgpPT57dihgW3BsYXNtby9wYXJjZWwtcnVudGltZV06IENvbm5lY3RlZCB0byBITVIgc2VydmVyIGZvciAke24uZW50cnlGaWxlUGF0aH1gKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsKCk9PntmKGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGlvbiB0byB0aGUgSE1SIHNlcnZlciBpcyBjbG9zZWQgZm9yICR7bi5lbnRyeUZpbGVQYXRofWApfSksdH12YXIgdz1tb2R1bGUuYnVuZGxlLnBhcmVudCxhPXtidWlsZFJlYWR5OiExLGJnQ2hhbmdlZDohMSxjc0NoYW5nZWQ6ITEscGFnZUNoYW5nZWQ6ITEsc2NyaXB0UG9ydHM6bmV3IFNldCxwYWdlUG9ydHM6bmV3IFNldH07YXN5bmMgZnVuY3Rpb24gcChlPSExKXtpZihlfHxhLmJ1aWxkUmVhZHkmJmEucGFnZUNoYW5nZWQpe2koXCJCR1NXIFJ1bnRpbWUgLSByZWxvYWRpbmcgUGFnZVwiKTtmb3IobGV0IHQgb2YgYS5wYWdlUG9ydHMpdC5wb3N0TWVzc2FnZShudWxsKX1pZihlfHxhLmJ1aWxkUmVhZHkmJihhLmJnQ2hhbmdlZHx8YS5jc0NoYW5nZWQpKXtpKFwiQkdTVyBSdW50aW1lIC0gcmVsb2FkaW5nIENTXCIpO2xldCB0PWF3YWl0IGM/LnRhYnMucXVlcnkoe2FjdGl2ZTohMH0pO2ZvcihsZXQgbyBvZiBhLnNjcmlwdFBvcnRzKXtsZXQgcz10LnNvbWUocj0+ci5pZD09PW8uc2VuZGVyLnRhYj8uaWQpO28ucG9zdE1lc3NhZ2Uoe19fcGxhc21vX2NzX2FjdGl2ZV90YWJfXzpzfSl9Yy5ydW50aW1lLnJlbG9hZCgpfX1pZighd3x8IXcuaXNQYXJjZWxSZXF1aXJlKXtiKCk7bGV0IGU9QShhc3luYyB0PT57aShcIkJHU1cgUnVudGltZSAtIE9uIEhNUiBVcGRhdGVcIiksYS5iZ0NoYW5nZWR8fD10LmZpbHRlcihzPT5zLmVudkhhc2g9PT1uLmVudkhhc2gpLnNvbWUocz0+RShtb2R1bGUuYnVuZGxlLHMuaWQpKTtsZXQgbz10LmZpbmQocz0+cy50eXBlPT09XCJqc29uXCIpO2lmKG8pe2xldCBzPW5ldyBTZXQodC5tYXAobD0+bC5pZCkpLHI9T2JqZWN0LnZhbHVlcyhvLmRlcHNCeUJ1bmRsZSkubWFwKGw9Pk9iamVjdC52YWx1ZXMobCkpLmZsYXQoKTthLmJnQ2hhbmdlZHx8PXIuZXZlcnkobD0+cy5oYXMobCkpfXAoKX0pO2UuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwoKT0+e2xldCB0PXNldEludGVydmFsKCgpPT5lLnNlbmQoXCJwaW5nXCIpLDI0ZTMpO2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsKCk9PmNsZWFySW50ZXJ2YWwodCkpfSksZS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIixhc3luYygpPT57YXdhaXQgaygpLHAoITApfSl9VChhc3luYyBlPT57c3dpdGNoKGkoXCJCR1NXIFJ1bnRpbWUgLSBPbiBCdWlsZCBSZXBhY2thZ2VkXCIpLGUudHlwZSl7Y2FzZVwiYnVpbGRfcmVhZHlcIjp7YS5idWlsZFJlYWR5fHw9ITAscCgpO2JyZWFrfWNhc2VcImNzX2NoYW5nZWRcIjp7YS5jc0NoYW5nZWR8fD0hMCxwKCk7YnJlYWt9fX0pO2MucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIoZnVuY3Rpb24oZSl7bGV0IHQ9ZS5uYW1lLnN0YXJ0c1dpdGgoUCksbz1lLm5hbWUuc3RhcnRzV2l0aChTKTtpZih0fHxvKXtsZXQgcz10P2EucGFnZVBvcnRzOmEuc2NyaXB0UG9ydHM7cy5hZGQoZSksZS5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoKCk9PntzLmRlbGV0ZShlKX0pLGUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHIpe2koXCJCR1NXIFJ1bnRpbWUgLSBPbiBzb3VyY2UgY2hhbmdlZFwiLHIpLHIuX19wbGFzbW9fY3NfY2hhbmdlZF9fJiYoYS5jc0NoYW5nZWR8fD0hMCksci5fX3BsYXNtb19wYWdlX2NoYW5nZWRfXyYmKGEucGFnZUNoYW5nZWR8fD0hMCkscCgpfSl9fSk7Yy5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3BsYXNtb19mdWxsX3JlbG9hZF9fJiYoaShcIkJHU1cgUnVudGltZSAtIE9uIHRvcC1sZXZlbCBjb2RlIGNoYW5nZWRcIikscCgpKSwhMH0pO1xuIiwiaW1wb3J0IFwiLi4vLi4vLi4vc3JjL2JhY2tncm91bmRcIiIsIi8qKlxuICogTVYzIEJhY2tncm91bmQgU2VydmljZSBXb3JrZXIgLSBNYWluIEVudHJ5IFBvaW50XG4gKiBcbiAqIEhhbmRsZXM6XG4gKiAtIFNpZGUgcGFuZWwgaW5pdGlhbGl6YXRpb25cbiAqIC0gRXh0ZW5zaW9uIGxpZmVjeWNsZSBldmVudHNcbiAqIC0gTm90aW9uIE1DUCBPQXV0aCBhbmQgU1NFIGNvbm5lY3Rpb25cbiAqL1xuXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9jbGllbnQvaW5kZXguanNcIjtcbmltcG9ydCB7IFNTRUNsaWVudFRyYW5zcG9ydCB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2NsaWVudC9zc2UuanNcIjtcbmltcG9ydCB7IE1jcFNTRUNsaWVudCB9IGZyb20gJy4vbWNwL25vdGlvbkNsaWVudCc7XG5pbXBvcnQge1xuICAgIHJlZ2lzdGVyRHluYW1pY0NsaWVudCxcbiAgICBnZW5lcmF0ZVN0YXRlLFxuICAgIGNyZWF0ZUNvZGVWZXJpZmllcixcbiAgICBidWlsZEF1dGhVcmwsXG4gICAgZXhjaGFuZ2VDb2RlRm9yVG9rZW5zLFxuICAgIHJlZnJlc2hBY2Nlc3NUb2tlbixcbiAgICBpc1Rva2VuRXhwaXJlZCxcbiAgICBzdG9yZVRva2VucyxcbiAgICBnZXRTdG9yZWRUb2tlbnMsXG4gICAgY2xlYXJUb2tlbnMsXG4gICAgc3RvcmVDbGllbnRDcmVkZW50aWFscyxcbiAgICBnZXRTdG9yZWRDbGllbnRDcmVkZW50aWFscyxcbiAgICBjbGVhckNsaWVudENyZWRlbnRpYWxzLFxuICAgIHR5cGUgRHluYW1pY0NsaWVudENyZWRlbnRpYWxzXG59IGZyb20gJy4vbWNwL29hdXRoJztcbmltcG9ydCB0eXBlIHtcbiAgICBOb3Rpb25PQXV0aFRva2VucyxcbiAgICBPQXV0aFN0YXRlLFxuICAgIE5vdGlvbk1jcFN0YXR1cyxcbiAgICBOb3Rpb25NY3BNZXNzYWdlLFxuICAgIE5vdGlvbk1jcFJlc3BvbnNlLFxuICAgIE1jcE1lc3NhZ2Vcbn0gZnJvbSAnLi9tY3AvdHlwZXMnO1xuaW1wb3J0IHsgTk9USU9OX0NPTkZJRyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTm90aW9uIE1DUCBTdGF0ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5sZXQgbm90aW9uTWNwQ2xpZW50OiBNY3BTU0VDbGllbnQgfCBudWxsID0gbnVsbDtcbmxldCBub3Rpb25Ub2tlbnM6IE5vdGlvbk9BdXRoVG9rZW5zIHwgbnVsbCA9IG51bGw7XG5sZXQgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHM6IER5bmFtaWNDbGllbnRDcmVkZW50aWFscyB8IG51bGwgPSBudWxsO1xubGV0IG9hdXRoU3RhdGU6IE9BdXRoU3RhdGUgfCBudWxsID0gbnVsbDtcbmxldCBub3Rpb25TdGF0dXM6IE5vdGlvbk1jcFN0YXR1cyA9IHsgc3RhdGU6ICdkaXNjb25uZWN0ZWQnIH07XG5sZXQgaXNFbmFibGVkID0gZmFsc2U7XG5cblxuXG4vKipcbiAqIFN0YXJ0IE9BdXRoIGZsb3cgZm9yIE5vdGlvbiBNQ1Agd2l0aCBkeW5hbWljIGNsaWVudCByZWdpc3RyYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhcnROb3Rpb25BdXRoKCk6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFN0YXJ0aW5nIE5vdGlvbiBPQXV0aCBmbG93IHdpdGggZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uJyk7XG5cbiAgICAgICAgLy8gU3RlcCAxOiBSZWdpc3RlciBhIGR5bmFtaWMgY2xpZW50XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUmVnaXN0ZXJpbmcgZHluYW1pYyBjbGllbnQuLi4nKTtcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ3JlZ2lzdGVyaW5nJyB9O1xuICAgICAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcblxuICAgICAgICBjb25zdCBjbGllbnRDcmVkZW50aWFscyA9IGF3YWl0IHJlZ2lzdGVyRHluYW1pY0NsaWVudChOT1RJT05fQ09ORklHLk9BVVRIX1JFRElSRUNUX1VSSSk7XG5cbiAgICAgICAgLy8gU3RvcmUgY2xpZW50IGNyZWRlbnRpYWxzXG4gICAgICAgIG5vdGlvbkNsaWVudENyZWRlbnRpYWxzID0gY2xpZW50Q3JlZGVudGlhbHM7XG4gICAgICAgIGF3YWl0IHN0b3JlQ2xpZW50Q3JlZGVudGlhbHMoY2xpZW50Q3JlZGVudGlhbHMpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gRHluYW1pYyBjbGllbnQgcmVnaXN0ZXJlZDonLCBjbGllbnRDcmVkZW50aWFscy5jbGllbnRfaWQpO1xuXG4gICAgICAgIC8vIFN0ZXAgMjogR2VuZXJhdGUgc3RhdGUgZm9yIENTUkYgcHJvdGVjdGlvblxuICAgICAgICBjb25zdCBzdGF0ZSA9IGdlbmVyYXRlU3RhdGUoKTtcblxuICAgICAgICAvLyBTdG9yZSBzdGF0ZSBpbiBtZW1vcnkgZm9yIHRoZSBjYWxsYmFja1xuICAgICAgICBvYXV0aFN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBjb2RlVmVyaWZpZXI6ICcnLCAvLyBOb3QgbmVlZGVkIGZvciBzdGFuZGFyZCBPQXV0aFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN0ZXAgMzogQnVpbGQgYXV0aG9yaXphdGlvbiBVUkwgdXNpbmcgdGhlIGR5bmFtaWMgY2xpZW50IElEXG4gICAgICAgIGNvbnN0IGF1dGhVcmwgPSBidWlsZEF1dGhVcmwoXG4gICAgICAgICAgICBjbGllbnRDcmVkZW50aWFscy5jbGllbnRfaWQsXG4gICAgICAgICAgICBOT1RJT05fQ09ORklHLk9BVVRIX1JFRElSRUNUX1VSSSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBMYXVuY2hpbmcgT0F1dGggd2l0aCBVUkw6JywgYXV0aFVybCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgICBub3Rpb25TdGF0dXMgPSB7IHN0YXRlOiAnYXV0aG9yaXppbmcnIH07XG4gICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xuXG4gICAgICAgIC8vIFN0ZXAgNDogTGF1bmNoIE9BdXRoIGZsb3cgdXNpbmcgQ2hyb21lIElkZW50aXR5IEFQSVxuICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IGF3YWl0IGNocm9tZS5pZGVudGl0eS5sYXVuY2hXZWJBdXRoRmxvdyh7XG4gICAgICAgICAgICB1cmw6IGF1dGhVcmwsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlZGlyZWN0VXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09BdXRoIGZsb3cgY2FuY2VsbGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIE9BdXRoIHJlZGlyZWN0IFVSTDonLCByZWRpcmVjdFVybCk7XG5cbiAgICAgICAgLy8gU3RlcCA1OiBFeHRyYWN0IGNvZGUgYW5kIHN0YXRlIGZyb20gcmVkaXJlY3QgVVJMXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICBjb25zdCBjb2RlID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2NvZGUnKTtcbiAgICAgICAgY29uc3QgcmV0dXJuZWRTdGF0ZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdzdGF0ZScpO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGNvZGUgcmVjZWl2ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSBzdGF0ZVxuICAgICAgICBpZiAoIW9hdXRoU3RhdGUgfHwgcmV0dXJuZWRTdGF0ZSAhPT0gb2F1dGhTdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBtaXNtYXRjaCAtIHBvc3NpYmxlIENTUkYgYXR0YWNrJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIEV4Y2hhbmdpbmcgY29kZSBmb3IgdG9rZW5zJyk7XG5cbiAgICAgICAgLy8gU3RlcCA2OiBFeGNoYW5nZSBjb2RlIGZvciB0b2tlbnMgdXNpbmcgZHluYW1pYyBjbGllbnQgY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgZXhjaGFuZ2VDb2RlRm9yVG9rZW5zKFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGNsaWVudENyZWRlbnRpYWxzLmNsaWVudF9pZCxcbiAgICAgICAgICAgIGNsaWVudENyZWRlbnRpYWxzLmNsaWVudF9zZWNyZXQsXG4gICAgICAgICAgICBOT1RJT05fQ09ORklHLk9BVVRIX1JFRElSRUNUX1VSSVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0b3JlIHRva2Vuc1xuICAgICAgICBub3Rpb25Ub2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIGF3YWl0IHN0b3JlVG9rZW5zKHRva2Vucyk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBUb2tlbnMgc3RvcmVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2F1dGhlbnRpY2F0ZWQnIH07XG4gICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gTm90aW9uIE1DUCBPQXV0aCBzdWNjZXNzZnVsJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBzdGF0ZTogJ2F1dGhlbnRpY2F0ZWQnIH0gfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gTm90aW9uIE1DUCBPQXV0aCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIG5vdGlvblN0YXR1cyA9IHtcbiAgICAgICAgICAgIHN0YXRlOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCdcbiAgICAgICAgfTtcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXG4gICAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgb2F1dGhTdGF0ZSA9IG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlZnJlc2ggTm90aW9uIGFjY2VzcyB0b2tlblxuICovXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoTm90aW9uVG9rZW4oKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFub3Rpb25Ub2tlbnM/LnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIE5vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgICAgIG5vdGlvblN0YXR1cyA9IHsgc3RhdGU6ICduZWVkcy1hdXRoJywgZXJyb3I6ICdObyByZWZyZXNoIHRva2VuJyB9O1xuICAgICAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIExvYWQgY2xpZW50IGNyZWRlbnRpYWxzIGlmIG5vdCBpbiBtZW1vcnlcbiAgICBpZiAoIW5vdGlvbkNsaWVudENyZWRlbnRpYWxzKSB7XG4gICAgICAgIG5vdGlvbkNsaWVudENyZWRlbnRpYWxzID0gYXdhaXQgZ2V0U3RvcmVkQ2xpZW50Q3JlZGVudGlhbHMoKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vdGlvbkNsaWVudENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBObyBjbGllbnQgY3JlZGVudGlhbHMgYXZhaWxhYmxlIGZvciB0b2tlbiByZWZyZXNoJyk7XG4gICAgICAgIG5vdGlvblN0YXR1cyA9IHsgc3RhdGU6ICduZWVkcy1hdXRoJywgZXJyb3I6ICdObyBjbGllbnQgY3JlZGVudGlhbHMnIH07XG4gICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBSZWZyZXNoaW5nIE5vdGlvbiB0b2tlbicpO1xuICAgICAgICBub3Rpb25TdGF0dXMgPSB7IHN0YXRlOiAndG9rZW4tcmVmcmVzaCcgfTtcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG5cbiAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gYXdhaXQgcmVmcmVzaEFjY2Vzc1Rva2VuKFxuICAgICAgICAgICAgbm90aW9uVG9rZW5zLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscy5jbGllbnRfaWQsXG4gICAgICAgICAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscy5jbGllbnRfc2VjcmV0XG4gICAgICAgICk7XG4gICAgICAgIG5vdGlvblRva2VucyA9IG5ld1Rva2VucztcbiAgICAgICAgYXdhaXQgc3RvcmVUb2tlbnMobmV3VG9rZW5zKTtcblxuICAgICAgICBub3Rpb25TdGF0dXMgPSB7IHN0YXRlOiAnYXV0aGVudGljYXRlZCcgfTtcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBUb2tlbiByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBUb2tlbiByZWZyZXNoIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgIC8vIENsZWFyIGludmFsaWQgdG9rZW5zXG4gICAgICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XG4gICAgICAgIG5vdGlvblRva2VucyA9IG51bGw7XG4gICAgICAgIG5vdGlvblN0YXR1cyA9IHtcbiAgICAgICAgICAgIHN0YXRlOiAnbmVlZHMtYXV0aCcsXG4gICAgICAgICAgICBlcnJvcjogJ1Rva2VuIHJlZnJlc2ggZmFpbGVkLiBQbGVhc2UgcmUtYXV0aGVudGljYXRlLidcbiAgICAgICAgfTtcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBhY2Nlc3MgdG9rZW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5zdXJlVmFsaWRUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIW5vdGlvblRva2Vucykge1xuICAgICAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIHN0b3JhZ2VcbiAgICAgICAgbm90aW9uVG9rZW5zID0gYXdhaXQgZ2V0U3RvcmVkVG9rZW5zKCk7XG4gICAgfVxuXG4gICAgaWYgKCFub3Rpb25Ub2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgZXhwaXJlZFxuICAgIGlmIChpc1Rva2VuRXhwaXJlZChub3Rpb25Ub2tlbnMpKSB7XG4gICAgICAgIC8vIGNvbnN0IHJlZnJlc2hlZCA9IGF3YWl0IHJlZnJlc2hOb3Rpb25Ub2tlbigpO1xuICAgICAgICAvLyBpZiAoIXJlZnJlc2hlZCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm90aW9uVG9rZW5zLmFjY2Vzc190b2tlbjtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTm90aW9uIE1DUCBDb25uZWN0aW9uIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIENvbm5lY3QgdG8gTm90aW9uIE1DUCBzZXJ2ZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29ubmVjdE5vdGlvbk1jcCgpOiBQcm9taXNlPE5vdGlvbk1jcFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBDb25uZWN0aW5nIHRvIE5vdGlvbiBNQ1AnKTtcblxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IGVuc3VyZVZhbGlkVG9rZW4oKTtcbiAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBTU0UgY2xpZW50XG4gICAgICAgIG5vdGlvbk1jcENsaWVudCA9IG5ldyBNY3BTU0VDbGllbnQoXG4gICAgICAgICAgICBOT1RJT05fQ09ORklHLk1DUF9TU0VfVVJMLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2U6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdG9rZW4gZXhwaXJ5IChidXQgbm90IGZvcm1hdCBlcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuc3RhdGUgPT09ICduZWVkcy1hdXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlVG9rZW5FeHBpcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMuc3RhdGUgPT09ICdpbnZhbGlkLXRva2VuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9rZW4gZm9ybWF0IGlzIGludmFsaWQgLSBjbGVhciB0b2tlbnMgYW5kIHJlcXVpcmUgcmUtYXV0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlSW52YWxpZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBNQ1AgbWVzc2FnZTonLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ29ubmVjdFxuICAgICAgICBhd2FpdCBub3Rpb25NY3BDbGllbnQuY29ubmVjdCgpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgTUNQIHByb3RvY29sXG4gICAgICAgIGF3YWl0IG5vdGlvbk1jcENsaWVudC5pbml0aWFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbm90aW9uTWNwQ2xpZW50LmdldFN0YXR1cygpIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIE5vdGlvbiBNQ1AgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDb25uZWN0aW9uIGZhaWxlZCdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogRGlzY29ubmVjdCBmcm9tIE5vdGlvbiBNQ1Agc2VydmVyXG4gKi9cbmZ1bmN0aW9uIGRpc2Nvbm5lY3ROb3Rpb25NY3AoKTogdm9pZCB7XG4gICAgaWYgKG5vdGlvbk1jcENsaWVudCkge1xuICAgICAgICBub3Rpb25NY3BDbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBub3Rpb25NY3BDbGllbnQgPSBudWxsO1xuICAgIH1cbiAgICBub3Rpb25TdGF0dXMgPSB7IHN0YXRlOiAnYXV0aGVudGljYXRlZCcgfTtcbiAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdG9rZW4gZXhwaXJ5IC0gYXR0ZW1wdCByZWZyZXNoIGFuZCByZWNvbm5lY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVG9rZW5FeHBpcnkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBIYW5kbGluZyB0b2tlbiBleHBpcnknKTtcblxuICAgIC8vIERpc2Nvbm5lY3QgY3VycmVudCBjbGllbnRcbiAgICBpZiAobm90aW9uTWNwQ2xpZW50KSB7XG4gICAgICAgIG5vdGlvbk1jcENsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIG5vdGlvbk1jcENsaWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIHJlZnJlc2hcbiAgICBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCByZWZyZXNoTm90aW9uVG9rZW4oKTtcblxuICAgIC8vIElmIGVuYWJsZWQgYW5kIHJlZnJlc2ggc3VjY2VlZGVkLCByZWNvbm5lY3RcbiAgICBpZiAocmVmcmVzaGVkICYmIGlzRW5hYmxlZCkge1xuICAgICAgICBhd2FpdCBjb25uZWN0Tm90aW9uTWNwKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBpbnZhbGlkIHRva2VuIGZvcm1hdCAtIGNsZWFyIHRva2VucyBhbmQgcmVxdWlyZSByZS1hdXRoXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUludmFsaWRUb2tlbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIEhhbmRsaW5nIGludmFsaWQgdG9rZW4gZm9ybWF0Jyk7XG5cbiAgICAvLyBEaXNjb25uZWN0IGN1cnJlbnQgY2xpZW50XG4gICAgaWYgKG5vdGlvbk1jcENsaWVudCkge1xuICAgICAgICBub3Rpb25NY3BDbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBub3Rpb25NY3BDbGllbnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGludmFsaWQgdG9rZW5zIGFuZCBjbGllbnQgY3JlZGVudGlhbHMgLSBkb24ndCB0cnkgdG8gcmVmcmVzaFxuICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XG4gICAgYXdhaXQgY2xlYXJDbGllbnRDcmVkZW50aWFscygpO1xuICAgIG5vdGlvblRva2VucyA9IG51bGw7XG4gICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMgPSBudWxsO1xuICAgIG5vdGlvblN0YXR1cyA9IHtcbiAgICAgICAgc3RhdGU6ICdpbnZhbGlkLXRva2VuJyxcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIHRva2VuIGZvcm1hdCAtIHBsZWFzZSByZS1hdXRoZW50aWNhdGUnXG4gICAgfTtcbiAgICBpc0VuYWJsZWQgPSBmYWxzZTtcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyAnbWNwLm5vdGlvbi5lbmFibGVkJzogZmFsc2UgfSk7XG4gICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG59XG5cbi8qKlxuICogRW5hYmxlIE5vdGlvbiBNQ1AgKGNvbm5lY3QgaWYgYXV0aGVudGljYXRlZClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTm90aW9uTWNwKCk6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcbiAgICBpc0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgLy8gU3RvcmUgZW5hYmxlZCBzdGF0ZVxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7ICdtY3Aubm90aW9uLmVuYWJsZWQnOiB0cnVlIH0pO1xuXG4gICAgLy8gSWYgYWxyZWFkeSBjb25uZWN0ZWQsIHBlcmZvcm0gaGVhbHRoIGNoZWNrXG4gICAgaWYgKG5vdGlvbk1jcENsaWVudCAmJiBub3Rpb25TdGF0dXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQWxyZWFkeSBjb25uZWN0ZWQsIHBlcmZvcm1pbmcgaGVhbHRoIGNoZWNrJyk7XG4gICAgICAgIGNvbnN0IGhlYWx0aENoZWNrID0gYXdhaXQgcGVyZm9ybUhlYWx0aENoZWNrKCk7XG5cbiAgICAgICAgaWYgKGhlYWx0aENoZWNrLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5vdGlvblN0YXR1cyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQmFja2dyb3VuZF0gSGVhbHRoIGNoZWNrIGZhaWxlZCwgcmVjb25uZWN0aW5nLi4uJywgaGVhbHRoQ2hlY2suZXJyb3IpO1xuICAgICAgICAgICAgLy8gSGVhbHRoIGNoZWNrIGZhaWxlZCwgdHJ5IHRvIHJlY29ubmVjdFxuICAgICAgICAgICAgZGlzY29ubmVjdE5vdGlvbk1jcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYXV0aGVudGljYXRlZCwgY29ubmVjdFxuICAgIGlmIChub3Rpb25Ub2tlbnMgfHwgYXdhaXQgZ2V0U3RvcmVkVG9rZW5zKCkpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdFJlc3VsdCA9IGF3YWl0IGNvbm5lY3ROb3Rpb25NY3AoKTtcblxuICAgICAgICAvLyBJZiBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwsIHBlcmZvcm0gaGVhbHRoIGNoZWNrXG4gICAgICAgIGlmIChjb25uZWN0UmVzdWx0LnN1Y2Nlc3MgJiYgbm90aW9uTWNwQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIENvbm5lY3Rpb24gc3VjY2Vzc2Z1bCwgcGVyZm9ybWluZyBoZWFsdGggY2hlY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aENoZWNrID0gYXdhaXQgcGVyZm9ybUhlYWx0aENoZWNrKCk7XG5cbiAgICAgICAgICAgIGlmICghaGVhbHRoQ2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBmYWlsZWQgYWZ0ZXIgY29ubmVjdGlvbjonLCBoZWFsdGhDaGVjay5lcnJvcik7XG4gICAgICAgICAgICAgICAgbm90aW9uU3RhdHVzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub3Rpb25TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQ29ubmVjdGVkIGJ1dCBoZWFsdGggY2hlY2sgZmFpbGVkOiAke2hlYWx0aENoZWNrLmVycm9yfWBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBwYXNzZWQ6JywgaGVhbHRoQ2hlY2suZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29ubmVjdFJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIG5lZWQgYXV0aFxuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLiBQbGVhc2UgY29ubmVjdCBmaXJzdC4nXG4gICAgfTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlIE5vdGlvbiBNQ1AgKGRpc2Nvbm5lY3QpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVOb3Rpb25NY3AoKTogUHJvbWlzZTxOb3Rpb25NY3BSZXNwb25zZT4ge1xuICAgIGlzRW5hYmxlZCA9IGZhbHNlO1xuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7ICdtY3Aubm90aW9uLmVuYWJsZWQnOiBmYWxzZSB9KTtcbiAgICBkaXNjb25uZWN0Tm90aW9uTWNwKCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xufVxuXG4vKipcbiAqIERpc2Nvbm5lY3QgYW5kIGNsZWFyIGF1dGhlbnRpY2F0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3ROb3Rpb25BdXRoKCk6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcbiAgICBkaXNjb25uZWN0Tm90aW9uTWNwKCk7XG4gICAgYXdhaXQgY2xlYXJUb2tlbnMoKTtcbiAgICBhd2FpdCBjbGVhckNsaWVudENyZWRlbnRpYWxzKCk7XG4gICAgbm90aW9uVG9rZW5zID0gbnVsbDtcbiAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscyA9IG51bGw7XG4gICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICBpc0VuYWJsZWQgPSBmYWxzZTtcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyAnbWNwLm5vdGlvbi5lbmFibGVkJzogZmFsc2UgfSk7XG4gICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xufVxuXG4vKipcbiAqIEdldCBjdXJyZW50IE5vdGlvbiBNQ1Agc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIGdldE5vdGlvblN0YXR1cygpOiBOb3Rpb25NY3BTdGF0dXMge1xuICAgIHJldHVybiBub3Rpb25TdGF0dXM7XG59XG5cbi8qKlxuICogUGVyZm9ybSBoZWFsdGggY2hlY2sgb24gTm90aW9uIE1DUCBjb25uZWN0aW9uIHVzaW5nIG9mZmljaWFsIE1DUCBTREtcbiAqIFZhbGlkYXRlcyBjb25uZWN0aW9uIGFuZCByZXRyaWV2ZXMgYXZhaWxhYmxlIHRvb2xzXG4gKiBTaW1pbGFyIHRvOiBodHRwczovL21vZGVsY29udGV4dHByb3RvY29sLmlvL2RvY3MvdG9vbHMvY2xpZW50c1xuICovXG5hc3luYyBmdW5jdGlvbiBwZXJmb3JtSGVhbHRoQ2hlY2soKTogUHJvbWlzZTxOb3Rpb25NY3BSZXNwb25zZT4ge1xuICAgIGxldCBjbGllbnQ6IENsaWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUGVyZm9ybWluZyBOb3Rpb24gTUNQIGhlYWx0aCBjaGVjayB3aXRoIFNESycpO1xuXG4gICAgICAgIC8vIEdldCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCBlbnN1cmVWYWxpZFRva2VuKCk7XG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdObyB2YWxpZCBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoTk9USU9OX0NPTkZJRy5NQ1BfU1NFX1VSTCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBNQ1AgY2xpZW50XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hyb21lLWFpLWhlYWx0aC1jaGVjaycsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAgICAgICAgICAgICByb290czogeyBsaXN0Q2hhbmdlZDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQ29ubmVjdGluZyB0byBNQ1Agc2VydmVyIHdpdGggU1NFIHRyYW5zcG9ydC4uLicpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgU1NFIHRyYW5zcG9ydCB3aXRoIGF1dGhvcml6YXRpb25cbiAgICAgICAgICAgIC8vIFVzZSByZXF1ZXN0SW5pdCB0byBhZGQgQXV0aG9yaXphdGlvbiBoZWFkZXIgdG8gUE9TVCByZXF1ZXN0c1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFNTRUNsaWVudFRyYW5zcG9ydCh1cmwsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SW5pdDoge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2V2ZW50LXN0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSBmZXRjaCB0byBhZGQgQXV0aG9yaXphdGlvbiBoZWFkZXIgdG8gU1NFIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBmZXRjaDogYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0Py5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAndGV4dC9ldmVudC1zdHJlYW0sIGFwcGxpY2F0aW9uL2pzb24nKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jb25uZWN0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIENvbm5lY3RlZCB1c2luZyBTU0UgdHJhbnNwb3J0Jyk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0b29scyBmcm9tIHRoZSBjb25uZWN0ZWQgY2xpZW50XG4gICAgICAgICAgICBjb25zdCB0b29sc1Jlc3BvbnNlID0gYXdhaXQgY2xpZW50Lmxpc3RUb29scygpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBUb29scyByZXNwb25zZTonLCB0b29sc1Jlc3BvbnNlKTtcblxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBhZnRlciBnZXR0aW5nIHRvb2xzXG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuY2xvc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRvb2xzUmVzcG9uc2UgJiYgdG9vbHNSZXNwb25zZS50b29scykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDb3VudCA9IHRvb2xzUmVzcG9uc2UudG9vbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gSGVhbHRoIGNoZWNrIHBhc3NlZC4gVG9vbHMgYXZhaWxhYmxlOicsIHRvb2xDb3VudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogdG9vbHNSZXNwb25zZS50b29scy5tYXAodG9vbCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYTogdG9vbC5pbnB1dFNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENvdW50OiB0b29sQ291bnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ05vIHRvb2xzIGF2YWlsYWJsZSBmcm9tIHNlcnZlcidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh0cmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBmYWlsZWQ6JywgdHJhbnNwb3J0RXJyb3IpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBjbGllbnQgaWYgZXhpc3RzXG4gICAgICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gRXJyb3IgY2xvc2luZyBjbGllbnQ6JywgY2xvc2VFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0cmFuc3BvcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdHJhbnNwb3J0RXJyb3IubWVzc2FnZSA6ICdDb25uZWN0aW9uIGZhaWxlZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gSGVhbHRoIGNoZWNrIGVycm9yOicsIGVycm9yKTtcblxuICAgICAgICAvLyBDbGVhbiB1cCBjbGllbnQgaWYgZXhpc3RzXG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsb3NlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChjbG9zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEVycm9yIGNsb3NpbmcgY2xpZW50OicsIGNsb3NlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0hlYWx0aCBjaGVjayBmYWlsZWQnXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGwgYSBOb3Rpb24gTUNQIHRvb2xcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FsbE5vdGlvblRvb2wobmFtZTogc3RyaW5nLCBhcmdzPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcbiAgICBpZiAoIW5vdGlvbk1jcENsaWVudCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdOb3QgY29ubmVjdGVkJyB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5vdGlvbk1jcENsaWVudC5jYWxsVG9vbChuYW1lLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0IH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIFRvb2wgY2FsbCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdUb29sIGNhbGwgZmFpbGVkJ1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBCcm9hZGNhc3Qgc3RhdHVzIHVwZGF0ZSB0byBhbGwgbGlzdGVuZXJzXG4gKi9cbmZ1bmN0aW9uIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdtY3Avbm90aW9uL3N0YXR1cy91cGRhdGUnLFxuICAgICAgICBwYXlsb2FkOiBub3Rpb25TdGF0dXNcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgaWYgbm8gbGlzdGVuZXJzXG4gICAgfSk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1lc3NhZ2UgSGFuZGxlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2U6IE5vdGlvbk1jcE1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSA9PiB7XG4gICAgLy8gSGFuZGxlIE5vdGlvbiBNQ1AgbWVzc2FnZXNcbiAgICBpZiAobWVzc2FnZS50eXBlPy5zdGFydHNXaXRoKCdtY3Avbm90aW9uLycpKSB7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U6IE5vdGlvbk1jcFJlc3BvbnNlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vYXV0aC9zdGFydCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RhcnROb3Rpb25BdXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbWNwL25vdGlvbi9lbmFibGUnOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGVuYWJsZU5vdGlvbk1jcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vZGlzYWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZGlzYWJsZU5vdGlvbk1jcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vZGlzY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZGlzY29ubmVjdE5vdGlvbkF1dGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtY3Avbm90aW9uL3N0YXR1cy9nZXQnOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogZ2V0Tm90aW9uU3RhdHVzKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtY3Avbm90aW9uL3Rvb2wvY2FsbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbE5vdGlvblRvb2woXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQ/Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQ/LmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vaGVhbHRoL2NoZWNrJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBwZXJmb3JtSGVhbHRoQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVW5rbm93biBtZXNzYWdlIHR5cGUnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbmRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIFdpbGwgcmVzcG9uZCBhc3luY2hyb25vdXNseVxuICAgIH1cbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSdW50aW1lIExpc3RlbmVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBHbG9iYWwgbm90aWZpY2F0aW9uIGNsaWNrIGhhbmRsZXIgZm9yIHJlbWluZGVyc1xuY2hyb21lLm5vdGlmaWNhdGlvbnMub25DbGlja2VkLmFkZExpc3RlbmVyKGFzeW5jIChub3RpZmljYXRpb25JZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghbm90aWZpY2F0aW9uSWQuc3RhcnRzV2l0aCgncmVtaW5kZXI6JykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gbm90aWZpY2F0aW9uSWQuc3BsaXQoJzonKVsxXTtcbiAgICAgICAgY29uc3QgeyByZW1pbmRlcnMgPSB7fSB9ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCdyZW1pbmRlcnMnKTtcbiAgICAgICAgY29uc3QgcmVtaW5kZXI6IFJlbWluZGVyIHwgdW5kZWZpbmVkID0gcmVtaW5kZXJzW2lkXTtcblxuICAgICAgICBpZiAocmVtaW5kZXI/LnVybCkge1xuICAgICAgICAgICAgYXdhaXQgY2hyb21lLnRhYnMuY3JlYXRlKHsgdXJsOiByZW1pbmRlci51cmwgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbnVwOiByZW1vdmUgcmVtaW5kZXIgYW5kIGNsZWFyIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAocmVtaW5kZXJzW2lkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHJlbWluZGVyc1tpZF07XG4gICAgICAgICAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyByZW1pbmRlcnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHJvbWUubm90aWZpY2F0aW9ucy5jbGVhcihub3RpZmljYXRpb25JZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEVycm9yIGhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazonLCBlcnJvcik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogRXh0ZW5zaW9uIGluc3RhbGwvdXBkYXRlIGhhbmRsZXJcbiAqL1xuY2hyb21lLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoYXN5bmMgKGRldGFpbHMpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIG9uSW5zdGFsbGVkOicsIGRldGFpbHMucmVhc29uKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIEVuYWJsZSBzaWRlIHBhbmVsIG9uIGFsbCBleGlzdGluZyB0YWJzXG4gICAgICAgIGlmIChjaHJvbWUuc2lkZVBhbmVsKSB7XG4gICAgICAgICAgICBjaHJvbWUuc2lkZVBhbmVsLnNldFBhbmVsQmVoYXZpb3IoeyBvcGVuUGFuZWxPbkFjdGlvbkNsaWNrOiB0cnVlIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBzYXZlZCBzdGF0ZVxuICAgICAgICBjb25zdCBzdG9yZWQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoWydtY3Aubm90aW9uLmVuYWJsZWQnXSk7XG4gICAgICAgIGlzRW5hYmxlZCA9IHN0b3JlZFsnbWNwLm5vdGlvbi5lbmFibGVkJ10gfHwgZmFsc2U7XG5cbiAgICAgICAgLy8gSWYgZW5hYmxlZCwgdHJ5IHRvIHJlc3RvcmUgY29ubmVjdGlvblxuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBnZXRTdG9yZWRUb2tlbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gYXdhaXQgZ2V0U3RvcmVkQ2xpZW50Q3JlZGVudGlhbHMoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbnMgJiYgY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBub3Rpb25Ub2tlbnMgPSB0b2tlbnM7XG4gICAgICAgICAgICAgICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0Tm90aW9uTWNwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFNpZGUgcGFuZWwgY29uZmlndXJlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBvbkluc3RhbGxlZCBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogRXh0ZW5zaW9uIHN0YXJ0dXAgaGFuZGxlclxuICovXG5jaHJvbWUucnVudGltZS5vblN0YXJ0dXAuYWRkTGlzdGVuZXIoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gb25TdGFydHVwIC0gRXh0ZW5zaW9uIHJlYWR5Jyk7XG5cbiAgICAvLyBMb2FkIHNhdmVkIHN0YXRlXG4gICAgY29uc3Qgc3RvcmVkID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFsnbWNwLm5vdGlvbi5lbmFibGVkJ10pO1xuICAgIGlzRW5hYmxlZCA9IHN0b3JlZFsnbWNwLm5vdGlvbi5lbmFibGVkJ10gfHwgZmFsc2U7XG5cbiAgICAvLyBJZiBlbmFibGVkLCB0cnkgdG8gcmVzdG9yZSBjb25uZWN0aW9uXG4gICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBnZXRTdG9yZWRUb2tlbnMoKTtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCBnZXRTdG9yZWRDbGllbnRDcmVkZW50aWFscygpO1xuICAgICAgICBpZiAodG9rZW5zICYmIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBub3Rpb25Ub2tlbnMgPSB0b2tlbnM7XG4gICAgICAgICAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdE5vdGlvbk1jcCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQWN0aW9uIGNsaWNrIGhhbmRsZXIgLSBvcGVuIHNpZGUgcGFuZWxcbiAqL1xuaWYgKGNocm9tZS5hY3Rpb24pIHtcbiAgICBjaHJvbWUuYWN0aW9uLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihhc3luYyAodGFiKSA9PiB7XG4gICAgICAgIGlmIChjaHJvbWUuc2lkZVBhbmVsICYmIHRhYi5pZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaHJvbWUuc2lkZVBhbmVsLm9wZW4oeyB0YWJJZDogdGFiLmlkIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gRXJyb3Igb3BlbmluZyBzaWRlIHBhbmVsOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cbi8vIENyZWF0ZSBjbGVhbnVwIGFsYXJtIChydW5zIGV2ZXJ5IGhvdXIpXG5jaHJvbWUuYWxhcm1zLmNyZWF0ZSgnY2xlYW51cC1leHBpcmVkLXNlc3Npb25zJywge1xuICAgIHBlcmlvZEluTWludXRlczogNjBcbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZW1pbmRlciBBbGFybXMgSGFuZGxlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbnRlcmZhY2UgUmVtaW5kZXIge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICB3aGVuOiBudW1iZXI7XG4gICAgdXJsPzogc3RyaW5nO1xuICAgIGNyZWF0ZWRBdDogbnVtYmVyO1xuICAgIGdlbmVyYXRlZFRpdGxlPzogc3RyaW5nO1xuICAgIGdlbmVyYXRlZERlc2NyaXB0aW9uPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEhhbmRsZSByZW1pbmRlciBhbGFybXMgLSBzaG93IG5vdGlmaWNhdGlvbiB3aGVuIHJlbWluZGVyIGZpcmVzXG4gKi9cbmNocm9tZS5hbGFybXMub25BbGFybS5hZGRMaXN0ZW5lcihhc3luYyAoYWxhcm0pID0+IHtcbiAgICAvLyBPbmx5IGhhbmRsZSByZW1pbmRlciBhbGFybXNcbiAgICBpZiAoIWFsYXJtLm5hbWUuc3RhcnRzV2l0aCgncmVtaW5kZXI6JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gYWxhcm0ubmFtZS5zcGxpdCgnOicpWzFdO1xuICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUmVtaW5kZXIgYWxhcm0gZmlyZWQ6JywgaWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2V0IHRoZSByZW1pbmRlciBmcm9tIHN0b3JhZ2VcbiAgICAgICAgY29uc3QgeyByZW1pbmRlcnMgPSB7fSB9ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCdyZW1pbmRlcnMnKTtcbiAgICAgICAgY29uc3QgcmVtaW5kZXI6IFJlbWluZGVyIHwgdW5kZWZpbmVkID0gcmVtaW5kZXJzW2lkXTtcblxuICAgICAgICBpZiAoIXJlbWluZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tCYWNrZ3JvdW5kXSBSZW1pbmRlciBub3QgZm91bmQ6JywgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiB3aXRoIEFJLWdlbmVyYXRlZCBjb250ZW50IG9yIGZhbGxiYWNrIHRvIG9yaWdpbmFsIHRpdGxlXG4gICAgICAgIGNvbnN0IHNpbXBsZUljb24gPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1OaytNOVFEd0FEaGdHQVdqUjlhd0FBQUFCSlJVNUVya0pnZ2c9PSc7XG5cbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uVGl0bGUgPSByZW1pbmRlci5nZW5lcmF0ZWRUaXRsZSB8fCAn4o+wIFJlbWluZGVyJztcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uTWVzc2FnZSA9IHJlbWluZGVyLmdlbmVyYXRlZERlc2NyaXB0aW9uIHx8IHJlbWluZGVyLnRpdGxlO1xuXG4gICAgICAgIC8vIFVzZSBhIG5hbWVzcGFjZWQgbm90aWZpY2F0aW9uIElEIHRvIGRpc3Rpbmd1aXNoIHJlbWluZGVyc1xuICAgICAgICBjaHJvbWUubm90aWZpY2F0aW9ucy5jcmVhdGUoYHJlbWluZGVyOiR7aWR9YCwge1xuICAgICAgICAgICAgdHlwZTogJ2Jhc2ljJyxcbiAgICAgICAgICAgIGljb25Vcmw6IHNpbXBsZUljb24sXG4gICAgICAgICAgICB0aXRsZTogbm90aWZpY2F0aW9uVGl0bGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBub3RpZmljYXRpb25NZXNzYWdlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDIsXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb246IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUmVtaW5kZXIgbm90aWZpY2F0aW9uIGNyZWF0ZWQ6Jywge1xuICAgICAgICAgICAgdGl0bGU6IG5vdGlmaWNhdGlvblRpdGxlLFxuICAgICAgICAgICAgbWVzc2FnZTogbm90aWZpY2F0aW9uTWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEbyBub3QgcmVtb3ZlIHRoZSByZW1pbmRlciBoZXJlOyBpdCB3aWxsIGJlIHJlbW92ZWQgYnkgdGhlIGdsb2JhbFxuICAgICAgICAvLyBub3RpZmljYXRpb24gY2xpY2sgaGFuZGxlciB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgYW5kIGVuc3VyZSB0aGVcbiAgICAgICAgLy8gY2xpY2sgaGFuZGxlciBoYXMgYWNjZXNzIHRvIHRoZSBzdG9yZWQgcmVtaW5kZXIgZGF0YS5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gRXJyb3IgaGFuZGxpbmcgcmVtaW5kZXIgYWxhcm06JywgZXJyb3IpO1xuICAgIH1cbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJbml0aWFsaXphdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFNlcnZpY2Ugd29ya2VyIGxvYWRlZCAtIENvcGlsb3RLaXQgcG93ZXJlZCBleHRlbnNpb24gcmVhZHknKTtcbmNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQnJvd3NlciBhY3Rpb25zIGV2ZW50IGxpc3RlbmVycyBpbml0aWFsaXplZCcpO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPZmZzY3JlZW4gRG9jdW1lbnQ6IFN1bW1hcml6ZXIgQnJva2VyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIEVuc3VyZSBhIHNpbmdsZSBvZmZzY3JlZW4gZG9jdW1lbnQgZXhpc3RzXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVPZmZzY3JlZW5Eb2N1bWVudCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaHJvbWUgMTE2KyBoYXMgY2hyb21lLm9mZnNjcmVlbi5oYXNEb2N1bWVudFxuICAgICAgICAvLyBGYWxsYmFjazogdHJ5IGNyZWF0aW5nIGFuZCBpZ25vcmUgaWYgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgY29uc3QgaGFzRG9jOiBib29sZWFuID0gdHlwZW9mIGNocm9tZS5vZmZzY3JlZW4/Lmhhc0RvY3VtZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNocm9tZS5vZmZzY3JlZW4uaGFzRG9jdW1lbnQoKVxuICAgICAgICAgICAgOiBmYWxzZTtcblxuICAgICAgICBpZiAoIWhhc0RvYykge1xuICAgICAgICAgICAgYXdhaXQgY2hyb21lLm9mZnNjcmVlbi5jcmVhdGVEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgdXJsOiAnb2Zmc2NyZWVuLmh0bWwnLFxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIElGUkFNRV9TQ1JJUFRJTkcgaXMgYXBwcm9wcmlhdGUgZm9yIHJ1bm5pbmcgRE9NIEFQSXMgJiBzY3JpcHRzXG4gICAgICAgICAgICAgICAgcmVhc29uczogW2Nocm9tZS5vZmZzY3JlZW4uUmVhc29uLklGUkFNRV9TQ1JJUFRJTkddLFxuICAgICAgICAgICAgICAgIGp1c3RpZmljYXRpb246ICdSdW4gQ2hyb21lIFN1bW1hcml6ZXIgQVBJIGluIGFuIGlzb2xhdGVkIG9mZnNjcmVlbiBkb2N1bWVudCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBPZmZzY3JlZW4gZG9jdW1lbnQgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gU29tZSBDaHJvbWUgdmVyc2lvbnMgdGhyb3cgaWYgYSBkb2N1bWVudCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tCYWNrZ3JvdW5kXSBlbnN1cmVPZmZzY3JlZW5Eb2N1bWVudCB3YXJuaW5nOicsIGVycm9yKTtcbiAgICB9XG59XG5cbnR5cGUgU3VtbWFyaXplQXZhaWxhYmlsaXR5TWVzc2FnZSA9IHsgdHlwZTogJ3N1bW1hcml6ZTphdmFpbGFiaWxpdHknIH07XG50eXBlIFN1bW1hcml6ZVJlcXVlc3RNZXNzYWdlID0ge1xuICAgIHR5cGU6ICdzdW1tYXJpemU6cmVxdWVzdCc7XG4gICAgcGF5bG9hZDoge1xuICAgICAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgICAgICAgdGV4dDogc3RyaW5nO1xuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgICAgdHlwZT86ICdrZXktcG9pbnRzJyB8ICd0bGRyJyB8ICd0ZWFzZXInIHwgJ2hlYWRsaW5lJztcbiAgICAgICAgICAgIGZvcm1hdD86ICdtYXJrZG93bicgfCAncGxhaW4tdGV4dCc7XG4gICAgICAgICAgICBsZW5ndGg/OiAnc2hvcnQnIHwgJ21lZGl1bScgfCAnbG9uZyc7XG4gICAgICAgICAgICBzaGFyZWRDb250ZXh0Pzogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBjb250ZXh0Pzogc3RyaW5nO1xuICAgIH07XG59O1xuXG4vLyBXaXJlIHN1bW1hcml6ZSBtZXNzYWdlcyBjb21pbmcgZnJvbSBVSSB0byB0aGUgb2Zmc2NyZWVuIGRvY3VtZW50XG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2U6IGFueSwgX3NlbmRlciwgc2VuZFJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2U/LnR5cGUgPT09ICdzdW1tYXJpemU6YXZhaWxhYmlsaXR5Jykge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZW5zdXJlT2Zmc2NyZWVuRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoeyB0eXBlOiAnb2Zmc2NyZWVuL3N1bW1hcml6ZS9hdmFpbGFiaWxpdHknIH0pO1xuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShyZXMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoeyBvazogZmFsc2UsIGNvZGU6ICdlcnJvcicsIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZT8udHlwZSA9PT0gJ3N1bW1hcml6ZTpyZXF1ZXN0Jykge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gbWVzc2FnZSBhcyBTdW1tYXJpemVSZXF1ZXN0TWVzc2FnZTtcbiAgICAgICAgICAgIGF3YWl0IGVuc3VyZU9mZnNjcmVlbkRvY3VtZW50KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29mZnNjcmVlbi9zdW1tYXJpemUvcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1zZy5wYXlsb2FkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IG9rOiBmYWxzZSwgY29kZTogJ2Vycm9yJywgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvcHJvdG9jb2wuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3QgYWp2XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFqdlwiKSk7XG4vKipcbiAqIEFuIE1DUCBjbGllbnQgb24gdG9wIG9mIGEgcGx1Z2dhYmxlIHRyYW5zcG9ydC5cbiAqXG4gKiBUaGUgY2xpZW50IHdpbGwgYXV0b21hdGljYWxseSBiZWdpbiB0aGUgaW5pdGlhbGl6YXRpb24gZmxvdyB3aXRoIHRoZSBzZXJ2ZXIgd2hlbiBjb25uZWN0KCkgaXMgY2FsbGVkLlxuICpcbiAqIFRvIHVzZSB3aXRoIGN1c3RvbSB0eXBlcywgZXh0ZW5kIHRoZSBiYXNlIFJlcXVlc3QvTm90aWZpY2F0aW9uL1Jlc3VsdCB0eXBlcyBhbmQgcGFzcyB0aGVtIGFzIHR5cGUgcGFyYW1ldGVyczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBDdXN0b20gc2NoZW1hc1xuICogY29uc3QgQ3VzdG9tUmVxdWVzdFNjaGVtYSA9IFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHsuLi59KVxuICogY29uc3QgQ3VzdG9tTm90aWZpY2F0aW9uU2NoZW1hID0gTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7Li4ufSlcbiAqIGNvbnN0IEN1c3RvbVJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoey4uLn0pXG4gKlxuICogLy8gVHlwZSBhbGlhc2VzXG4gKiB0eXBlIEN1c3RvbVJlcXVlc3QgPSB6LmluZmVyPHR5cGVvZiBDdXN0b21SZXF1ZXN0U2NoZW1hPlxuICogdHlwZSBDdXN0b21Ob3RpZmljYXRpb24gPSB6LmluZmVyPHR5cGVvZiBDdXN0b21Ob3RpZmljYXRpb25TY2hlbWE+XG4gKiB0eXBlIEN1c3RvbVJlc3VsdCA9IHouaW5mZXI8dHlwZW9mIEN1c3RvbVJlc3VsdFNjaGVtYT5cbiAqXG4gKiAvLyBDcmVhdGUgdHlwZWQgY2xpZW50XG4gKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50PEN1c3RvbVJlcXVlc3QsIEN1c3RvbU5vdGlmaWNhdGlvbiwgQ3VzdG9tUmVzdWx0Pih7XG4gKiAgIG5hbWU6IFwiQ3VzdG9tQ2xpZW50XCIsXG4gKiAgIHZlcnNpb246IFwiMS4wLjBcIlxuICogfSlcbiAqIGBgYFxuICovXG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBwcm90b2NvbF9qc18xLlByb3RvY29sIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9jbGllbnRJbmZvLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2NsaWVudEluZm8gPSBfY2xpZW50SW5mbztcbiAgICAgICAgdGhpcy5fY2FjaGVkVG9vbE91dHB1dFZhbGlkYXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXBhYmlsaXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICB0aGlzLl9hanYgPSBuZXcgYWp2XzEuZGVmYXVsdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbmV3IGNhcGFiaWxpdGllcy4gVGhpcyBjYW4gb25seSBiZSBjYWxsZWQgYmVmb3JlIGNvbm5lY3RpbmcgdG8gYSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBUaGUgbmV3IGNhcGFiaWxpdGllcyB3aWxsIGJlIG1lcmdlZCB3aXRoIGFueSBleGlzdGluZyBjYXBhYmlsaXRpZXMgcHJldmlvdXNseSBnaXZlbiAoZS5nLiwgYXQgaW5pdGlhbGl6YXRpb24pLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllcykge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGNhcGFiaWxpdGllcyBhZnRlciBjb25uZWN0aW5nIHRvIHRyYW5zcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9ICgwLCBwcm90b2NvbF9qc18xLm1lcmdlQ2FwYWJpbGl0aWVzKSh0aGlzLl9jYXBhYmlsaXRpZXMsIGNhcGFiaWxpdGllcyk7XG4gICAgfVxuICAgIGFzc2VydENhcGFiaWxpdHkoY2FwYWJpbGl0eSwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2FwYWJpbGl0eV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0ICR7Y2FwYWJpbGl0eX0gKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdCh0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuY29ubmVjdCh0cmFuc3BvcnQpO1xuICAgICAgICAvLyBXaGVuIHRyYW5zcG9ydCBzZXNzaW9uSWQgaXMgYWxyZWFkeSBzZXQgdGhpcyBtZWFucyB3ZSBhcmUgdHJ5aW5nIHRvIHJlY29ubmVjdC5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGRvbid0IG5lZWQgdG8gaW5pdGlhbGl6ZSBhZ2Fpbi5cbiAgICAgICAgaWYgKHRyYW5zcG9ydC5zZXNzaW9uSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2luaXRpYWxpemUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IHR5cGVzX2pzXzEuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogdGhpcy5fY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJbmZvOiB0aGlzLl9jbGllbnRJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHlwZXNfanNfMS5Jbml0aWFsaXplUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHNlbnQgaW52YWxpZCBpbml0aWFsaXplIHJlc3VsdDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXR5cGVzX2pzXzEuU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05TLmluY2x1ZGVzKHJlc3VsdC5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIncyBwcm90b2NvbCB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6ICR7cmVzdWx0LnByb3RvY29sVmVyc2lvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlcnZlckNhcGFiaWxpdGllcyA9IHJlc3VsdC5jYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJWZXJzaW9uID0gcmVzdWx0LnNlcnZlckluZm87XG4gICAgICAgICAgICAvLyBIVFRQIHRyYW5zcG9ydHMgbXVzdCBzZXQgdGhlIHByb3RvY29sIHZlcnNpb24gaW4gZWFjaCBoZWFkZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0LnNldFByb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZXRQcm90b2NvbFZlcnNpb24ocmVzdWx0LnByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnMgPSByZXN1bHQuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ub3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ25vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgaWYgaW5pdGlhbGl6YXRpb24gZmFpbHMuXG4gICAgICAgICAgICB2b2lkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFmdGVyIGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWQsIHRoaXMgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgc2VydmVyJ3MgcmVwb3J0ZWQgY2FwYWJpbGl0aWVzLlxuICAgICAqL1xuICAgIGdldFNlcnZlckNhcGFiaWxpdGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNhcGFiaWxpdGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZCwgdGhpcyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJ2ZXIncyBuYW1lIGFuZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGdldFNlcnZlclZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJWZXJzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZnRlciBpbml0aWFsaXphdGlvbiBoYXMgY29tcGxldGVkLCB0aGlzIG1heSBiZSBwb3B1bGF0ZWQgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VydmVyJ3MgaW5zdHJ1Y3Rpb25zLlxuICAgICAqL1xuICAgIGdldEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcbiAgICB9XG4gICAgYXNzZXJ0Q2FwYWJpbGl0eUZvck1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xvZ2dpbmcvc2V0TGV2ZWwnOlxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IHRoaXMuX3NlcnZlckNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZ2dpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgbG9nZ2luZyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcm9tcHRzL2dldCc6XG4gICAgICAgICAgICBjYXNlICdwcm9tcHRzL2xpc3QnOlxuICAgICAgICAgICAgICAgIGlmICghKChfYiA9IHRoaXMuX3NlcnZlckNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnByb21wdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvbXB0cyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZXMvbGlzdCc6XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZXMvdGVtcGxhdGVzL2xpc3QnOlxuICAgICAgICAgICAgY2FzZSAncmVzb3VyY2VzL3JlYWQnOlxuICAgICAgICAgICAgY2FzZSAncmVzb3VyY2VzL3N1YnNjcmliZSc6XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZXMvdW5zdWJzY3JpYmUnOlxuICAgICAgICAgICAgICAgIGlmICghKChfYyA9IHRoaXMuX3NlcnZlckNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc291cmNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCByZXNvdXJjZXMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdyZXNvdXJjZXMvc3Vic2NyaWJlJyAmJiAhdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzLnJlc291cmNlcy5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCByZXNvdXJjZSBzdWJzY3JpcHRpb25zIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Rvb2xzL2NhbGwnOlxuICAgICAgICAgICAgY2FzZSAndG9vbHMvbGlzdCc6XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9kID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdG9vbHMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tcGxldGlvbi9jb21wbGV0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9lID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY29tcGxldGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgY29tcGxldGlvbnMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZSc6XG4gICAgICAgICAgICAgICAgLy8gTm8gc3BlY2lmaWMgY2FwYWJpbGl0eSByZXF1aXJlZCBmb3IgaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGluZyc6XG4gICAgICAgICAgICAgICAgLy8gTm8gc3BlY2lmaWMgY2FwYWJpbGl0eSByZXF1aXJlZCBmb3IgcGluZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydE5vdGlmaWNhdGlvbkNhcGFiaWxpdHkobWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ25vdGlmaWNhdGlvbnMvcm9vdHMvbGlzdF9jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSB0aGlzLl9jYXBhYmlsaXRpZXMucm9vdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saXN0Q2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCByb290cyBsaXN0IGNoYW5nZWQgbm90aWZpY2F0aW9ucyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub3RpZmljYXRpb25zL2luaXRpYWxpemVkJzpcbiAgICAgICAgICAgICAgICAvLyBObyBzcGVjaWZpYyBjYXBhYmlsaXR5IHJlcXVpcmVkIGZvciBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9ucy9jYW5jZWxsZWQnOlxuICAgICAgICAgICAgICAgIC8vIENhbmNlbGxhdGlvbiBub3RpZmljYXRpb25zIGFyZSBhbHdheXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9ucy9wcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBhcmUgYWx3YXlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRSZXF1ZXN0SGFuZGxlckNhcGFiaWxpdHkobWV0aG9kKSB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdzYW1wbGluZy9jcmVhdGVNZXNzYWdlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcy5zYW1wbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCBkb2VzIG5vdCBzdXBwb3J0IHNhbXBsaW5nIGNhcGFiaWxpdHkgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZWxpY2l0YXRpb24vY3JlYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcy5lbGljaXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCBkb2VzIG5vdCBzdXBwb3J0IGVsaWNpdGF0aW9uIGNhcGFiaWxpdHkgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9vdHMvbGlzdCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMucm9vdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCByb290cyBjYXBhYmlsaXR5IChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICAgICAgICAgIC8vIE5vIHNwZWNpZmljIGNhcGFiaWxpdHkgcmVxdWlyZWQgZm9yIHBpbmdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3BpbmcnIH0sIHR5cGVzX2pzXzEuRW1wdHlSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjb21wbGV0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ2NvbXBsZXRpb24vY29tcGxldGUnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5Db21wbGV0ZVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNldExvZ2dpbmdMZXZlbChsZXZlbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnbG9nZ2luZy9zZXRMZXZlbCcsIHBhcmFtczogeyBsZXZlbCB9IH0sIHR5cGVzX2pzXzEuRW1wdHlSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQcm9tcHQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdwcm9tcHRzL2dldCcsIHBhcmFtcyB9LCB0eXBlc19qc18xLkdldFByb21wdFJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RQcm9tcHRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncHJvbXB0cy9saXN0JywgcGFyYW1zIH0sIHR5cGVzX2pzXzEuTGlzdFByb21wdHNSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0UmVzb3VyY2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncmVzb3VyY2VzL2xpc3QnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5MaXN0UmVzb3VyY2VzUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFJlc291cmNlVGVtcGxhdGVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncmVzb3VyY2VzL3RlbXBsYXRlcy9saXN0JywgcGFyYW1zIH0sIHR5cGVzX2pzXzEuTGlzdFJlc291cmNlVGVtcGxhdGVzUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJlc291cmNlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncmVzb3VyY2VzL3JlYWQnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5SZWFkUmVzb3VyY2VSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmVSZXNvdXJjZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3Jlc291cmNlcy9zdWJzY3JpYmUnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5FbXB0eVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVuc3Vic2NyaWJlUmVzb3VyY2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdyZXNvdXJjZXMvdW5zdWJzY3JpYmUnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5FbXB0eVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGxUb29sKHBhcmFtcywgcmVzdWx0U2NoZW1hID0gdHlwZXNfanNfMS5DYWxsVG9vbFJlc3VsdFNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICd0b29scy9jYWxsJywgcGFyYW1zIH0sIHJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0b29sIGhhcyBhbiBvdXRwdXRTY2hlbWFcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdGhpcy5nZXRUb29sT3V0cHV0VmFsaWRhdG9yKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgLy8gSWYgdG9vbCBoYXMgb3V0cHV0U2NoZW1hLCBpdCBNVVNUIHJldHVybiBzdHJ1Y3R1cmVkQ29udGVudCAodW5sZXNzIGl0J3MgYW4gZXJyb3IpXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdHJ1Y3R1cmVkQ29udGVudCAmJiAhcmVzdWx0LmlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5JbnZhbGlkUmVxdWVzdCwgYFRvb2wgJHtwYXJhbXMubmFtZX0gaGFzIGFuIG91dHB1dCBzY2hlbWEgYnV0IGRpZCBub3QgcmV0dXJuIHN0cnVjdHVyZWQgY29udGVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSB2YWxpZGF0ZSBzdHJ1Y3R1cmVkIGNvbnRlbnQgaWYgcHJlc2VudCAobm90IHdoZW4gdGhlcmUncyBhbiBlcnJvcilcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RydWN0dXJlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc3RydWN0dXJlZCBjb250ZW50ICh3aGljaCBpcyBhbHJlYWR5IGFuIG9iamVjdCkgYWdhaW5zdCB0aGUgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IocmVzdWx0LnN0cnVjdHVyZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgU3RydWN0dXJlZCBjb250ZW50IGRvZXMgbm90IG1hdGNoIHRoZSB0b29sJ3Mgb3V0cHV0IHNjaGVtYTogJHt0aGlzLl9hanYuZXJyb3JzVGV4dCh2YWxpZGF0b3IuZXJyb3JzKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgdHlwZXNfanNfMS5NY3BFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzX2pzXzEuTWNwRXJyb3IodHlwZXNfanNfMS5FcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYEZhaWxlZCB0byB2YWxpZGF0ZSBzdHJ1Y3R1cmVkIGNvbnRlbnQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYWNoZVRvb2xPdXRwdXRTY2hlbWFzKHRvb2xzKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFRvb2xPdXRwdXRWYWxpZGF0b3JzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRvb2wgaGFzIGFuIG91dHB1dFNjaGVtYSwgY3JlYXRlIGFuZCBjYWNoZSB0aGUgQWp2IHZhbGlkYXRvclxuICAgICAgICAgICAgaWYgKHRvb2wub3V0cHV0U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdGhpcy5fYWp2LmNvbXBpbGUodG9vbC5vdXRwdXRTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRUb29sT3V0cHV0VmFsaWRhdG9ycy5zZXQodG9vbC5uYW1lLCB2YWxpZGF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjaGVtYSBjb21waWxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VG9vbE91dHB1dFZhbGlkYXRvcih0b29sTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVG9vbE91dHB1dFZhbGlkYXRvcnMuZ2V0KHRvb2xOYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFRvb2xzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICd0b29scy9saXN0JywgcGFyYW1zIH0sIHR5cGVzX2pzXzEuTGlzdFRvb2xzUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHRvb2xzIGFuZCB0aGVpciBvdXRwdXQgc2NoZW1hcyBmb3IgZnV0dXJlIHZhbGlkYXRpb25cbiAgICAgICAgdGhpcy5jYWNoZVRvb2xPdXRwdXRTY2hlbWFzKHJlc3VsdC50b29scyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRSb290c0xpc3RDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb24oeyBtZXRob2Q6ICdub3RpZmljYXRpb25zL3Jvb3RzL2xpc3RfY2hhbmdlZCcgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLG51bGwsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm90b2NvbCA9IGV4cG9ydHMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVRfTVNFQyA9IHZvaWQgMDtcbmV4cG9ydHMubWVyZ2VDYXBhYmlsaXRpZXMgPSBtZXJnZUNhcGFiaWxpdGllcztcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlcXVlc3QgdGltZW91dCwgaW4gbWlsaXNlY29uZHMuXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVRfTVNFQyA9IDYwMDAwO1xuLyoqXG4gKiBJbXBsZW1lbnRzIE1DUCBwcm90b2NvbCBmcmFtaW5nIG9uIHRvcCBvZiBhIHBsdWdnYWJsZSB0cmFuc3BvcnQsIGluY2x1ZGluZ1xuICogZmVhdHVyZXMgbGlrZSByZXF1ZXN0L3Jlc3BvbnNlIGxpbmtpbmcsIG5vdGlmaWNhdGlvbnMsIGFuZCBwcm9ncmVzcy5cbiAqL1xuY2xhc3MgUHJvdG9jb2wge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcmVxdWVzdE1lc3NhZ2VJZCA9IDA7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJBYm9ydENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdGltZW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnNldE5vdGlmaWNhdGlvbkhhbmRsZXIodHlwZXNfanNfMS5DYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEsIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5fcmVxdWVzdEhhbmRsZXJBYm9ydENvbnRyb2xsZXJzLmdldChub3RpZmljYXRpb24ucGFyYW1zLnJlcXVlc3RJZCk7XG4gICAgICAgICAgICBjb250cm9sbGVyID09PSBudWxsIHx8IGNvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQobm90aWZpY2F0aW9uLnBhcmFtcy5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXROb3RpZmljYXRpb25IYW5kbGVyKHR5cGVzX2pzXzEuUHJvZ3Jlc3NOb3RpZmljYXRpb25TY2hlbWEsIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbnByb2dyZXNzKG5vdGlmaWNhdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFJlcXVlc3RIYW5kbGVyKHR5cGVzX2pzXzEuUGluZ1JlcXVlc3RTY2hlbWEsIFxuICAgICAgICAvLyBBdXRvbWF0aWMgcG9uZyBieSBkZWZhdWx0LlxuICAgICAgICBfcmVxdWVzdCA9PiAoe30pKTtcbiAgICB9XG4gICAgX3NldHVwVGltZW91dChtZXNzYWdlSWQsIHRpbWVvdXQsIG1heFRvdGFsVGltZW91dCwgb25UaW1lb3V0LCByZXNldFRpbWVvdXRPblByb2dyZXNzID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dEluZm8uc2V0KG1lc3NhZ2VJZCwge1xuICAgICAgICAgICAgdGltZW91dElkOiBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGltZW91dCksXG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgbWF4VG90YWxUaW1lb3V0LFxuICAgICAgICAgICAgcmVzZXRUaW1lb3V0T25Qcm9ncmVzcyxcbiAgICAgICAgICAgIG9uVGltZW91dFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Jlc2V0VGltZW91dChtZXNzYWdlSWQpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX3RpbWVvdXRJbmZvLmdldChtZXNzYWdlSWQpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRvdGFsRWxhcHNlZCA9IERhdGUubm93KCkgLSBpbmZvLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKGluZm8ubWF4VG90YWxUaW1lb3V0ICYmIHRvdGFsRWxhcHNlZCA+PSBpbmZvLm1heFRvdGFsVGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dEluZm8uZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5SZXF1ZXN0VGltZW91dCwgJ01heGltdW0gdG90YWwgdGltZW91dCBleGNlZWRlZCcsIHtcbiAgICAgICAgICAgICAgICBtYXhUb3RhbFRpbWVvdXQ6IGluZm8ubWF4VG90YWxUaW1lb3V0LFxuICAgICAgICAgICAgICAgIHRvdGFsRWxhcHNlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KGluZm8udGltZW91dElkKTtcbiAgICAgICAgaW5mby50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGluZm8ub25UaW1lb3V0LCBpbmZvLnRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2NsZWFudXBUaW1lb3V0KG1lc3NhZ2VJZCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5fdGltZW91dEluZm8uZ2V0KG1lc3NhZ2VJZCk7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5mby50aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dEluZm8uZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdG8gdGhlIGdpdmVuIHRyYW5zcG9ydCwgc3RhcnRzIGl0LCBhbmQgc3RhcnRzIGxpc3RlbmluZyBmb3IgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBUaGUgUHJvdG9jb2wgb2JqZWN0IGFzc3VtZXMgb3duZXJzaGlwIG9mIHRoZSBUcmFuc3BvcnQsIHJlcGxhY2luZyBhbnkgY2FsbGJhY2tzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LCBhbmQgZXhwZWN0cyB0aGF0IGl0IGlzIHRoZSBvbmx5IHVzZXIgb2YgdGhlIFRyYW5zcG9ydCBpbnN0YW5jZSBnb2luZyBmb3J3YXJkLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QodHJhbnNwb3J0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIGNvbnN0IF9vbmNsb3NlID0gKF9hID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbmNsb3NlO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIF9vbmNsb3NlID09PSBudWxsIHx8IF9vbmNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb25jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fb25jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfb25lcnJvciA9IChfYiA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub25lcnJvcjtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIF9vbmVycm9yID09PSBudWxsIHx8IF9vbmVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX29ubWVzc2FnZSA9IChfYyA9IHRoaXMuX3RyYW5zcG9ydCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm9ubWVzc2FnZTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Lm9ubWVzc2FnZSA9IChtZXNzYWdlLCBleHRyYSkgPT4ge1xuICAgICAgICAgICAgX29ubWVzc2FnZSA9PT0gbnVsbCB8fCBfb25tZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb25tZXNzYWdlKG1lc3NhZ2UsIGV4dHJhKTtcbiAgICAgICAgICAgIGlmICgoMCwgdHlwZXNfanNfMS5pc0pTT05SUENSZXNwb25zZSkobWVzc2FnZSkgfHwgKDAsIHR5cGVzX2pzXzEuaXNKU09OUlBDRXJyb3IpKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25yZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB0eXBlc19qc18xLmlzSlNPTlJQQ1JlcXVlc3QpKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25yZXF1ZXN0KG1lc3NhZ2UsIGV4dHJhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB0eXBlc19qc18xLmlzSlNPTlJQQ05vdGlmaWNhdGlvbikobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbm5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBVbmtub3duIG1lc3NhZ2UgdHlwZTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5zdGFydCgpO1xuICAgIH1cbiAgICBfb25jbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXJzID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycztcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRGVib3VuY2VkTm90aWZpY2F0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfYSA9IHRoaXMub25jbG9zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IHR5cGVzX2pzXzEuTWNwRXJyb3IodHlwZXNfanNfMS5FcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCwgJ0Nvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiByZXNwb25zZUhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25lcnJvcihlcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMub25lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgICBfb25ub3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IChfYSA9IHRoaXMuX25vdGlmaWNhdGlvbkhhbmRsZXJzLmdldChub3RpZmljYXRpb24ubWV0aG9kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5mYWxsYmFja05vdGlmaWNhdGlvbkhhbmRsZXI7XG4gICAgICAgIC8vIElnbm9yZSBub3RpZmljYXRpb25zIG5vdCBiZWluZyBzdWJzY3JpYmVkIHRvLlxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBQcm9taXNlLnJlc29sdmUoKSBwdXRzIGFueSBzeW5jaHJvbm91cyBlcnJvcnMgaW50byB0aGUgbW9uYWQgYXMgd2VsbC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGhhbmRsZXIobm90aWZpY2F0aW9uKSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgVW5jYXVnaHQgZXJyb3IgaW4gbm90aWZpY2F0aW9uIGhhbmRsZXI6ICR7ZXJyb3J9YCkpKTtcbiAgICB9XG4gICAgX29ucmVxdWVzdChyZXF1ZXN0LCBleHRyYSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gKF9hID0gdGhpcy5fcmVxdWVzdEhhbmRsZXJzLmdldChyZXF1ZXN0Lm1ldGhvZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZmFsbGJhY2tSZXF1ZXN0SGFuZGxlcjtcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgY3VycmVudCB0cmFuc3BvcnQgYXQgcmVxdWVzdCB0aW1lIHRvIGVuc3VyZSByZXNwb25zZXMgZ28gdG8gdGhlIGNvcnJlY3QgY2xpZW50XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0O1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwdHVyZWRUcmFuc3BvcnQuc2VuZCh7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdHlwZXNfanNfMS5FcnJvckNvZGUuTWV0aG9kTm90Rm91bmQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IGZvdW5kJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gc2VuZCBhbiBlcnJvciByZXNwb25zZTogJHtlcnJvcn1gKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJBYm9ydENvbnRyb2xsZXJzLnNldChyZXF1ZXN0LmlkLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBmdWxsRXh0cmEgPSB7XG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IGNhcHR1cmVkVHJhbnNwb3J0ID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zcG9ydC5zZXNzaW9uSWQsXG4gICAgICAgICAgICBfbWV0YTogKF9iID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fbWV0YSxcbiAgICAgICAgICAgIHNlbmROb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbiA9PiB0aGlzLm5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIHsgcmVsYXRlZFJlcXVlc3RJZDogcmVxdWVzdC5pZCB9KSxcbiAgICAgICAgICAgIHNlbmRSZXF1ZXN0OiAociwgcmVzdWx0U2NoZW1hLCBvcHRpb25zKSA9PiB0aGlzLnJlcXVlc3QociwgcmVzdWx0U2NoZW1hLCB7IC4uLm9wdGlvbnMsIHJlbGF0ZWRSZXF1ZXN0SWQ6IHJlcXVlc3QuaWQgfSksXG4gICAgICAgICAgICBhdXRoSW5mbzogZXh0cmEgPT09IG51bGwgfHwgZXh0cmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dHJhLmF1dGhJbmZvLFxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0LmlkLFxuICAgICAgICAgICAgcmVxdWVzdEluZm86IGV4dHJhID09PSBudWxsIHx8IGV4dHJhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRyYS5yZXF1ZXN0SW5mb1xuICAgICAgICB9O1xuICAgICAgICAvLyBTdGFydGluZyB3aXRoIFByb21pc2UucmVzb2x2ZSgpIHB1dHMgYW55IHN5bmNocm9ub3VzIGVycm9ycyBpbnRvIHRoZSBtb25hZCBhcyB3ZWxsLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gaGFuZGxlcihyZXF1ZXN0LCBmdWxsRXh0cmEpKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FwdHVyZWRUcmFuc3BvcnQgPT09IG51bGwgfHwgY2FwdHVyZWRUcmFuc3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNwb3J0LnNlbmQoe1xuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FwdHVyZWRUcmFuc3BvcnQgPT09IG51bGwgfHwgY2FwdHVyZWRUcmFuc3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNwb3J0LnNlbmQoe1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0LmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IE51bWJlci5pc1NhZmVJbnRlZ2VyKGVycm9yWydjb2RlJ10pID8gZXJyb3JbJ2NvZGUnXSA6IHR5cGVzX2pzXzEuRXJyb3JDb2RlLkludGVybmFsRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfYSA9IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdJbnRlcm5hbCBlcnJvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIHNlbmQgcmVzcG9uc2U6ICR7ZXJyb3J9YCkpKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJBYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShyZXF1ZXN0LmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9vbnByb2dyZXNzKG5vdGlmaWNhdGlvbikge1xuICAgICAgICBjb25zdCB7IHByb2dyZXNzVG9rZW4sIC4uLnBhcmFtcyB9ID0gbm90aWZpY2F0aW9uLnBhcmFtcztcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gTnVtYmVyKHByb2dyZXNzVG9rZW4pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcHJvZ3Jlc3NIYW5kbGVycy5nZXQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgUmVjZWl2ZWQgYSBwcm9ncmVzcyBub3RpZmljYXRpb24gZm9yIGFuIHVua25vd24gdG9rZW46ICR7SlNPTi5zdHJpbmdpZnkobm90aWZpY2F0aW9uKX1gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5nZXQobWVzc2FnZUlkKTtcbiAgICAgICAgY29uc3QgdGltZW91dEluZm8gPSB0aGlzLl90aW1lb3V0SW5mby5nZXQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKHRpbWVvdXRJbmZvICYmIHJlc3BvbnNlSGFuZGxlciAmJiB0aW1lb3V0SW5mby5yZXNldFRpbWVvdXRPblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0VGltZW91dChtZXNzYWdlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcihwYXJhbXMpO1xuICAgIH1cbiAgICBfb25yZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSBOdW1iZXIocmVzcG9uc2UuaWQpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5nZXQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYFJlY2VpdmVkIGEgcmVzcG9uc2UgZm9yIGFuIHVua25vd24gbWVzc2FnZSBJRDogJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZSl9YCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgIHRoaXMuX2NsZWFudXBUaW1lb3V0KG1lc3NhZ2VJZCk7XG4gICAgICAgIGlmICgoMCwgdHlwZXNfanNfMS5pc0pTT05SUENSZXNwb25zZSkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IHR5cGVzX2pzXzEuTWNwRXJyb3IocmVzcG9uc2UuZXJyb3IuY29kZSwgcmVzcG9uc2UuZXJyb3IubWVzc2FnZSwgcmVzcG9uc2UuZXJyb3IuZGF0YSk7XG4gICAgICAgICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdHJhbnNwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuX3RyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlcXVlc3QgYW5kIHdhaXQgZm9yIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIGVtaXQgbm90aWZpY2F0aW9ucyEgVXNlIG5vdGlmaWNhdGlvbigpIGluc3RlYWQuXG4gICAgICovXG4gICAgcmVxdWVzdChyZXF1ZXN0LCByZXN1bHRTY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkUmVxdWVzdElkLCByZXN1bXB0aW9uVG9rZW4sIG9ucmVzdW1wdGlvbnRva2VuIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZm9yY2VTdHJpY3RDYXBhYmlsaXRpZXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRDYXBhYmlsaXR5Rm9yTWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5fcmVxdWVzdE1lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgY29uc3QganNvbnJwY1JlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbnByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVycy5zZXQobWVzc2FnZUlkLCBvcHRpb25zLm9ucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIGpzb25ycGNSZXF1ZXN0LnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVxdWVzdC5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIF9tZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oKChfYyA9IHJlcXVlc3QucGFyYW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuX21ldGEpIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzVG9rZW46IG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBUaW1lb3V0KG1lc3NhZ2VJZCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdub3RpZmljYXRpb25zL2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFN0cmluZyhyZWFzb24pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7IHJlbGF0ZWRSZXF1ZXN0SWQsIHJlc3VtcHRpb25Ub2tlbiwgb25yZXN1bXB0aW9udG9rZW4gfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIGNhbmNlbGxhdGlvbjogJHtlcnJvcn1gKSkpO1xuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc2V0KG1lc3NhZ2VJZCwgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0U2NoZW1hLnBhcnNlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNhbmNlbCgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhc29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBleHBvcnRzLkRFRkFVTFRfUkVRVUVTVF9USU1FT1VUX01TRUM7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SGFuZGxlciA9ICgpID0+IGNhbmNlbChuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5SZXF1ZXN0VGltZW91dCwgJ1JlcXVlc3QgdGltZWQgb3V0JywgeyB0aW1lb3V0IH0pKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwVGltZW91dChtZXNzYWdlSWQsIHRpbWVvdXQsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhUb3RhbFRpbWVvdXQsIHRpbWVvdXRIYW5kbGVyLCAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzZXRUaW1lb3V0T25Qcm9ncmVzcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoanNvbnJwY1JlcXVlc3QsIHsgcmVsYXRlZFJlcXVlc3RJZCwgcmVzdW1wdGlvblRva2VuLCBvbnJlc3VtcHRpb250b2tlbiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cFRpbWVvdXQobWVzc2FnZUlkKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIG5vdGlmaWNhdGlvbiwgd2hpY2ggaXMgYSBvbmUtd2F5IG1lc3NhZ2UgdGhhdCBkb2VzIG5vdCBleHBlY3QgYSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydE5vdGlmaWNhdGlvbkNhcGFiaWxpdHkobm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgICAgIGNvbnN0IGRlYm91bmNlZE1ldGhvZHMgPSAoX2IgPSAoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVib3VuY2VkTm90aWZpY2F0aW9uTWV0aG9kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIC8vIEEgbm90aWZpY2F0aW9uIGNhbiBvbmx5IGJlIGRlYm91bmNlZCBpZiBpdCdzIGluIHRoZSBsaXN0IEFORCBpdCdzIFwic2ltcGxlXCJcbiAgICAgICAgLy8gKGkuZS4sIGhhcyBubyBwYXJhbWV0ZXJzIGFuZCBubyByZWxhdGVkIHJlcXVlc3QgSUQgdGhhdCBjb3VsZCBiZSBsb3N0KS5cbiAgICAgICAgY29uc3QgY2FuRGVib3VuY2UgPSBkZWJvdW5jZWRNZXRob2RzLmluY2x1ZGVzKG5vdGlmaWNhdGlvbi5tZXRob2QpICYmICFub3RpZmljYXRpb24ucGFyYW1zICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbGF0ZWRSZXF1ZXN0SWQpO1xuICAgICAgICBpZiAoY2FuRGVib3VuY2UpIHtcbiAgICAgICAgICAgIC8vIElmIGEgbm90aWZpY2F0aW9uIG9mIHRoaXMgdHlwZSBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgZG8gbm90aGluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRGVib3VuY2VkTm90aWZpY2F0aW9ucy5oYXMobm90aWZpY2F0aW9uLm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHRoaXMgbm90aWZpY2F0aW9uIHR5cGUgYXMgcGVuZGluZy5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zLmFkZChub3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgc2VuZCB0byBoYXBwZW4gaW4gdGhlIG5leHQgbWljcm90YXNrLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgYWxsIHN5bmNocm9ub3VzIGNhbGxzIGluIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AgdGljayB0byBiZSBjb2FsZXNjZWQuXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gVW4tbWFyayB0aGUgbm90aWZpY2F0aW9uIHNvIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2NoZWR1bGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zLmRlbGV0ZShub3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFkgQ0hFQ0s6IElmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgd2hpbGUgdGhpcyB3YXMgcGVuZGluZywgYWJvcnQuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBqc29ucnBjTm90aWZpY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBub3RpZmljYXRpb24sIGJ1dCBkb24ndCBhd2FpdCBpdCBoZXJlIHRvIGF2b2lkIGJsb2NraW5nLlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBwb3RlbnRpYWwgZXJyb3JzIHdpdGggYSAuY2F0Y2goKS5cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl90cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kKGpzb25ycGNOb3RpZmljYXRpb24sIG9wdGlvbnMpLmNhdGNoKGVycm9yID0+IHRoaXMuX29uZXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb25ycGNOb3RpZmljYXRpb24gPSB7XG4gICAgICAgICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQuc2VuZChqc29ucnBjTm90aWZpY2F0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciB0byBpbnZva2Ugd2hlbiB0aGlzIHByb3RvY29sIG9iamVjdCByZWNlaXZlcyBhIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXBsYWNlIGFueSBwcmV2aW91cyByZXF1ZXN0IGhhbmRsZXIgZm9yIHRoZSBzYW1lIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzZXRSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0U2NoZW1hLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3RTY2hlbWEuc2hhcGUubWV0aG9kLnZhbHVlO1xuICAgICAgICB0aGlzLmFzc2VydFJlcXVlc3RIYW5kbGVyQ2FwYWJpbGl0eShtZXRob2QpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlcnMuc2V0KG1ldGhvZCwgKHJlcXVlc3QsIGV4dHJhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIocmVxdWVzdFNjaGVtYS5wYXJzZShyZXF1ZXN0KSwgZXh0cmEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJlcXVlc3QgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAgICAgKi9cbiAgICByZW1vdmVSZXF1ZXN0SGFuZGxlcihtZXRob2QpIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnRzIHRoYXQgYSByZXF1ZXN0IGhhbmRsZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gc2V0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCBpbiBwcmVwYXJhdGlvbiBmb3IgYSBuZXcgb25lIGJlaW5nIGF1dG9tYXRpY2FsbHkgaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIGFzc2VydENhblNldFJlcXVlc3RIYW5kbGVyKG1ldGhvZCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVxdWVzdCBoYW5kbGVyIGZvciAke21ldGhvZH0gYWxyZWFkeSBleGlzdHMsIHdoaWNoIHdvdWxkIGJlIG92ZXJyaWRkZW5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRvIGludm9rZSB3aGVuIHRoaXMgcHJvdG9jb2wgb2JqZWN0IHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIHdpdGggdGhlIGdpdmVuIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmVwbGFjZSBhbnkgcHJldmlvdXMgbm90aWZpY2F0aW9uIGhhbmRsZXIgZm9yIHRoZSBzYW1lIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzZXROb3RpZmljYXRpb25IYW5kbGVyKG5vdGlmaWNhdGlvblNjaGVtYSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25IYW5kbGVycy5zZXQobm90aWZpY2F0aW9uU2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSwgbm90aWZpY2F0aW9uID0+IFByb21pc2UucmVzb2x2ZShoYW5kbGVyKG5vdGlmaWNhdGlvblNjaGVtYS5wYXJzZShub3RpZmljYXRpb24pKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBub3RpZmljYXRpb24gaGFuZGxlciBmb3IgdGhlIGdpdmVuIG1ldGhvZC5cbiAgICAgKi9cbiAgICByZW1vdmVOb3RpZmljYXRpb25IYW5kbGVyKG1ldGhvZCkge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25IYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sID0gUHJvdG9jb2w7XG5mdW5jdGlvbiBtZXJnZUNhcGFiaWxpdGllcyhiYXNlLCBhZGRpdGlvbmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGFkZGl0aW9uYWwpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gYWNjW2tleV0gPyB7IC4uLmFjY1trZXldLCAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgeyAuLi5iYXNlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdG9jb2wuanMubWFwIixudWxsLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb3VyY2VMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuUmVhZFJlc291cmNlUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZWFkUmVzb3VyY2VSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5MaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkxpc3RSZXNvdXJjZVRlbXBsYXRlc1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkxpc3RSZXNvdXJjZXNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkxpc3RSZXNvdXJjZXNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVNjaGVtYSA9IGV4cG9ydHMuQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWEgPSBleHBvcnRzLlRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlBhZ2luYXRlZFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Qcm9ncmVzc1NjaGVtYSA9IGV4cG9ydHMuUGluZ1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLmlzSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Jbml0aWFsaXplUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5TZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEgPSBleHBvcnRzLmlzSW5pdGlhbGl6ZVJlcXVlc3QgPSBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5DbGllbnRDYXBhYmlsaXRpZXNTY2hlbWEgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uU2NoZW1hID0gZXhwb3J0cy5CYXNlTWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLkljb25zU2NoZW1hID0gZXhwb3J0cy5JY29uU2NoZW1hID0gZXhwb3J0cy5DYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLkVtcHR5UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5KU09OUlBDTWVzc2FnZVNjaGVtYSA9IGV4cG9ydHMuaXNKU09OUlBDRXJyb3IgPSBleHBvcnRzLkpTT05SUENFcnJvclNjaGVtYSA9IGV4cG9ydHMuRXJyb3JDb2RlID0gZXhwb3J0cy5pc0pTT05SUENSZXNwb25zZSA9IGV4cG9ydHMuSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hID0gZXhwb3J0cy5pc0pTT05SUENOb3RpZmljYXRpb24gPSBleHBvcnRzLkpTT05SUENOb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLmlzSlNPTlJQQ1JlcXVlc3QgPSBleHBvcnRzLkpTT05SUENSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0SWRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5DdXJzb3JTY2hlbWEgPSBleHBvcnRzLlByb2dyZXNzVG9rZW5TY2hlbWEgPSBleHBvcnRzLkpTT05SUENfVkVSU0lPTiA9IGV4cG9ydHMuU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05TID0gZXhwb3J0cy5ERUZBVUxUX05FR09USUFURURfUFJPVE9DT0xfVkVSU0lPTiA9IGV4cG9ydHMuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSB2b2lkIDA7XG5leHBvcnRzLkNsaWVudFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJvb3RzTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLkxpc3RSb290c1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFJvb3RzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUm9vdFNjaGVtYSA9IGV4cG9ydHMuQ29tcGxldGVSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkNvbXBsZXRlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUHJvbXB0UmVmZXJlbmNlU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVJlZmVyZW5jZVNjaGVtYSA9IGV4cG9ydHMuUmVzb3VyY2VUZW1wbGF0ZVJlZmVyZW5jZVNjaGVtYSA9IGV4cG9ydHMuRWxpY2l0UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5FbGljaXRSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5QcmltaXRpdmVTY2hlbWFEZWZpbml0aW9uU2NoZW1hID0gZXhwb3J0cy5FbnVtU2NoZW1hU2NoZW1hID0gZXhwb3J0cy5OdW1iZXJTY2hlbWFTY2hlbWEgPSBleHBvcnRzLlN0cmluZ1NjaGVtYVNjaGVtYSA9IGV4cG9ydHMuQm9vbGVhblNjaGVtYVNjaGVtYSA9IGV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlNhbXBsaW5nTWVzc2FnZVNjaGVtYSA9IGV4cG9ydHMuTW9kZWxQcmVmZXJlbmNlc1NjaGVtYSA9IGV4cG9ydHMuTW9kZWxIaW50U2NoZW1hID0gZXhwb3J0cy5Mb2dnaW5nTWVzc2FnZU5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuU2V0TGV2ZWxSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5Mb2dnaW5nTGV2ZWxTY2hlbWEgPSBleHBvcnRzLlRvb2xMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5Db21wYXRpYmlsaXR5Q2FsbFRvb2xSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkNhbGxUb29sUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5MaXN0VG9vbHNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkxpc3RUb29sc1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlRvb2xTY2hlbWEgPSBleHBvcnRzLlRvb2xBbm5vdGF0aW9uc1NjaGVtYSA9IGV4cG9ydHMuUHJvbXB0TGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLkdldFByb21wdFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUHJvbXB0TWVzc2FnZVNjaGVtYSA9IGV4cG9ydHMuQ29udGVudEJsb2NrU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZUxpbmtTY2hlbWEgPSBleHBvcnRzLkVtYmVkZGVkUmVzb3VyY2VTY2hlbWEgPSBleHBvcnRzLkF1ZGlvQ29udGVudFNjaGVtYSA9IGV4cG9ydHMuSW1hZ2VDb250ZW50U2NoZW1hID0gZXhwb3J0cy5UZXh0Q29udGVudFNjaGVtYSA9IGV4cG9ydHMuR2V0UHJvbXB0UmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFByb21wdHNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkxpc3RQcm9tcHRzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUHJvbXB0U2NoZW1hID0gZXhwb3J0cy5Qcm9tcHRBcmd1bWVudFNjaGVtYSA9IGV4cG9ydHMuUmVzb3VyY2VVcGRhdGVkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5VbnN1YnNjcmliZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlN1YnNjcmliZVJlcXVlc3RTY2hlbWEgPSB2b2lkIDA7XG5leHBvcnRzLk1jcEVycm9yID0gZXhwb3J0cy5TZXJ2ZXJSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlNlcnZlck5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuU2VydmVyUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuQ2xpZW50UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5DbGllbnROb3RpZmljYXRpb25TY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5leHBvcnRzLkxBVEVTVF9QUk9UT0NPTF9WRVJTSU9OID0gJzIwMjUtMDYtMTgnO1xuZXhwb3J0cy5ERUZBVUxUX05FR09USUFURURfUFJPVE9DT0xfVkVSU0lPTiA9ICcyMDI1LTAzLTI2JztcbmV4cG9ydHMuU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05TID0gW2V4cG9ydHMuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04sICcyMDI1LTAzLTI2JywgJzIwMjQtMTEtMDUnLCAnMjAyNC0xMC0wNyddO1xuLyogSlNPTi1SUEMgdHlwZXMgKi9cbmV4cG9ydHMuSlNPTlJQQ19WRVJTSU9OID0gJzIuMCc7XG4vKipcbiAqIEEgcHJvZ3Jlc3MgdG9rZW4sIHVzZWQgdG8gYXNzb2NpYXRlIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgd2l0aCB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAqL1xuZXhwb3J0cy5Qcm9ncmVzc1Rva2VuU2NoZW1hID0gem9kXzEuei51bmlvbihbem9kXzEuei5zdHJpbmcoKSwgem9kXzEuei5udW1iZXIoKS5pbnQoKV0pO1xuLyoqXG4gKiBBbiBvcGFxdWUgdG9rZW4gdXNlZCB0byByZXByZXNlbnQgYSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gKi9cbmV4cG9ydHMuQ3Vyc29yU2NoZW1hID0gem9kXzEuei5zdHJpbmcoKTtcbmNvbnN0IFJlcXVlc3RNZXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIElmIHNwZWNpZmllZCwgdGhlIGNhbGxlciBpcyByZXF1ZXN0aW5nIG91dC1vZi1iYW5kIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZm9yIHRoaXMgcmVxdWVzdCAoYXMgcmVwcmVzZW50ZWQgYnkgbm90aWZpY2F0aW9ucy9wcm9ncmVzcykuIFRoZSB2YWx1ZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBhbiBvcGFxdWUgdG9rZW4gdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIGFueSBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMuIFRoZSByZWNlaXZlciBpcyBub3Qgb2JsaWdhdGVkIHRvIHByb3ZpZGUgdGhlc2Ugbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBwcm9ncmVzc1Rva2VuOiB6b2RfMS56Lm9wdGlvbmFsKGV4cG9ydHMuUHJvZ3Jlc3NUb2tlblNjaGVtYSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG5jb25zdCBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbChSZXF1ZXN0TWV0YVNjaGVtYSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG5leHBvcnRzLlJlcXVlc3RTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHBhcmFtczogem9kXzEuei5vcHRpb25hbChCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYSlcbn0pO1xuY29uc3QgQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIG1ldGhvZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoub3B0aW9uYWwoQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYSlcbn0pO1xuZXhwb3J0cy5SZXN1bHRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEEgdW5pcXVlbHkgaWRlbnRpZnlpbmcgSUQgZm9yIGEgcmVxdWVzdCBpbiBKU09OLVJQQy5cbiAqL1xuZXhwb3J0cy5SZXF1ZXN0SWRTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFt6b2RfMS56LnN0cmluZygpLCB6b2RfMS56Lm51bWJlcigpLmludCgpXSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0aGF0IGV4cGVjdHMgYSByZXNwb25zZS5cbiAqL1xuZXhwb3J0cy5KU09OUlBDUmVxdWVzdFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBqc29ucnBjOiB6b2RfMS56LmxpdGVyYWwoZXhwb3J0cy5KU09OUlBDX1ZFUlNJT04pLFxuICAgIGlkOiBleHBvcnRzLlJlcXVlc3RJZFNjaGVtYVxufSlcbiAgICAubWVyZ2UoZXhwb3J0cy5SZXF1ZXN0U2NoZW1hKVxuICAgIC5zdHJpY3QoKTtcbmNvbnN0IGlzSlNPTlJQQ1JlcXVlc3QgPSAodmFsdWUpID0+IGV4cG9ydHMuSlNPTlJQQ1JlcXVlc3RTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xuZXhwb3J0cy5pc0pTT05SUENSZXF1ZXN0ID0gaXNKU09OUlBDUmVxdWVzdDtcbi8qKlxuICogQSBub3RpZmljYXRpb24gd2hpY2ggZG9lcyBub3QgZXhwZWN0IGEgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydHMuSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBqc29ucnBjOiB6b2RfMS56LmxpdGVyYWwoZXhwb3J0cy5KU09OUlBDX1ZFUlNJT04pXG59KVxuICAgIC5tZXJnZShleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYSlcbiAgICAuc3RyaWN0KCk7XG5jb25zdCBpc0pTT05SUENOb3RpZmljYXRpb24gPSAodmFsdWUpID0+IGV4cG9ydHMuSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYS5zYWZlUGFyc2UodmFsdWUpLnN1Y2Nlc3M7XG5leHBvcnRzLmlzSlNPTlJQQ05vdGlmaWNhdGlvbiA9IGlzSlNPTlJQQ05vdGlmaWNhdGlvbjtcbi8qKlxuICogQSBzdWNjZXNzZnVsIChub24tZXJyb3IpIHJlc3BvbnNlIHRvIGEgcmVxdWVzdC5cbiAqL1xuZXhwb3J0cy5KU09OUlBDUmVzcG9uc2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAganNvbnJwYzogem9kXzEuei5saXRlcmFsKGV4cG9ydHMuSlNPTlJQQ19WRVJTSU9OKSxcbiAgICBpZDogZXhwb3J0cy5SZXF1ZXN0SWRTY2hlbWEsXG4gICAgcmVzdWx0OiBleHBvcnRzLlJlc3VsdFNjaGVtYVxufSlcbiAgICAuc3RyaWN0KCk7XG5jb25zdCBpc0pTT05SUENSZXNwb25zZSA9ICh2YWx1ZSkgPT4gZXhwb3J0cy5KU09OUlBDUmVzcG9uc2VTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xuZXhwb3J0cy5pc0pTT05SUENSZXNwb25zZSA9IGlzSlNPTlJQQ1Jlc3BvbnNlO1xuLyoqXG4gKiBFcnJvciBjb2RlcyBkZWZpbmVkIGJ5IHRoZSBKU09OLVJQQyBzcGVjaWZpY2F0aW9uLlxuICovXG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLyBTREsgZXJyb3IgY29kZXNcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29ubmVjdGlvbkNsb3NlZFwiXSA9IC0zMjAwMF0gPSBcIkNvbm5lY3Rpb25DbG9zZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSAtMzIwMDFdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICAgIC8vIFN0YW5kYXJkIEpTT04tUlBDIGVycm9yIGNvZGVzXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBhcnNlRXJyb3JcIl0gPSAtMzI3MDBdID0gXCJQYXJzZUVycm9yXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRSZXF1ZXN0XCJdID0gLTMyNjAwXSA9IFwiSW52YWxpZFJlcXVlc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTWV0aG9kTm90Rm91bmRcIl0gPSAtMzI2MDFdID0gXCJNZXRob2ROb3RGb3VuZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJbnZhbGlkUGFyYW1zXCJdID0gLTMyNjAyXSA9IFwiSW52YWxpZFBhcmFtc1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gLTMyNjAzXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xufSkoRXJyb3JDb2RlIHx8IChleHBvcnRzLkVycm9yQ29kZSA9IEVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIEEgcmVzcG9uc2UgdG8gYSByZXF1ZXN0IHRoYXQgaW5kaWNhdGVzIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnRzLkpTT05SUENFcnJvclNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBqc29ucnBjOiB6b2RfMS56LmxpdGVyYWwoZXhwb3J0cy5KU09OUlBDX1ZFUlNJT04pLFxuICAgIGlkOiBleHBvcnRzLlJlcXVlc3RJZFNjaGVtYSxcbiAgICBlcnJvcjogem9kXzEuei5vYmplY3Qoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVycm9yIHR5cGUgdGhhdCBvY2N1cnJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvZGU6IHpvZF8xLnoubnVtYmVyKCkuaW50KCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci4gVGhlIG1lc3NhZ2UgU0hPVUxEIGJlIGxpbWl0ZWQgdG8gYSBjb25jaXNlIHNpbmdsZSBzZW50ZW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci4gVGhlIHZhbHVlIG9mIHRoaXMgbWVtYmVyIGlzIGRlZmluZWQgYnkgdGhlIHNlbmRlciAoZS5nLiBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiwgbmVzdGVkIGVycm9ycyBldGMuKS5cbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei51bmtub3duKCkpXG4gICAgfSlcbn0pXG4gICAgLnN0cmljdCgpO1xuY29uc3QgaXNKU09OUlBDRXJyb3IgPSAodmFsdWUpID0+IGV4cG9ydHMuSlNPTlJQQ0Vycm9yU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbmV4cG9ydHMuaXNKU09OUlBDRXJyb3IgPSBpc0pTT05SUENFcnJvcjtcbmV4cG9ydHMuSlNPTlJQQ01lc3NhZ2VTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtleHBvcnRzLkpTT05SUENSZXF1ZXN0U2NoZW1hLCBleHBvcnRzLkpTT05SUENOb3RpZmljYXRpb25TY2hlbWEsIGV4cG9ydHMuSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLCBleHBvcnRzLkpTT05SUENFcnJvclNjaGVtYV0pO1xuLyogRW1wdHkgcmVzdWx0ICovXG4vKipcbiAqIEEgcmVzcG9uc2UgdGhhdCBpbmRpY2F0ZXMgc3VjY2VzcyBidXQgY2FycmllcyBubyBkYXRhLlxuICovXG5leHBvcnRzLkVtcHR5UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuc3RyaWN0KCk7XG4vKiBDYW5jZWxsYXRpb24gKi9cbi8qKlxuICogVGhpcyBub3RpZmljYXRpb24gY2FuIGJlIHNlbnQgYnkgZWl0aGVyIHNpZGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyBjYW5jZWxsaW5nIGEgcHJldmlvdXNseS1pc3N1ZWQgcmVxdWVzdC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBTSE9VTEQgc3RpbGwgYmUgaW4tZmxpZ2h0LCBidXQgZHVlIHRvIGNvbW11bmljYXRpb24gbGF0ZW5jeSwgaXQgaXMgYWx3YXlzIHBvc3NpYmxlIHRoYXQgdGhpcyBub3RpZmljYXRpb24gTUFZIGFycml2ZSBhZnRlciB0aGUgcmVxdWVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZC5cbiAqXG4gKiBUaGlzIG5vdGlmaWNhdGlvbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVzdWx0IHdpbGwgYmUgdW51c2VkLCBzbyBhbnkgYXNzb2NpYXRlZCBwcm9jZXNzaW5nIFNIT1VMRCBjZWFzZS5cbiAqXG4gKiBBIGNsaWVudCBNVVNUIE5PVCBhdHRlbXB0IHRvIGNhbmNlbCBpdHMgYGluaXRpYWxpemVgIHJlcXVlc3QuXG4gKi9cbmV4cG9ydHMuQ2FuY2VsbGVkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9jYW5jZWxsZWQnKSxcbiAgICBwYXJhbXM6IEJhc2VOb3RpZmljYXRpb25QYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgcmVxdWVzdCB0byBjYW5jZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgTVVTVCBjb3JyZXNwb25kIHRvIHRoZSBJRCBvZiBhIHJlcXVlc3QgcHJldmlvdXNseSBpc3N1ZWQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdElkOiBleHBvcnRzLlJlcXVlc3RJZFNjaGVtYSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHN0cmluZyBkZXNjcmliaW5nIHRoZSByZWFzb24gZm9yIHRoZSBjYW5jZWxsYXRpb24uIFRoaXMgTUFZIGJlIGxvZ2dlZCBvciBwcmVzZW50ZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZWFzb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG59KTtcbi8qIEJhc2UgTWV0YWRhdGEgKi9cbi8qKlxuICogSWNvbiBzY2hlbWEgZm9yIHVzZSBpbiB0b29scywgcHJvbXB0cywgcmVzb3VyY2VzLCBhbmQgaW1wbGVtZW50YXRpb25zLlxuICovXG5leHBvcnRzLkljb25TY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogVVJMIG9yIGRhdGEgVVJJIGZvciB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBzcmM6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgTUlNRSB0eXBlIGZvciB0aGUgaWNvbi5cbiAgICAgKi9cbiAgICBtaW1lVHlwZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBhcnJheSBvZiBzdHJpbmdzIHRoYXQgc3BlY2lmeSBzaXplcyBhdCB3aGljaCB0aGUgaWNvbiBjYW4gYmUgdXNlZC5cbiAgICAgKiBFYWNoIHN0cmluZyBzaG91bGQgYmUgaW4gV3hIIGZvcm1hdCAoZS5nLiwgYFwiNDh4NDhcImAsIGBcIjk2eDk2XCJgKSBvciBgXCJhbnlcImAgZm9yIHNjYWxhYmxlIGZvcm1hdHMgbGlrZSBTVkcuXG4gICAgICpcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjbGllbnQgc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBpY29uIGNhbiBiZSB1c2VkIGF0IGFueSBzaXplLlxuICAgICAqL1xuICAgIHNpemVzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBCYXNlIHNjaGVtYSB0byBhZGQgYGljb25zYCBwcm9wZXJ0eS5cbiAqXG4gKi9cbmV4cG9ydHMuSWNvbnNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgc2V0IG9mIHNpemVkIGljb25zIHRoYXQgdGhlIGNsaWVudCBjYW4gZGlzcGxheSBpbiBhIHVzZXIgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyB0aGF0IHN1cHBvcnQgcmVuZGVyaW5nIGljb25zIE1VU1Qgc3VwcG9ydCBhdCBsZWFzdCB0aGUgZm9sbG93aW5nIE1JTUUgdHlwZXM6XG4gICAgICogLSBgaW1hZ2UvcG5nYCAtIFBORyBpbWFnZXMgKHNhZmUsIHVuaXZlcnNhbCBjb21wYXRpYmlsaXR5KVxuICAgICAqIC0gYGltYWdlL2pwZWdgIChhbmQgYGltYWdlL2pwZ2ApIC0gSlBFRyBpbWFnZXMgKHNhZmUsIHVuaXZlcnNhbCBjb21wYXRpYmlsaXR5KVxuICAgICAqXG4gICAgICogQ2xpZW50cyB0aGF0IHN1cHBvcnQgcmVuZGVyaW5nIGljb25zIFNIT1VMRCBhbHNvIHN1cHBvcnQ6XG4gICAgICogLSBgaW1hZ2Uvc3ZnK3htbGAgLSBTVkcgaW1hZ2VzIChzY2FsYWJsZSBidXQgcmVxdWlyZXMgc2VjdXJpdHkgcHJlY2F1dGlvbnMpXG4gICAgICogLSBgaW1hZ2Uvd2VicGAgLSBXZWJQIGltYWdlcyAobW9kZXJuLCBlZmZpY2llbnQgZm9ybWF0KVxuICAgICAqL1xuICAgIGljb25zOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuSWNvblNjaGVtYSkub3B0aW9uYWwoKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQmFzZSBtZXRhZGF0YSBpbnRlcmZhY2UgZm9yIGNvbW1vbiBwcm9wZXJ0aWVzIGFjcm9zcyByZXNvdXJjZXMsIHRvb2xzLCBwcm9tcHRzLCBhbmQgaW1wbGVtZW50YXRpb25zLlxuICovXG5leHBvcnRzLkJhc2VNZXRhZGF0YVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKiogSW50ZW5kZWQgZm9yIHByb2dyYW1tYXRpYyBvciBsb2dpY2FsIHVzZSwgYnV0IHVzZWQgYXMgYSBkaXNwbGF5IG5hbWUgaW4gcGFzdCBzcGVjcyBvciBmYWxsYmFjayAqL1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIFVJIGFuZCBlbmQtdXNlciBjb250ZXh0cyDigJQgb3B0aW1pemVkIHRvIGJlIGh1bWFuLXJlYWRhYmxlIGFuZCBlYXNpbHkgdW5kZXJzdG9vZCxcbiAgICAgKiBldmVuIGJ5IHRob3NlIHVuZmFtaWxpYXIgd2l0aCBkb21haW4tc3BlY2lmaWMgdGVybWlub2xvZ3kuXG4gICAgICpcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBuYW1lIHNob3VsZCBiZSB1c2VkIGZvciBkaXNwbGF5IChleGNlcHQgZm9yIFRvb2wsXG4gICAgICogd2hlcmUgYGFubm90YXRpb25zLnRpdGxlYCBzaG91bGQgYmUgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIHVzaW5nIGBuYW1lYCxcbiAgICAgKiBpZiBwcmVzZW50KS5cbiAgICAgKi9cbiAgICB0aXRsZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qIEluaXRpYWxpemF0aW9uICovXG4vKipcbiAqIERlc2NyaWJlcyB0aGUgbmFtZSBhbmQgdmVyc2lvbiBvZiBhbiBNQ1AgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydHMuSW1wbGVtZW50YXRpb25TY2hlbWEgPSBleHBvcnRzLkJhc2VNZXRhZGF0YVNjaGVtYS5leHRlbmQoe1xuICAgIHZlcnNpb246IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgVVJMIG9mIHRoZSB3ZWJzaXRlIGZvciB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIHdlYnNpdGVVcmw6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSlcbn0pLm1lcmdlKGV4cG9ydHMuSWNvbnNTY2hlbWEpO1xuLyoqXG4gKiBDYXBhYmlsaXRpZXMgYSBjbGllbnQgbWF5IHN1cHBvcnQuIEtub3duIGNhcGFiaWxpdGllcyBhcmUgZGVmaW5lZCBoZXJlLCBpbiB0aGlzIHNjaGVtYSwgYnV0IHRoaXMgaXMgbm90IGEgY2xvc2VkIHNldDogYW55IGNsaWVudCBjYW4gZGVmaW5lIGl0cyBvd24sIGFkZGl0aW9uYWwgY2FwYWJpbGl0aWVzLlxuICovXG5leHBvcnRzLkNsaWVudENhcGFiaWxpdGllc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwsIG5vbi1zdGFuZGFyZCBjYXBhYmlsaXRpZXMgdGhhdCB0aGUgY2xpZW50IHN1cHBvcnRzLlxuICAgICAqL1xuICAgIGV4cGVyaW1lbnRhbDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgY2xpZW50IHN1cHBvcnRzIHNhbXBsaW5nIGZyb20gYW4gTExNLlxuICAgICAqL1xuICAgIHNhbXBsaW5nOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgICAvKipcbiAgICAgKiBQcmVzZW50IGlmIHRoZSBjbGllbnQgc3VwcG9ydHMgZWxpY2l0aW5nIHVzZXIgaW5wdXQuXG4gICAgICovXG4gICAgZWxpY2l0YXRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIGNsaWVudCBzdXBwb3J0cyBsaXN0aW5nIHJvb3RzLlxuICAgICAqL1xuICAgIHJvb3RzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgc3VwcG9ydHMgaXNzdWluZyBub3RpZmljYXRpb25zIGZvciBjaGFuZ2VzIHRvIHRoZSByb290cyBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENoYW5nZWQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBUaGlzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuIGl0IGZpcnN0IGNvbm5lY3RzLCBhc2tpbmcgaXQgdG8gYmVnaW4gaW5pdGlhbGl6YXRpb24uXG4gKi9cbmV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnaW5pdGlhbGl6ZScpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGUgTW9kZWwgQ29udGV4dCBQcm90b2NvbCB0aGF0IHRoZSBjbGllbnQgc3VwcG9ydHMuIFRoZSBjbGllbnQgTUFZIGRlY2lkZSB0byBzdXBwb3J0IG9sZGVyIHZlcnNpb25zIGFzIHdlbGwuXG4gICAgICAgICAqL1xuICAgICAgICBwcm90b2NvbFZlcnNpb246IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIGNhcGFiaWxpdGllczogZXhwb3J0cy5DbGllbnRDYXBhYmlsaXRpZXNTY2hlbWEsXG4gICAgICAgIGNsaWVudEluZm86IGV4cG9ydHMuSW1wbGVtZW50YXRpb25TY2hlbWFcbiAgICB9KVxufSk7XG5jb25zdCBpc0luaXRpYWxpemVSZXF1ZXN0ID0gKHZhbHVlKSA9PiBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0U2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbmV4cG9ydHMuaXNJbml0aWFsaXplUmVxdWVzdCA9IGlzSW5pdGlhbGl6ZVJlcXVlc3Q7XG4vKipcbiAqIENhcGFiaWxpdGllcyB0aGF0IGEgc2VydmVyIG1heSBzdXBwb3J0LiBLbm93biBjYXBhYmlsaXRpZXMgYXJlIGRlZmluZWQgaGVyZSwgaW4gdGhpcyBzY2hlbWEsIGJ1dCB0aGlzIGlzIG5vdCBhIGNsb3NlZCBzZXQ6IGFueSBzZXJ2ZXIgY2FuIGRlZmluZSBpdHMgb3duLCBhZGRpdGlvbmFsIGNhcGFiaWxpdGllcy5cbiAqL1xuZXhwb3J0cy5TZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLCBub24tc3RhbmRhcmQgY2FwYWJpbGl0aWVzIHRoYXQgdGhlIHNlcnZlciBzdXBwb3J0cy5cbiAgICAgKi9cbiAgICBleHBlcmltZW50YWw6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBzZW5kaW5nIGxvZyBtZXNzYWdlcyB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGxvZ2dpbmc6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBzZW5kaW5nIGNvbXBsZXRpb25zIHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgY29tcGxldGlvbnM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIHNlcnZlciBvZmZlcnMgYW55IHByb21wdCB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHJvbXB0czogem9kXzEuei5vcHRpb25hbCh6b2RfMS56XG4gICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHNlcnZlciBzdXBwb3J0cyBpc3N1aW5nIG5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gdGhlIHByb21wdCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENoYW5nZWQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIHNlcnZlciBvZmZlcnMgYW55IHJlc291cmNlcyB0byByZWFkLlxuICAgICAqL1xuICAgIHJlc291cmNlczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56XG4gICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHNlcnZlciBzdXBwb3J0cyBjbGllbnRzIHN1YnNjcmliaW5nIHRvIHJlc291cmNlIHVwZGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBzdWJzY3JpYmU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHNlcnZlciBzdXBwb3J0cyBpc3N1aW5nIG5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gdGhlIHJlc291cmNlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q2hhbmdlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSlcbiAgICB9KVxuICAgICAgICAucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgc2VydmVyIG9mZmVycyBhbnkgdG9vbHMgdG8gY2FsbC5cbiAgICAgKi9cbiAgICB0b29sczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56XG4gICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHNlcnZlciBzdXBwb3J0cyBpc3N1aW5nIG5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gdGhlIHRvb2wgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDaGFuZ2VkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxuICAgIH0pXG4gICAgICAgIC5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQWZ0ZXIgcmVjZWl2aW5nIGFuIGluaXRpYWxpemUgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQsIHRoZSBzZXJ2ZXIgc2VuZHMgdGhpcyByZXNwb25zZS5cbiAqL1xuZXhwb3J0cy5Jbml0aWFsaXplUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgTW9kZWwgQ29udGV4dCBQcm90b2NvbCB0aGF0IHRoZSBzZXJ2ZXIgd2FudHMgdG8gdXNlLiBUaGlzIG1heSBub3QgbWF0Y2ggdGhlIHZlcnNpb24gdGhhdCB0aGUgY2xpZW50IHJlcXVlc3RlZC4gSWYgdGhlIGNsaWVudCBjYW5ub3Qgc3VwcG9ydCB0aGlzIHZlcnNpb24sIGl0IE1VU1QgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICBwcm90b2NvbFZlcnNpb246IHpvZF8xLnouc3RyaW5nKCksXG4gICAgY2FwYWJpbGl0aWVzOiBleHBvcnRzLlNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSxcbiAgICBzZXJ2ZXJJbmZvOiBleHBvcnRzLkltcGxlbWVudGF0aW9uU2NoZW1hLFxuICAgIC8qKlxuICAgICAqIEluc3RydWN0aW9ucyBkZXNjcmliaW5nIGhvdyB0byB1c2UgdGhlIHNlcnZlciBhbmQgaXRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCBieSBjbGllbnRzIHRvIGltcHJvdmUgdGhlIExMTSdzIHVuZGVyc3RhbmRpbmcgb2YgYXZhaWxhYmxlIHRvb2xzLCByZXNvdXJjZXMsIGV0Yy4gSXQgY2FuIGJlIHRob3VnaHQgb2YgbGlrZSBhIFwiaGludFwiIHRvIHRoZSBtb2RlbC4gRm9yIGV4YW1wbGUsIHRoaXMgaW5mb3JtYXRpb24gTUFZIGJlIGFkZGVkIHRvIHRoZSBzeXN0ZW0gcHJvbXB0LlxuICAgICAqL1xuICAgIGluc3RydWN0aW9uczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKVxufSk7XG4vKipcbiAqIFRoaXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaGFzIGZpbmlzaGVkLlxuICovXG5leHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9pbml0aWFsaXplZCcpXG59KTtcbmNvbnN0IGlzSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSAodmFsdWUpID0+IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb25TY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xuZXhwb3J0cy5pc0luaXRpYWxpemVkTm90aWZpY2F0aW9uID0gaXNJbml0aWFsaXplZE5vdGlmaWNhdGlvbjtcbi8qIFBpbmcgKi9cbi8qKlxuICogQSBwaW5nLCBpc3N1ZWQgYnkgZWl0aGVyIHRoZSBzZXJ2ZXIgb3IgdGhlIGNsaWVudCwgdG8gY2hlY2sgdGhhdCB0aGUgb3RoZXIgcGFydHkgaXMgc3RpbGwgYWxpdmUuIFRoZSByZWNlaXZlciBtdXN0IHByb21wdGx5IHJlc3BvbmQsIG9yIGVsc2UgbWF5IGJlIGRpc2Nvbm5lY3RlZC5cbiAqL1xuZXhwb3J0cy5QaW5nUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdwaW5nJylcbn0pO1xuLyogUHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyAqL1xuZXhwb3J0cy5Qcm9ncmVzc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvZ3Jlc3MgdGh1cyBmYXIuIFRoaXMgc2hvdWxkIGluY3JlYXNlIGV2ZXJ5IHRpbWUgcHJvZ3Jlc3MgaXMgbWFkZSwgZXZlbiBpZiB0aGUgdG90YWwgaXMgdW5rbm93bi5cbiAgICAgKi9cbiAgICBwcm9ncmVzczogem9kXzEuei5udW1iZXIoKSxcbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgaXRlbXMgdG8gcHJvY2VzcyAob3IgdG90YWwgcHJvZ3Jlc3MgcmVxdWlyZWQpLCBpZiBrbm93bi5cbiAgICAgKi9cbiAgICB0b3RhbDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpKSxcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgbWVzc2FnZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQW4gb3V0LW9mLWJhbmQgbm90aWZpY2F0aW9uIHVzZWQgdG8gaW5mb3JtIHRoZSByZWNlaXZlciBvZiBhIHByb2dyZXNzIHVwZGF0ZSBmb3IgYSBsb25nLXJ1bm5pbmcgcmVxdWVzdC5cbiAqL1xuZXhwb3J0cy5Qcm9ncmVzc05vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ25vdGlmaWNhdGlvbnMvcHJvZ3Jlc3MnKSxcbiAgICBwYXJhbXM6IEJhc2VOb3RpZmljYXRpb25QYXJhbXNTY2hlbWEubWVyZ2UoZXhwb3J0cy5Qcm9ncmVzc1NjaGVtYSkuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9ncmVzcyB0b2tlbiB3aGljaCB3YXMgZ2l2ZW4gaW4gdGhlIGluaXRpYWwgcmVxdWVzdCwgdXNlZCB0byBhc3NvY2lhdGUgdGhpcyBub3RpZmljYXRpb24gd2l0aCB0aGUgcmVxdWVzdCB0aGF0IGlzIHByb2NlZWRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9ncmVzc1Rva2VuOiBleHBvcnRzLlByb2dyZXNzVG9rZW5TY2hlbWFcbiAgICB9KVxufSk7XG4vKiBQYWdpbmF0aW9uICovXG5leHBvcnRzLlBhZ2luYXRlZFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcGFxdWUgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHBhZ2luYXRpb24gcG9zaXRpb24uXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0aGUgc2VydmVyIHNob3VsZCByZXR1cm4gcmVzdWx0cyBzdGFydGluZyBhZnRlciB0aGlzIGN1cnNvci5cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogem9kXzEuei5vcHRpb25hbChleHBvcnRzLkN1cnNvclNjaGVtYSlcbiAgICB9KS5vcHRpb25hbCgpXG59KTtcbmV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBBbiBvcGFxdWUgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBwYWdpbmF0aW9uIHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IHJldHVybmVkIHJlc3VsdC5cbiAgICAgKiBJZiBwcmVzZW50LCB0aGVyZSBtYXkgYmUgbW9yZSByZXN1bHRzIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBuZXh0Q3Vyc29yOiB6b2RfMS56Lm9wdGlvbmFsKGV4cG9ydHMuQ3Vyc29yU2NoZW1hKVxufSk7XG4vKiBSZXNvdXJjZXMgKi9cbi8qKlxuICogVGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgcmVzb3VyY2Ugb3Igc3ViLXJlc291cmNlLlxuICovXG5leHBvcnRzLlJlc291cmNlQ29udGVudHNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogVGhlIFVSSSBvZiB0aGlzIHJlc291cmNlLlxuICAgICAqL1xuICAgIHVyaTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoaXMgcmVzb3VyY2UsIGlmIGtub3duLlxuICAgICAqL1xuICAgIG1pbWVUeXBlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuZXhwb3J0cy5UZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IGV4cG9ydHMuUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBpdGVtLiBUaGlzIG11c3Qgb25seSBiZSBzZXQgaWYgdGhlIGl0ZW0gY2FuIGFjdHVhbGx5IGJlIHJlcHJlc2VudGVkIGFzIHRleHQgKG5vdCBiaW5hcnkgZGF0YSkuXG4gICAgICovXG4gICAgdGV4dDogem9kXzEuei5zdHJpbmcoKVxufSk7XG4vKipcbiAqIEEgWm9kIHNjaGVtYSBmb3IgdmFsaWRhdGluZyBCYXNlNjQgc3RyaW5ncyB0aGF0IGlzIG1vcmUgcGVyZm9ybWFudCBhbmRcbiAqIHJvYnVzdCBmb3IgdmVyeSBsYXJnZSBpbnB1dHMgdGhhbiB0aGUgZGVmYXVsdCByZWdleC1iYXNlZCBjaGVjay4gSXQgYXZvaWRzXG4gKiBzdGFjayBvdmVyZmxvd3MgYnkgdXNpbmcgdGhlIG5hdGl2ZSBgYXRvYmAgZnVuY3Rpb24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmNvbnN0IEJhc2U2NFNjaGVtYSA9IHpvZF8xLnouc3RyaW5nKCkucmVmaW5lKHZhbCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYXRvYiB0aHJvd3MgYSBET01FeGNlcHRpb24gaWYgdGhlIHN0cmluZyBjb250YWlucyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBCYXNlNjQgY2hhcmFjdGVyIHNldC5cbiAgICAgICAgYXRvYih2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59LCB7IG1lc3NhZ2U6ICdJbnZhbGlkIEJhc2U2NCBzdHJpbmcnIH0pO1xuZXhwb3J0cy5CbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IGV4cG9ydHMuUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYmluYXJ5IGRhdGEgb2YgdGhlIGl0ZW0uXG4gICAgICovXG4gICAgYmxvYjogQmFzZTY0U2NoZW1hXG59KTtcbi8qKlxuICogQSBrbm93biByZXNvdXJjZSB0aGF0IHRoZSBzZXJ2ZXIgaXMgY2FwYWJsZSBvZiByZWFkaW5nLlxuICovXG5leHBvcnRzLlJlc291cmNlU2NoZW1hID0gZXhwb3J0cy5CYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBUaGUgVVJJIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAgICovXG4gICAgdXJpOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHJlc291cmNlIHJlcHJlc2VudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGNsaWVudHMgdG8gaW1wcm92ZSB0aGUgTExNJ3MgdW5kZXJzdGFuZGluZyBvZiBhdmFpbGFibGUgcmVzb3VyY2VzLiBJdCBjYW4gYmUgdGhvdWdodCBvZiBsaWtlIGEgXCJoaW50XCIgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhpcyByZXNvdXJjZSwgaWYga25vd24uXG4gICAgICovXG4gICAgbWltZVR5cGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLm1lcmdlKGV4cG9ydHMuSWNvbnNTY2hlbWEpO1xuLyoqXG4gKiBBIHRlbXBsYXRlIGRlc2NyaXB0aW9uIGZvciByZXNvdXJjZXMgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VUZW1wbGF0ZVNjaGVtYSA9IGV4cG9ydHMuQmFzZU1ldGFkYXRhU2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQSBVUkkgdGVtcGxhdGUgKGFjY29yZGluZyB0byBSRkMgNjU3MCkgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgcmVzb3VyY2UgVVJJcy5cbiAgICAgKi9cbiAgICB1cmlUZW1wbGF0ZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyB0ZW1wbGF0ZSBpcyBmb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGNsaWVudHMgdG8gaW1wcm92ZSB0aGUgTExNJ3MgdW5kZXJzdGFuZGluZyBvZiBhdmFpbGFibGUgcmVzb3VyY2VzLiBJdCBjYW4gYmUgdGhvdWdodCBvZiBsaWtlIGEgXCJoaW50XCIgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIFRoZSBNSU1FIHR5cGUgZm9yIGFsbCByZXNvdXJjZXMgdGhhdCBtYXRjaCB0aGlzIHRlbXBsYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGluY2x1ZGVkIGlmIGFsbCByZXNvdXJjZXMgbWF0Y2hpbmcgdGhpcyB0ZW1wbGF0ZSBoYXZlIHRoZSBzYW1lIHR5cGUuXG4gICAgICovXG4gICAgbWltZVR5cGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLm1lcmdlKGV4cG9ydHMuSWNvbnNTY2hlbWEpO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIGNsaWVudCB0byByZXF1ZXN0IGEgbGlzdCBvZiByZXNvdXJjZXMgdGhlIHNlcnZlciBoYXMuXG4gKi9cbmV4cG9ydHMuTGlzdFJlc291cmNlc1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlBhZ2luYXRlZFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgncmVzb3VyY2VzL2xpc3QnKVxufSk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIHJlc291cmNlcy9saXN0IHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkxpc3RSZXNvdXJjZXNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlBhZ2luYXRlZFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIHJlc291cmNlczogem9kXzEuei5hcnJheShleHBvcnRzLlJlc291cmNlU2NoZW1hKVxufSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHJlcXVlc3QgYSBsaXN0IG9mIHJlc291cmNlIHRlbXBsYXRlcyB0aGUgc2VydmVyIGhhcy5cbiAqL1xuZXhwb3J0cy5MaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Jlc291cmNlcy90ZW1wbGF0ZXMvbGlzdCcpXG59KTtcbi8qKlxuICogVGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvIGEgcmVzb3VyY2VzL3RlbXBsYXRlcy9saXN0IHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkxpc3RSZXNvdXJjZVRlbXBsYXRlc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgcmVzb3VyY2VUZW1wbGF0ZXM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlU2NoZW1hKVxufSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIsIHRvIHJlYWQgYSBzcGVjaWZpYyByZXNvdXJjZSBVUkkuXG4gKi9cbmV4cG9ydHMuUmVhZFJlc291cmNlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdyZXNvdXJjZXMvcmVhZCcpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkkgb2YgdGhlIHJlc291cmNlIHRvIHJlYWQuIFRoZSBVUkkgY2FuIHVzZSBhbnkgcHJvdG9jb2w7IGl0IGlzIHVwIHRvIHRoZSBzZXJ2ZXIgaG93IHRvIGludGVycHJldCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHVyaTogem9kXzEuei5zdHJpbmcoKVxuICAgIH0pXG59KTtcbi8qKlxuICogVGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvIGEgcmVzb3VyY2VzL3JlYWQgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuUmVhZFJlc291cmNlUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICBjb250ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnVuaW9uKFtleHBvcnRzLlRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLCBleHBvcnRzLkJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hXSkpXG59KTtcbi8qKlxuICogQW4gb3B0aW9uYWwgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LCBpbmZvcm1pbmcgaXQgdGhhdCB0aGUgbGlzdCBvZiByZXNvdXJjZXMgaXQgY2FuIHJlYWQgZnJvbSBoYXMgY2hhbmdlZC4gVGhpcyBtYXkgYmUgaXNzdWVkIGJ5IHNlcnZlcnMgd2l0aG91dCBhbnkgcHJldmlvdXMgc3Vic2NyaXB0aW9uIGZyb20gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0cy5SZXNvdXJjZUxpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9yZXNvdXJjZXMvbGlzdF9jaGFuZ2VkJylcbn0pO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIGNsaWVudCB0byByZXF1ZXN0IHJlc291cmNlcy91cGRhdGVkIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgc2VydmVyIHdoZW5ldmVyIGEgcGFydGljdWxhciByZXNvdXJjZSBjaGFuZ2VzLlxuICovXG5leHBvcnRzLlN1YnNjcmliZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgncmVzb3VyY2VzL3N1YnNjcmliZScpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkkgb2YgdGhlIHJlc291cmNlIHRvIHN1YnNjcmliZSB0by4gVGhlIFVSSSBjYW4gdXNlIGFueSBwcm90b2NvbDsgaXQgaXMgdXAgdG8gdGhlIHNlcnZlciBob3cgdG8gaW50ZXJwcmV0IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdXJpOiB6b2RfMS56LnN0cmluZygpXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIGNsaWVudCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiByZXNvdXJjZXMvdXBkYXRlZCBub3RpZmljYXRpb25zIGZyb20gdGhlIHNlcnZlci4gVGhpcyBzaG91bGQgZm9sbG93IGEgcHJldmlvdXMgcmVzb3VyY2VzL3N1YnNjcmliZSByZXF1ZXN0LlxuICovXG5leHBvcnRzLlVuc3Vic2NyaWJlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdyZXNvdXJjZXMvdW5zdWJzY3JpYmUnKSxcbiAgICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJJIG9mIHRoZSByZXNvdXJjZSB0byB1bnN1YnNjcmliZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdXJpOiB6b2RfMS56LnN0cmluZygpXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCwgaW5mb3JtaW5nIGl0IHRoYXQgYSByZXNvdXJjZSBoYXMgY2hhbmdlZCBhbmQgbWF5IG5lZWQgdG8gYmUgcmVhZCBhZ2Fpbi4gVGhpcyBzaG91bGQgb25seSBiZSBzZW50IGlmIHRoZSBjbGllbnQgcHJldmlvdXNseSBzZW50IGEgcmVzb3VyY2VzL3N1YnNjcmliZSByZXF1ZXN0LlxuICovXG5leHBvcnRzLlJlc291cmNlVXBkYXRlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ25vdGlmaWNhdGlvbnMvcmVzb3VyY2VzL3VwZGF0ZWQnKSxcbiAgICBwYXJhbXM6IEJhc2VOb3RpZmljYXRpb25QYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkkgb2YgdGhlIHJlc291cmNlIHRoYXQgaGFzIGJlZW4gdXBkYXRlZC4gVGhpcyBtaWdodCBiZSBhIHN1Yi1yZXNvdXJjZSBvZiB0aGUgb25lIHRoYXQgdGhlIGNsaWVudCBhY3R1YWxseSBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdXJpOiB6b2RfMS56LnN0cmluZygpXG4gICAgfSlcbn0pO1xuLyogUHJvbXB0cyAqL1xuLyoqXG4gKiBEZXNjcmliZXMgYW4gYXJndW1lbnQgdGhhdCBhIHByb21wdCBjYW4gYWNjZXB0LlxuICovXG5leHBvcnRzLlByb21wdEFyZ3VtZW50U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBhcmd1bWVudCBtdXN0IGJlIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQSBwcm9tcHQgb3IgcHJvbXB0IHRlbXBsYXRlIHRoYXQgdGhlIHNlcnZlciBvZmZlcnMuXG4gKi9cbmV4cG9ydHMuUHJvbXB0U2NoZW1hID0gZXhwb3J0cy5CYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgcHJvbXB0IHByb3ZpZGVzXG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFyZ3VtZW50cyB0byB1c2UgZm9yIHRlbXBsYXRpbmcgdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5hcnJheShleHBvcnRzLlByb21wdEFyZ3VtZW50U2NoZW1hKSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLm1lcmdlKGV4cG9ydHMuSWNvbnNTY2hlbWEpO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIGNsaWVudCB0byByZXF1ZXN0IGEgbGlzdCBvZiBwcm9tcHRzIGFuZCBwcm9tcHQgdGVtcGxhdGVzIHRoZSBzZXJ2ZXIgaGFzLlxuICovXG5leHBvcnRzLkxpc3RQcm9tcHRzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdwcm9tcHRzL2xpc3QnKVxufSk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIHByb21wdHMvbGlzdCByZXF1ZXN0IGZyb20gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0cy5MaXN0UHJvbXB0c1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgcHJvbXB0czogem9kXzEuei5hcnJheShleHBvcnRzLlByb21wdFNjaGVtYSlcbn0pO1xuLyoqXG4gKiBVc2VkIGJ5IHRoZSBjbGllbnQgdG8gZ2V0IGEgcHJvbXB0IHByb3ZpZGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydHMuR2V0UHJvbXB0UmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdwcm9tcHRzL2dldCcpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9tcHQgb3IgcHJvbXB0IHRlbXBsYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyZ3VtZW50cyB0byB1c2UgZm9yIHRlbXBsYXRpbmcgdGhlIHByb21wdC5cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3VtZW50czogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnJlY29yZCh6b2RfMS56LnN0cmluZygpKSlcbiAgICB9KVxufSk7XG4vKipcbiAqIFRleHQgcHJvdmlkZWQgdG8gb3IgZnJvbSBhbiBMTE0uXG4gKi9cbmV4cG9ydHMuVGV4dENvbnRlbnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKCd0ZXh0JyksXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICB0ZXh0OiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBbiBpbWFnZSBwcm92aWRlZCB0byBvciBmcm9tIGFuIExMTS5cbiAqL1xuZXhwb3J0cy5JbWFnZUNvbnRlbnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdpbWFnZScpLFxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlNjQtZW5jb2RlZCBpbWFnZSBkYXRhLlxuICAgICAqL1xuICAgIGRhdGE6IEJhc2U2NFNjaGVtYSxcbiAgICAvKipcbiAgICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoZSBpbWFnZS4gRGlmZmVyZW50IHByb3ZpZGVycyBtYXkgc3VwcG9ydCBkaWZmZXJlbnQgaW1hZ2UgdHlwZXMuXG4gICAgICovXG4gICAgbWltZVR5cGU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEFuIEF1ZGlvIHByb3ZpZGVkIHRvIG9yIGZyb20gYW4gTExNLlxuICovXG5leHBvcnRzLkF1ZGlvQ29udGVudFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ2F1ZGlvJyksXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2U2NC1lbmNvZGVkIGF1ZGlvIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTogQmFzZTY0U2NoZW1hLFxuICAgIC8qKlxuICAgICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGF1ZGlvLiBEaWZmZXJlbnQgcHJvdmlkZXJzIG1heSBzdXBwb3J0IGRpZmZlcmVudCBhdWRpbyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW1lVHlwZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogVGhlIGNvbnRlbnRzIG9mIGEgcmVzb3VyY2UsIGVtYmVkZGVkIGludG8gYSBwcm9tcHQgb3IgdG9vbCBjYWxsIHJlc3VsdC5cbiAqL1xuZXhwb3J0cy5FbWJlZGRlZFJlc291cmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgncmVzb3VyY2UnKSxcbiAgICByZXNvdXJjZTogem9kXzEuei51bmlvbihbZXhwb3J0cy5UZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSwgZXhwb3J0cy5CbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYV0pLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBIHJlc291cmNlIHRoYXQgdGhlIHNlcnZlciBpcyBjYXBhYmxlIG9mIHJlYWRpbmcsIGluY2x1ZGVkIGluIGEgcHJvbXB0IG9yIHRvb2wgY2FsbCByZXN1bHQuXG4gKlxuICogTm90ZTogcmVzb3VyY2UgbGlua3MgcmV0dXJuZWQgYnkgdG9vbHMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGFwcGVhciBpbiB0aGUgcmVzdWx0cyBvZiBgcmVzb3VyY2VzL2xpc3RgIHJlcXVlc3RzLlxuICovXG5leHBvcnRzLlJlc291cmNlTGlua1NjaGVtYSA9IGV4cG9ydHMuUmVzb3VyY2VTY2hlbWEuZXh0ZW5kKHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ3Jlc291cmNlX2xpbmsnKVxufSk7XG4vKipcbiAqIEEgY29udGVudCBibG9jayB0aGF0IGNhbiBiZSB1c2VkIGluIHByb21wdHMgYW5kIHRvb2wgcmVzdWx0cy5cbiAqL1xuZXhwb3J0cy5Db250ZW50QmxvY2tTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtcbiAgICBleHBvcnRzLlRleHRDb250ZW50U2NoZW1hLFxuICAgIGV4cG9ydHMuSW1hZ2VDb250ZW50U2NoZW1hLFxuICAgIGV4cG9ydHMuQXVkaW9Db250ZW50U2NoZW1hLFxuICAgIGV4cG9ydHMuUmVzb3VyY2VMaW5rU2NoZW1hLFxuICAgIGV4cG9ydHMuRW1iZWRkZWRSZXNvdXJjZVNjaGVtYVxuXSk7XG4vKipcbiAqIERlc2NyaWJlcyBhIG1lc3NhZ2UgcmV0dXJuZWQgYXMgcGFydCBvZiBhIHByb21wdC5cbiAqL1xuZXhwb3J0cy5Qcm9tcHRNZXNzYWdlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHJvbGU6IHpvZF8xLnouZW51bShbJ3VzZXInLCAnYXNzaXN0YW50J10pLFxuICAgIGNvbnRlbnQ6IGV4cG9ydHMuQ29udGVudEJsb2NrU2NoZW1hXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcmVzcG9uc2UgdG8gYSBwcm9tcHRzL2dldCByZXF1ZXN0IGZyb20gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0cy5HZXRQcm9tcHRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIGRlc2NyaXB0aW9uIGZvciB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIG1lc3NhZ2VzOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuUHJvbXB0TWVzc2FnZVNjaGVtYSlcbn0pO1xuLyoqXG4gKiBBbiBvcHRpb25hbCBub3RpZmljYXRpb24gZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQsIGluZm9ybWluZyBpdCB0aGF0IHRoZSBsaXN0IG9mIHByb21wdHMgaXQgb2ZmZXJzIGhhcyBjaGFuZ2VkLiBUaGlzIG1heSBiZSBpc3N1ZWQgYnkgc2VydmVycyB3aXRob3V0IGFueSBwcmV2aW91cyBzdWJzY3JpcHRpb24gZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLlByb21wdExpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9wcm9tcHRzL2xpc3RfY2hhbmdlZCcpXG59KTtcbi8qIFRvb2xzICovXG4vKipcbiAqIEFkZGl0aW9uYWwgcHJvcGVydGllcyBkZXNjcmliaW5nIGEgVG9vbCB0byBjbGllbnRzLlxuICpcbiAqIE5PVEU6IGFsbCBwcm9wZXJ0aWVzIGluIFRvb2xBbm5vdGF0aW9ucyBhcmUgKipoaW50cyoqLlxuICogVGhleSBhcmUgbm90IGd1YXJhbnRlZWQgdG8gcHJvdmlkZSBhIGZhaXRoZnVsIGRlc2NyaXB0aW9uIG9mXG4gKiB0b29sIGJlaGF2aW9yIChpbmNsdWRpbmcgZGVzY3JpcHRpdmUgcHJvcGVydGllcyBsaWtlIGB0aXRsZWApLlxuICpcbiAqIENsaWVudHMgc2hvdWxkIG5ldmVyIG1ha2UgdG9vbCB1c2UgZGVjaXNpb25zIGJhc2VkIG9uIFRvb2xBbm5vdGF0aW9uc1xuICogcmVjZWl2ZWQgZnJvbSB1bnRydXN0ZWQgc2VydmVycy5cbiAqL1xuZXhwb3J0cy5Ub29sQW5ub3RhdGlvbnNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSB0aXRsZSBmb3IgdGhlIHRvb2wuXG4gICAgICovXG4gICAgdGl0bGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHRvb2wgZG9lcyBub3QgbW9kaWZ5IGl0cyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IGZhbHNlXG4gICAgICovXG4gICAgcmVhZE9ubHlIaW50OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgdG9vbCBtYXkgcGVyZm9ybSBkZXN0cnVjdGl2ZSB1cGRhdGVzIHRvIGl0cyBlbnZpcm9ubWVudC5cbiAgICAgKiBJZiBmYWxzZSwgdGhlIHRvb2wgcGVyZm9ybXMgb25seSBhZGRpdGl2ZSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogKFRoaXMgcHJvcGVydHkgaXMgbWVhbmluZ2Z1bCBvbmx5IHdoZW4gYHJlYWRPbmx5SGludCA9PSBmYWxzZWApXG4gICAgICpcbiAgICAgKiBEZWZhdWx0OiB0cnVlXG4gICAgICovXG4gICAgZGVzdHJ1Y3RpdmVIaW50OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBjYWxsaW5nIHRoZSB0b29sIHJlcGVhdGVkbHkgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGhhdmUgbm8gYWRkaXRpb25hbCBlZmZlY3Qgb24gdGhlIGl0cyBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIChUaGlzIHByb3BlcnR5IGlzIG1lYW5pbmdmdWwgb25seSB3aGVuIGByZWFkT25seUhpbnQgPT0gZmFsc2VgKVxuICAgICAqXG4gICAgICogRGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgICBpZGVtcG90ZW50SGludDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSksXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyB0b29sIG1heSBpbnRlcmFjdCB3aXRoIGFuIFwib3BlbiB3b3JsZFwiIG9mIGV4dGVybmFsXG4gICAgICogZW50aXRpZXMuIElmIGZhbHNlLCB0aGUgdG9vbCdzIGRvbWFpbiBvZiBpbnRlcmFjdGlvbiBpcyBjbG9zZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSB3b3JsZCBvZiBhIHdlYiBzZWFyY2ggdG9vbCBpcyBvcGVuLCB3aGVyZWFzIHRoYXRcbiAgICAgKiBvZiBhIG1lbW9yeSB0b29sIGlzIG5vdC5cbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IHRydWVcbiAgICAgKi9cbiAgICBvcGVuV29ybGRIaW50OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogRGVmaW5pdGlvbiBmb3IgYSB0b29sIHRoZSBjbGllbnQgY2FuIGNhbGwuXG4gKi9cbmV4cG9ydHMuVG9vbFNjaGVtYSA9IGV4cG9ydHMuQmFzZU1ldGFkYXRhU2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBBIEpTT04gU2NoZW1hIG9iamVjdCBkZWZpbmluZyB0aGUgZXhwZWN0ZWQgcGFyYW1ldGVycyBmb3IgdGhlIHRvb2wuXG4gICAgICovXG4gICAgaW5wdXRTY2hlbWE6IHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgnb2JqZWN0JyksXG4gICAgICAgIHByb3BlcnRpZXM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgICAgICByZXF1aXJlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpKVxuICAgIH0pXG4gICAgICAgIC5wYXNzdGhyb3VnaCgpLFxuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIEpTT04gU2NoZW1hIG9iamVjdCBkZWZpbmluZyB0aGUgc3RydWN0dXJlIG9mIHRoZSB0b29sJ3Mgb3V0cHV0IHJldHVybmVkIGluXG4gICAgICogdGhlIHN0cnVjdHVyZWRDb250ZW50IGZpZWxkIG9mIGEgQ2FsbFRvb2xSZXN1bHQuXG4gICAgICovXG4gICAgb3V0cHV0U2NoZW1hOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgnb2JqZWN0JyksXG4gICAgICAgIHByb3BlcnRpZXM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgICAgICByZXF1aXJlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpKVxuICAgIH0pXG4gICAgICAgIC5wYXNzdGhyb3VnaCgpKSxcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBhZGRpdGlvbmFsIHRvb2wgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgYW5ub3RhdGlvbnM6IHpvZF8xLnoub3B0aW9uYWwoZXhwb3J0cy5Ub29sQW5ub3RhdGlvbnNTY2hlbWEpLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5tZXJnZShleHBvcnRzLkljb25zU2NoZW1hKTtcbi8qKlxuICogU2VudCBmcm9tIHRoZSBjbGllbnQgdG8gcmVxdWVzdCBhIGxpc3Qgb2YgdG9vbHMgdGhlIHNlcnZlciBoYXMuXG4gKi9cbmV4cG9ydHMuTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCd0b29scy9saXN0Jylcbn0pO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcmVzcG9uc2UgdG8gYSB0b29scy9saXN0IHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkxpc3RUb29sc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgdG9vbHM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5Ub29sU2NoZW1hKVxufSk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIHRvb2wgY2FsbC5cbiAqL1xuZXhwb3J0cy5DYWxsVG9vbFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGNvbnRlbnQgb2JqZWN0cyB0aGF0IHJlcHJlc2VudCB0aGUgcmVzdWx0IG9mIHRoZSB0b29sIGNhbGwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVG9vbCBkb2VzIG5vdCBkZWZpbmUgYW4gb3V0cHV0U2NoZW1hLCB0aGlzIGZpZWxkIE1VU1QgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0LlxuICAgICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdGhpcyBmaWVsZCBpcyBhbHdheXMgcHJlc2VudCwgYnV0IGl0IG1heSBiZSBlbXB0eS5cbiAgICAgKi9cbiAgICBjb250ZW50OiB6b2RfMS56LmFycmF5KGV4cG9ydHMuQ29udGVudEJsb2NrU2NoZW1hKS5kZWZhdWx0KFtdKSxcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBzdHJ1Y3R1cmVkIHRvb2wgb3V0cHV0LlxuICAgICAqXG4gICAgICogSWYgdGhlIFRvb2wgZGVmaW5lcyBhbiBvdXRwdXRTY2hlbWEsIHRoaXMgZmllbGQgTVVTVCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHQsIGFuZCBjb250YWluIGEgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RydWN0dXJlZENvbnRlbnQ6IHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpLm9wdGlvbmFsKCksXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdG9vbCBjYWxsIGVuZGVkIGluIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogSWYgbm90IHNldCwgdGhpcyBpcyBhc3N1bWVkIHRvIGJlIGZhbHNlICh0aGUgY2FsbCB3YXMgc3VjY2Vzc2Z1bCkuXG4gICAgICpcbiAgICAgKiBBbnkgZXJyb3JzIHRoYXQgb3JpZ2luYXRlIGZyb20gdGhlIHRvb2wgU0hPVUxEIGJlIHJlcG9ydGVkIGluc2lkZSB0aGUgcmVzdWx0XG4gICAgICogb2JqZWN0LCB3aXRoIGBpc0Vycm9yYCBzZXQgdG8gdHJ1ZSwgX25vdF8gYXMgYW4gTUNQIHByb3RvY29sLWxldmVsIGVycm9yXG4gICAgICogcmVzcG9uc2UuIE90aGVyd2lzZSwgdGhlIExMTSB3b3VsZCBub3QgYmUgYWJsZSB0byBzZWUgdGhhdCBhbiBlcnJvciBvY2N1cnJlZFxuICAgICAqIGFuZCBzZWxmLWNvcnJlY3QuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBhbnkgZXJyb3JzIGluIF9maW5kaW5nXyB0aGUgdG9vbCwgYW4gZXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZVxuICAgICAqIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRvb2wgY2FsbHMsIG9yIGFueSBvdGhlciBleGNlcHRpb25hbCBjb25kaXRpb25zLFxuICAgICAqIHNob3VsZCBiZSByZXBvcnRlZCBhcyBhbiBNQ1AgZXJyb3IgcmVzcG9uc2UuXG4gICAgICovXG4gICAgaXNFcnJvcjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSlcbn0pO1xuLyoqXG4gKiBDYWxsVG9vbFJlc3VsdFNjaGVtYSBleHRlbmRlZCB3aXRoIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIHByb3RvY29sIHZlcnNpb24gMjAyNC0xMC0wNy5cbiAqL1xuZXhwb3J0cy5Db21wYXRpYmlsaXR5Q2FsbFRvb2xSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkNhbGxUb29sUmVzdWx0U2NoZW1hLm9yKGV4cG9ydHMuUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgdG9vbFJlc3VsdDogem9kXzEuei51bmtub3duKClcbn0pKTtcbi8qKlxuICogVXNlZCBieSB0aGUgY2xpZW50IHRvIGludm9rZSBhIHRvb2wgcHJvdmlkZWQgYnkgdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0cy5DYWxsVG9vbFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgndG9vbHMvY2FsbCcpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgYXJndW1lbnRzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoucmVjb3JkKHpvZF8xLnoudW5rbm93bigpKSlcbiAgICB9KVxufSk7XG4vKipcbiAqIEFuIG9wdGlvbmFsIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCwgaW5mb3JtaW5nIGl0IHRoYXQgdGhlIGxpc3Qgb2YgdG9vbHMgaXQgb2ZmZXJzIGhhcyBjaGFuZ2VkLiBUaGlzIG1heSBiZSBpc3N1ZWQgYnkgc2VydmVycyB3aXRob3V0IGFueSBwcmV2aW91cyBzdWJzY3JpcHRpb24gZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLlRvb2xMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ25vdGlmaWNhdGlvbnMvdG9vbHMvbGlzdF9jaGFuZ2VkJylcbn0pO1xuLyogTG9nZ2luZyAqL1xuLyoqXG4gKiBUaGUgc2V2ZXJpdHkgb2YgYSBsb2cgbWVzc2FnZS5cbiAqL1xuZXhwb3J0cy5Mb2dnaW5nTGV2ZWxTY2hlbWEgPSB6b2RfMS56LmVudW0oWydkZWJ1ZycsICdpbmZvJywgJ25vdGljZScsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2NyaXRpY2FsJywgJ2FsZXJ0JywgJ2VtZXJnZW5jeSddKTtcbi8qKlxuICogQSByZXF1ZXN0IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLCB0byBlbmFibGUgb3IgYWRqdXN0IGxvZ2dpbmcuXG4gKi9cbmV4cG9ydHMuU2V0TGV2ZWxSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ2xvZ2dpbmcvc2V0TGV2ZWwnKSxcbiAgICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGV2ZWwgb2YgbG9nZ2luZyB0aGF0IHRoZSBjbGllbnQgd2FudHMgdG8gcmVjZWl2ZSBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSBzZXJ2ZXIgc2hvdWxkIHNlbmQgYWxsIGxvZ3MgYXQgdGhpcyBsZXZlbCBhbmQgaGlnaGVyIChpLmUuLCBtb3JlIHNldmVyZSkgdG8gdGhlIGNsaWVudCBhcyBub3RpZmljYXRpb25zL2xvZ2dpbmcvbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldmVsOiBleHBvcnRzLkxvZ2dpbmdMZXZlbFNjaGVtYVxuICAgIH0pXG59KTtcbi8qKlxuICogTm90aWZpY2F0aW9uIG9mIGEgbG9nIG1lc3NhZ2UgcGFzc2VkIGZyb20gc2VydmVyIHRvIGNsaWVudC4gSWYgbm8gbG9nZ2luZy9zZXRMZXZlbCByZXF1ZXN0IGhhcyBiZWVuIHNlbnQgZnJvbSB0aGUgY2xpZW50LCB0aGUgc2VydmVyIE1BWSBkZWNpZGUgd2hpY2ggbWVzc2FnZXMgdG8gc2VuZCBhdXRvbWF0aWNhbGx5LlxuICovXG5leHBvcnRzLkxvZ2dpbmdNZXNzYWdlTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9tZXNzYWdlJyksXG4gICAgcGFyYW1zOiBCYXNlTm90aWZpY2F0aW9uUGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2V2ZXJpdHkgb2YgdGhpcyBsb2cgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldmVsOiBleHBvcnRzLkxvZ2dpbmdMZXZlbFNjaGVtYSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGxvZ2dlciBpc3N1aW5nIHRoaXMgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGxvZ2dlcjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhIHRvIGJlIGxvZ2dlZCwgc3VjaCBhcyBhIHN0cmluZyBtZXNzYWdlIG9yIGFuIG9iamVjdC4gQW55IEpTT04gc2VyaWFsaXphYmxlIHR5cGUgaXMgYWxsb3dlZCBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YTogem9kXzEuei51bmtub3duKClcbiAgICB9KVxufSk7XG4vKiBTYW1wbGluZyAqL1xuLyoqXG4gKiBIaW50cyB0byB1c2UgZm9yIG1vZGVsIHNlbGVjdGlvbi5cbiAqL1xuZXhwb3J0cy5Nb2RlbEhpbnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogQSBoaW50IGZvciBhIG1vZGVsIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcHJlZmVyZW5jZXMgZm9yIG1vZGVsIHNlbGVjdGlvbiwgcmVxdWVzdGVkIG9mIHRoZSBjbGllbnQgZHVyaW5nIHNhbXBsaW5nLlxuICovXG5leHBvcnRzLk1vZGVsUHJlZmVyZW5jZXNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgaGludHMgdG8gdXNlIGZvciBtb2RlbCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgaGludHM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5hcnJheShleHBvcnRzLk1vZGVsSGludFNjaGVtYSkpLFxuICAgIC8qKlxuICAgICAqIEhvdyBtdWNoIHRvIHByaW9yaXRpemUgY29zdCB3aGVuIHNlbGVjdGluZyBhIG1vZGVsLlxuICAgICAqL1xuICAgIGNvc3RQcmlvcml0eTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMSkpLFxuICAgIC8qKlxuICAgICAqIEhvdyBtdWNoIHRvIHByaW9yaXRpemUgc2FtcGxpbmcgc3BlZWQgKGxhdGVuY3kpIHdoZW4gc2VsZWN0aW5nIGEgbW9kZWwuXG4gICAgICovXG4gICAgc3BlZWRQcmlvcml0eTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMSkpLFxuICAgIC8qKlxuICAgICAqIEhvdyBtdWNoIHRvIHByaW9yaXRpemUgaW50ZWxsaWdlbmNlIGFuZCBjYXBhYmlsaXRpZXMgd2hlbiBzZWxlY3RpbmcgYSBtb2RlbC5cbiAgICAgKi9cbiAgICBpbnRlbGxpZ2VuY2VQcmlvcml0eTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMSkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBEZXNjcmliZXMgYSBtZXNzYWdlIGlzc3VlZCB0byBvciByZWNlaXZlZCBmcm9tIGFuIExMTSBBUEkuXG4gKi9cbmV4cG9ydHMuU2FtcGxpbmdNZXNzYWdlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHJvbGU6IHpvZF8xLnouZW51bShbJ3VzZXInLCAnYXNzaXN0YW50J10pLFxuICAgIGNvbnRlbnQ6IHpvZF8xLnoudW5pb24oW2V4cG9ydHMuVGV4dENvbnRlbnRTY2hlbWEsIGV4cG9ydHMuSW1hZ2VDb250ZW50U2NoZW1hLCBleHBvcnRzLkF1ZGlvQ29udGVudFNjaGVtYV0pXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBIHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIHRvIHNhbXBsZSBhbiBMTE0gdmlhIHRoZSBjbGllbnQuIFRoZSBjbGllbnQgaGFzIGZ1bGwgZGlzY3JldGlvbiBvdmVyIHdoaWNoIG1vZGVsIHRvIHNlbGVjdC4gVGhlIGNsaWVudCBzaG91bGQgYWxzbyBpbmZvcm0gdGhlIHVzZXIgYmVmb3JlIGJlZ2lubmluZyBzYW1wbGluZywgdG8gYWxsb3cgdGhlbSB0byBpbnNwZWN0IHRoZSByZXF1ZXN0IChodW1hbiBpbiB0aGUgbG9vcCkgYW5kIGRlY2lkZSB3aGV0aGVyIHRvIGFwcHJvdmUgaXQuXG4gKi9cbmV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnc2FtcGxpbmcvY3JlYXRlTWVzc2FnZScpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgbWVzc2FnZXM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5TYW1wbGluZ01lc3NhZ2VTY2hlbWEpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3lzdGVtIHByb21wdCB0aGUgc2VydmVyIHdhbnRzIHRvIHVzZSBmb3Igc2FtcGxpbmcuIFRoZSBjbGllbnQgTUFZIG1vZGlmeSBvciBvbWl0IHRoaXMgcHJvbXB0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3lzdGVtUHJvbXB0OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZXF1ZXN0IHRvIGluY2x1ZGUgY29udGV4dCBmcm9tIG9uZSBvciBtb3JlIE1DUCBzZXJ2ZXJzIChpbmNsdWRpbmcgdGhlIGNhbGxlciksIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBwcm9tcHQuIFRoZSBjbGllbnQgTUFZIGlnbm9yZSB0aGlzIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpbmNsdWRlQ29udGV4dDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmVudW0oWydub25lJywgJ3RoaXNTZXJ2ZXInLCAnYWxsU2VydmVycyddKSksXG4gICAgICAgIHRlbXBlcmF0dXJlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0byBzYW1wbGUsIGFzIHJlcXVlc3RlZCBieSB0aGUgc2VydmVyLiBUaGUgY2xpZW50IE1BWSBjaG9vc2UgdG8gc2FtcGxlIGZld2VyIHRva2VucyB0aGFuIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIG1heFRva2Vuczogem9kXzEuei5udW1iZXIoKS5pbnQoKSxcbiAgICAgICAgc3RvcFNlcXVlbmNlczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdGhyb3VnaCB0byB0aGUgTExNIHByb3ZpZGVyLiBUaGUgZm9ybWF0IG9mIHRoaXMgbWV0YWRhdGEgaXMgcHJvdmlkZXItc3BlY2lmaWMuXG4gICAgICAgICAqL1xuICAgICAgICBtZXRhZGF0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VydmVyJ3MgcHJlZmVyZW5jZXMgZm9yIHdoaWNoIG1vZGVsIHRvIHNlbGVjdC5cbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsUHJlZmVyZW5jZXM6IHpvZF8xLnoub3B0aW9uYWwoZXhwb3J0cy5Nb2RlbFByZWZlcmVuY2VzU2NoZW1hKVxuICAgIH0pXG59KTtcbi8qKlxuICogVGhlIGNsaWVudCdzIHJlc3BvbnNlIHRvIGEgc2FtcGxpbmcvY3JlYXRlX21lc3NhZ2UgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSBjbGllbnQgc2hvdWxkIGluZm9ybSB0aGUgdXNlciBiZWZvcmUgcmV0dXJuaW5nIHRoZSBzYW1wbGVkIG1lc3NhZ2UsIHRvIGFsbG93IHRoZW0gdG8gaW5zcGVjdCB0aGUgcmVzcG9uc2UgKGh1bWFuIGluIHRoZSBsb29wKSBhbmQgZGVjaWRlIHdoZXRoZXIgdG8gYWxsb3cgdGhlIHNlcnZlciB0byBzZWUgaXQuXG4gKi9cbmV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRoYXQgZ2VuZXJhdGVkIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIG1vZGVsOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gd2h5IHNhbXBsaW5nIHN0b3BwZWQuXG4gICAgICovXG4gICAgc3RvcFJlYXNvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmVudW0oWydlbmRUdXJuJywgJ3N0b3BTZXF1ZW5jZScsICdtYXhUb2tlbnMnXSkub3Ioem9kXzEuei5zdHJpbmcoKSkpLFxuICAgIHJvbGU6IHpvZF8xLnouZW51bShbJ3VzZXInLCAnYXNzaXN0YW50J10pLFxuICAgIGNvbnRlbnQ6IHpvZF8xLnouZGlzY3JpbWluYXRlZFVuaW9uKCd0eXBlJywgW2V4cG9ydHMuVGV4dENvbnRlbnRTY2hlbWEsIGV4cG9ydHMuSW1hZ2VDb250ZW50U2NoZW1hLCBleHBvcnRzLkF1ZGlvQ29udGVudFNjaGVtYV0pXG59KTtcbi8qIEVsaWNpdGF0aW9uICovXG4vKipcbiAqIFByaW1pdGl2ZSBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgYm9vbGVhbiBmaWVsZHMuXG4gKi9cbmV4cG9ydHMuQm9vbGVhblNjaGVtYVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ2Jvb2xlYW4nKSxcbiAgICB0aXRsZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBkZXNjcmlwdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBkZWZhdWx0OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogUHJpbWl0aXZlIHNjaGVtYSBkZWZpbml0aW9uIGZvciBzdHJpbmcgZmllbGRzLlxuICovXG5leHBvcnRzLlN0cmluZ1NjaGVtYVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ3N0cmluZycpLFxuICAgIHRpdGxlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIG1pbkxlbmd0aDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpKSxcbiAgICBtYXhMZW5ndGg6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5udW1iZXIoKSksXG4gICAgZm9ybWF0OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouZW51bShbJ2VtYWlsJywgJ3VyaScsICdkYXRlJywgJ2RhdGUtdGltZSddKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIFByaW1pdGl2ZSBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgbnVtYmVyIGZpZWxkcy5cbiAqL1xuZXhwb3J0cy5OdW1iZXJTY2hlbWFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5lbnVtKFsnbnVtYmVyJywgJ2ludGVnZXInXSksXG4gICAgdGl0bGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgbWluaW11bTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpKSxcbiAgICBtYXhpbXVtOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBQcmltaXRpdmUgc2NoZW1hIGRlZmluaXRpb24gZm9yIGVudW0gZmllbGRzLlxuICovXG5leHBvcnRzLkVudW1TY2hlbWFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdzdHJpbmcnKSxcbiAgICB0aXRsZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBkZXNjcmlwdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBlbnVtOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGVudW1OYW1lczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogVW5pb24gb2YgYWxsIHByaW1pdGl2ZSBzY2hlbWEgZGVmaW5pdGlvbnMuXG4gKi9cbmV4cG9ydHMuUHJpbWl0aXZlU2NoZW1hRGVmaW5pdGlvblNjaGVtYSA9IHpvZF8xLnoudW5pb24oW2V4cG9ydHMuQm9vbGVhblNjaGVtYVNjaGVtYSwgZXhwb3J0cy5TdHJpbmdTY2hlbWFTY2hlbWEsIGV4cG9ydHMuTnVtYmVyU2NoZW1hU2NoZW1hLCBleHBvcnRzLkVudW1TY2hlbWFTY2hlbWFdKTtcbi8qKlxuICogQSByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciB0byBlbGljaXQgdXNlciBpbnB1dCB2aWEgdGhlIGNsaWVudC5cbiAqIFRoZSBjbGllbnQgc2hvdWxkIHByZXNlbnQgdGhlIG1lc3NhZ2UgYW5kIGZvcm0gZmllbGRzIHRvIHRoZSB1c2VyLlxuICovXG5leHBvcnRzLkVsaWNpdFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnZWxpY2l0YXRpb24vY3JlYXRlJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lc3NhZ2UgdG8gcHJlc2VudCB0byB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NoZW1hIGZvciB0aGUgcmVxdWVzdGVkIHVzZXIgaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0ZWRTY2hlbWE6IHpvZF8xLnpcbiAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdvYmplY3QnKSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouc3RyaW5nKCksIGV4cG9ydHMuUHJpbWl0aXZlU2NoZW1hRGVmaW5pdGlvblNjaGVtYSksXG4gICAgICAgICAgICByZXF1aXJlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnBhc3N0aHJvdWdoKClcbiAgICB9KVxufSk7XG4vKipcbiAqIFRoZSBjbGllbnQncyByZXNwb25zZSB0byBhbiBlbGljaXRhdGlvbi9jcmVhdGUgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydHMuRWxpY2l0UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcidzIHJlc3BvbnNlIGFjdGlvbi5cbiAgICAgKi9cbiAgICBhY3Rpb246IHpvZF8xLnouZW51bShbJ2FjY2VwdCcsICdkZWNsaW5lJywgJ2NhbmNlbCddKSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGVkIHVzZXIgaW5wdXQgY29udGVudCAob25seSBwcmVzZW50IGlmIGFjdGlvbiBpcyBcImFjY2VwdFwiKS5cbiAgICAgKi9cbiAgICBjb250ZW50OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoucmVjb3JkKHpvZF8xLnouc3RyaW5nKCksIHpvZF8xLnoudW5rbm93bigpKSlcbn0pO1xuLyogQXV0b2NvbXBsZXRlICovXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgcmVzb3VyY2Ugb3IgcmVzb3VyY2UgdGVtcGxhdGUgZGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlUmVmZXJlbmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgncmVmL3Jlc291cmNlJyksXG4gICAgLyoqXG4gICAgICogVGhlIFVSSSBvciBVUkkgdGVtcGxhdGUgb2YgdGhlIHJlc291cmNlLlxuICAgICAqL1xuICAgIHVyaTogem9kXzEuei5zdHJpbmcoKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFJlc291cmNlVGVtcGxhdGVSZWZlcmVuY2VTY2hlbWEgaW5zdGVhZFxuICovXG5leHBvcnRzLlJlc291cmNlUmVmZXJlbmNlU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlUmVmZXJlbmNlU2NoZW1hO1xuLyoqXG4gKiBJZGVudGlmaWVzIGEgcHJvbXB0LlxuICovXG5leHBvcnRzLlByb21wdFJlZmVyZW5jZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ3JlZi9wcm9tcHQnKSxcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvbXB0IG9yIHByb21wdCB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKClcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEEgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciwgdG8gYXNrIGZvciBjb21wbGV0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydHMuQ29tcGxldGVSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ2NvbXBsZXRpb24vY29tcGxldGUnKSxcbiAgICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIHJlZjogem9kXzEuei51bmlvbihbZXhwb3J0cy5Qcm9tcHRSZWZlcmVuY2VTY2hlbWEsIGV4cG9ydHMuUmVzb3VyY2VUZW1wbGF0ZVJlZmVyZW5jZVNjaGVtYV0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZ3VtZW50J3MgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3VtZW50OiB6b2RfMS56XG4gICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgdG8gdXNlIGZvciBjb21wbGV0aW9uIG1hdGNoaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YWx1ZTogem9kXzEuei5zdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnBhc3N0aHJvdWdoKCksXG4gICAgICAgIGNvbnRleHQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmV2aW91c2x5LXJlc29sdmVkIHZhcmlhYmxlcyBpbiBhIFVSSSB0ZW1wbGF0ZSBvciBwcm9tcHQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFyZ3VtZW50czogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnJlY29yZCh6b2RfMS56LnN0cmluZygpLCB6b2RfMS56LnN0cmluZygpKSlcbiAgICAgICAgfSkpXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcmVzcG9uc2UgdG8gYSBjb21wbGV0aW9uL2NvbXBsZXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0cy5Db21wbGV0ZVJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgY29tcGxldGlvbjogem9kXzEuelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGNvbXBsZXRpb24gdmFsdWVzLiBNdXN0IG5vdCBleGNlZWQgMTAwIGl0ZW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVzOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm1heCgxMDApLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBjb21wbGV0aW9uIG9wdGlvbnMgYXZhaWxhYmxlLiBUaGlzIGNhbiBleGNlZWQgdGhlIG51bWJlciBvZiB2YWx1ZXMgYWN0dWFsbHkgc2VudCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpLmludCgpKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBhZGRpdGlvbmFsIGNvbXBsZXRpb24gb3B0aW9ucyBiZXlvbmQgdGhvc2UgcHJvdmlkZWQgaW4gdGhlIGN1cnJlbnQgcmVzcG9uc2UsIGV2ZW4gaWYgdGhlIGV4YWN0IHRvdGFsIGlzIHVua25vd24uXG4gICAgICAgICAqL1xuICAgICAgICBoYXNNb3JlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxuICAgIH0pXG4gICAgICAgIC5wYXNzdGhyb3VnaCgpXG59KTtcbi8qIFJvb3RzICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSByb290IGRpcmVjdG9yeSBvciBmaWxlIHRoYXQgdGhlIHNlcnZlciBjYW4gb3BlcmF0ZSBvbi5cbiAqL1xuZXhwb3J0cy5Sb290U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIFRoZSBVUkkgaWRlbnRpZnlpbmcgdGhlIHJvb3QuIFRoaXMgKm11c3QqIHN0YXJ0IHdpdGggZmlsZTovLyBmb3Igbm93LlxuICAgICAqL1xuICAgIHVyaTogem9kXzEuei5zdHJpbmcoKS5zdGFydHNXaXRoKCdmaWxlOi8vJyksXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHJvb3QuXG4gICAgICovXG4gICAgbmFtZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogU2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gcmVxdWVzdCBhIGxpc3Qgb2Ygcm9vdCBVUklzIGZyb20gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0cy5MaXN0Um9vdHNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Jvb3RzL2xpc3QnKVxufSk7XG4vKipcbiAqIFRoZSBjbGllbnQncyByZXNwb25zZSB0byBhIHJvb3RzL2xpc3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydHMuTGlzdFJvb3RzUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICByb290czogem9kXzEuei5hcnJheShleHBvcnRzLlJvb3RTY2hlbWEpXG59KTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIsIGluZm9ybWluZyBpdCB0aGF0IHRoZSBsaXN0IG9mIHJvb3RzIGhhcyBjaGFuZ2VkLlxuICovXG5leHBvcnRzLlJvb3RzTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL3Jvb3RzL2xpc3RfY2hhbmdlZCcpXG59KTtcbi8qIENsaWVudCBtZXNzYWdlcyAqL1xuZXhwb3J0cy5DbGllbnRSZXF1ZXN0U2NoZW1hID0gem9kXzEuei51bmlvbihbXG4gICAgZXhwb3J0cy5QaW5nUmVxdWVzdFNjaGVtYSxcbiAgICBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuQ29tcGxldGVSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuU2V0TGV2ZWxSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuR2V0UHJvbXB0UmVxdWVzdFNjaGVtYSxcbiAgICBleHBvcnRzLkxpc3RQcm9tcHRzUmVxdWVzdFNjaGVtYSxcbiAgICBleHBvcnRzLkxpc3RSZXNvdXJjZXNSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFJlc291cmNlVGVtcGxhdGVzUmVxdWVzdFNjaGVtYSxcbiAgICBleHBvcnRzLlJlYWRSZXNvdXJjZVJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5TdWJzY3JpYmVSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuVW5zdWJzY3JpYmVSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFRvb2xzUmVxdWVzdFNjaGVtYVxuXSk7XG5leHBvcnRzLkNsaWVudE5vdGlmaWNhdGlvblNjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIGV4cG9ydHMuQ2FuY2VsbGVkTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuUHJvZ3Jlc3NOb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvblNjaGVtYSxcbiAgICBleHBvcnRzLlJvb3RzTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWFcbl0pO1xuZXhwb3J0cy5DbGllbnRSZXN1bHRTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtleHBvcnRzLkVtcHR5UmVzdWx0U2NoZW1hLCBleHBvcnRzLkNyZWF0ZU1lc3NhZ2VSZXN1bHRTY2hlbWEsIGV4cG9ydHMuRWxpY2l0UmVzdWx0U2NoZW1hLCBleHBvcnRzLkxpc3RSb290c1Jlc3VsdFNjaGVtYV0pO1xuLyogU2VydmVyIG1lc3NhZ2VzICovXG5leHBvcnRzLlNlcnZlclJlcXVlc3RTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtleHBvcnRzLlBpbmdSZXF1ZXN0U2NoZW1hLCBleHBvcnRzLkNyZWF0ZU1lc3NhZ2VSZXF1ZXN0U2NoZW1hLCBleHBvcnRzLkVsaWNpdFJlcXVlc3RTY2hlbWEsIGV4cG9ydHMuTGlzdFJvb3RzUmVxdWVzdFNjaGVtYV0pO1xuZXhwb3J0cy5TZXJ2ZXJOb3RpZmljYXRpb25TY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtcbiAgICBleHBvcnRzLkNhbmNlbGxlZE5vdGlmaWNhdGlvblNjaGVtYSxcbiAgICBleHBvcnRzLlByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuTG9nZ2luZ01lc3NhZ2VOb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5SZXNvdXJjZVVwZGF0ZWROb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5SZXNvdXJjZUxpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuVG9vbExpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuUHJvbXB0TGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWFcbl0pO1xuZXhwb3J0cy5TZXJ2ZXJSZXN1bHRTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtcbiAgICBleHBvcnRzLkVtcHR5UmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuSW5pdGlhbGl6ZVJlc3VsdFNjaGVtYSxcbiAgICBleHBvcnRzLkNvbXBsZXRlUmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuR2V0UHJvbXB0UmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFByb21wdHNSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0UmVzb3VyY2VzUmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFJlc291cmNlVGVtcGxhdGVzUmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuUmVhZFJlc291cmNlUmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuQ2FsbFRvb2xSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0VG9vbHNSZXN1bHRTY2hlbWFcbl0pO1xuY2xhc3MgTWNwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihgTUNQIGVycm9yICR7Y29kZX06ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01jcEVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLk1jcEVycm9yID0gTWNwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLG51bGwsImltcG9ydCAqIGFzIHogZnJvbSBcIi4vdjMvZXh0ZXJuYWwuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3YzL2V4dGVybmFsLmpzXCI7XG5leHBvcnQgeyB6IH07XG5leHBvcnQgZGVmYXVsdCB6O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzL3BhcnNlVXRpbC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVscGVycy90eXBlQWxpYXNlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbiIsImltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4vbG9jYWxlcy9lbi5qc1wiO1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBkZWZhdWx0RXJyb3JNYXA7XG5leHBvcnQgeyBkZWZhdWx0RXJyb3JNYXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxuIiwiaW1wb3J0IHsgWm9kSXNzdWVDb2RlIH0gZnJvbSBcIi4uL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbC5qc1wiO1xuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGVycm9yTWFwO1xuIiwiaW1wb3J0IHsgdXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwiaW52YWxpZF90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW52YWxpZF91bmlvblwiLFxuICAgIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcbiAgICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxuICAgIFwiaW52YWxpZF9kYXRlXCIsXG4gICAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICAgIFwidG9vX3NtYWxsXCIsXG4gICAgXCJ0b29fYmlnXCIsXG4gICAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICAgIFwibm90X211bHRpcGxlX29mXCIsXG4gICAgXCJub3RfZmluaXRlXCIsXG5dKTtcbmV4cG9ydCBjb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgc3RhdGljIGFzc2VydCh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsID0gc3ViLnBhdGhbMF07XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0gPSBmaWVsZEVycm9yc1tmaXJzdEVsXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuIiwiZXhwb3J0IHZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9IChfKSA9PiB7IH07XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbiAgICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSkuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG5leHBvcnQgdmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgLi4uc2Vjb25kLCAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgICAgICB9O1xuICAgIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbmV4cG9ydCBjb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5leHBvcnQgY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5hcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmtub3duO1xuICAgIH1cbn07XG4iLCJleHBvcnRzLmludGVyb3BEZWZhdWx0ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS5fX2VzTW9kdWxlID8gYSA6IHtkZWZhdWx0OiBhfTtcbn07XG5cbmV4cG9ydHMuZGVmaW5lSW50ZXJvcEZsYWcgPSBmdW5jdGlvbiAoYSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcbn07XG5cbmV4cG9ydHMuZXhwb3J0QWxsID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdCkge1xuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdkZWZhdWx0JyB8fCBrZXkgPT09ICdfX2VzTW9kdWxlJyB8fCBkZXN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZXhwb3J0cy5leHBvcnQgPSBmdW5jdGlvbiAoZGVzdCwgZGVzdE5hbWUsIGdldCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgZGVzdE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZ2V0LFxuICB9KTtcbn07XG4iLCJpbXBvcnQgeyBnZXRFcnJvck1hcCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4uL2xvY2FsZXMvZW4uanNcIjtcbmV4cG9ydCBjb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGlmIChpc3N1ZURhdGEubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBkZWZhdWx0RXJyb3JNYXAgPyB1bmRlZmluZWQgOiBkZWZhdWx0RXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuZXhwb3J0IGNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmV4cG9ydCBjb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmV4cG9ydCBjb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5leHBvcnQgY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuZXhwb3J0IGNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG4iLCJleHBvcnQge307XG4iLCJpbXBvcnQgeyBab2RFcnJvciwgWm9kSXNzdWVDb2RlLCB9IGZyb20gXCIuL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RXJyb3JNYXAsIGdldEVycm9yTWFwIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBlcnJvclV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL2Vycm9yVXRpbC5qc1wiO1xuaW1wb3J0IHsgRElSVFksIElOVkFMSUQsIE9LLCBQYXJzZVN0YXR1cywgYWRkSXNzdWVUb0NvbnRleHQsIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbWFrZUlzc3VlLCB9IGZyb20gXCIuL2hlbHBlcnMvcGFyc2VVdGlsLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlLCBnZXRQYXJzZWRUeXBlIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IHJlcXVpcmVkX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gaW52YWxpZF90eXBlX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5leHBvcnQgY2xhc3MgWm9kVHlwZSB7XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogcGFyYW1zPy5hc3luYyA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpPy5pbmNsdWRlcyhcImVuY291bnRlcmVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguY29tbW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUFzeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pLnRoZW4oKHJlc3VsdCkgPT4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpID8gbWF5YmVBc3luY1Jlc3VsdCA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xuICAgICAgICAgICAgY29uc3Qgc2V0RXJyb3IgPSAoKSA9PiBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIiA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KSA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKGRhdGEpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0oZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBpc09wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIH1cbiAgICBpc051bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICB9XG59XG5jb25zdCBjdWlkUmVnZXggPSAvXmNbXlxccy1dezgsfSQvaTtcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuY29uc3QgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pO1xuY29uc3Qgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XycrXFwtXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16MC05LiEjJCUm4oCZKisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppUmVnZXggPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xubGV0IGVtb2ppUmVnZXg7XG4vLyBmYXN0ZXIsIHNpbXBsZXIsIHNhZmVyXG5jb25zdCBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xuLy8gY29uc3QgaXB2NlJlZ2V4ID1cbi8vIC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XG5jb25zdCBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XG4vLyBodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmxcbmNvbnN0IGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xuLy8gc2ltcGxlXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1gO1xuLy8gbm8gbGVhcCB5ZWFyIHZhbGlkYXRpb25cbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XG4vLyB3aXRoIGxlYXAgeWVhciB2YWxpZGF0aW9uXG5jb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICAgIGxldCBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgWzAtNV1cXFxcZGA7XG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfShcXFxcLlxcXFxkKyk/YDtcbiAgICB9XG4gICAgY29uc3Qgc2Vjb25kc1F1YW50aWZpZXIgPSBhcmdzLnByZWNpc2lvbiA/IFwiK1wiIDogXCI/XCI7IC8vIHJlcXVpcmUgc2Vjb25kcyBpZiBwcmVjaXNpb24gaXMgbm9uemVyb1xuICAgIHJldHVybiBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQoOiR7c2Vjb25kc1JlZ2V4U291cmNlfSkke3NlY29uZHNRdWFudGlmaWVyfWA7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9JGApO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVjb2RlZCAhPT0gXCJvYmplY3RcIiB8fCBkZWNvZGVkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoXCJ0eXBcIiBpbiBkZWNvZGVkICYmIGRlY29kZWQ/LnR5cCAhPT0gXCJKV1RcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFkZWNvZGVkLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZENpZHIoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NENpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgand0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBjaWRyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIG9wdGlvbnM/LnByZWNpc2lvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zPy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnM/Lm9mZnNldCA/PyBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsOiBvcHRpb25zPy5sb2NhbCA/PyBmYWxzZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgICB9XG4gICAgdGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIG9wdGlvbnM/LnByZWNpc2lvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zPy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkdXJhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zPy5wb3NpdGlvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBOdW1iZXIucGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyAxMCAqKiBkZWNDb3VudDtcbn1cbmV4cG9ydCBjbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fCAoY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKSk7XG4gICAgfVxuICAgIGdldCBpc0Zpbml0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiAodG9vU21hbGwgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiAodG9vQmlnID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1pbkxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoID4gZGVmLm1heExlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiB7IHZhbHVlOiBtaW5MZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heExlbmd0aDogeyB2YWx1ZTogbWF4TGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBleGFjdExlbmd0aDogeyB2YWx1ZTogbGVuLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZEFycmF5LmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIG1pbkxlbmd0aDogbnVsbCxcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgICAgICBleGFjdExlbmd0aDogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHNjaGVtYS5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShmaWVsZFNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XG4gICAgICAgIHJldHVybiBab2RUdXBsZS5jcmVhdGUoc2NoZW1hLml0ZW1zLm1hcCgoaXRlbSkgPT4gZGVlcFBhcnRpYWxpZnkoaXRlbSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlWYWxpZGF0b3IgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGtleVZhbGlkYXRvci5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gdGhpcy5fZGVmLnVua25vd25LZXlzO1xuICAgICAgICAgICAgaWYgKHVua25vd25LZXlzID09PSBcInBhc3N0aHJvdWdoXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcnVuIGNhdGNoYWxsIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNhdGNoYWxsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhdGNoYWxsLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICB9XG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSB0aGlzLl9kZWYuZXJyb3JNYXA/Lihpc3N1ZSwgY3R4KS5tZXNzYWdlID8/IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlID8/IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gICAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgLy8gICApOiBab2RPYmplY3Q8XG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAgIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyAgID4gPT4ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgICAgLi4uZGVmLFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgLy8gICAgICAgfSksXG4gICAgLy8gICAgIH0pIGFzIGFueTtcbiAgICAvLyAgIH07XG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIC8vIG1lcmdlPFxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfSxcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9XG4gICAgLy8gPihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgICAvLyAgIE5ld091dHB1dCxcbiAgICAvLyAgIE5ld0lucHV0XG4gICAgLy8gPiB7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICAgIH1cbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gICAgLy8gWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAgIC8vID4ge1xuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAvLyAgIC8vICk7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGljayhtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyhtYXNrKSkge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmV4cG9ydCBjbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0UGFyc2VkVHlwZShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKHBhcnNlZExlZnQudmFsdWUsIHBhcnNlZFJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIHR5cGUgWm9kVHVwbGVJdGVtcyA9IFtab2RUeXBlQW55LCAuLi5ab2RUeXBlQW55W11dO1xuZXhwb3J0IGNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICAgICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCBnZXRFcnJvck1hcCgpLCBkZWZhdWx0RXJyb3JNYXBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzLnBhcnNlQXN5bmMoYXJncywgcGFyYW1zKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzID8gYXJncyA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTGl0ZXJhbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdGhpcy5fZGVmLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xuICAgIH1cbn1cblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVpvZEVudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IFZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBFbnVtKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuZXhwb3J0IGNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJiBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlID8gY3R4LmRhdGEgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgICAgICByZXR1cm4gT0socHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IHsgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciB9O1xuZXhwb3J0IGNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE51bGxhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0eXBlb2YgcGFyYW1zLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5kZWZhdWx0IDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG59XG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYU4sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5leHBvcnQgY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBc3luYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5pbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKGluUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xuICAgICAgICAgICAgaW46IGEsXG4gICAgICAgICAgICBvdXQ6IGIsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpID8gcmVzdWx0LnRoZW4oKGRhdGEpID0+IGZyZWV6ZShkYXRhKSkgOiBmcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoZGF0YSkgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwYXJhbXMgfSA6IHBhcmFtcztcbiAgICBjb25zdCBwMiA9IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwIH0gOiBwO1xuICAgIHJldHVybiBwMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjaGVjayhkYXRhKTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5leHBvcnQgeyBab2RUeXBlIGFzIFNjaGVtYSwgWm9kVHlwZSBhcyBab2RTY2hlbWEgfTtcbmV4cG9ydCBjb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xuZXhwb3J0IHZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVtYmVyXCJdID0gXCJab2ROdW1iZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQm9vbGVhblwiXSA9IFwiWm9kQm9vbGVhblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RDYXRjaFwiXSA9IFwiWm9kQ2F0Y2hcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFBpcGVsaW5lXCJdID0gXCJab2RQaXBlbGluZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuLy8gcmVxdWlyZXMgVFMgNC40K1xuY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl8pIHsgfVxufVxuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xuY29uc3QgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG5jb25zdCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xuY29uc3QgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbmNvbnN0IGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZTtcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG5jb25zdCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuY29uc3QgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xuY29uc3QgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcbmNvbnN0IHNldFR5cGUgPSBab2RTZXQuY3JlYXRlO1xuY29uc3QgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbmNvbnN0IGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGU7XG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmNvbnN0IHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGU7XG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xuY29uc3QgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xuY29uc3Qgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG5leHBvcnQgY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuZXhwb3J0IHsgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGRhdGVUeXBlIGFzIGRhdGUsIGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgYXMgZGlzY3JpbWluYXRlZFVuaW9uLCBlZmZlY3RzVHlwZSBhcyBlZmZlY3QsIGVudW1UeXBlIGFzIGVudW0sIGZ1bmN0aW9uVHlwZSBhcyBmdW5jdGlvbiwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGxhenlUeXBlIGFzIGxhenksIGxpdGVyYWxUeXBlIGFzIGxpdGVyYWwsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHN0cmljdE9iamVjdFR5cGUgYXMgc3RyaWN0T2JqZWN0LCBzdHJpbmdUeXBlIGFzIHN0cmluZywgc3ltYm9sVHlwZSBhcyBzeW1ib2wsIGVmZmVjdHNUeXBlIGFzIHRyYW5zZm9ybWVyLCB0dXBsZVR5cGUgYXMgdHVwbGUsIHVuZGVmaW5lZFR5cGUgYXMgdW5kZWZpbmVkLCB1bmlvblR5cGUgYXMgdW5pb24sIHVua25vd25UeXBlIGFzIHVua25vd24sIHZvaWRUeXBlIGFzIHZvaWQsIH07XG5leHBvcnQgY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuIiwiZXhwb3J0IHZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXBpbGVTY2hlbWEgPSByZXF1aXJlKCcuL2NvbXBpbGUnKVxuICAsIHJlc29sdmUgPSByZXF1aXJlKCcuL2NvbXBpbGUvcmVzb2x2ZScpXG4gICwgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJylcbiAgLCBTY2hlbWFPYmplY3QgPSByZXF1aXJlKCcuL2NvbXBpbGUvc2NoZW1hX29iaicpXG4gICwgc3RhYmxlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnknKVxuICAsIGZvcm1hdHMgPSByZXF1aXJlKCcuL2NvbXBpbGUvZm9ybWF0cycpXG4gICwgcnVsZXMgPSByZXF1aXJlKCcuL2NvbXBpbGUvcnVsZXMnKVxuICAsICRkYXRhTWV0YVNjaGVtYSA9IHJlcXVpcmUoJy4vZGF0YScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vY29tcGlsZS91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWp2O1xuXG5BanYucHJvdG90eXBlLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5BanYucHJvdG90eXBlLmNvbXBpbGUgPSBjb21waWxlO1xuQWp2LnByb3RvdHlwZS5hZGRTY2hlbWEgPSBhZGRTY2hlbWE7XG5BanYucHJvdG90eXBlLmFkZE1ldGFTY2hlbWEgPSBhZGRNZXRhU2NoZW1hO1xuQWp2LnByb3RvdHlwZS52YWxpZGF0ZVNjaGVtYSA9IHZhbGlkYXRlU2NoZW1hO1xuQWp2LnByb3RvdHlwZS5nZXRTY2hlbWEgPSBnZXRTY2hlbWE7XG5BanYucHJvdG90eXBlLnJlbW92ZVNjaGVtYSA9IHJlbW92ZVNjaGVtYTtcbkFqdi5wcm90b3R5cGUuYWRkRm9ybWF0ID0gYWRkRm9ybWF0O1xuQWp2LnByb3RvdHlwZS5lcnJvcnNUZXh0ID0gZXJyb3JzVGV4dDtcblxuQWp2LnByb3RvdHlwZS5fYWRkU2NoZW1hID0gX2FkZFNjaGVtYTtcbkFqdi5wcm90b3R5cGUuX2NvbXBpbGUgPSBfY29tcGlsZTtcblxuQWp2LnByb3RvdHlwZS5jb21waWxlQXN5bmMgPSByZXF1aXJlKCcuL2NvbXBpbGUvYXN5bmMnKTtcbnZhciBjdXN0b21LZXl3b3JkID0gcmVxdWlyZSgnLi9rZXl3b3JkJyk7XG5BanYucHJvdG90eXBlLmFkZEtleXdvcmQgPSBjdXN0b21LZXl3b3JkLmFkZDtcbkFqdi5wcm90b3R5cGUuZ2V0S2V5d29yZCA9IGN1c3RvbUtleXdvcmQuZ2V0O1xuQWp2LnByb3RvdHlwZS5yZW1vdmVLZXl3b3JkID0gY3VzdG9tS2V5d29yZC5yZW1vdmU7XG5BanYucHJvdG90eXBlLnZhbGlkYXRlS2V5d29yZCA9IGN1c3RvbUtleXdvcmQudmFsaWRhdGU7XG5cbnZhciBlcnJvckNsYXNzZXMgPSByZXF1aXJlKCcuL2NvbXBpbGUvZXJyb3JfY2xhc3NlcycpO1xuQWp2LlZhbGlkYXRpb25FcnJvciA9IGVycm9yQ2xhc3Nlcy5WYWxpZGF0aW9uO1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IGVycm9yQ2xhc3Nlcy5NaXNzaW5nUmVmO1xuQWp2LiRkYXRhTWV0YVNjaGVtYSA9ICRkYXRhTWV0YVNjaGVtYTtcblxudmFyIE1FVEFfU0NIRU1BX0lEID0gJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hJztcblxudmFyIE1FVEFfSUdOT1JFX09QVElPTlMgPSBbICdyZW1vdmVBZGRpdGlvbmFsJywgJ3VzZURlZmF1bHRzJywgJ2NvZXJjZVR5cGVzJywgJ3N0cmljdERlZmF1bHRzJyBdO1xudmFyIE1FVEFfU1VQUE9SVF9EQVRBID0gWycvcHJvcGVydGllcyddO1xuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdG9yIGluc3RhbmNlLlxuICogVXNhZ2U6IGBBanYob3B0cylgXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFqdiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBanYob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWp2KSkgcmV0dXJuIG5ldyBBanYob3B0cyk7XG4gIG9wdHMgPSB0aGlzLl9vcHRzID0gdXRpbC5jb3B5KG9wdHMpIHx8IHt9O1xuICBzZXRMb2dnZXIodGhpcyk7XG4gIHRoaXMuX3NjaGVtYXMgPSB7fTtcbiAgdGhpcy5fcmVmcyA9IHt9O1xuICB0aGlzLl9mcmFnbWVudHMgPSB7fTtcbiAgdGhpcy5fZm9ybWF0cyA9IGZvcm1hdHMob3B0cy5mb3JtYXQpO1xuXG4gIHRoaXMuX2NhY2hlID0gb3B0cy5jYWNoZSB8fCBuZXcgQ2FjaGU7XG4gIHRoaXMuX2xvYWRpbmdTY2hlbWFzID0ge307XG4gIHRoaXMuX2NvbXBpbGF0aW9ucyA9IFtdO1xuICB0aGlzLlJVTEVTID0gcnVsZXMoKTtcbiAgdGhpcy5fZ2V0SWQgPSBjaG9vc2VHZXRJZChvcHRzKTtcblxuICBvcHRzLmxvb3BSZXF1aXJlZCA9IG9wdHMubG9vcFJlcXVpcmVkIHx8IEluZmluaXR5O1xuICBpZiAob3B0cy5lcnJvckRhdGFQYXRoID09ICdwcm9wZXJ0eScpIG9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSA9IHRydWU7XG4gIGlmIChvcHRzLnNlcmlhbGl6ZSA9PT0gdW5kZWZpbmVkKSBvcHRzLnNlcmlhbGl6ZSA9IHN0YWJsZVN0cmluZ2lmeTtcbiAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucyh0aGlzKTtcblxuICBpZiAob3B0cy5mb3JtYXRzKSBhZGRJbml0aWFsRm9ybWF0cyh0aGlzKTtcbiAgaWYgKG9wdHMua2V5d29yZHMpIGFkZEluaXRpYWxLZXl3b3Jkcyh0aGlzKTtcbiAgYWRkRGVmYXVsdE1ldGFTY2hlbWEodGhpcyk7XG4gIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09ICdvYmplY3QnKSB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgaWYgKG9wdHMubnVsbGFibGUpIHRoaXMuYWRkS2V5d29yZCgnbnVsbGFibGUnLCB7bWV0YVNjaGVtYToge3R5cGU6ICdib29sZWFuJ319KTtcbiAgYWRkSW5pdGlhbFNjaGVtYXModGhpcyk7XG59XG5cblxuXG4vKipcbiAqIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gKiBTY2hlbWEgd2lsbCBiZSBjb21waWxlZCBhbmQgY2FjaGVkICh1c2luZyBzZXJpYWxpemVkIEpTT04gYXMga2V5LiBbZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeSkgaXMgdXNlZCB0byBzZXJpYWxpemUuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSAge0FueX0gZGF0YSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHZhbGlkYXRpb24gcmVzdWx0LiBFcnJvcnMgZnJvbSB0aGUgbGFzdCB2YWxpZGF0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIGluIGBhanYuZXJyb3JzYCAoYW5kIGFsc28gaW4gY29tcGlsZWQgc2NoZW1hOiBgc2NoZW1hLmVycm9yc2ApLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIGRhdGEpIHtcbiAgdmFyIHY7XG4gIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09ICdzdHJpbmcnKSB7XG4gICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoJ25vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCInICsgc2NoZW1hS2V5UmVmICsgJ1wiJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVtYU9iaiA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgIHYgPSBzY2hlbWFPYmoudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShzY2hlbWFPYmopO1xuICB9XG5cbiAgdmFyIHZhbGlkID0gdihkYXRhKTtcbiAgaWYgKHYuJGFzeW5jICE9PSB0cnVlKSB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICByZXR1cm4gdmFsaWQ7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYS5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0gIHtCb29sZWFufSBfbWV0YSB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgY3VzdG9tIGtleXdvcmRzLlxuICogQHJldHVybiB7RnVuY3Rpb259IHZhbGlkYXRpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIF9tZXRhKSB7XG4gIHZhciBzY2hlbWFPYmogPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCB1bmRlZmluZWQsIF9tZXRhKTtcbiAgcmV0dXJuIHNjaGVtYU9iai52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHNjaGVtYU9iaik7XG59XG5cblxuLyoqXG4gKiBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2UuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHNjaGVtYSBzY2hlbWEgb3IgYXJyYXkgb2Ygc2NoZW1hcy4gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCBhbmQgb3RoZXIgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IF9za2lwVmFsaWRhdGlvbiB0cnVlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IF9tZXRhIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICogQHJldHVybiB7QWp2fSB0aGlzIGZvciBtZXRob2QgY2hhaW5pbmdcbiAqL1xuZnVuY3Rpb24gYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpe1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHRoaXMuYWRkU2NoZW1hKHNjaGVtYVtpXSwgdW5kZWZpbmVkLCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWEpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgaWQgbXVzdCBiZSBzdHJpbmcnKTtcbiAga2V5ID0gcmVzb2x2ZS5ub3JtYWxpemVJZChrZXkgfHwgaWQpO1xuICBjaGVja1VuaXF1ZSh0aGlzLCBrZXkpO1xuICB0aGlzLl9zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAqIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IG9wdGlvbmFsIHNjaGVtYSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFZhbGlkYXRpb24gdHJ1ZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCBza2lwVmFsaWRhdGlvbikge1xuICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgc2tpcFZhbGlkYXRpb24sIHRydWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFZhbGlkYXRlIHNjaGVtYVxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRocm93T3JMb2dFcnJvciBwYXNzIHRydWUgdG8gdGhyb3cgKG9yIGxvZykgYW4gZXJyb3IgaWYgaW52YWxpZFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2hlbWEgaXMgdmFsaWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgdmFyICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZycpO1xuICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLl9vcHRzLmRlZmF1bHRNZXRhIHx8IGRlZmF1bHRNZXRhKHRoaXMpO1xuICBpZiAoISRzY2hlbWEpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlJyk7XG4gICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdzY2hlbWEgaXMgaW52YWxpZDogJyArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgIGlmICh0aGlzLl9vcHRzLnZhbGlkYXRlU2NoZW1hID09ICdsb2cnKSB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdE1ldGEoc2VsZikge1xuICB2YXIgbWV0YSA9IHNlbGYuX29wdHMubWV0YTtcbiAgc2VsZi5fb3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLl9nZXRJZChtZXRhKSB8fCBtZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUVUQV9TQ0hFTUFfSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICByZXR1cm4gc2VsZi5fb3B0cy5kZWZhdWx0TWV0YTtcbn1cblxuXG4vKipcbiAqIEdldCBjb21waWxlZCBzY2hlbWEgZnJvbSB0aGUgaW5zdGFuY2UgYnkgYGtleWAgb3IgYHJlZmAuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7U3RyaW5nfSBrZXlSZWYgYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAoYHNjaGVtYS5pZGAgb3IgcmVzb2x2ZWQgaWQpLlxuICogQHJldHVybiB7RnVuY3Rpb259IHNjaGVtYSB2YWxpZGF0aW5nIGZ1bmN0aW9uICh3aXRoIHByb3BlcnR5IGBzY2hlbWFgKS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hKGtleVJlZikge1xuICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaih0aGlzLCBrZXlSZWYpO1xuICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFPYmopIHtcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gdGhpcy5nZXRTY2hlbWEoc2NoZW1hT2JqKTtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gX2dldFNjaGVtYUZyYWdtZW50KHRoaXMsIGtleVJlZik7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBfZ2V0U2NoZW1hRnJhZ21lbnQoc2VsZiwgcmVmKSB7XG4gIHZhciByZXMgPSByZXNvbHZlLnNjaGVtYS5jYWxsKHNlbGYsIHsgc2NoZW1hOiB7fSB9LCByZWYpO1xuICBpZiAocmVzKSB7XG4gICAgdmFyIHNjaGVtYSA9IHJlcy5zY2hlbWFcbiAgICAgICwgcm9vdCA9IHJlcy5yb290XG4gICAgICAsIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gICAgdmFyIHYgPSBjb21waWxlU2NoZW1hLmNhbGwoc2VsZiwgc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gICAgc2VsZi5fZnJhZ21lbnRzW3JlZl0gPSBuZXcgU2NoZW1hT2JqZWN0KHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZnJhZ21lbnQ6IHRydWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBiYXNlSWQ6IGJhc2VJZCxcbiAgICAgIHZhbGlkYXRlOiB2XG4gICAgfSk7XG4gICAgcmV0dXJuIHY7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBfZ2V0U2NoZW1hT2JqKHNlbGYsIGtleVJlZikge1xuICBrZXlSZWYgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleVJlZik7XG4gIHJldHVybiBzZWxmLl9zY2hlbWFzW2tleVJlZl0gfHwgc2VsZi5fcmVmc1trZXlSZWZdIHx8IHNlbGYuX2ZyYWdtZW50c1trZXlSZWZdO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gKiBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gKiBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAqIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmLCBwYXR0ZXJuIHRvIG1hdGNoIGtleS9yZWYgb3Igc2NoZW1hIG9iamVjdFxuICogQHJldHVybiB7QWp2fSB0aGlzIGZvciBtZXRob2QgY2hhaW5pbmdcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgX3JlbW92ZUFsbFNjaGVtYXModGhpcywgdGhpcy5fc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9zY2hlbWFzKTtcbiAgICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3JlZnMpO1xuICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaih0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgaWYgKHNjaGVtYU9iaikgdGhpcy5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICBkZWxldGUgdGhpcy5fc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgZGVsZXRlIHRoaXMuX3JlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fb3B0cy5zZXJpYWxpemU7XG4gICAgICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemUgPyBzZXJpYWxpemUoc2NoZW1hS2V5UmVmKSA6IHNjaGVtYUtleVJlZjtcbiAgICAgIHRoaXMuX2NhY2hlLmRlbChjYWNoZUtleSk7XG4gICAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWFLZXlSZWYpO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnNbaWRdO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIF9yZW1vdmVBbGxTY2hlbWFzKHNlbGYsIHNjaGVtYXMsIHJlZ2V4KSB7XG4gIGZvciAodmFyIGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgdmFyIHNjaGVtYU9iaiA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICBpZiAoIXNjaGVtYU9iai5tZXRhICYmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSkge1xuICAgICAgc2VsZi5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qIEB0aGlzICAgQWp2ICovXG5mdW5jdGlvbiBfYWRkU2NoZW1hKHNjaGVtYSwgc2tpcFZhbGlkYXRpb24sIG1ldGEsIHNob3VsZEFkZFNjaGVtYSkge1xuICBpZiAodHlwZW9mIHNjaGVtYSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2NoZW1hICE9ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSBzaG91bGQgYmUgb2JqZWN0IG9yIGJvb2xlYW4nKTtcbiAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX29wdHMuc2VyaWFsaXplO1xuICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemUgPyBzZXJpYWxpemUoc2NoZW1hKSA6IHNjaGVtYTtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgc2hvdWxkQWRkU2NoZW1hID0gc2hvdWxkQWRkU2NoZW1hIHx8IHRoaXMuX29wdHMuYWRkVXNlZFNjaGVtYSAhPT0gZmFsc2U7XG5cbiAgdmFyIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZCh0aGlzLl9nZXRJZChzY2hlbWEpKTtcbiAgaWYgKGlkICYmIHNob3VsZEFkZFNjaGVtYSkgY2hlY2tVbmlxdWUodGhpcywgaWQpO1xuXG4gIHZhciB3aWxsVmFsaWRhdGUgPSB0aGlzLl9vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSAmJiAhc2tpcFZhbGlkYXRpb247XG4gIHZhciByZWN1cnNpdmVNZXRhO1xuICBpZiAod2lsbFZhbGlkYXRlICYmICEocmVjdXJzaXZlTWV0YSA9IGlkICYmIGlkID09IHJlc29sdmUubm9ybWFsaXplSWQoc2NoZW1hLiRzY2hlbWEpKSlcbiAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG5cbiAgdmFyIGxvY2FsUmVmcyA9IHJlc29sdmUuaWRzLmNhbGwodGhpcywgc2NoZW1hKTtcblxuICB2YXIgc2NoZW1hT2JqID0gbmV3IFNjaGVtYU9iamVjdCh7XG4gICAgaWQ6IGlkLFxuICAgIHNjaGVtYTogc2NoZW1hLFxuICAgIGxvY2FsUmVmczogbG9jYWxSZWZzLFxuICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICBtZXRhOiBtZXRhXG4gIH0pO1xuXG4gIGlmIChpZFswXSAhPSAnIycgJiYgc2hvdWxkQWRkU2NoZW1hKSB0aGlzLl9yZWZzW2lkXSA9IHNjaGVtYU9iajtcbiAgdGhpcy5fY2FjaGUucHV0KGNhY2hlS2V5LCBzY2hlbWFPYmopO1xuXG4gIGlmICh3aWxsVmFsaWRhdGUgJiYgcmVjdXJzaXZlTWV0YSkgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuXG4gIHJldHVybiBzY2hlbWFPYmo7XG59XG5cblxuLyogQHRoaXMgICBBanYgKi9cbmZ1bmN0aW9uIF9jb21waWxlKHNjaGVtYU9iaiwgcm9vdCkge1xuICBpZiAoc2NoZW1hT2JqLmNvbXBpbGluZykge1xuICAgIHNjaGVtYU9iai52YWxpZGF0ZSA9IGNhbGxWYWxpZGF0ZTtcbiAgICBjYWxsVmFsaWRhdGUuc2NoZW1hID0gc2NoZW1hT2JqLnNjaGVtYTtcbiAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICBjYWxsVmFsaWRhdGUucm9vdCA9IHJvb3QgPyByb290IDogY2FsbFZhbGlkYXRlO1xuICAgIGlmIChzY2hlbWFPYmouc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSlcbiAgICAgIGNhbGxWYWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgIHJldHVybiBjYWxsVmFsaWRhdGU7XG4gIH1cbiAgc2NoZW1hT2JqLmNvbXBpbGluZyA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRPcHRzO1xuICBpZiAoc2NoZW1hT2JqLm1ldGEpIHtcbiAgICBjdXJyZW50T3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdGhpcy5fb3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICB9XG5cbiAgdmFyIHY7XG4gIHRyeSB7IHYgPSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoZW1hT2JqLnNjaGVtYSwgcm9vdCwgc2NoZW1hT2JqLmxvY2FsUmVmcyk7IH1cbiAgY2F0Y2goZSkge1xuICAgIGRlbGV0ZSBzY2hlbWFPYmoudmFsaWRhdGU7XG4gICAgdGhyb3cgZTtcbiAgfVxuICBmaW5hbGx5IHtcbiAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gZmFsc2U7XG4gICAgaWYgKHNjaGVtYU9iai5tZXRhKSB0aGlzLl9vcHRzID0gY3VycmVudE9wdHM7XG4gIH1cblxuICBzY2hlbWFPYmoudmFsaWRhdGUgPSB2O1xuICBzY2hlbWFPYmoucmVmcyA9IHYucmVmcztcbiAgc2NoZW1hT2JqLnJlZlZhbCA9IHYucmVmVmFsO1xuICBzY2hlbWFPYmoucm9vdCA9IHYucm9vdDtcbiAgcmV0dXJuIHY7XG5cblxuICAvKiBAdGhpcyAgIHsqfSAtIGN1c3RvbSBjb250ZXh0LCBzZWUgcGFzc0NvbnRleHQgb3B0aW9uICovXG4gIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgdmFyIF92YWxpZGF0ZSA9IHNjaGVtYU9iai52YWxpZGF0ZTtcbiAgICB2YXIgcmVzdWx0ID0gX3ZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY2FsbFZhbGlkYXRlLmVycm9ycyA9IF92YWxpZGF0ZS5lcnJvcnM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNob29zZUdldElkKG9wdHMpIHtcbiAgc3dpdGNoIChvcHRzLnNjaGVtYUlkKSB7XG4gICAgY2FzZSAnYXV0byc6IHJldHVybiBfZ2V0JElkT3JJZDtcbiAgICBjYXNlICdpZCc6IHJldHVybiBfZ2V0SWQ7XG4gICAgZGVmYXVsdDogcmV0dXJuIF9nZXQkSWQ7XG4gIH1cbn1cblxuLyogQHRoaXMgICBBanYgKi9cbmZ1bmN0aW9uIF9nZXRJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS4kaWQpIHRoaXMubG9nZ2VyLndhcm4oJ3NjaGVtYSAkaWQgaWdub3JlZCcsIHNjaGVtYS4kaWQpO1xuICByZXR1cm4gc2NoZW1hLmlkO1xufVxuXG4vKiBAdGhpcyAgIEFqdiAqL1xuZnVuY3Rpb24gX2dldCRJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5pZCkgdGhpcy5sb2dnZXIud2Fybignc2NoZW1hIGlkIGlnbm9yZWQnLCBzY2hlbWEuaWQpO1xuICByZXR1cm4gc2NoZW1hLiRpZDtcbn1cblxuXG5mdW5jdGlvbiBfZ2V0JElkT3JJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS4kaWQgJiYgc2NoZW1hLmlkICYmIHNjaGVtYS4kaWQgIT0gc2NoZW1hLmlkKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hICRpZCBpcyBkaWZmZXJlbnQgZnJvbSBpZCcpO1xuICByZXR1cm4gc2NoZW1hLiRpZCB8fCBzY2hlbWEuaWQ7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIGVycm9yIG1lc3NhZ2Ugb2JqZWN0cyB0byBzdHJpbmdcbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBlcnJvcnMgb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnMsIGlmIG5vdCBwYXNzZWQgZXJyb3JzIGZyb20gdGhlIGluc3RhbmNlIGFyZSB1c2VkLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmAuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGh1bWFuIHJlYWRhYmxlIHN0cmluZyB3aXRoIGFsbCBlcnJvcnMgZGVzY3JpcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVycm9yc1RleHQoZXJyb3JzLCBvcHRpb25zKSB7XG4gIGVycm9ycyA9IGVycm9ycyB8fCB0aGlzLmVycm9ycztcbiAgaWYgKCFlcnJvcnMpIHJldHVybiAnTm8gZXJyb3JzJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywgJyA6IG9wdGlvbnMuc2VwYXJhdG9yO1xuICB2YXIgZGF0YVZhciA9IG9wdGlvbnMuZGF0YVZhciA9PT0gdW5kZWZpbmVkID8gJ2RhdGEnIDogb3B0aW9ucy5kYXRhVmFyO1xuXG4gIHZhciB0ZXh0ID0gJyc7XG4gIGZvciAodmFyIGk9MDsgaTxlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVycm9yc1tpXTtcbiAgICBpZiAoZSkgdGV4dCArPSBkYXRhVmFyICsgZS5kYXRhUGF0aCArICcgJyArIGUubWVzc2FnZSArIHNlcGFyYXRvcjtcbiAgfVxuICByZXR1cm4gdGV4dC5zbGljZSgwLCAtc2VwYXJhdG9yLmxlbmd0aCk7XG59XG5cblxuLyoqXG4gKiBBZGQgY3VzdG9tIGZvcm1hdFxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGZvcm1hdCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8RnVuY3Rpb259IGZvcm1hdCBzdHJpbmcgaXMgY29udmVydGVkIHRvIFJlZ0V4cDsgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBib29sZWFuICh0cnVlIHdoZW4gdmFsaWQpXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09ICdzdHJpbmcnKSBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gIHRoaXMuX2Zvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIGFkZERlZmF1bHRNZXRhU2NoZW1hKHNlbGYpIHtcbiAgdmFyICRkYXRhU2NoZW1hO1xuICBpZiAoc2VsZi5fb3B0cy4kZGF0YSkge1xuICAgICRkYXRhU2NoZW1hID0gcmVxdWlyZSgnLi9yZWZzL2RhdGEuanNvbicpO1xuICAgIHNlbGYuYWRkTWV0YVNjaGVtYSgkZGF0YVNjaGVtYSwgJGRhdGFTY2hlbWEuJGlkLCB0cnVlKTtcbiAgfVxuICBpZiAoc2VsZi5fb3B0cy5tZXRhID09PSBmYWxzZSkgcmV0dXJuO1xuICB2YXIgbWV0YVNjaGVtYSA9IHJlcXVpcmUoJy4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uJyk7XG4gIGlmIChzZWxmLl9vcHRzLiRkYXRhKSBtZXRhU2NoZW1hID0gJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKTtcbiAgc2VsZi5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCB0cnVlKTtcbiAgc2VsZi5fcmVmc1snaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWEnXSA9IE1FVEFfU0NIRU1BX0lEO1xufVxuXG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKHNlbGYpIHtcbiAgdmFyIG9wdHNTY2hlbWFzID0gc2VsZi5fb3B0cy5zY2hlbWFzO1xuICBpZiAoIW9wdHNTY2hlbWFzKSByZXR1cm47XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSkgc2VsZi5hZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICBlbHNlIGZvciAodmFyIGtleSBpbiBvcHRzU2NoZW1hcykgc2VsZi5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cblxuXG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cyhzZWxmKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gc2VsZi5fb3B0cy5mb3JtYXRzKSB7XG4gICAgdmFyIGZvcm1hdCA9IHNlbGYuX29wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICBzZWxmLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKHNlbGYpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBzZWxmLl9vcHRzLmtleXdvcmRzKSB7XG4gICAgdmFyIGtleXdvcmQgPSBzZWxmLl9vcHRzLmtleXdvcmRzW25hbWVdO1xuICAgIHNlbGYuYWRkS2V5d29yZChuYW1lLCBrZXl3b3JkKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNoZWNrVW5pcXVlKHNlbGYsIGlkKSB7XG4gIGlmIChzZWxmLl9zY2hlbWFzW2lkXSB8fCBzZWxmLl9yZWZzW2lkXSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSB3aXRoIGtleSBvciBpZCBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cycpO1xufVxuXG5cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKHNlbGYpIHtcbiAgdmFyIG1ldGFPcHRzID0gdXRpbC5jb3B5KHNlbGYuX29wdHMpO1xuICBmb3IgKHZhciBpPTA7IGk8TUVUQV9JR05PUkVfT1BUSU9OUy5sZW5ndGg7IGkrKylcbiAgICBkZWxldGUgbWV0YU9wdHNbTUVUQV9JR05PUkVfT1BUSU9OU1tpXV07XG4gIHJldHVybiBtZXRhT3B0cztcbn1cblxuXG5mdW5jdGlvbiBzZXRMb2dnZXIoc2VsZikge1xuICB2YXIgbG9nZ2VyID0gc2VsZi5fb3B0cy5sb2dnZXI7XG4gIGlmIChsb2dnZXIgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5sb2dnZXIgPSB7bG9nOiBub29wLCB3YXJuOiBub29wLCBlcnJvcjogbm9vcH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSBsb2dnZXIgPSBjb25zb2xlO1xuICAgIGlmICghKHR5cGVvZiBsb2dnZXIgPT0gJ29iamVjdCcgJiYgbG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzJyk7XG4gICAgc2VsZi5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIGVycm9yQ2xhc3NlcyA9IHJlcXVpcmUoJy4vZXJyb3JfY2xhc3NlcycpXG4gICwgc3RhYmxlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnknKTtcblxudmFyIHZhbGlkYXRlR2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vZG90anMvdmFsaWRhdGUnKTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgYmVsb3cgYXJlIHVzZWQgaW5zaWRlIGNvbXBpbGVkIHZhbGlkYXRpb25zIGZ1bmN0aW9uXG4gKi9cblxudmFyIHVjczJsZW5ndGggPSB1dGlsLnVjczJsZW5ndGg7XG52YXIgZXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKTtcblxuLy8gdGhpcyBlcnJvciBpcyB0aHJvd24gYnkgYXN5bmMgc2NoZW1hcyB0byByZXR1cm4gdmFsaWRhdGlvbiBlcnJvcnMgdmlhIGV4Y2VwdGlvblxudmFyIFZhbGlkYXRpb25FcnJvciA9IGVycm9yQ2xhc3Nlcy5WYWxpZGF0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7XG5cblxuLyoqXG4gKiBDb21waWxlcyBzY2hlbWEgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoaXMgc2NoZW1hXG4gKiBAcGFyYW0gIHtPYmplY3R9IGxvY2FsUmVmcyB0aGUgaGFzaCBvZiBsb2NhbCByZWZlcmVuY2VzIGluc2lkZSB0aGUgc2NoZW1hIChjcmVhdGVkIGJ5IHJlc29sdmUuaWQpLCB1c2VkIGZvciBpbmxpbmUgcmVzb2x1dGlvblxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBJRCBmb3IgSURzIGluIHRoZSBzY2hlbWFcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hLCByb290LCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlLCBldmlsOiB0cnVlICovXG4gIC8qIGVzbGludCBuby1zaGFkb3c6IDAgKi9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBvcHRzID0gdGhpcy5fb3B0c1xuICAgICwgcmVmVmFsID0gWyB1bmRlZmluZWQgXVxuICAgICwgcmVmcyA9IHt9XG4gICAgLCBwYXR0ZXJucyA9IFtdXG4gICAgLCBwYXR0ZXJuc0hhc2ggPSB7fVxuICAgICwgZGVmYXVsdHMgPSBbXVxuICAgICwgZGVmYXVsdHNIYXNoID0ge31cbiAgICAsIGN1c3RvbVJ1bGVzID0gW107XG5cbiAgcm9vdCA9IHJvb3QgfHwgeyBzY2hlbWE6IHNjaGVtYSwgcmVmVmFsOiByZWZWYWwsIHJlZnM6IHJlZnMgfTtcblxuICB2YXIgYyA9IGNoZWNrQ29tcGlsaW5nLmNhbGwodGhpcywgc2NoZW1hLCByb290LCBiYXNlSWQpO1xuICB2YXIgY29tcGlsYXRpb24gPSB0aGlzLl9jb21waWxhdGlvbnNbYy5pbmRleF07XG4gIGlmIChjLmNvbXBpbGluZykgcmV0dXJuIChjb21waWxhdGlvbi5jYWxsVmFsaWRhdGUgPSBjYWxsVmFsaWRhdGUpO1xuXG4gIHZhciBmb3JtYXRzID0gdGhpcy5fZm9ybWF0cztcbiAgdmFyIFJVTEVTID0gdGhpcy5SVUxFUztcblxuICB0cnkge1xuICAgIHZhciB2ID0gbG9jYWxDb21waWxlKHNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuICAgIGNvbXBpbGF0aW9uLnZhbGlkYXRlID0gdjtcbiAgICB2YXIgY3YgPSBjb21waWxhdGlvbi5jYWxsVmFsaWRhdGU7XG4gICAgaWYgKGN2KSB7XG4gICAgICBjdi5zY2hlbWEgPSB2LnNjaGVtYTtcbiAgICAgIGN2LmVycm9ycyA9IG51bGw7XG4gICAgICBjdi5yZWZzID0gdi5yZWZzO1xuICAgICAgY3YucmVmVmFsID0gdi5yZWZWYWw7XG4gICAgICBjdi5yb290ID0gdi5yb290O1xuICAgICAgY3YuJGFzeW5jID0gdi4kYXN5bmM7XG4gICAgICBpZiAob3B0cy5zb3VyY2VDb2RlKSBjdi5zb3VyY2UgPSB2LnNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQ29tcGlsaW5nLmNhbGwodGhpcywgc2NoZW1hLCByb290LCBiYXNlSWQpO1xuICB9XG5cbiAgLyogQHRoaXMgICB7Kn0gLSBjdXN0b20gY29udGV4dCwgc2VlIHBhc3NDb250ZXh0IG9wdGlvbiAqL1xuICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIHZhciB2YWxpZGF0ZSA9IGNvbXBpbGF0aW9uLnZhbGlkYXRlO1xuICAgIHZhciByZXN1bHQgPSB2YWxpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSB2YWxpZGF0ZS5lcnJvcnM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsQ29tcGlsZShfc2NoZW1hLCBfcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpIHtcbiAgICB2YXIgaXNSb290ID0gIV9yb290IHx8IChfcm9vdCAmJiBfcm9vdC5zY2hlbWEgPT0gX3NjaGVtYSk7XG4gICAgaWYgKF9yb290LnNjaGVtYSAhPSByb290LnNjaGVtYSlcbiAgICAgIHJldHVybiBjb21waWxlLmNhbGwoc2VsZiwgX3NjaGVtYSwgX3Jvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcblxuICAgIHZhciAkYXN5bmMgPSBfc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZTtcblxuICAgIHZhciBzb3VyY2VDb2RlID0gdmFsaWRhdGVHZW5lcmF0b3Ioe1xuICAgICAgaXNUb3A6IHRydWUsXG4gICAgICBzY2hlbWE6IF9zY2hlbWEsXG4gICAgICBpc1Jvb3Q6IGlzUm9vdCxcbiAgICAgIGJhc2VJZDogYmFzZUlkLFxuICAgICAgcm9vdDogX3Jvb3QsXG4gICAgICBzY2hlbWFQYXRoOiAnJyxcbiAgICAgIGVyclNjaGVtYVBhdGg6ICcjJyxcbiAgICAgIGVycm9yUGF0aDogJ1wiXCInLFxuICAgICAgTWlzc2luZ1JlZkVycm9yOiBlcnJvckNsYXNzZXMuTWlzc2luZ1JlZixcbiAgICAgIFJVTEVTOiBSVUxFUyxcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUdlbmVyYXRvcixcbiAgICAgIHV0aWw6IHV0aWwsXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgcmVzb2x2ZVJlZjogcmVzb2x2ZVJlZixcbiAgICAgIHVzZVBhdHRlcm46IHVzZVBhdHRlcm4sXG4gICAgICB1c2VEZWZhdWx0OiB1c2VEZWZhdWx0LFxuICAgICAgdXNlQ3VzdG9tUnVsZTogdXNlQ3VzdG9tUnVsZSxcbiAgICAgIG9wdHM6IG9wdHMsXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgICAgbG9nZ2VyOiBzZWxmLmxvZ2dlcixcbiAgICAgIHNlbGY6IHNlbGZcbiAgICB9KTtcblxuICAgIHNvdXJjZUNvZGUgPSB2YXJzKHJlZlZhbCwgcmVmVmFsQ29kZSkgKyB2YXJzKHBhdHRlcm5zLCBwYXR0ZXJuQ29kZSlcbiAgICAgICAgICAgICAgICAgICArIHZhcnMoZGVmYXVsdHMsIGRlZmF1bHRDb2RlKSArIHZhcnMoY3VzdG9tUnVsZXMsIGN1c3RvbVJ1bGVDb2RlKVxuICAgICAgICAgICAgICAgICAgICsgc291cmNlQ29kZTtcblxuICAgIGlmIChvcHRzLnByb2Nlc3NDb2RlKSBzb3VyY2VDb2RlID0gb3B0cy5wcm9jZXNzQ29kZShzb3VyY2VDb2RlLCBfc2NoZW1hKTtcbiAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuICoqKiBcXG4nLCBKU09OLnN0cmluZ2lmeShzb3VyY2VDb2RlKSk7XG4gICAgdmFyIHZhbGlkYXRlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAnc2VsZicsXG4gICAgICAgICdSVUxFUycsXG4gICAgICAgICdmb3JtYXRzJyxcbiAgICAgICAgJ3Jvb3QnLFxuICAgICAgICAncmVmVmFsJyxcbiAgICAgICAgJ2RlZmF1bHRzJyxcbiAgICAgICAgJ2N1c3RvbVJ1bGVzJyxcbiAgICAgICAgJ2VxdWFsJyxcbiAgICAgICAgJ3VjczJsZW5ndGgnLFxuICAgICAgICAnVmFsaWRhdGlvbkVycm9yJyxcbiAgICAgICAgc291cmNlQ29kZVxuICAgICAgKTtcblxuICAgICAgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIFJVTEVTLFxuICAgICAgICBmb3JtYXRzLFxuICAgICAgICByb290LFxuICAgICAgICByZWZWYWwsXG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICBjdXN0b21SdWxlcyxcbiAgICAgICAgZXF1YWwsXG4gICAgICAgIHVjczJsZW5ndGgsXG4gICAgICAgIFZhbGlkYXRpb25FcnJvclxuICAgICAgKTtcblxuICAgICAgcmVmVmFsWzBdID0gdmFsaWRhdGU7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZWxmLmxvZ2dlci5lcnJvcignRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTonLCBzb3VyY2VDb2RlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUuc2NoZW1hID0gX3NjaGVtYTtcbiAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgIHZhbGlkYXRlLnJlZnMgPSByZWZzO1xuICAgIHZhbGlkYXRlLnJlZlZhbCA9IHJlZlZhbDtcbiAgICB2YWxpZGF0ZS5yb290ID0gaXNSb290ID8gdmFsaWRhdGUgOiBfcm9vdDtcbiAgICBpZiAoJGFzeW5jKSB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgIGlmIChvcHRzLnNvdXJjZUNvZGUgPT09IHRydWUpIHtcbiAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHtcbiAgICAgICAgY29kZTogc291cmNlQ29kZSxcbiAgICAgICAgcGF0dGVybnM6IHBhdHRlcm5zLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihiYXNlSWQsIHJlZiwgaXNSb290KSB7XG4gICAgcmVmID0gcmVzb2x2ZS51cmwoYmFzZUlkLCByZWYpO1xuICAgIHZhciByZWZJbmRleCA9IHJlZnNbcmVmXTtcbiAgICB2YXIgX3JlZlZhbCwgcmVmQ29kZTtcbiAgICBpZiAocmVmSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgX3JlZlZhbCA9IHJlZlZhbFtyZWZJbmRleF07XG4gICAgICByZWZDb2RlID0gJ3JlZlZhbFsnICsgcmVmSW5kZXggKyAnXSc7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgfVxuICAgIGlmICghaXNSb290ICYmIHJvb3QucmVmcykge1xuICAgICAgdmFyIHJvb3RSZWZJZCA9IHJvb3QucmVmc1tyZWZdO1xuICAgICAgaWYgKHJvb3RSZWZJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9yZWZWYWwgPSByb290LnJlZlZhbFtyb290UmVmSWRdO1xuICAgICAgICByZWZDb2RlID0gYWRkTG9jYWxSZWYocmVmLCBfcmVmVmFsKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUmVmKF9yZWZWYWwsIHJlZkNvZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYpO1xuICAgIHZhciB2ID0gcmVzb2x2ZS5jYWxsKHNlbGYsIGxvY2FsQ29tcGlsZSwgcm9vdCwgcmVmKTtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgbG9jYWxTY2hlbWEgPSBsb2NhbFJlZnMgJiYgbG9jYWxSZWZzW3JlZl07XG4gICAgICBpZiAobG9jYWxTY2hlbWEpIHtcbiAgICAgICAgdiA9IHJlc29sdmUuaW5saW5lUmVmKGxvY2FsU2NoZW1hLCBvcHRzLmlubGluZVJlZnMpXG4gICAgICAgICAgICA/IGxvY2FsU2NoZW1hXG4gICAgICAgICAgICA6IGNvbXBpbGUuY2FsbChzZWxmLCBsb2NhbFNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbW92ZUxvY2FsUmVmKHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VMb2NhbFJlZihyZWYsIHYpO1xuICAgICAgcmV0dXJuIHJlc29sdmVkUmVmKHYsIHJlZkNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExvY2FsUmVmKHJlZiwgdikge1xuICAgIHZhciByZWZJZCA9IHJlZlZhbC5sZW5ndGg7XG4gICAgcmVmVmFsW3JlZklkXSA9IHY7XG4gICAgcmVmc1tyZWZdID0gcmVmSWQ7XG4gICAgcmV0dXJuICdyZWZWYWwnICsgcmVmSWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMb2NhbFJlZihyZWYpIHtcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUxvY2FsUmVmKHJlZiwgdikge1xuICAgIHZhciByZWZJZCA9IHJlZnNbcmVmXTtcbiAgICByZWZWYWxbcmVmSWRdID0gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVkUmVmKHJlZlZhbCwgY29kZSkge1xuICAgIHJldHVybiB0eXBlb2YgcmVmVmFsID09ICdvYmplY3QnIHx8IHR5cGVvZiByZWZWYWwgPT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IHsgY29kZTogY29kZSwgc2NoZW1hOiByZWZWYWwsIGlubGluZTogdHJ1ZSB9XG4gICAgICAgICAgICA6IHsgY29kZTogY29kZSwgJGFzeW5jOiByZWZWYWwgJiYgISFyZWZWYWwuJGFzeW5jIH07XG4gIH1cblxuICBmdW5jdGlvbiB1c2VQYXR0ZXJuKHJlZ2V4U3RyKSB7XG4gICAgdmFyIGluZGV4ID0gcGF0dGVybnNIYXNoW3JlZ2V4U3RyXTtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggPSBwYXR0ZXJuc0hhc2hbcmVnZXhTdHJdID0gcGF0dGVybnMubGVuZ3RoO1xuICAgICAgcGF0dGVybnNbaW5kZXhdID0gcmVnZXhTdHI7XG4gICAgfVxuICAgIHJldHVybiAncGF0dGVybicgKyBpbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZURlZmF1bHQodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiB1dGlsLnRvUXVvdGVkU3RyaW5nKHZhbHVlKTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgICAgICAgdmFyIHZhbHVlU3RyID0gc3RhYmxlU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZGVmYXVsdHNIYXNoW3ZhbHVlU3RyXTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGRlZmF1bHRzSGFzaFt2YWx1ZVN0cl0gPSBkZWZhdWx0cy5sZW5ndGg7XG4gICAgICAgICAgZGVmYXVsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdkZWZhdWx0JyArIGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUN1c3RvbVJ1bGUocnVsZSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSB7XG4gICAgaWYgKHNlbGYuX29wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKSB7XG4gICAgICB2YXIgZGVwcyA9IHJ1bGUuZGVmaW5pdGlvbi5kZXBlbmRlbmNpZXM7XG4gICAgICBpZiAoZGVwcyAmJiAhZGVwcy5ldmVyeShmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyZW50U2NoZW1hLCBrZXl3b3JkKTtcbiAgICAgIH0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGFsbCByZXF1aXJlZCBrZXl3b3JkczogJyArIGRlcHMuam9pbignLCcpKTtcblxuICAgICAgdmFyIHZhbGlkYXRlU2NoZW1hID0gcnVsZS5kZWZpbml0aW9uLnZhbGlkYXRlU2NoZW1hO1xuICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdrZXl3b3JkIHNjaGVtYSBpcyBpbnZhbGlkOiAnICsgc2VsZi5lcnJvcnNUZXh0KHZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgaWYgKHNlbGYuX29wdHMudmFsaWRhdGVTY2hlbWEgPT0gJ2xvZycpIHNlbGYubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGUgPSBydWxlLmRlZmluaXRpb24uY29tcGlsZVxuICAgICAgLCBpbmxpbmUgPSBydWxlLmRlZmluaXRpb24uaW5saW5lXG4gICAgICAsIG1hY3JvID0gcnVsZS5kZWZpbml0aW9uLm1hY3JvO1xuXG4gICAgdmFyIHZhbGlkYXRlO1xuICAgIGlmIChjb21waWxlKSB7XG4gICAgICB2YWxpZGF0ZSA9IGNvbXBpbGUuY2FsbChzZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIH0gZWxzZSBpZiAobWFjcm8pIHtcbiAgICAgIHZhbGlkYXRlID0gbWFjcm8uY2FsbChzZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKSBzZWxmLnZhbGlkYXRlU2NoZW1hKHZhbGlkYXRlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlubGluZSkge1xuICAgICAgdmFsaWRhdGUgPSBpbmxpbmUuY2FsbChzZWxmLCBpdCwgcnVsZS5rZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlID0gcnVsZS5kZWZpbml0aW9uLnZhbGlkYXRlO1xuICAgICAgaWYgKCF2YWxpZGF0ZSkgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXN0b20ga2V5d29yZCBcIicgKyBydWxlLmtleXdvcmQgKyAnXCJmYWlsZWQgdG8gY29tcGlsZScpO1xuXG4gICAgdmFyIGluZGV4ID0gY3VzdG9tUnVsZXMubGVuZ3RoO1xuICAgIGN1c3RvbVJ1bGVzW2luZGV4XSA9IHZhbGlkYXRlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6ICdjdXN0b21SdWxlJyArIGluZGV4LFxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlXG4gICAgfTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2hlbWEgaXMgY3VycmVudGx5IGNvbXBpbGVkXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdFxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBzY2hlbWEgSURcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggcHJvcGVydGllcyBcImluZGV4XCIgKGNvbXBpbGF0aW9uIGluZGV4KSBhbmQgXCJjb21waWxpbmdcIiAoYm9vbGVhbilcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21waWxpbmcoc2NoZW1hLCByb290LCBiYXNlSWQpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgaW5kZXggPSBjb21wSW5kZXguY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIGJhc2VJZCk7XG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4geyBpbmRleDogaW5kZXgsIGNvbXBpbGluZzogdHJ1ZSB9O1xuICBpbmRleCA9IHRoaXMuX2NvbXBpbGF0aW9ucy5sZW5ndGg7XG4gIHRoaXMuX2NvbXBpbGF0aW9uc1tpbmRleF0gPSB7XG4gICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgcm9vdDogcm9vdCxcbiAgICBiYXNlSWQ6IGJhc2VJZFxuICB9O1xuICByZXR1cm4geyBpbmRleDogaW5kZXgsIGNvbXBpbGluZzogZmFsc2UgfTtcbn1cblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHNjaGVtYSBmcm9tIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSB0byBjb21waWxlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJvb3Qgcm9vdCBvYmplY3RcbiAqIEBwYXJhbSAge1N0cmluZ30gYmFzZUlkIGJhc2Ugc2NoZW1hIElEXG4gKi9cbmZ1bmN0aW9uIGVuZENvbXBpbGluZyhzY2hlbWEsIHJvb3QsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBpID0gY29tcEluZGV4LmNhbGwodGhpcywgc2NoZW1hLCByb290LCBiYXNlSWQpO1xuICBpZiAoaSA+PSAwKSB0aGlzLl9jb21waWxhdGlvbnMuc3BsaWNlKGksIDEpO1xufVxuXG5cbi8qKlxuICogSW5kZXggb2Ygc2NoZW1hIGNvbXBpbGF0aW9uIGluIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSB0byBjb21waWxlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJvb3Qgcm9vdCBvYmplY3RcbiAqIEBwYXJhbSAge1N0cmluZ30gYmFzZUlkIGJhc2Ugc2NoZW1hIElEXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBjb21waWxhdGlvbiBpbmRleFxuICovXG5mdW5jdGlvbiBjb21wSW5kZXgoc2NoZW1hLCByb290LCBiYXNlSWQpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICBmb3IgKHZhciBpPTA7IGk8dGhpcy5fY29tcGlsYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9jb21waWxhdGlvbnNbaV07XG4gICAgaWYgKGMuc2NoZW1hID09IHNjaGVtYSAmJiBjLnJvb3QgPT0gcm9vdCAmJiBjLmJhc2VJZCA9PSBiYXNlSWQpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5mdW5jdGlvbiBwYXR0ZXJuQ29kZShpLCBwYXR0ZXJucykge1xuICByZXR1cm4gJ3ZhciBwYXR0ZXJuJyArIGkgKyAnID0gbmV3IFJlZ0V4cCgnICsgdXRpbC50b1F1b3RlZFN0cmluZyhwYXR0ZXJuc1tpXSkgKyAnKTsnO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb2RlKGkpIHtcbiAgcmV0dXJuICd2YXIgZGVmYXVsdCcgKyBpICsgJyA9IGRlZmF1bHRzWycgKyBpICsgJ107Jztcbn1cblxuXG5mdW5jdGlvbiByZWZWYWxDb2RlKGksIHJlZlZhbCkge1xuICByZXR1cm4gcmVmVmFsW2ldID09PSB1bmRlZmluZWQgPyAnJyA6ICd2YXIgcmVmVmFsJyArIGkgKyAnID0gcmVmVmFsWycgKyBpICsgJ107Jztcbn1cblxuXG5mdW5jdGlvbiBjdXN0b21SdWxlQ29kZShpKSB7XG4gIHJldHVybiAndmFyIGN1c3RvbVJ1bGUnICsgaSArICcgPSBjdXN0b21SdWxlc1snICsgaSArICddOyc7XG59XG5cblxuZnVuY3Rpb24gdmFycyhhcnIsIHN0YXRlbWVudCkge1xuICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiAnJztcbiAgdmFyIGNvZGUgPSAnJztcbiAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2RlICs9IHN0YXRlbWVudChpLCBhcnIpO1xuICByZXR1cm4gY29kZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFVSSSA9IHJlcXVpcmUoJ3VyaS1qcycpXG4gICwgZXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIFNjaGVtYU9iamVjdCA9IHJlcXVpcmUoJy4vc2NoZW1hX29iaicpXG4gICwgdHJhdmVyc2UgPSByZXF1aXJlKCdqc29uLXNjaGVtYS10cmF2ZXJzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7XG5cbnJlc29sdmUubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbnJlc29sdmUuZnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbnJlc29sdmUudXJsID0gcmVzb2x2ZVVybDtcbnJlc29sdmUuaWRzID0gcmVzb2x2ZUlkcztcbnJlc29sdmUuaW5saW5lUmVmID0gaW5saW5lUmVmO1xucmVzb2x2ZS5zY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuXG4vKipcbiAqIFtyZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKV1cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY29tcGlsZSByZWZlcmVuY2UgdG8gc2NoZW1hIGNvbXBpbGF0aW9uIGZ1bmNpdG9uIChsb2NhbENvbXBpbGUpXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJvb3Qgb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbiAqIEBwYXJhbSAge1N0cmluZ30gcmVmIHJlZmVyZW5jZSB0byByZXNvbHZlXG4gKiBAcmV0dXJuIHtPYmplY3R8RnVuY3Rpb259IHNjaGVtYSBvYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShjb21waWxlLCByb290LCByZWYpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZdO1xuICBpZiAodHlwZW9mIHJlZlZhbCA9PSAnc3RyaW5nJykge1xuICAgIGlmICh0aGlzLl9yZWZzW3JlZlZhbF0pIHJlZlZhbCA9IHRoaXMuX3JlZnNbcmVmVmFsXTtcbiAgICBlbHNlIHJldHVybiByZXNvbHZlLmNhbGwodGhpcywgY29tcGlsZSwgcm9vdCwgcmVmVmFsKTtcbiAgfVxuXG4gIHJlZlZhbCA9IHJlZlZhbCB8fCB0aGlzLl9zY2hlbWFzW3JlZl07XG4gIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICByZXR1cm4gaW5saW5lUmVmKHJlZlZhbC5zY2hlbWEsIHRoaXMuX29wdHMuaW5saW5lUmVmcylcbiAgICAgICAgICAgID8gcmVmVmFsLnNjaGVtYVxuICAgICAgICAgICAgOiByZWZWYWwudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICB2YXIgc2NoZW1hLCB2LCBiYXNlSWQ7XG4gIGlmIChyZXMpIHtcbiAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICB9XG5cbiAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgIHYgPSBzY2hlbWEudmFsaWRhdGUgfHwgY29tcGlsZS5jYWxsKHRoaXMsIHNjaGVtYS5zY2hlbWEsIHJvb3QsIHVuZGVmaW5lZCwgYmFzZUlkKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgIHYgPSBpbmxpbmVSZWYoc2NoZW1hLCB0aGlzLl9vcHRzLmlubGluZVJlZnMpXG4gICAgICAgID8gc2NoZW1hXG4gICAgICAgIDogY29tcGlsZS5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cblxuLyoqXG4gKiBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuICogQHRoaXMgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJvb3Qgcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmVmFsLCByZWZzXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHJlZiAgcmVmZXJlbmNlIHRvIHJlc29sdmVcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJvb3QsIGJhc2VJZFxuICovXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBwID0gVVJJLnBhcnNlKHJlZilcbiAgICAsIHJlZlBhdGggPSBfZ2V0RnVsbFBhdGgocClcbiAgICAsIGJhc2VJZCA9IGdldEZ1bGxQYXRoKHRoaXMuX2dldElkKHJvb3Quc2NoZW1hKSk7XG4gIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID09PSAwIHx8IHJlZlBhdGggIT09IGJhc2VJZCkge1xuICAgIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHJlZlBhdGgpO1xuICAgIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW2lkXTtcbiAgICBpZiAodHlwZW9mIHJlZlZhbCA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHJlc29sdmVSZWN1cnNpdmUuY2FsbCh0aGlzLCByb290LCByZWZWYWwsIHApO1xuICAgIH0gZWxzZSBpZiAocmVmVmFsIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KSB7XG4gICAgICBpZiAoIXJlZlZhbC52YWxpZGF0ZSkgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICAgICAgcm9vdCA9IHJlZlZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmVmFsID0gdGhpcy5fc2NoZW1hc1tpZF07XG4gICAgICBpZiAocmVmVmFsIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KSB7XG4gICAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKSB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gICAgICAgIGlmIChpZCA9PSBub3JtYWxpemVJZChyZWYpKVxuICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogcmVmVmFsLCByb290OiByb290LCBiYXNlSWQ6IGJhc2VJZCB9O1xuICAgICAgICByb290ID0gcmVmVmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJvb3Quc2NoZW1hKSByZXR1cm47XG4gICAgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5fZ2V0SWQocm9vdC5zY2hlbWEpKTtcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBiYXNlSWQsIHJvb3Quc2NoZW1hLCByb290KTtcbn1cblxuXG4vKiBAdGhpcyBBanYgKi9cbmZ1bmN0aW9uIHJlc29sdmVSZWN1cnNpdmUocm9vdCwgcmVmLCBwYXJzZWRSZWYpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgcmVzID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gIGlmIChyZXMpIHtcbiAgICB2YXIgc2NoZW1hID0gcmVzLnNjaGVtYTtcbiAgICB2YXIgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICByb290ID0gcmVzLnJvb3Q7XG4gICAgdmFyIGlkID0gdGhpcy5fZ2V0SWQoc2NoZW1hKTtcbiAgICBpZiAoaWQpIGJhc2VJZCA9IHJlc29sdmVVcmwoYmFzZUlkLCBpZCk7XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCk7XG4gIH1cbn1cblxuXG52YXIgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSB1dGlsLnRvSGFzaChbJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZW51bScsICdkZXBlbmRlbmNpZXMnLCAnZGVmaW5pdGlvbnMnXSk7XG4vKiBAdGhpcyBBanYgKi9cbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgYmFzZUlkLCBzY2hlbWEsIHJvb3QpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICBwYXJzZWRSZWYuZnJhZ21lbnQgPSBwYXJzZWRSZWYuZnJhZ21lbnQgfHwgJyc7XG4gIGlmIChwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMCwxKSAhPSAnLycpIHJldHVybjtcbiAgdmFyIHBhcnRzID0gcGFyc2VkUmVmLmZyYWdtZW50LnNwbGl0KCcvJyk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQgPSB1dGlsLnVuZXNjYXBlRnJhZ21lbnQocGFydCk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFbcGFydF07XG4gICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgdmFyIGlkO1xuICAgICAgaWYgKCFQUkVWRU5UX1NDT1BFX0NIQU5HRVtwYXJ0XSkge1xuICAgICAgICBpZCA9IHRoaXMuX2dldElkKHNjaGVtYSk7XG4gICAgICAgIGlmIChpZCkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIGlkKTtcbiAgICAgICAgaWYgKHNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgdmFyICRyZWYgPSByZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICAgIHZhciByZXMgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgc2NoZW1hID0gcmVzLnNjaGVtYTtcbiAgICAgICAgICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICAgICAgICAgIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHJvb3Quc2NoZW1hKVxuICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCByb290OiByb290LCBiYXNlSWQ6IGJhc2VJZCB9O1xufVxuXG5cbnZhciBTSU1QTEVfSU5MSU5FRCA9IHV0aWwudG9IYXNoKFtcbiAgJ3R5cGUnLCAnZm9ybWF0JywgJ3BhdHRlcm4nLFxuICAnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsXG4gICdtYXhQcm9wZXJ0aWVzJywgJ21pblByb3BlcnRpZXMnLFxuICAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLFxuICAnbWF4aW11bScsICdtaW5pbXVtJyxcbiAgJ3VuaXF1ZUl0ZW1zJywgJ211bHRpcGxlT2YnLFxuICAncmVxdWlyZWQnLCAnZW51bSdcbl0pO1xuZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYSwgbGltaXQpIHtcbiAgaWYgKGxpbWl0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCB8fCBsaW1pdCA9PT0gdHJ1ZSkgcmV0dXJuIGNoZWNrTm9SZWYoc2NoZW1hKTtcbiAgZWxzZSBpZiAobGltaXQpIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cblxuXG5mdW5jdGlvbiBjaGVja05vUmVmKHNjaGVtYSkge1xuICB2YXIgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcgJiYgIWNoZWNrTm9SZWYoaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgaWYgKGtleSA9PSAnJHJlZicpIHJldHVybiBmYWxzZTtcbiAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gIHZhciBjb3VudCA9IDAsIGl0ZW07XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8c2NoZW1hLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtID0gc2NoZW1hW2ldO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSBjb3VudCArPSBjb3VudEtleXMoaXRlbSk7XG4gICAgICBpZiAoY291bnQgPT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgaWYgKGtleSA9PSAnJHJlZicpIHJldHVybiBJbmZpbml0eTtcbiAgICAgIGlmIChTSU1QTEVfSU5MSU5FRFtrZXldKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JykgY291bnQgKz0gY291bnRLZXlzKGl0ZW0pICsgMTtcbiAgICAgICAgaWYgKGNvdW50ID09IEluZmluaXR5KSByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuXG5mdW5jdGlvbiBnZXRGdWxsUGF0aChpZCwgbm9ybWFsaXplKSB7XG4gIGlmIChub3JtYWxpemUgIT09IGZhbHNlKSBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgdmFyIHAgPSBVUkkucGFyc2UoaWQpO1xuICByZXR1cm4gX2dldEZ1bGxQYXRoKHApO1xufVxuXG5cbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChwKSB7XG4gIHJldHVybiBVUkkuc2VyaWFsaXplKHApLnNwbGl0KCcjJylbMF0gKyAnIyc7XG59XG5cblxudmFyIFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgJycpIDogJyc7XG59XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlSWQsIGlkKSB7XG4gIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICByZXR1cm4gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5cblxuLyogQHRoaXMgQWp2ICovXG5mdW5jdGlvbiByZXNvbHZlSWRzKHNjaGVtYSkge1xuICB2YXIgc2NoZW1hSWQgPSBub3JtYWxpemVJZCh0aGlzLl9nZXRJZChzY2hlbWEpKTtcbiAgdmFyIGJhc2VJZHMgPSB7Jyc6IHNjaGVtYUlkfTtcbiAgdmFyIGZ1bGxQYXRocyA9IHsnJzogZ2V0RnVsbFBhdGgoc2NoZW1hSWQsIGZhbHNlKX07XG4gIHZhciBsb2NhbFJlZnMgPSB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyYXZlcnNlKHNjaGVtYSwge2FsbEtleXM6IHRydWV9LCBmdW5jdGlvbihzY2gsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgICBpZiAoanNvblB0ciA9PT0gJycpIHJldHVybjtcbiAgICB2YXIgaWQgPSBzZWxmLl9nZXRJZChzY2gpO1xuICAgIHZhciBiYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgIHZhciBmdWxsUGF0aCA9IGZ1bGxQYXRoc1twYXJlbnRKc29uUHRyXSArICcvJyArIHBhcmVudEtleXdvcmQ7XG4gICAgaWYgKGtleUluZGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICBmdWxsUGF0aCArPSAnLycgKyAodHlwZW9mIGtleUluZGV4ID09ICdudW1iZXInID8ga2V5SW5kZXggOiB1dGlsLmVzY2FwZUZyYWdtZW50KGtleUluZGV4KSk7XG5cbiAgICBpZiAodHlwZW9mIGlkID09ICdzdHJpbmcnKSB7XG4gICAgICBpZCA9IGJhc2VJZCA9IG5vcm1hbGl6ZUlkKGJhc2VJZCA/IFVSSS5yZXNvbHZlKGJhc2VJZCwgaWQpIDogaWQpO1xuXG4gICAgICB2YXIgcmVmVmFsID0gc2VsZi5fcmVmc1tpZF07XG4gICAgICBpZiAodHlwZW9mIHJlZlZhbCA9PSAnc3RyaW5nJykgcmVmVmFsID0gc2VsZi5fcmVmc1tyZWZWYWxdO1xuICAgICAgaWYgKHJlZlZhbCAmJiByZWZWYWwuc2NoZW1hKSB7XG4gICAgICAgIGlmICghZXF1YWwoc2NoLCByZWZWYWwuc2NoZW1hKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIFwiJyArIGlkICsgJ1wiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hJyk7XG4gICAgICB9IGVsc2UgaWYgKGlkICE9IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICBpZiAoaWRbMF0gPT0gJyMnKSB7XG4gICAgICAgICAgaWYgKGxvY2FsUmVmc1tpZF0gJiYgIWVxdWFsKHNjaCwgbG9jYWxSZWZzW2lkXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIFwiJyArIGlkICsgJ1wiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hJyk7XG4gICAgICAgICAgbG9jYWxSZWZzW2lkXSA9IHNjaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9yZWZzW2lkXSA9IGZ1bGxQYXRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhc2VJZHNbanNvblB0cl0gPSBiYXNlSWQ7XG4gICAgZnVsbFBhdGhzW2pzb25QdHJdID0gZnVsbFBhdGg7XG4gIH0pO1xuXG4gIHJldHVybiBsb2NhbFJlZnM7XG59XG4iLCIvKiogQGxpY2Vuc2UgVVJJLmpzIHY0LjQuMSAoYykgMjAxMSBHYXJ5IENvdXJ0LiBMaWNlbnNlOiBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVVJJID0gZ2xvYmFsLlVSSSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJleHAoc3RyKSB7XG4gICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiBvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBvYmogPSB0YXJnZXQ7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xuICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuICAgICAgICBDUiQgPSBcIltcXFxceDBEXVwiLFxuICAgICAgICBESUdJVCQkID0gXCJbMC05XVwiLFxuICAgICAgICBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG4gICAgICAgIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSxcbiAgICAgICAgLy9jYXNlLWluc2Vuc2l0aXZlXG4gICAgTEYkJCA9IFwiW1xcXFx4MEFdXCIsXG4gICAgICAgIFNQJCQgPSBcIltcXFxceDIwXVwiLFxuICAgICAgICBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksXG4gICAgICAgIC8vZXhwYW5kZWRcbiAgICBHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcbiAgICAgICAgU1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcbiAgICAgICAgUkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcbiAgICAgICAgVUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0XG4gICAgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG4gICAgICAgIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG4gICAgICAgIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcbiAgICAgICAgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG4gICAgICAgIERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksXG4gICAgICAgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG4gICAgICAgIEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuICAgICAgICBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuICAgICAgICBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLFxuICAgICAgICAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgSVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIpLFxuICAgICAgICAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuICAgICAgICBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcbiAgICAgICAgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcbiAgICAgICAgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcbiAgICAgICAgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcbiAgICAgICAgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG4gICAgICAgIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG4gICAgICAgIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcbiAgICAgICAgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuICAgICAgICBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcbiAgICAgICAgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuICAgICAgICBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG4gICAgICAgIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcbiAgICAgICAgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG4gICAgICAgIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuICAgICAgICBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG4gICAgICAgIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG4gICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcbiAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcbiAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIH07XG59XG52YXIgVVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKGZhbHNlKTtcblxudmFyIElSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyh0cnVlKTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbi8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbnZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuXHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHQvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG52YXIgdWNzMmVuY29kZSA9IGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xudmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdHZhciBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9kZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdHZhciBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdGlmIChiYXNpYyA8IDApIHtcblx0XHRiYXNpYyA9IDA7XG5cdH1cblxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRlcnJvciQxKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0dmFyIG9sZGkgPSBpO1xuXHRcdGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IkMSgnaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cdFx0fVxuXG5cdFx0dmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBkZWx0YSA9IDA7XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZTIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKF9jdXJyZW50VmFsdWUyIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0dmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0dmFyIG0gPSBtYXhJbnQ7XG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBfY3VycmVudFZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG5cdFx0XHRcdFx0dmFyIHEgPSBkZWx0YTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG52YXIgdG9Vbmljb2RlID0gZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbnZhciB0b0FTQ0lJID0gZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbnZhciBwdW55Y29kZSA9IHtcblx0LyoqXG4gICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBPYmplY3RcbiAgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG4vKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cbnZhciBTQ0hFTUVTID0ge307XG5mdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgIHZhciBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGUgPSB2b2lkIDA7XG4gICAgaWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKGMgPj4gNiB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cikge1xuICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaWwgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoX2MgJiA2MykgPDwgNiB8IGMzICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpIHtcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgICAgcmV0dXJuICFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXNbMV07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzMiA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMyksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlczJbMV0sXG4gICAgICAgIHpvbmUgPSBfbWF0Y2hlczJbMl07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX2FkZHJlc3MkdG9Mb3dlckNhc2UkID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKSxcbiAgICAgICAgICAgIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksXG4gICAgICAgICAgICBsYXN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlswXSxcbiAgICAgICAgICAgIGZpcnN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlsxXTtcblxuICAgICAgICB2YXIgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuICAgICAgICB2YXIgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuICAgICAgICB2YXIgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG4gICAgICAgIHZhciBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSBBcnJheShmaWVsZENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcbiAgICAgICAgICAgIGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBpbmRleDogaW5kZXgsIGxlbmd0aDogMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHZhciBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgbmV3SG9zdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgbmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxudmFyIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xudmFyIE5PX01BVENIX0lTX1VOREVGSU5FRCA9IFwiXCIubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgIHZhciBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHNcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCBJUkkgLT4gVVJJXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIGVuY29kaW5nc1xuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG52YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG52YXIgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG52YXIgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuICAgICAgICAgICAgaWYgKGltKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpbVswXTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG4gICAgICAgIGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHt9XG4gICAgICAgIC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblxuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcbiAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICB9XG4gICAgdmFyIGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi9cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIiNcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7IC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcbiAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgfVxuICAgIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmlBID09PSB1cmlCO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpO1xufVxuXG52YXIgaGFuZGxlciA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cFwiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XG4gICAgICAgIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gICAgICAgIC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gICAgICAgIC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQxID0ge1xuICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplXG59O1xuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cbi8vUkZDIDY0NTVcbnZhciBoYW5kbGVyJDIgPSB7XG4gICAgc2NoZW1lOiBcIndzXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgd3NDb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgLy9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuICAgICAgICAvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHdzQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIF93c0NvbXBvbmVudHMkcmVzb3VyYyA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKSxcbiAgICAgICAgICAgICAgICBfd3NDb21wb25lbnRzJHJlc291cmMyID0gc2xpY2VkVG9BcnJheShfd3NDb21wb25lbnRzJHJlc291cmMsIDIpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcblxuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSBwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gICAgICAgIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQzID0ge1xuICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyJDIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlciQyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxufTtcblxudmFyIE8gPSB7fTtcbnZhciBpc0lSSSA9IHRydWU7XG4vL1JGQyAzOTg2XG52YXIgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xudmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAvL2Nhc2UtaW5zZW5zaXRpdmVcbnZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7IC8vZXhwYW5kZWRcbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbnZhciBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbnZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG52YXIgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xudmFyIFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xudmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xudmFyIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbnZhciBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG52YXIgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgcmV0dXJuICFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG59XG52YXIgaGFuZGxlciQ0ID0ge1xuICAgIHNjaGVtZTogXCJtYWlsdG9cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSBtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZmllbGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IDAsIF94bCA9IHRvQWRkcnMubGVuZ3RoOyBfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1tfeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBfeDIgPSAwLCBfeGwyID0gdG8ubGVuZ3RoOyBfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1tfeDJdLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgICAgIGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1tfeDJdID0gYWRkci5qb2luKFwiQFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKG1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcbiAgICAgICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBhcnQgPSB0b0FkZHIuc2xpY2UoMCwgYXRJZHgpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArIFwiPVwiICsgaGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuLy9SRkMgMjE0MVxudmFyIGhhbmRsZXIkNSA9IHtcbiAgICBzY2hlbWU6IFwidXJuXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHZhciBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcbiAgICAgICAgdXJpQ29tcG9uZW50cy5wYXRoID0gKG5pZCB8fCBvcHRpb25zLm5pZCkgKyBcIjpcIiArIG5zcztcbiAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4vL1JGQyA0MTIyXG52YXIgaGFuZGxlciQ2ID0ge1xuICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcbiAgICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh1dWlkQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzO1xuICAgICAgICAvL25vcm1hbGl6ZSBVVUlEXG4gICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfVxufTtcblxuU0NIRU1FU1toYW5kbGVyLnNjaGVtZV0gPSBoYW5kbGVyO1xuU0NIRU1FU1toYW5kbGVyJDEuc2NoZW1lXSA9IGhhbmRsZXIkMTtcblNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG5TQ0hFTUVTW2hhbmRsZXIkMy5zY2hlbWVdID0gaGFuZGxlciQzO1xuU0NIRU1FU1toYW5kbGVyJDQuc2NoZW1lXSA9IGhhbmRsZXIkNDtcblNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG5TQ0hFTUVTW2hhbmRsZXIkNi5zY2hlbWVdID0gaGFuZGxlciQ2O1xuXG5leHBvcnRzLlNDSEVNRVMgPSBTQ0hFTUVTO1xuZXhwb3J0cy5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbmV4cG9ydHMucGN0RGVjQ2hhcnMgPSBwY3REZWNDaGFycztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50cyA9IHJlc29sdmVDb21wb25lbnRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlQ29tcG9uZW50ID0gdW5lc2NhcGVDb21wb25lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuYWxsLmpzLm1hcFxuIiwiaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuL3VyaVwiO1xuXG5pbXBvcnQgaHR0cCBmcm9tIFwiLi9zY2hlbWVzL2h0dHBcIjtcblNDSEVNRVNbaHR0cC5zY2hlbWVdID0gaHR0cDtcblxuaW1wb3J0IGh0dHBzIGZyb20gXCIuL3NjaGVtZXMvaHR0cHNcIjtcblNDSEVNRVNbaHR0cHMuc2NoZW1lXSA9IGh0dHBzO1xuXG5pbXBvcnQgd3MgZnJvbSBcIi4vc2NoZW1lcy93c1wiO1xuU0NIRU1FU1t3cy5zY2hlbWVdID0gd3M7XG5cbmltcG9ydCB3c3MgZnJvbSBcIi4vc2NoZW1lcy93c3NcIjtcblNDSEVNRVNbd3NzLnNjaGVtZV0gPSB3c3M7XG5cbmltcG9ydCBtYWlsdG8gZnJvbSBcIi4vc2NoZW1lcy9tYWlsdG9cIjtcblNDSEVNRVNbbWFpbHRvLnNjaGVtZV0gPSBtYWlsdG87XG5cbmltcG9ydCB1cm4gZnJvbSBcIi4vc2NoZW1lcy91cm5cIjtcblNDSEVNRVNbdXJuLnNjaGVtZV0gPSB1cm47XG5cbmltcG9ydCB1dWlkIGZyb20gXCIuL3NjaGVtZXMvdXJuLXV1aWRcIjtcblNDSEVNRVNbdXVpZC5zY2hlbWVdID0gdXVpZDtcblxuZXhwb3J0ICogZnJvbSBcIi4vdXJpXCI7XG4iLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgVVJOQ29tcG9uZW50cyB9IGZyb20gXCIuL3VyblwiO1xuaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVVUlEQ29tcG9uZW50cyBleHRlbmRzIFVSTkNvbXBvbmVudHMge1xuXHR1dWlkPzogc3RyaW5nO1xufVxuXG5jb25zdCBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuY29uc3QgVVVJRF9QQVJTRSA9IC9eWzAtOUEtRmEtZlxcLV17MzZ9LztcblxuLy9SRkMgNDEyMlxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVVSURDb21wb25lbnRzLCBVUklPcHRpb25zLCBVUk5Db21wb25lbnRzPiA9IHtcblx0c2NoZW1lIDogXCJ1cm46dXVpZFwiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKHVybkNvbXBvbmVudHM6VVJOQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVVUlEQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzIGFzIFVVSURDb21wb25lbnRzO1xuXHRcdHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG5cdFx0dXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcblx0XHRcdHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXVpZENvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHV1aWRDb21wb25lbnRzOlVVSURDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cyBhcyBVUk5Db21wb25lbnRzO1xuXHRcdC8vbm9ybWFsaXplIFVVSURcblx0XHR1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIHVybkNvbXBvbmVudHM7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBwY3RFbmNDaGFyLCBTQ0hFTUVTIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVSTkNvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzIHtcblx0bmlkPzpzdHJpbmc7XG5cdG5zcz86c3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSTk9wdGlvbnMgZXh0ZW5kcyBVUklPcHRpb25zIHtcblx0bmlkPzpzdHJpbmc7XG59XG5cbmNvbnN0IE5JRCQgPSBcIig/OlswLTlBLVphLXpdWzAtOUEtWmEtelxcXFwtXXsxLDMxfSlcIjtcbmNvbnN0IFBDVF9FTkNPREVEJCA9IFwiKD86XFxcXCVbMC05QS1GYS1mXXsyfSlcIjtcbmNvbnN0IFRSQU5TJCQgPSBcIlswLTlBLVphLXpcXFxcKFxcXFwpXFxcXCtcXFxcLFxcXFwtXFxcXC5cXFxcOlxcXFw9XFxcXEBcXFxcO1xcXFwkXFxcXF9cXFxcIVxcXFwqXFxcXCdcXFxcL1xcXFw/XFxcXCNdXCI7XG5jb25zdCBOU1MkID0gXCIoPzooPzpcIiArIFBDVF9FTkNPREVEJCArIFwifFwiICsgVFJBTlMkJCArIFwiKSspXCI7XG5jb25zdCBVUk5fU0NIRU1FID0gbmV3IFJlZ0V4cChcIl51cm5cXFxcOihcIiArIE5JRCQgKyBcIikkXCIpO1xuY29uc3QgVVJOX1BBVEggPSBuZXcgUmVnRXhwKFwiXihcIiArIE5JRCQgKyBcIilcXFxcOihcIiArIE5TUyQgKyBcIikkXCIpO1xuY29uc3QgVVJOX1BBUlNFID0gL14oW15cXDpdKylcXDooLiopLztcbmNvbnN0IFVSTl9FWENMVURFRCA9IC9bXFx4MDAtXFx4MjBcXFxcXFxcIlxcJlxcPFxcPlxcW1xcXVxcXlxcYFxce1xcfFxcfVxcflxceDdGLVxceEZGXS9nO1xuXG4vL1JGQyAyMTQxXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXI8VVJOQ29tcG9uZW50cyxVUk5PcHRpb25zPiA9IHtcblx0c2NoZW1lIDogXCJ1cm5cIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJOT3B0aW9ucyk6VVJOQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcblx0XHRsZXQgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgVVJOQ29tcG9uZW50cztcblxuXHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuXHRcdFx0Y29uc3QgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29uc3QgbnNzID0gbWF0Y2hlc1syXTtcblx0XHRcdGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YDtcblx0XHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG5cblx0XHRcdHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuXHRcdFx0dXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG5cdFx0XHR1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmIChzY2hlbWVIYW5kbGVyKSB7XG5cdFx0XHRcdHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuXHRcdH1cblxuXHRcdHJldHVybiB1cm5Db21wb25lbnRzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZSA6IGZ1bmN0aW9uICh1cm5Db21wb25lbnRzOlVSTkNvbXBvbmVudHMsIG9wdGlvbnM6VVJOT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Y29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcblx0XHRjb25zdCBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcblx0XHRjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWA7XG5cdFx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcblxuXHRcdGlmIChzY2hlbWVIYW5kbGVyKSB7XG5cdFx0XHR1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucykgYXMgVVJOQ29tcG9uZW50cztcblx0XHR9XG5cblx0XHRjb25zdCB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cyBhcyBVUklDb21wb25lbnRzO1xuXHRcdGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuXHRcdHVyaUNvbXBvbmVudHMucGF0aCA9IGAke25pZCB8fCBvcHRpb25zLm5pZH06JHtuc3N9YDtcblxuXHRcdHJldHVybiB1cmlDb21wb25lbnRzO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgcGN0RGVjQ2hhcnMsIHVuZXNjYXBlQ29tcG9uZW50IH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHB1bnljb2RlIGZyb20gXCJwdW55Y29kZVwiO1xuaW1wb3J0IHsgbWVyZ2UsIHN1YmV4cCwgdG9VcHBlckNhc2UsIHRvQXJyYXkgfSBmcm9tIFwiLi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1haWx0b0hlYWRlcnMge1xuXHRbaGZuYW1lOnN0cmluZ106c3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvQ29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMge1xuXHR0bzpBcnJheTxzdHJpbmc+LFxuXHRoZWFkZXJzPzpNYWlsdG9IZWFkZXJzLFxuXHRzdWJqZWN0PzpzdHJpbmcsXG5cdGJvZHk/OnN0cmluZ1xufVxuXG5jb25zdCBPOk1haWx0b0hlYWRlcnMgPSB7fTtcbmNvbnN0IGlzSVJJID0gdHJ1ZTtcblxuLy9SRkMgMzk4NlxuY29uc3QgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xuY29uc3QgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7ICAvL2Nhc2UtaW5zZW5zaXRpdmVcbmNvbnN0IFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgIC8vZXhwYW5kZWRcblxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xuY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG5jb25zdCBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG5jb25zdCBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG5jb25zdCBET1RfQVRPTV9URVhUJCA9IHN1YmV4cChBVEVYVCQkICsgXCIrXCIgKyBzdWJleHAoXCJcXFxcLlwiICsgQVRFWFQkJCArIFwiK1wiKSArIFwiKlwiKTtcbmNvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBWQ0hBUiQkKTtcbmNvbnN0IFFDT05URU5UJCA9IHN1YmV4cChRVEVYVCQkICsgXCJ8XCIgKyBRVU9URURfUEFJUiQpO1xuY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBRQ09OVEVOVCQgKyBcIipcIiArICdcXFxcXCInKTtcblxuLy9SRkMgNjA2OFxuY29uc3QgRFRFWFRfTk9fT0JTJCQgPSBcIltcXFxceDIxLVxcXFx4NUFcXFxceDVFLVxcXFx4N0VdXCI7ICAvLyVkMzMtOTAgLyAlZDk0LTEyNlxuY29uc3QgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG5jb25zdCBRQ0hBUiQgPSBzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFNPTUVfREVMSU1TJCQpO1xuY29uc3QgRE9NQUlOJCA9IHN1YmV4cChET1RfQVRPTV9URVhUJCArIFwifFwiICsgXCJcXFxcW1wiICsgRFRFWFRfTk9fT0JTJCQgKyBcIipcIiArIFwiXFxcXF1cIik7XG5jb25zdCBMT0NBTF9QQVJUJCA9IHN1YmV4cChET1RfQVRPTV9URVhUJCArIFwifFwiICsgUVVPVEVEX1NUUklORyQpO1xuY29uc3QgQUREUl9TUEVDJCA9IHN1YmV4cChMT0NBTF9QQVJUJCArIFwiXFxcXEBcIiArIERPTUFJTiQpO1xuY29uc3QgVE8kID0gc3ViZXhwKEFERFJfU1BFQyQgKyBzdWJleHAoXCJcXFxcLFwiICsgQUREUl9TUEVDJCkgKyBcIipcIik7XG5jb25zdCBIRk5BTUUkID0gc3ViZXhwKFFDSEFSJCArIFwiKlwiKTtcbmNvbnN0IEhGVkFMVUUkID0gSEZOQU1FJDtcbmNvbnN0IEhGSUVMRCQgPSBzdWJleHAoSEZOQU1FJCArIFwiXFxcXD1cIiArIEhGVkFMVUUkKTtcbmNvbnN0IEhGSUVMRFMyJCA9IHN1YmV4cChIRklFTEQkICsgc3ViZXhwKFwiXFxcXCZcIiArIEhGSUVMRCQpICsgXCIqXCIpO1xuY29uc3QgSEZJRUxEUyQgPSBzdWJleHAoXCJcXFxcP1wiICsgSEZJRUxEUzIkKTtcbmNvbnN0IE1BSUxUT19VUkkgPSBuZXcgUmVnRXhwKFwiXm1haWx0b1xcXFw6XCIgKyBUTyQgKyBcIj9cIiArIEhGSUVMRFMkICsgXCI/JFwiKTtcblxuY29uc3QgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG5jb25zdCBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG5jb25zdCBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG5jb25zdCBOT1RfRE9NQUlOID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgXCJbXFxcXFtdXCIsIERURVhUX05PX09CUyQkLCBcIltcXFxcXV1cIiksIFwiZ1wiKTtcbmNvbnN0IE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmNvbnN0IFRPID0gbmV3IFJlZ0V4cChcIl5cIiArIFRPJCArIFwiJFwiKTtcbmNvbnN0IEhGSUVMRFMgPSBuZXcgUmVnRXhwKFwiXlwiICsgSEZJRUxEUzIkICsgXCIkXCIpO1xuXG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG5cdHJldHVybiAoIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cik7XG59XG5cbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxNYWlsdG9Db21wb25lbnRzPiA9ICB7XG5cdHNjaGVtZSA6IFwibWFpbHRvXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOk1haWx0b0NvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIE1haWx0b0NvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gKG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXSk7XG5cdFx0bWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcblx0XHRcdGxldCB1bmtub3duSGVhZGVycyA9IGZhbHNlXG5cdFx0XHRjb25zdCBoZWFkZXJzOk1haWx0b0hlYWRlcnMgPSB7fTtcblx0XHRcdGNvbnN0IGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcblxuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdGNvbnN0IGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuXG5cdFx0XHRcdHN3aXRjaCAoaGZpZWxkWzBdKSB7XG5cdFx0XHRcdFx0Y2FzZSBcInRvXCI6XG5cdFx0XHRcdFx0XHRjb25zdCB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IHggPSAwLCB4bCA9IHRvQWRkcnMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRcdFx0XHR0by5wdXNoKHRvQWRkcnNbeF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInN1YmplY3RcIjpcblx0XHRcdFx0XHRcdG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYm9keVwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR1bmtub3duSGVhZGVycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR9XG5cblx0XHRtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG5cdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0Y29uc3QgYWRkciA9IHRvW3hdLnNwbGl0KFwiQFwiKTtcblxuXHRcdFx0YWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuXG5cdFx0XHRpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcblx0XHRcdFx0Ly9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0b1t4XSA9IGFkZHIuam9pbihcIkBcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKG1haWx0b0NvbXBvbmVudHM6TWFpbHRvQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cyBhcyBVUklDb21wb25lbnRzO1xuXHRcdGNvbnN0IHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcblx0XHRpZiAodG8pIHtcblx0XHRcdGZvciAobGV0IHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcblx0XHRcdFx0Y29uc3QgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuXHRcdFx0XHRjb25zdCBsb2NhbFBhcnQgPSAodG9BZGRyLnNsaWNlKDAsIGF0SWR4KSkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuXHRcdFx0XHRsZXQgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG5cblx0XHRcdFx0Ly9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkb21haW4gPSAoIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbikpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcblx0XHR9XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuXG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG5cdFx0aWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG5cblx0XHRjb25zdCBmaWVsZHMgPSBbXTtcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gaGVhZGVycykge1xuXHRcdFx0aWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcblx0XHRcdFx0ZmllbGRzLnB1c2goXG5cdFx0XHRcdFx0bmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArXG5cdFx0XHRcdFx0XCI9XCIgK1xuXHRcdFx0XHRcdGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChmaWVsZHMubGVuZ3RoKSB7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB3cyBmcm9tIFwiLi93c1wiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwid3NzXCIsXG5cdGRvbWFpbkhvc3QgOiB3cy5kb21haW5Ib3N0LFxuXHRwYXJzZSA6IHdzLnBhcnNlLFxuXHRzZXJpYWxpemUgOiB3cy5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdTQ29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMge1xuXHRyZXNvdXJjZU5hbWU/OiBzdHJpbmc7XG5cdHNlY3VyZT86IGJvb2xlYW47XG59XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50czpXU0NvbXBvbmVudHMpOmJvb2xlYW4ge1xuXHRyZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cblxuLy9SRkMgNjQ1NVxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcIndzXCIsXG5cblx0ZG9tYWluSG9zdCA6IHRydWUsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOldTQ29tcG9uZW50cyB7XG5cdFx0Y29uc3Qgd3NDb21wb25lbnRzID0gY29tcG9uZW50cyBhcyBXU0NvbXBvbmVudHM7XG5cblx0XHQvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcblx0XHR3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKTtcblxuXHRcdC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuXHRcdHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJyk7XG5cdFx0d3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cdFx0d3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIHdzQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAod3NDb21wb25lbnRzOldTQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHQvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG5cdFx0aWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0d3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcblx0XHRpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuXHRcdFx0d3NDb21wb25lbnRzLnNjaGVtZSA9ICh3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnKTtcblx0XHRcdHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuXHRcdGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG5cdFx0XHRjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpO1xuXHRcdFx0d3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKTtcblx0XHRcdHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuXHRcdFx0d3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcblx0XHR3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG5cblx0XHRyZXR1cm4gd3NDb21wb25lbnRzO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgaHR0cCBmcm9tIFwiLi9odHRwXCI7XG5cbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlciA9IHtcblx0c2NoZW1lIDogXCJodHRwc1wiLFxuXHRkb21haW5Ib3N0IDogaHR0cC5kb21haW5Ib3N0LFxuXHRwYXJzZSA6IGh0dHAucGFyc2UsXG5cdHNlcmlhbGl6ZSA6IGh0dHAuc2VyaWFsaXplXG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9yZXBvcnQgbWlzc2luZyBob3N0XG5cdFx0aWYgKCFjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcblxuXHRcdC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcblx0XHRpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuXHRcdGlmICghY29tcG9uZW50cy5wYXRoKSB7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHQvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcblx0XHQvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuXHRcdC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cblxuaW1wb3J0IFVSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLXVyaVwiO1xuaW1wb3J0IElSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLWlyaVwiO1xuaW1wb3J0IHB1bnljb2RlIGZyb20gXCJwdW55Y29kZVwiO1xuaW1wb3J0IHsgdG9VcHBlckNhc2UsIHR5cGVPZiwgYXNzaWduIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVSSUNvbXBvbmVudHMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0dXNlcmluZm8/OnN0cmluZztcblx0aG9zdD86c3RyaW5nO1xuXHRwb3J0PzpudW1iZXJ8c3RyaW5nO1xuXHRwYXRoPzpzdHJpbmc7XG5cdHF1ZXJ5PzpzdHJpbmc7XG5cdGZyYWdtZW50PzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHRlcnJvcj86c3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSU9wdGlvbnMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0cmVmZXJlbmNlPzpzdHJpbmc7XG5cdHRvbGVyYW50Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG5cdGlyaT86Ym9vbGVhbjtcblx0dW5pY29kZVN1cHBvcnQ/OmJvb2xlYW47XG5cdGRvbWFpbkhvc3Q/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJU2NoZW1lSGFuZGxlcjxDb21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyA9IFVSSUNvbXBvbmVudHMsIE9wdGlvbnMgZXh0ZW5kcyBVUklPcHRpb25zID0gVVJJT3B0aW9ucywgUGFyZW50Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzPiB7XG5cdHNjaGVtZTpzdHJpbmc7XG5cdHBhcnNlKGNvbXBvbmVudHM6UGFyZW50Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpDb21wb25lbnRzO1xuXHRzZXJpYWxpemUoY29tcG9uZW50czpDb21wb25lbnRzLCBvcHRpb25zOk9wdGlvbnMpOlBhcmVudENvbXBvbmVudHM7XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJUmVnRXhwcyB7XG5cdE5PVF9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9VU0VSSU5GTyA6IFJlZ0V4cCxcblx0Tk9UX0hPU1QgOiBSZWdFeHAsXG5cdE5PVF9QQVRIIDogUmVnRXhwLFxuXHROT1RfUEFUSF9OT1NDSEVNRSA6IFJlZ0V4cCxcblx0Tk9UX1FVRVJZIDogUmVnRXhwLFxuXHROT1RfRlJBR01FTlQgOiBSZWdFeHAsXG5cdEVTQ0FQRSA6IFJlZ0V4cCxcblx0VU5SRVNFUlZFRCA6IFJlZ0V4cCxcblx0T1RIRVJfQ0hBUlMgOiBSZWdFeHAsXG5cdFBDVF9FTkNPREVEIDogUmVnRXhwLFxuXHRJUFY0QUREUkVTUyA6IFJlZ0V4cCxcblx0SVBWNkFERFJFU1MgOiBSZWdFeHAsXG59XG5cbmV4cG9ydCBjb25zdCBTQ0hFTUVTOntbc2NoZW1lOnN0cmluZ106VVJJU2NoZW1lSGFuZGxlcn0gPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuXHRsZXQgZTpzdHJpbmc7XG5cblx0aWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoKGMgPj4gNikgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGUgPSBcIiVcIiArICgoYyA+PiAxMikgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKChjID4+IDYpICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuXHRyZXR1cm4gZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdGxldCBuZXdTdHIgPSBcIlwiO1xuXHRsZXQgaSA9IDA7XG5cdGNvbnN0IGlsID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaSA8IGlsKSB7XG5cdFx0Y29uc3QgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG5cblx0XHRpZiAoYyA8IDEyOCkge1xuXHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG5cdFx0XHRpICs9IDM7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA2KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA2O1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDIyNCkge1xuXHRcdFx0aWYgKChpbCAtIGkpID49IDkpIHtcblx0XHRcdFx0Y29uc3QgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuXHRcdFx0XHRjb25zdCBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA5O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdTdHI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIHByb3RvY29sOlVSSVJlZ0V4cHMpIHtcblx0ZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRcdGNvbnN0IGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG5cdFx0cmV0dXJuICghZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcblx0aWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzc10gPSBtYXRjaGVzO1xuXHRcblx0aWYgKGFkZHJlc3MpIHtcblx0XHRyZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzcywgem9uZV0gPSBtYXRjaGVzO1xuXG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0Y29uc3QgW2xhc3QsIGZpcnN0XSA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCk7XG5cdFx0Y29uc3QgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuXHRcdGNvbnN0IGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcblx0XHRjb25zdCBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuXHRcdGNvbnN0IGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG5cdFx0Y29uc3QgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuXHRcdGNvbnN0IGZpZWxkcyA9IEFycmF5PHN0cmluZz4oZmllbGRDb3VudCk7XG5cblx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuXHRcdFx0ZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcblx0XHR9XG5cblx0XHRpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuXHRcdFx0ZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHRjb25zdCBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZTxBcnJheTx7aW5kZXg6bnVtYmVyLGxlbmd0aDpudW1iZXJ9Pj4oKGFjYywgZmllbGQsIGluZGV4KSA9PiB7XG5cdFx0XHRpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuXHRcdFx0XHRjb25zdCBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcblx0XHRcdFx0XHRsYXN0TG9uZ2VzdC5sZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY2MucHVzaCh7IGluZGV4LCBsZW5ndGggOiAxIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIFtdKTtcblxuXHRcdGNvbnN0IGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVswXTtcblxuXHRcdGxldCBuZXdIb3N0OnN0cmluZztcblx0XHRpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Y29uc3QgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpIDtcblx0XHRcdGNvbnN0IG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuXHRcdFx0bmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcblx0XHR9XG5cblx0XHRpZiAoem9uZSkge1xuXHRcdFx0bmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld0hvc3Q7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG5jb25zdCBOT19NQVRDSF9JU19VTkRFRklORUQgPSAoPFJlZ0V4cE1hdGNoQXJyYXk+KFwiXCIpLm1hdGNoKC8oKXswfS8pKVsxXSA9PT0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nOnN0cmluZywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCBjb21wb25lbnRzOlVSSUNvbXBvbmVudHMgPSB7fTtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcblxuXHRjb25zdCBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG5cblx0aWYgKG1hdGNoZXMpIHtcblx0XHRpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG5cdFx0XHQvL3N0b3JlIGVhY2ggY29tcG9uZW50XG5cdFx0XHRjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcblx0XHRcdGNvbXBvbmVudHMudXNlcmluZm8gPSAodXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSAodXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQpO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gKHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29tcG9uZW50cy5ob3N0KSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBJUCBob3N0c1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHQvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuXHRcdGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuXHRcdH1cblxuXHRcdC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcblx0XHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG5cdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuXHRcdH1cblxuXHRcdC8vZmluZCBzY2hlbWUgaGFuZGxlclxuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHRcdC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG5cdFx0aWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcblx0XHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdFx0aWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpKSB7XG5cdFx0XHRcdC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly9jb252ZXJ0IElSSSAtPiBVUklcblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBlbmNvZGluZ3Ncblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG5cdFx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuXHRcdFx0c2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG5cdH1cblxuXHRyZXR1cm4gY29tcG9uZW50cztcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOnN0cmluZ3x1bmRlZmluZWQge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0wpO1xuXHRjb25zdCB1cmlUb2tlbnM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcblx0XHR1cmlUb2tlbnMucHVzaChcIkBcIik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcblx0XHR1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgKF8sICQxLCAkMikgPT4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCIpKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIjpcIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xuY29uc3QgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG5jb25zdCBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbmNvbnN0IFJEUzQgPSAvXlxcLlxcLj8kLztcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dDpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IG91dHB1dDpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuXHRcdGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG5cdFx0fSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcblx0XHRcdG91dHB1dC5wb3AoKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG5cdFx0XHRpbnB1dCA9IFwiXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG5cdFx0XHRpZiAoaW0pIHtcblx0XHRcdFx0Y29uc3QgcyA9IGltWzBdO1xuXHRcdFx0XHRpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcblx0XHRcdFx0b3V0cHV0LnB1c2gocyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOnN0cmluZyB7XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuXG5cdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuXHRpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG5cdFx0aWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge1xuXHRcdFx0Ly9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXHRcdH1cblxuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG5cdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9ub3JtYWxpemUgZW5jb2Rpbmdcblx0X25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHR9XG5cblx0Y29uc3QgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0aWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG5cblx0XHRpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi9cIik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bGV0IHMgPSBjb21wb25lbnRzLnBhdGg7XG5cblx0XHRpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG5cdFx0XHRzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG5cdFx0fVxuXG5cdFx0aWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKHMpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIiNcIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG5cdH1cblxuXHRyZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7ICAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZTpVUklDb21wb25lbnRzLCByZWxhdGl2ZTpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMgPSB7fSwgc2tpcE5vcm1hbGl6YXRpb24/OmJvb2xlYW4pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCB0YXJnZXQ6VVJJQ29tcG9uZW50cyA9IHt9O1xuXG5cdGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcblx0XHRiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgIC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuXHRcdHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG5cdH1cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuXHRcdHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG5cdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuXHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHR0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG5cdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHR9IGVsc2Uge1xuXHRcdGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghcmVsYXRpdmUucGF0aCkge1xuXHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG5cdFx0XHR0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcblx0XHR9XG5cdFx0dGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuXHR9XG5cblx0dGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGJhc2VVUkk6c3RyaW5nLCByZWxhdGl2ZVVSSTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lIDogJ251bGwnIH0sIG9wdGlvbnMpO1xuXHRyZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodXJpOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHM7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmFueSB7XG5cdGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpID0gcGFyc2Uoc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOnN0cmluZywgdXJpQjpzdHJpbmcsIG9wdGlvbnM/OiBVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6VVJJQ29tcG9uZW50cywgdXJpQjpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6YW55LCB1cmlCOmFueSwgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbiB7XG5cdGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUoPFVSSUNvbXBvbmVudHM+dXJpQSwgb3B0aW9ucyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaUEgPT09IHVyaUI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0cjpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUpLCBwY3RFbmNDaGFyKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCksIHBjdERlY0NoYXJzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGFycmF5ID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG5jb25zdCBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGxldCBvbGRpID0gaTtcblx0XHRmb3IgKGxldCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdGxldCBtID0gbWF4SW50O1xuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHRjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IGJ1aWxkRXhwcyB9IGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyh0cnVlKTtcbiIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IG1lcmdlLCBzdWJleHAgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHMoaXNJUkk6Ym9vbGVhbik6VVJJUmVnRXhwcyB7XG5cdGNvbnN0XG5cdFx0QUxQSEEkJCA9IFwiW0EtWmEtel1cIixcblx0XHRDUiQgPSBcIltcXFxceDBEXVwiLFxuXHRcdERJR0lUJCQgPSBcIlswLTldXCIsXG5cdFx0RFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuXHRcdEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSwgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdExGJCQgPSBcIltcXFxceDBBXVwiLFxuXHRcdFNQJCQgPSBcIltcXFxceDIwXVwiLFxuXHRcdFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSwgIC8vZXhwYW5kZWRcblx0XHRHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcblx0XHRTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuXHRcdFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG5cdFx0VUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcblx0XHRJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLCAgLy9zdWJzZXRcblx0XHRVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcblx0XHRTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuXHRcdFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcblx0XHRERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcblx0XHRERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLCAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcblx0XHRIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcblx0XHRMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuXHRcdElQVjZBRERSRVNTMSQgPSBzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSwgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1MyJCA9IHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLCAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSwgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArICAgICAgICBIMTYkICsgXCJcXFxcOlwiICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG5cdFx0SVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuXHRcdElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIEgxNiQgKSwgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuXHRcdElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcblx0XHRJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcblx0XHRaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksICAvL1JGQyA2ODc0XG5cdFx0SVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NFxuXHRcdElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcblx0XHRJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSwgIC8vUkZDIDY4NzRcblx0XHRSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcblx0XHRIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuXHRcdFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG5cdFx0QVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG5cdFx0UENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcblx0XHRTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG5cdFx0U0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuXHRcdFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuXHRcdFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcblx0XHRQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG5cdFx0UEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG5cdFx0RlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG5cdFx0SElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0UkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0VVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcblx0XHRBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG5cblx0XHRHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0UkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCJcblx0O1xuXG5cdHJldHVybiB7XG5cdFx0Tk9UX1NDSEVNRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuXHRcdE5PVF9VU0VSSU5GTyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9IT1NUIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIX05PU0NIRU1FIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUVVFUlkgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuXHRcdE5PVF9GUkFHTUVOVCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG5cdFx0RVNDQVBFIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHRVTlJFU0VSVkVEIDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcblx0XHRPVEhFUl9DSEFSUyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG5cdFx0UENUX0VOQ09ERUQgOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuXHRcdElQVjRBRERSRVNTIDogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuXHRcdElQVjZBRERSRVNTIDogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyhmYWxzZSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gbWVyZ2UoLi4uc2V0czpBcnJheTxzdHJpbmc+KTpzdHJpbmcge1xuXHRpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG5cdFx0c2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuXHRcdGNvbnN0IHhsID0gc2V0cy5sZW5ndGggLSAxO1xuXHRcdGZvciAobGV0IHggPSAxOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0c2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuXHRcdH1cblx0XHRzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuXHRcdHJldHVybiBzZXRzLmpvaW4oJycpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzZXRzWzBdO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJleHAoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZihvOmFueSk6c3RyaW5nIHtcblx0cmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiAobyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkob2JqOmFueSk6QXJyYXk8YW55PiB7XG5cdHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyAob2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiAodHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSkpIDogW107XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IG9iamVjdCwgc291cmNlOiBhbnkpOiBhbnkge1xuXHRjb25zdCBvYmogPSB0YXJnZXQgYXMgYW55O1xuXHRpZiAoc291cmNlKSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb2JqO1xufSIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiBjb3B5LFxuICBjaGVja0RhdGFUeXBlOiBjaGVja0RhdGFUeXBlLFxuICBjaGVja0RhdGFUeXBlczogY2hlY2tEYXRhVHlwZXMsXG4gIGNvZXJjZVRvVHlwZXM6IGNvZXJjZVRvVHlwZXMsXG4gIHRvSGFzaDogdG9IYXNoLFxuICBnZXRQcm9wZXJ0eTogZ2V0UHJvcGVydHksXG4gIGVzY2FwZVF1b3RlczogZXNjYXBlUXVvdGVzLFxuICBlcXVhbDogcmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyksXG4gIHVjczJsZW5ndGg6IHJlcXVpcmUoJy4vdWNzMmxlbmd0aCcpLFxuICB2YXJPY2N1cmVuY2VzOiB2YXJPY2N1cmVuY2VzLFxuICB2YXJSZXBsYWNlOiB2YXJSZXBsYWNlLFxuICBzY2hlbWFIYXNSdWxlczogc2NoZW1hSGFzUnVsZXMsXG4gIHNjaGVtYUhhc1J1bGVzRXhjZXB0OiBzY2hlbWFIYXNSdWxlc0V4Y2VwdCxcbiAgc2NoZW1hVW5rbm93blJ1bGVzOiBzY2hlbWFVbmtub3duUnVsZXMsXG4gIHRvUXVvdGVkU3RyaW5nOiB0b1F1b3RlZFN0cmluZyxcbiAgZ2V0UGF0aEV4cHI6IGdldFBhdGhFeHByLFxuICBnZXRQYXRoOiBnZXRQYXRoLFxuICBnZXREYXRhOiBnZXREYXRhLFxuICB1bmVzY2FwZUZyYWdtZW50OiB1bmVzY2FwZUZyYWdtZW50LFxuICB1bmVzY2FwZUpzb25Qb2ludGVyOiB1bmVzY2FwZUpzb25Qb2ludGVyLFxuICBlc2NhcGVGcmFnbWVudDogZXNjYXBlRnJhZ21lbnQsXG4gIGVzY2FwZUpzb25Qb2ludGVyOiBlc2NhcGVKc29uUG9pbnRlclxufTtcblxuXG5mdW5jdGlvbiBjb3B5KG8sIHRvKSB7XG4gIHRvID0gdG8gfHwge307XG4gIGZvciAodmFyIGtleSBpbiBvKSB0b1trZXldID0gb1trZXldO1xuICByZXR1cm4gdG87XG59XG5cblxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgc3RyaWN0TnVtYmVycywgbmVnYXRlKSB7XG4gIHZhciBFUVVBTCA9IG5lZ2F0ZSA/ICcgIT09ICcgOiAnID09PSAnXG4gICAgLCBBTkQgPSBuZWdhdGUgPyAnIHx8ICcgOiAnICYmICdcbiAgICAsIE9LID0gbmVnYXRlID8gJyEnIDogJydcbiAgICAsIE5PVCA9IG5lZ2F0ZSA/ICcnIDogJyEnO1xuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSAnbnVsbCc6IHJldHVybiBkYXRhICsgRVFVQUwgKyAnbnVsbCc7XG4gICAgY2FzZSAnYXJyYXknOiByZXR1cm4gT0sgKyAnQXJyYXkuaXNBcnJheSgnICsgZGF0YSArICcpJztcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gJygnICsgT0sgKyBkYXRhICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wib2JqZWN0XCInICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTk9UICsgJ0FycmF5LmlzQXJyYXkoJyArIGRhdGEgKyAnKSknO1xuICAgIGNhc2UgJ2ludGVnZXInOiByZXR1cm4gJyh0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIm51bWJlclwiJyArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBOT1QgKyAnKCcgKyBkYXRhICsgJyAlIDEpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBTkQgKyBkYXRhICsgRVFVQUwgKyBkYXRhICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHJpY3ROdW1iZXJzID8gKEFORCArIE9LICsgJ2lzRmluaXRlKCcgKyBkYXRhICsgJyknKSA6ICcnKSArICcpJztcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gJyh0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIicgKyBkYXRhVHlwZSArICdcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RyaWN0TnVtYmVycyA/IChBTkQgKyBPSyArICdpc0Zpbml0ZSgnICsgZGF0YSArICcpJykgOiAnJykgKyAnKSc7XG4gICAgZGVmYXVsdDogcmV0dXJuICd0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIicgKyBkYXRhVHlwZSArICdcIic7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bWJlcnMpIHtcbiAgc3dpdGNoIChkYXRhVHlwZXMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bWJlcnMsIHRydWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgdmFyIHR5cGVzID0gdG9IYXNoKGRhdGFUeXBlcyk7XG4gICAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvZGUgPSB0eXBlcy5udWxsID8gJygnOiAnKCEnICsgZGF0YSArICcgfHwgJztcbiAgICAgICAgY29kZSArPSAndHlwZW9mICcgKyBkYXRhICsgJyAhPT0gXCJvYmplY3RcIiknO1xuICAgICAgICBkZWxldGUgdHlwZXMubnVsbDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLmFycmF5O1xuICAgICAgICBkZWxldGUgdHlwZXMub2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzLm51bWJlcikgZGVsZXRlIHR5cGVzLmludGVnZXI7XG4gICAgICBmb3IgKHZhciB0IGluIHR5cGVzKVxuICAgICAgICBjb2RlICs9IChjb2RlID8gJyAmJiAnIDogJycgKSArIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtYmVycywgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBjb2RlO1xuICB9XG59XG5cblxudmFyIENPRVJDRV9UT19UWVBFUyA9IHRvSGFzaChbICdzdHJpbmcnLCAnbnVtYmVyJywgJ2ludGVnZXInLCAnYm9vbGVhbicsICdudWxsJyBdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXMob3B0aW9uQ29lcmNlVHlwZXMsIGRhdGFUeXBlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhVHlwZXMpKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaT0wOyBpPGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSBkYXRhVHlwZXNbaV07XG4gICAgICBpZiAoQ09FUkNFX1RPX1RZUEVTW3RdKSB0eXBlc1t0eXBlcy5sZW5ndGhdID0gdDtcbiAgICAgIGVsc2UgaWYgKG9wdGlvbkNvZXJjZVR5cGVzID09PSAnYXJyYXknICYmIHQgPT09ICdhcnJheScpIHR5cGVzW3R5cGVzLmxlbmd0aF0gPSB0O1xuICAgIH1cbiAgICBpZiAodHlwZXMubGVuZ3RoKSByZXR1cm4gdHlwZXM7XG4gIH0gZWxzZSBpZiAoQ09FUkNFX1RPX1RZUEVTW2RhdGFUeXBlc10pIHtcbiAgICByZXR1cm4gW2RhdGFUeXBlc107XG4gIH0gZWxzZSBpZiAob3B0aW9uQ29lcmNlVHlwZXMgPT09ICdhcnJheScgJiYgZGF0YVR5cGVzID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFsnYXJyYXknXTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgdmFyIGhhc2ggPSB7fTtcbiAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIGhhc2g7XG59XG5cblxudmFyIElERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbnZhciBTSU5HTEVfUVVPVEUgPSAvJ3xcXFxcL2c7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gJ251bWJlcidcbiAgICAgICAgICA/ICdbJyArIGtleSArICddJ1xuICAgICAgICAgIDogSURFTlRJRklFUi50ZXN0KGtleSlcbiAgICAgICAgICAgID8gJy4nICsga2V5XG4gICAgICAgICAgICA6IFwiWydcIiArIGVzY2FwZVF1b3RlcyhrZXkpICsgXCInXVwiO1xufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVF1b3RlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFNJTkdMRV9RVU9URSwgJ1xcXFwkJicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpO1xufVxuXG5cbmZ1bmN0aW9uIHZhck9jY3VyZW5jZXMoc3RyLCBkYXRhVmFyKSB7XG4gIGRhdGFWYXIgKz0gJ1teMC05XSc7XG4gIHZhciBtYXRjaGVzID0gc3RyLm1hdGNoKG5ldyBSZWdFeHAoZGF0YVZhciwgJ2cnKSk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5sZW5ndGggOiAwO1xufVxuXG5cbmZ1bmN0aW9uIHZhclJlcGxhY2Uoc3RyLCBkYXRhVmFyLCBleHByKSB7XG4gIGRhdGFWYXIgKz0gJyhbXjAtOV0pJztcbiAgZXhwciA9IGV4cHIucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGRhdGFWYXIsICdnJyksIGV4cHIgKyAnJDEnKTtcbn1cblxuXG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09ICdib29sZWFuJykgcmV0dXJuICFzY2hlbWE7XG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0V4Y2VwdChzY2hlbWEsIHJ1bGVzLCBleGNlcHRLZXl3b3JkKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09ICdib29sZWFuJykgcmV0dXJuICFzY2hlbWEgJiYgZXhjZXB0S2V5d29yZCAhPSAnbm90JztcbiAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkgaWYgKGtleSAhPSBleGNlcHRLZXl3b3JkICYmIHJ1bGVzW2tleV0pIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVtYVVua25vd25SdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09ICdib29sZWFuJykgcmV0dXJuO1xuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSBpZiAoIXJ1bGVzW2tleV0pIHJldHVybiBrZXk7XG59XG5cblxuZnVuY3Rpb24gdG9RdW90ZWRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiAnXFwnJyArIGVzY2FwZVF1b3RlcyhzdHIpICsgJ1xcJyc7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aEV4cHIoY3VycmVudFBhdGgsIGV4cHIsIGpzb25Qb2ludGVycywgaXNOdW1iZXIpIHtcbiAgdmFyIHBhdGggPSBqc29uUG9pbnRlcnMgLy8gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICA/ICdcXCcvXFwnICsgJyArIGV4cHIgKyAoaXNOdW1iZXIgPyAnJyA6ICcucmVwbGFjZSgvfi9nLCBcXCd+MFxcJykucmVwbGFjZSgvXFxcXC8vZywgXFwnfjFcXCcpJylcbiAgICAgICAgICAgICAgOiAoaXNOdW1iZXIgPyAnXFwnW1xcJyArICcgKyBleHByICsgJyArIFxcJ11cXCcnIDogJ1xcJ1tcXFxcXFwnXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXFxcXFxcJ11cXCcnKTtcbiAgcmV0dXJuIGpvaW5QYXRocyhjdXJyZW50UGF0aCwgcGF0aCk7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aChjdXJyZW50UGF0aCwgcHJvcCwganNvblBvaW50ZXJzKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzIC8vIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgPyB0b1F1b3RlZFN0cmluZygnLycgKyBlc2NhcGVKc29uUG9pbnRlcihwcm9wKSlcbiAgICAgICAgICAgICAgOiB0b1F1b3RlZFN0cmluZyhnZXRQcm9wZXJ0eShwcm9wKSk7XG4gIHJldHVybiBqb2luUGF0aHMoY3VycmVudFBhdGgsIHBhdGgpO1xufVxuXG5cbnZhciBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xudmFyIFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgbHZsLCBwYXRocykge1xuICB2YXIgdXAsIGpzb25Qb2ludGVyLCBkYXRhLCBtYXRjaGVzO1xuICBpZiAoJGRhdGEgPT09ICcnKSByZXR1cm4gJ3Jvb3REYXRhJztcbiAgaWYgKCRkYXRhWzBdID09ICcvJykge1xuICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTi1wb2ludGVyOiAnICsgJGRhdGEpO1xuICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgZGF0YSA9ICdyb290RGF0YSc7XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hlcyA9ICRkYXRhLm1hdGNoKFJFTEFUSVZFX0pTT05fUE9JTlRFUik7XG4gICAgaWYgKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTi1wb2ludGVyOiAnICsgJGRhdGEpO1xuICAgIHVwID0gK21hdGNoZXNbMV07XG4gICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgIGlmIChqc29uUG9pbnRlciA9PSAnIycpIHtcbiAgICAgIGlmICh1cCA+PSBsdmwpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFjY2VzcyBwcm9wZXJ0eS9pbmRleCAnICsgdXAgKyAnIGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAnICsgbHZsKTtcbiAgICAgIHJldHVybiBwYXRoc1tsdmwgLSB1cF07XG4gICAgfVxuXG4gICAgaWYgKHVwID4gbHZsKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgZGF0YSAnICsgdXAgKyAnIGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAnICsgbHZsKTtcbiAgICBkYXRhID0gJ2RhdGEnICsgKChsdmwgLSB1cCkgfHwgJycpO1xuICAgIGlmICghanNvblBvaW50ZXIpIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGV4cHIgPSBkYXRhO1xuICB2YXIgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpPTA7IGk8c2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICBkYXRhICs9IGdldFByb3BlcnR5KHVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpO1xuICAgICAgZXhwciArPSAnICYmICcgKyBkYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcjtcbn1cblxuXG5mdW5jdGlvbiBqb2luUGF0aHMgKGEsIGIpIHtcbiAgaWYgKGEgPT0gJ1wiXCInKSByZXR1cm4gYjtcbiAgcmV0dXJuIChhICsgJyArICcgKyBiKS5yZXBsYWNlKC8oW15cXFxcXSknIFxcKyAnL2csICckMScpO1xufVxuXG5cbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cblxuXG5mdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gIHZhciBsZW5ndGggPSAwXG4gICAgLCBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBwb3MgPSAwXG4gICAgLCB2YWx1ZTtcbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGxlbmd0aCsrO1xuICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIHBvcyA8IGxlbikge1xuICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoKHZhbHVlICYgMHhGQzAwKSA9PSAweERDMDApIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU9iamVjdDtcblxuZnVuY3Rpb24gU2NoZW1hT2JqZWN0KG9iaikge1xuICB1dGlsLmNvcHkob2JqLCB0aGlzKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFZhbGlkYXRpb246IGVycm9yU3ViY2xhc3MoVmFsaWRhdGlvbkVycm9yKSxcbiAgTWlzc2luZ1JlZjogZXJyb3JTdWJjbGFzcyhNaXNzaW5nUmVmRXJyb3IpXG59O1xuXG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihlcnJvcnMpIHtcbiAgdGhpcy5tZXNzYWdlID0gJ3ZhbGlkYXRpb24gZmFpbGVkJztcbiAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbn1cblxuXG5NaXNzaW5nUmVmRXJyb3IubWVzc2FnZSA9IGZ1bmN0aW9uIChiYXNlSWQsIHJlZikge1xuICByZXR1cm4gJ2NhblxcJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJyArIHJlZiArICcgZnJvbSBpZCAnICsgYmFzZUlkO1xufTtcblxuXG5mdW5jdGlvbiBNaXNzaW5nUmVmRXJyb3IoYmFzZUlkLCByZWYsIG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBNaXNzaW5nUmVmRXJyb3IubWVzc2FnZShiYXNlSWQsIHJlZik7XG4gIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmUudXJsKGJhc2VJZCwgcmVmKTtcbiAgdGhpcy5taXNzaW5nU2NoZW1hID0gcmVzb2x2ZS5ub3JtYWxpemVJZChyZXNvbHZlLmZ1bGxQYXRoKHRoaXMubWlzc2luZ1JlZikpO1xufVxuXG5cbmZ1bmN0aW9uIGVycm9yU3ViY2xhc3MoU3ViY2xhc3MpIHtcbiAgU3ViY2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBTdWJjbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJjbGFzcztcbiAgcmV0dXJuIFN1YmNsYXNzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG5cbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcbiAgICAgICAgICAgICAgICB2YXIgYm9iaiA9IHsga2V5OiBiLCB2YWx1ZTogbm9kZVtiXSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KShvcHRzLmNtcCk7XG5cbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PSAnbnVtYmVyJykgcmV0dXJuIGlzRmluaXRlKG5vZGUpID8gJycgKyBub2RlIDogJ251bGwnO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9kZSk7XG5cbiAgICAgICAgdmFyIGksIG91dDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIG91dCA9ICdbJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIG91dCArPSAnLCc7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHN0cmluZ2lmeShub2RlW2ldKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0ICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG5cbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBKU09OLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5wdXNoKG5vZGUpIC0gMTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICBvdXQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGVba2V5XSk7XG5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG91dCkgb3V0ICs9ICcsJztcbiAgICAgICAgICAgIG91dCArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zcGxpY2Uoc2VlbkluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuICd7JyArIG91dCArICd9JztcbiAgICB9KShkYXRhKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3ZhbGlkYXRlKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnJztcbiAgdmFyICRhc3luYyA9IGl0LnNjaGVtYS4kYXN5bmMgPT09IHRydWUsXG4gICAgJHJlZktleXdvcmRzID0gaXQudXRpbC5zY2hlbWFIYXNSdWxlc0V4Y2VwdChpdC5zY2hlbWEsIGl0LlJVTEVTLmFsbCwgJyRyZWYnKSxcbiAgICAkaWQgPSBpdC5zZWxmLl9nZXRJZChpdC5zY2hlbWEpO1xuICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3Jkcykge1xuICAgIHZhciAkdW5rbm93bkt3ZCA9IGl0LnV0aWwuc2NoZW1hVW5rbm93blJ1bGVzKGl0LnNjaGVtYSwgaXQuUlVMRVMua2V5d29yZHMpO1xuICAgIGlmICgkdW5rbm93bkt3ZCkge1xuICAgICAgdmFyICRrZXl3b3Jkc01zZyA9ICd1bmtub3duIGtleXdvcmQ6ICcgKyAkdW5rbm93bkt3ZDtcbiAgICAgIGlmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzID09PSAnbG9nJykgaXQubG9nZ2VyLndhcm4oJGtleXdvcmRzTXNnKTtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3Jkc01zZyk7XG4gICAgfVxuICB9XG4gIGlmIChpdC5pc1RvcCkge1xuICAgIG91dCArPSAnIHZhciB2YWxpZGF0ZSA9ICc7XG4gICAgaWYgKCRhc3luYykge1xuICAgICAgaXQuYXN5bmMgPSB0cnVlO1xuICAgICAgb3V0ICs9ICdhc3luYyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJ2Z1bmN0aW9uKGRhdGEsIGRhdGFQYXRoLCBwYXJlbnREYXRhLCBwYXJlbnREYXRhUHJvcGVydHksIHJvb3REYXRhKSB7IFxcJ3VzZSBzdHJpY3RcXCc7ICc7XG4gICAgaWYgKCRpZCAmJiAoaXQub3B0cy5zb3VyY2VDb2RlIHx8IGl0Lm9wdHMucHJvY2Vzc0NvZGUpKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCcvXFwqIyBzb3VyY2VVUkw9JyArICRpZCArICcgKi8nKSArICcgJztcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBpdC5zY2hlbWEgPT0gJ2Jvb2xlYW4nIHx8ICEoJHJlZktleXdvcmRzIHx8IGl0LnNjaGVtYS4kcmVmKSkge1xuICAgIHZhciAka2V5d29yZCA9ICdmYWxzZSBzY2hlbWEnO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkO1xuICAgIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gICAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICAgIGlmIChpdC5zY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgICAgJGJyZWFrT25FcnJvciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICAgICAgfVxuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdmYWxzZSBzY2hlbWEnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2Jvb2xlYW4gc2NoZW1hIGlzIGZhbHNlXFwnICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgfVxuICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpdC5pc1RvcCkge1xuICAgICAgICBpZiAoJGFzeW5jKSB7XG4gICAgICAgICAgb3V0ICs9ICcgcmV0dXJuIGRhdGE7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgcmV0dXJuIHRydWU7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0LmlzVG9wKSB7XG4gICAgICBvdXQgKz0gJyB9OyByZXR1cm4gdmFsaWRhdGU7ICc7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKGl0LmlzVG9wKSB7XG4gICAgdmFyICR0b3AgPSBpdC5pc1RvcCxcbiAgICAgICRsdmwgPSBpdC5sZXZlbCA9IDAsXG4gICAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCA9IDAsXG4gICAgICAkZGF0YSA9ICdkYXRhJztcbiAgICBpdC5yb290SWQgPSBpdC5yZXNvbHZlLmZ1bGxQYXRoKGl0LnNlbGYuX2dldElkKGl0LnJvb3Quc2NoZW1hKSk7XG4gICAgaXQuYmFzZUlkID0gaXQuYmFzZUlkIHx8IGl0LnJvb3RJZDtcbiAgICBkZWxldGUgaXQuaXNUb3A7XG4gICAgaXQuZGF0YVBhdGhBcnIgPSBbXCJcIl07XG4gICAgaWYgKGl0LnNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgaXQub3B0cy51c2VEZWZhdWx0cyAmJiBpdC5vcHRzLnN0cmljdERlZmF1bHRzKSB7XG4gICAgICB2YXIgJGRlZmF1bHRNc2cgPSAnZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdCc7XG4gICAgICBpZiAoaXQub3B0cy5zdHJpY3REZWZhdWx0cyA9PT0gJ2xvZycpIGl0LmxvZ2dlci53YXJuKCRkZWZhdWx0TXNnKTtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCRkZWZhdWx0TXNnKTtcbiAgICB9XG4gICAgb3V0ICs9ICcgdmFyIHZFcnJvcnMgPSBudWxsOyAnO1xuICAgIG91dCArPSAnIHZhciBlcnJvcnMgPSAwOyAgICAgJztcbiAgICBvdXQgKz0gJyBpZiAocm9vdERhdGEgPT09IHVuZGVmaW5lZCkgcm9vdERhdGEgPSBkYXRhOyAnO1xuICB9IGVsc2Uge1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAgICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgICBpZiAoJGlkKSBpdC5iYXNlSWQgPSBpdC5yZXNvbHZlLnVybChpdC5iYXNlSWQsICRpZCk7XG4gICAgaWYgKCRhc3luYyAmJiAhaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hJyk7XG4gICAgb3V0ICs9ICcgdmFyIGVycnNfJyArICgkbHZsKSArICcgPSBlcnJvcnM7JztcbiAgfVxuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycyxcbiAgICAkY2xvc2luZ0JyYWNlczEgPSAnJyxcbiAgICAkY2xvc2luZ0JyYWNlczIgPSAnJztcbiAgdmFyICRlcnJvcktleXdvcmQ7XG4gIHZhciAkdHlwZVNjaGVtYSA9IGl0LnNjaGVtYS50eXBlLFxuICAgICR0eXBlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoJHR5cGVTY2hlbWEpO1xuICBpZiAoJHR5cGVTY2hlbWEgJiYgaXQub3B0cy5udWxsYWJsZSAmJiBpdC5zY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHtcbiAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICBpZiAoJHR5cGVTY2hlbWEuaW5kZXhPZignbnVsbCcpID09IC0xKSAkdHlwZVNjaGVtYSA9ICR0eXBlU2NoZW1hLmNvbmNhdCgnbnVsbCcpO1xuICAgIH0gZWxzZSBpZiAoJHR5cGVTY2hlbWEgIT0gJ251bGwnKSB7XG4gICAgICAkdHlwZVNjaGVtYSA9IFskdHlwZVNjaGVtYSwgJ251bGwnXTtcbiAgICAgICR0eXBlSXNBcnJheSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICgkdHlwZUlzQXJyYXkgJiYgJHR5cGVTY2hlbWEubGVuZ3RoID09IDEpIHtcbiAgICAkdHlwZVNjaGVtYSA9ICR0eXBlU2NoZW1hWzBdO1xuICAgICR0eXBlSXNBcnJheSA9IGZhbHNlO1xuICB9XG4gIGlmIChpdC5zY2hlbWEuJHJlZiAmJiAkcmVmS2V5d29yZHMpIHtcbiAgICBpZiAoaXQub3B0cy5leHRlbmRSZWZzID09ICdmYWlsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCckcmVmOiB2YWxpZGF0aW9uIGtleXdvcmRzIHVzZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIiAoc2VlIG9wdGlvbiBleHRlbmRSZWZzKScpO1xuICAgIH0gZWxzZSBpZiAoaXQub3B0cy5leHRlbmRSZWZzICE9PSB0cnVlKSB7XG4gICAgICAkcmVmS2V5d29yZHMgPSBmYWxzZTtcbiAgICAgIGl0LmxvZ2dlci53YXJuKCckcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJyArIGl0LmVyclNjaGVtYVBhdGggKyAnXCInKTtcbiAgICB9XG4gIH1cbiAgaWYgKGl0LnNjaGVtYS4kY29tbWVudCAmJiBpdC5vcHRzLiRjb21tZW50KSB7XG4gICAgb3V0ICs9ICcgJyArIChpdC5SVUxFUy5hbGwuJGNvbW1lbnQuY29kZShpdCwgJyRjb21tZW50JykpO1xuICB9XG4gIGlmICgkdHlwZVNjaGVtYSkge1xuICAgIGlmIChpdC5vcHRzLmNvZXJjZVR5cGVzKSB7XG4gICAgICB2YXIgJGNvZXJjZVRvVHlwZXMgPSBpdC51dGlsLmNvZXJjZVRvVHlwZXMoaXQub3B0cy5jb2VyY2VUeXBlcywgJHR5cGVTY2hlbWEpO1xuICAgIH1cbiAgICB2YXIgJHJ1bGVzR3JvdXAgPSBpdC5SVUxFUy50eXBlc1skdHlwZVNjaGVtYV07XG4gICAgaWYgKCRjb2VyY2VUb1R5cGVzIHx8ICR0eXBlSXNBcnJheSB8fCAkcnVsZXNHcm91cCA9PT0gdHJ1ZSB8fCAoJHJ1bGVzR3JvdXAgJiYgISRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkpKSB7XG4gICAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy50eXBlJyxcbiAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy90eXBlJztcbiAgICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnR5cGUnLFxuICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL3R5cGUnLFxuICAgICAgICAkbWV0aG9kID0gJHR5cGVJc0FycmF5ID8gJ2NoZWNrRGF0YVR5cGVzJyA6ICdjaGVja0RhdGFUeXBlJztcbiAgICAgIG91dCArPSAnIGlmICgnICsgKGl0LnV0aWxbJG1ldGhvZF0oJHR5cGVTY2hlbWEsICRkYXRhLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIHRydWUpKSArICcpIHsgJztcbiAgICAgIGlmICgkY29lcmNlVG9UeXBlcykge1xuICAgICAgICB2YXIgJGRhdGFUeXBlID0gJ2RhdGFUeXBlJyArICRsdmwsXG4gICAgICAgICAgJGNvZXJjZWQgPSAnY29lcmNlZCcgKyAkbHZsO1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkZGF0YVR5cGUpICsgJyA9IHR5cGVvZiAnICsgKCRkYXRhKSArICc7IHZhciAnICsgKCRjb2VyY2VkKSArICcgPSB1bmRlZmluZWQ7ICc7XG4gICAgICAgIGlmIChpdC5vcHRzLmNvZXJjZVR5cGVzID09ICdhcnJheScpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdvYmplY3RcXCcgJiYgQXJyYXkuaXNBcnJheSgnICsgKCRkYXRhKSArICcpICYmICcgKyAoJGRhdGEpICsgJy5sZW5ndGggPT0gMSkgeyAnICsgKCRkYXRhKSArICcgPSAnICsgKCRkYXRhKSArICdbMF07ICcgKyAoJGRhdGFUeXBlKSArICcgPSB0eXBlb2YgJyArICgkZGF0YSkgKyAnOyBpZiAoJyArIChpdC51dGlsLmNoZWNrRGF0YVR5cGUoaXQuc2NoZW1hLnR5cGUsICRkYXRhLCBpdC5vcHRzLnN0cmljdE51bWJlcnMpKSArICcpICcgKyAoJGNvZXJjZWQpICsgJyA9ICcgKyAoJGRhdGEpICsgJzsgfSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCRjb2VyY2VkKSArICcgIT09IHVuZGVmaW5lZCkgOyAnO1xuICAgICAgICB2YXIgYXJyMSA9ICRjb2VyY2VUb1R5cGVzO1xuICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgIHZhciAkdHlwZSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICAgICAkdHlwZSA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgICAgICBpZiAoJHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdudW1iZXJcXCcgfHwgJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdib29sZWFuXFwnKSAnICsgKCRjb2VyY2VkKSArICcgPSBcXCdcXCcgKyAnICsgKCRkYXRhKSArICc7IGVsc2UgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gbnVsbCkgJyArICgkY29lcmNlZCkgKyAnID0gXFwnXFwnOyAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSAnbnVtYmVyJyB8fCAkdHlwZSA9PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdib29sZWFuXFwnIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gbnVsbCB8fCAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdzdHJpbmdcXCcgJiYgJyArICgkZGF0YSkgKyAnICYmICcgKyAoJGRhdGEpICsgJyA9PSArJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICAgIGlmICgkdHlwZSA9PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAmJiAhKCcgKyAoJGRhdGEpICsgJyAlIDEpJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJykpICcgKyAoJGNvZXJjZWQpICsgJyA9ICsnICsgKCRkYXRhKSArICc7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBlbHNlIGlmICgnICsgKCRkYXRhKSArICcgPT09IFxcJ2ZhbHNlXFwnIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gMCB8fCAnICsgKCRkYXRhKSArICcgPT09IG51bGwpICcgKyAoJGNvZXJjZWQpICsgJyA9IGZhbHNlOyBlbHNlIGlmICgnICsgKCRkYXRhKSArICcgPT09IFxcJ3RydWVcXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSAxKSAnICsgKCRjb2VyY2VkKSArICcgPSB0cnVlOyAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSBpZiAoJyArICgkZGF0YSkgKyAnID09PSBcXCdcXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSAwIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gZmFsc2UpICcgKyAoJGNvZXJjZWQpICsgJyA9IG51bGw7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMgPT0gJ2FycmF5JyAmJiAkdHlwZSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGVsc2UgaWYgKCcgKyAoJGRhdGFUeXBlKSArICcgPT0gXFwnc3RyaW5nXFwnIHx8ICcgKyAoJGRhdGFUeXBlKSArICcgPT0gXFwnbnVtYmVyXFwnIHx8ICcgKyAoJGRhdGFUeXBlKSArICcgPT0gXFwnYm9vbGVhblxcJyB8fCAnICsgKCRkYXRhKSArICcgPT0gbnVsbCkgJyArICgkY29lcmNlZCkgKyAnID0gWycgKyAoJGRhdGEpICsgJ107ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAgICc7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICd0eXBlJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9IGlmICgnICsgKCRjb2VyY2VkKSArICcgIT09IHVuZGVmaW5lZCkgeyAgJztcbiAgICAgICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyAnZGF0YScgKyAoKCRkYXRhTHZsIC0gMSkgfHwgJycpIDogJ3BhcmVudERhdGEnLFxuICAgICAgICAgICRwYXJlbnREYXRhUHJvcGVydHkgPSAkZGF0YUx2bCA/IGl0LmRhdGFQYXRoQXJyWyRkYXRhTHZsXSA6ICdwYXJlbnREYXRhUHJvcGVydHknO1xuICAgICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcgPSAnICsgKCRjb2VyY2VkKSArICc7ICc7XG4gICAgICAgIGlmICghJGRhdGFMdmwpIHtcbiAgICAgICAgICBvdXQgKz0gJ2lmICgnICsgKCRwYXJlbnREYXRhKSArICcgIT09IHVuZGVmaW5lZCknO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICcgKyAoJHBhcmVudERhdGEpICsgJ1snICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJ10gPSAnICsgKCRjb2VyY2VkKSArICc7IH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICd0eXBlJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgfVxuICBpZiAoaXQuc2NoZW1hLiRyZWYgJiYgISRyZWZLZXl3b3Jkcykge1xuICAgIG91dCArPSAnICcgKyAoaXQuUlVMRVMuYWxsLiRyZWYuY29kZShpdCwgJyRyZWYnKSkgKyAnICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIH0gaWYgKGVycm9ycyA9PT0gJztcbiAgICAgIGlmICgkdG9wKSB7XG4gICAgICAgIG91dCArPSAnMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJ2VycnNfJyArICgkbHZsKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAkY2xvc2luZ0JyYWNlczIgKz0gJ30nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYXJyMiA9IGl0LlJVTEVTO1xuICAgIGlmIChhcnIyKSB7XG4gICAgICB2YXIgJHJ1bGVzR3JvdXAsIGkyID0gLTEsXG4gICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkyIDwgbDIpIHtcbiAgICAgICAgJHJ1bGVzR3JvdXAgPSBhcnIyW2kyICs9IDFdO1xuICAgICAgICBpZiAoJHNob3VsZFVzZUdyb3VwKCRydWxlc0dyb3VwKSkge1xuICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsLmNoZWNrRGF0YVR5cGUoJHJ1bGVzR3JvdXAudHlwZSwgJGRhdGEsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycykpICsgJykgeyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy51c2VEZWZhdWx0cykge1xuICAgICAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUgPT0gJ29iamVjdCcgJiYgaXQuc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAkc2NoZW1hS2V5cyA9IE9iamVjdC5rZXlzKCRzY2hlbWEpO1xuICAgICAgICAgICAgICB2YXIgYXJyMyA9ICRzY2hlbWFLZXlzO1xuICAgICAgICAgICAgICBpZiAoYXJyMykge1xuICAgICAgICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksIGkzID0gLTEsXG4gICAgICAgICAgICAgICAgICBsMyA9IGFycjMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaTMgPCBsMykge1xuICAgICAgICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyM1tpMyArPSAxXTtcbiAgICAgICAgICAgICAgICAgIHZhciAkc2NoID0gJHNjaGVtYVskcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgICAgICAgaWYgKCRzY2guZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3REZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRkZWZhdWx0TXNnID0gJ2RlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICcgKyAkcGFzc0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3REZWZhdWx0cyA9PT0gJ2xvZycpIGl0LmxvZ2dlci53YXJuKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHBhc3NEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoJHBhc3NEYXRhKSArICcgPT09IG51bGwgfHwgJyArICgkcGFzc0RhdGEpICsgJyA9PT0gXFwnXFwnICc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICkgJyArICgkcGFzc0RhdGEpICsgJyA9ICc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXNlRGVmYXVsdCgkc2NoLmRlZmF1bHQpKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChKU09OLnN0cmluZ2lmeSgkc2NoLmRlZmF1bHQpKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICc7ICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHJ1bGVzR3JvdXAudHlwZSA9PSAnYXJyYXknICYmIEFycmF5LmlzQXJyYXkoaXQuc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgICB2YXIgYXJyNCA9IGl0LnNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgICAgaWYgKGFycjQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgICAgICAgICAgICAgIGw0ID0gYXJyNC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlICgkaSA8IGw0KSB7XG4gICAgICAgICAgICAgICAgICAkc2NoID0gYXJyNFskaSArPSAxXTtcbiAgICAgICAgICAgICAgICAgIGlmICgkc2NoLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3REZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRkZWZhdWx0TXNnID0gJ2RlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICcgKyAkcGFzc0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3REZWZhdWx0cyA9PT0gJ2xvZycpIGl0LmxvZ2dlci53YXJuKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHBhc3NEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoJHBhc3NEYXRhKSArICcgPT09IG51bGwgfHwgJyArICgkcGFzc0RhdGEpICsgJyA9PT0gXFwnXFwnICc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICkgJyArICgkcGFzc0RhdGEpICsgJyA9ICc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXNlRGVmYXVsdCgkc2NoLmRlZmF1bHQpKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChKU09OLnN0cmluZ2lmeSgkc2NoLmRlZmF1bHQpKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICc7ICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFycjUgPSAkcnVsZXNHcm91cC5ydWxlcztcbiAgICAgICAgICBpZiAoYXJyNSkge1xuICAgICAgICAgICAgdmFyICRydWxlLCBpNSA9IC0xLFxuICAgICAgICAgICAgICBsNSA9IGFycjUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpNSA8IGw1KSB7XG4gICAgICAgICAgICAgICRydWxlID0gYXJyNVtpNSArPSAxXTtcbiAgICAgICAgICAgICAgaWYgKCRzaG91bGRVc2VSdWxlKCRydWxlKSkge1xuICAgICAgICAgICAgICAgIHZhciAkY29kZSA9ICRydWxlLmNvZGUoaXQsICRydWxlLmtleXdvcmQsICRydWxlc0dyb3VwLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICgkY29kZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkY2xvc2luZ0JyYWNlczEgKz0gJ30nO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlczEpICsgJyAnO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMxID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICBpZiAoJHR5cGVTY2hlbWEgJiYgJHR5cGVTY2hlbWEgPT09ICRydWxlc0dyb3VwLnR5cGUgJiYgISRjb2VyY2VUb1R5cGVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgICAgICAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy50eXBlJyxcbiAgICAgICAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL3R5cGUnO1xuICAgICAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAndHlwZScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgdHlwZTogXFwnJztcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyB9ICc7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnO1xuICAgICAgICAgICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKGVycm9ycyA9PT0gJztcbiAgICAgICAgICAgIGlmICgkdG9wKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2VycnNfJyArICgkbHZsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAgICAgICAkY2xvc2luZ0JyYWNlczIgKz0gJ30nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMyKSArICcgJztcbiAgfVxuICBpZiAoJHRvcCkge1xuICAgIGlmICgkYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIGlmIChlcnJvcnMgPT09IDApIHJldHVybiBkYXRhOyAgICAgICAgICAgJztcbiAgICAgIG91dCArPSAnIGVsc2UgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgJztcbiAgICAgIG91dCArPSAnIHJldHVybiBlcnJvcnMgPT09IDA7ICAgICAgICc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IHJldHVybiB2YWxpZGF0ZTsnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gZXJyb3JzID09PSBlcnJzXycgKyAoJGx2bCkgKyAnOyc7XG4gIH1cblxuICBmdW5jdGlvbiAkc2hvdWxkVXNlR3JvdXAoJHJ1bGVzR3JvdXApIHtcbiAgICB2YXIgcnVsZXMgPSAkcnVsZXNHcm91cC5ydWxlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKCRzaG91bGRVc2VSdWxlKHJ1bGVzW2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiAkc2hvdWxkVXNlUnVsZSgkcnVsZSkge1xuICAgIHJldHVybiBpdC5zY2hlbWFbJHJ1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fCAoJHJ1bGUuaW1wbGVtZW50cyAmJiAkcnVsZUltcGxlbWVudHNTb21lS2V5d29yZCgkcnVsZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gJHJ1bGVJbXBsZW1lbnRzU29tZUtleXdvcmQoJHJ1bGUpIHtcbiAgICB2YXIgaW1wbCA9ICRydWxlLmltcGxlbWVudHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbXBsLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKGl0LnNjaGVtYVtpbXBsW2ldXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDYWNoZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ2FjaGUoKSB7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBDYWNoZV9wdXQoa2V5LCB2YWx1ZSkge1xuICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBDYWNoZV9nZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gQ2FjaGVfZGVsKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2FjaGVba2V5XTtcbn07XG5cblxuQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gQ2FjaGVfY2xlYXIoKSB7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbnZhciBEQVlTID0gWzAsMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO1xudmFyIFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLlxcZCspPyh6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG52YXIgSE9TVE5BTUUgPSAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pO1xudmFyIFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG52YXIgVVJJUkVGID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbi8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbnZhciBVUklURU1QTEFURSA9IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pO1xuLy8gRm9yIHRoZSBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4vLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4vLyBAdG9kbyBEZWxldGUgY3VycmVudCBVUkwgaW4gZmF2b3VyIG9mIHRoZSBjb21tZW50ZWQgb3V0IFVSTCBydWxlIHdoZW4gdGhpcyBpc3N1ZSBpcyBmaXhlZCBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNzk4My5cbi8vIHZhciBVUkwgPSAvXig/Oig/Omh0dHBzP3xmdHApOlxcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ITEwKD86XFwuXFxkezEsM30pezN9KSg/ITEyNyg/OlxcLlxcZHsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTkyXFwuMTY4KD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstKSpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rKSg/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstKSpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rKSooPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfV17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2l1O1xudmFyIFVSTCA9IC9eKD86KD86aHR0cFtzXFx1MDE3Rl0/fGZ0cCk6XFwvXFwvKSg/Oig/OltcXDAtXFx4MDhcXHgwRS1cXHgxRiEtXFx4OUZcXHhBMS1cXHUxNjdGXFx1MTY4MS1cXHUxRkZGXFx1MjAwQi1cXHUyMDI3XFx1MjAyQS1cXHUyMDJFXFx1MjAzMC1cXHUyMDVFXFx1MjA2MC1cXHUyRkZGXFx1MzAwMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRUZFXFx1RkYwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSsoPzo6KD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKik/QCk/KD86KD8hMTAoPzpcXC5bMC05XXsxLDN9KXszfSkoPyExMjcoPzpcXC5bMC05XXsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5bMC05XXsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5bMC05XXsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlswLTldfDNbMDFdKSg/OlxcLlswLTldezEsM30pezJ9KSg/OlsxLTldWzAtOV0/fDFbMC05XVswLTldfDJbMDFdWzAtOV18MjJbMC0zXSkoPzpcXC4oPzoxP1swLTldezEsMn18MlswLTRdWzAtOV18MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1bMC05XT98MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC00XSkpfCg/Oig/Oig/OlswLTlhLXpcXHhBMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkrLSkqKD86WzAtOWEtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSspKD86XFwuKD86KD86WzAtOWEtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSstKSooPzpbMC05YS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKykqKD86XFwuKD86KD86W2EtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKXsyLH0pKSkoPzo6WzAtOV17Miw1fSk/KD86XFwvKD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKik/JC9pO1xudmFyIFVVSUQgPSAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaTtcbnZhciBKU09OX1BPSU5URVIgPSAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvO1xudmFyIEpTT05fUE9JTlRFUl9VUklfRlJBR01FTlQgPSAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pO1xudmFyIFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdHM7XG5cbmZ1bmN0aW9uIGZvcm1hdHMobW9kZSkge1xuICBtb2RlID0gbW9kZSA9PSAnZnVsbCcgPyAnZnVsbCcgOiAnZmFzdCc7XG4gIHJldHVybiB1dGlsLmNvcHkoZm9ybWF0c1ttb2RlXSk7XG59XG5cblxuZm9ybWF0cy5mYXN0ID0ge1xuICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIGRhdGU6IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sXG4gIC8vIGRhdGUtdGltZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB0aW1lOiAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSxcbiAgJ2RhdGUtdGltZSc6IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksXG4gIC8vIHVyaTogaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9pcy1teS1qc29uLXZhbGlkL2Jsb2IvbWFzdGVyL2Zvcm1hdHMuanNcbiAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICd1cmktcmVmZXJlbmNlJzogL14oPzooPzpbYS16XVthLXowLTkrXFwtLl0qOik/XFwvP1xcLyk/KD86W15cXFxcXFxzI11bXlxccyNdKik/KD86I1teXFxcXFxcc10qKT8kL2ksXG4gICd1cmktdGVtcGxhdGUnOiBVUklURU1QTEFURSxcbiAgdXJsOiBVUkwsXG4gIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MgKHNlYXJjaCBmb3IgJ3dpbGxmdWwgdmlvbGF0aW9uJylcbiAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG4gIGhvc3RuYW1lOiBIT1NUTkFNRSxcbiAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICAvLyBvcHRpbWl6ZWQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzQ5Ny9yZWd1bGFyLWV4cHJlc3Npb24tdGhhdC1tYXRjaGVzLXZhbGlkLWlwdjYtYWRkcmVzc2VzXG4gIGlwdjY6IC9eXFxzKig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs3fSg/OlswLTlhLWZdezEsNH18OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs2fSg/OjpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwyfSl8Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NH0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwzfSl8KD86KD86OlswLTlhLWZdezEsNH0pPzooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXszfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDR9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwyfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsyfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDV9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwzfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsxfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw0fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/OjooPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw3fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNX06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoPzolLispP1xccyokL2ksXG4gIHJlZ2V4OiByZWdleCxcbiAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICB1dWlkOiBVVUlELFxuICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICAnanNvbi1wb2ludGVyJzogSlNPTl9QT0lOVEVSLFxuICAnanNvbi1wb2ludGVyLXVyaS1mcmFnbWVudCc6IEpTT05fUE9JTlRFUl9VUklfRlJBR01FTlQsXG4gIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgJ3JlbGF0aXZlLWpzb24tcG9pbnRlcic6IFJFTEFUSVZFX0pTT05fUE9JTlRFUlxufTtcblxuXG5mb3JtYXRzLmZ1bGwgPSB7XG4gIGRhdGU6IGRhdGUsXG4gIHRpbWU6IHRpbWUsXG4gICdkYXRlLXRpbWUnOiBkYXRlX3RpbWUsXG4gIHVyaTogdXJpLFxuICAndXJpLXJlZmVyZW5jZSc6IFVSSVJFRixcbiAgJ3VyaS10ZW1wbGF0ZSc6IFVSSVRFTVBMQVRFLFxuICB1cmw6IFVSTCxcbiAgZW1haWw6IC9eW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/JC9pLFxuICBob3N0bmFtZTogSE9TVE5BTUUsXG4gIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gIGlwdjY6IC9eXFxzKig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs3fSg/OlswLTlhLWZdezEsNH18OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs2fSg/OjpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwyfSl8Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NH0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwzfSl8KD86KD86OlswLTlhLWZdezEsNH0pPzooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXszfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDR9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwyfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsyfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDV9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwzfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsxfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw0fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/OjooPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw3fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNX06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoPzolLispP1xccyokL2ksXG4gIHJlZ2V4OiByZWdleCxcbiAgdXVpZDogVVVJRCxcbiAgJ2pzb24tcG9pbnRlcic6IEpTT05fUE9JTlRFUixcbiAgJ2pzb24tcG9pbnRlci11cmktZnJhZ21lbnQnOiBKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5ULFxuICAncmVsYXRpdmUtanNvbi1wb2ludGVyJzogUkVMQVRJVkVfSlNPTl9QT0lOVEVSXG59O1xuXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuXG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIHZhciBtYXRjaGVzID0gc3RyLm1hdGNoKERBVEUpO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZTtcblxuICB2YXIgeWVhciA9ICttYXRjaGVzWzFdO1xuICB2YXIgbW9udGggPSArbWF0Y2hlc1syXTtcbiAgdmFyIGRheSA9ICttYXRjaGVzWzNdO1xuXG4gIHJldHVybiBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyICYmIGRheSA+PSAxICYmXG4gICAgICAgICAgZGF5IDw9IChtb250aCA9PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKTtcbn1cblxuXG5mdW5jdGlvbiB0aW1lKHN0ciwgZnVsbCkge1xuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChUSU1FKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGhvdXIgPSBtYXRjaGVzWzFdO1xuICB2YXIgbWludXRlID0gbWF0Y2hlc1syXTtcbiAgdmFyIHNlY29uZCA9IG1hdGNoZXNbM107XG4gIHZhciB0aW1lWm9uZSA9IG1hdGNoZXNbNV07XG4gIHJldHVybiAoKGhvdXIgPD0gMjMgJiYgbWludXRlIDw9IDU5ICYmIHNlY29uZCA8PSA1OSkgfHxcbiAgICAgICAgICAoaG91ciA9PSAyMyAmJiBtaW51dGUgPT0gNTkgJiYgc2Vjb25kID09IDYwKSkgJiZcbiAgICAgICAgICghZnVsbCB8fCB0aW1lWm9uZSk7XG59XG5cblxudmFyIERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgZGF0ZVRpbWUgPSBzdHIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdLCB0cnVlKTtcbn1cblxuXG52YXIgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuXG5cbnZhciBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHN0cik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcnVsZU1vZHVsZXMgPSByZXF1aXJlKCcuLi9kb3RqcycpXG4gICwgdG9IYXNoID0gcmVxdWlyZSgnLi91dGlsJykudG9IYXNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJ1bGVzKCkge1xuICB2YXIgUlVMRVMgPSBbXG4gICAgeyB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHJ1bGVzOiBbIHsgJ21heGltdW0nOiBbJ2V4Y2x1c2l2ZU1heGltdW0nXSB9LFxuICAgICAgICAgICAgICAgeyAnbWluaW11bSc6IFsnZXhjbHVzaXZlTWluaW11bSddIH0sICdtdWx0aXBsZU9mJywgJ2Zvcm1hdCddIH0sXG4gICAgeyB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJ1bGVzOiBbICdtYXhMZW5ndGgnLCAnbWluTGVuZ3RoJywgJ3BhdHRlcm4nLCAnZm9ybWF0JyBdIH0sXG4gICAgeyB0eXBlOiAnYXJyYXknLFxuICAgICAgcnVsZXM6IFsgJ21heEl0ZW1zJywgJ21pbkl0ZW1zJywgJ2l0ZW1zJywgJ2NvbnRhaW5zJywgJ3VuaXF1ZUl0ZW1zJyBdIH0sXG4gICAgeyB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHJ1bGVzOiBbICdtYXhQcm9wZXJ0aWVzJywgJ21pblByb3BlcnRpZXMnLCAncmVxdWlyZWQnLCAnZGVwZW5kZW5jaWVzJywgJ3Byb3BlcnR5TmFtZXMnLFxuICAgICAgICAgICAgICAgeyAncHJvcGVydGllcyc6IFsnYWRkaXRpb25hbFByb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnXSB9IF0gfSxcbiAgICB7IHJ1bGVzOiBbICckcmVmJywgJ2NvbnN0JywgJ2VudW0nLCAnbm90JywgJ2FueU9mJywgJ29uZU9mJywgJ2FsbE9mJywgJ2lmJyBdIH1cbiAgXTtcblxuICB2YXIgQUxMID0gWyAndHlwZScsICckY29tbWVudCcgXTtcbiAgdmFyIEtFWVdPUkRTID0gW1xuICAgICckc2NoZW1hJywgJyRpZCcsICdpZCcsICckZGF0YScsICckYXN5bmMnLCAndGl0bGUnLFxuICAgICdkZXNjcmlwdGlvbicsICdkZWZhdWx0JywgJ2RlZmluaXRpb25zJyxcbiAgICAnZXhhbXBsZXMnLCAncmVhZE9ubHknLCAnd3JpdGVPbmx5JyxcbiAgICAnY29udGVudE1lZGlhVHlwZScsICdjb250ZW50RW5jb2RpbmcnLFxuICAgICdhZGRpdGlvbmFsSXRlbXMnLCAndGhlbicsICdlbHNlJ1xuICBdO1xuICB2YXIgVFlQRVMgPSBbICdudW1iZXInLCAnaW50ZWdlcicsICdzdHJpbmcnLCAnYXJyYXknLCAnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVsbCcgXTtcbiAgUlVMRVMuYWxsID0gdG9IYXNoKEFMTCk7XG4gIFJVTEVTLnR5cGVzID0gdG9IYXNoKFRZUEVTKTtcblxuICBSVUxFUy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLnJ1bGVzID0gZ3JvdXAucnVsZXMubWFwKGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICB2YXIgaW1wbEtleXdvcmRzO1xuICAgICAgaWYgKHR5cGVvZiBrZXl3b3JkID09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhrZXl3b3JkKVswXTtcbiAgICAgICAgaW1wbEtleXdvcmRzID0ga2V5d29yZFtrZXldO1xuICAgICAgICBrZXl3b3JkID0ga2V5O1xuICAgICAgICBpbXBsS2V5d29yZHMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIEFMTC5wdXNoKGspO1xuICAgICAgICAgIFJVTEVTLmFsbFtrXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgQUxMLnB1c2goa2V5d29yZCk7XG4gICAgICB2YXIgcnVsZSA9IFJVTEVTLmFsbFtrZXl3b3JkXSA9IHtcbiAgICAgICAga2V5d29yZDoga2V5d29yZCxcbiAgICAgICAgY29kZTogcnVsZU1vZHVsZXNba2V5d29yZF0sXG4gICAgICAgIGltcGxlbWVudHM6IGltcGxLZXl3b3Jkc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0pO1xuXG4gICAgUlVMRVMuYWxsLiRjb21tZW50ID0ge1xuICAgICAga2V5d29yZDogJyRjb21tZW50JyxcbiAgICAgIGNvZGU6IHJ1bGVNb2R1bGVzLiRjb21tZW50XG4gICAgfTtcblxuICAgIGlmIChncm91cC50eXBlKSBSVUxFUy50eXBlc1tncm91cC50eXBlXSA9IGdyb3VwO1xuICB9KTtcblxuICBSVUxFUy5rZXl3b3JkcyA9IHRvSGFzaChBTEwuY29uY2F0KEtFWVdPUkRTKSk7XG4gIFJVTEVTLmN1c3RvbSA9IHt9O1xuXG4gIHJldHVybiBSVUxFUztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vYWxsIHJlcXVpcmVzIG11c3QgYmUgZXhwbGljaXQgYmVjYXVzZSBicm93c2VyaWZ5IHdvbid0IHdvcmsgd2l0aCBkeW5hbWljIHJlcXVpcmVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJyRyZWYnOiByZXF1aXJlKCcuL3JlZicpLFxuICBhbGxPZjogcmVxdWlyZSgnLi9hbGxPZicpLFxuICBhbnlPZjogcmVxdWlyZSgnLi9hbnlPZicpLFxuICAnJGNvbW1lbnQnOiByZXF1aXJlKCcuL2NvbW1lbnQnKSxcbiAgY29uc3Q6IHJlcXVpcmUoJy4vY29uc3QnKSxcbiAgY29udGFpbnM6IHJlcXVpcmUoJy4vY29udGFpbnMnKSxcbiAgZGVwZW5kZW5jaWVzOiByZXF1aXJlKCcuL2RlcGVuZGVuY2llcycpLFxuICAnZW51bSc6IHJlcXVpcmUoJy4vZW51bScpLFxuICBmb3JtYXQ6IHJlcXVpcmUoJy4vZm9ybWF0JyksXG4gICdpZic6IHJlcXVpcmUoJy4vaWYnKSxcbiAgaXRlbXM6IHJlcXVpcmUoJy4vaXRlbXMnKSxcbiAgbWF4aW11bTogcmVxdWlyZSgnLi9fbGltaXQnKSxcbiAgbWluaW11bTogcmVxdWlyZSgnLi9fbGltaXQnKSxcbiAgbWF4SXRlbXM6IHJlcXVpcmUoJy4vX2xpbWl0SXRlbXMnKSxcbiAgbWluSXRlbXM6IHJlcXVpcmUoJy4vX2xpbWl0SXRlbXMnKSxcbiAgbWF4TGVuZ3RoOiByZXF1aXJlKCcuL19saW1pdExlbmd0aCcpLFxuICBtaW5MZW5ndGg6IHJlcXVpcmUoJy4vX2xpbWl0TGVuZ3RoJyksXG4gIG1heFByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX2xpbWl0UHJvcGVydGllcycpLFxuICBtaW5Qcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19saW1pdFByb3BlcnRpZXMnKSxcbiAgbXVsdGlwbGVPZjogcmVxdWlyZSgnLi9tdWx0aXBsZU9mJyksXG4gIG5vdDogcmVxdWlyZSgnLi9ub3QnKSxcbiAgb25lT2Y6IHJlcXVpcmUoJy4vb25lT2YnKSxcbiAgcGF0dGVybjogcmVxdWlyZSgnLi9wYXR0ZXJuJyksXG4gIHByb3BlcnRpZXM6IHJlcXVpcmUoJy4vcHJvcGVydGllcycpLFxuICBwcm9wZXJ0eU5hbWVzOiByZXF1aXJlKCcuL3Byb3BlcnR5TmFtZXMnKSxcbiAgcmVxdWlyZWQ6IHJlcXVpcmUoJy4vcmVxdWlyZWQnKSxcbiAgdW5pcXVlSXRlbXM6IHJlcXVpcmUoJy4vdW5pcXVlSXRlbXMnKSxcbiAgdmFsaWRhdGU6IHJlcXVpcmUoJy4vdmFsaWRhdGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVmKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkYXN5bmMsICRyZWZDb2RlO1xuICBpZiAoJHNjaGVtYSA9PSAnIycgfHwgJHNjaGVtYSA9PSAnIy8nKSB7XG4gICAgaWYgKGl0LmlzUm9vdCkge1xuICAgICAgJGFzeW5jID0gaXQuYXN5bmM7XG4gICAgICAkcmVmQ29kZSA9ICd2YWxpZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhc3luYyA9IGl0LnJvb3Quc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZTtcbiAgICAgICRyZWZDb2RlID0gJ3Jvb3QucmVmVmFsWzBdJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICRyZWZWYWwgPSBpdC5yZXNvbHZlUmVmKGl0LmJhc2VJZCwgJHNjaGVtYSwgaXQuaXNSb290KTtcbiAgICBpZiAoJHJlZlZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgJG1lc3NhZ2UgPSBpdC5NaXNzaW5nUmVmRXJyb3IubWVzc2FnZShpdC5iYXNlSWQsICRzY2hlbWEpO1xuICAgICAgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gJ2ZhaWwnKSB7XG4gICAgICAgIGl0LmxvZ2dlci5lcnJvcigkbWVzc2FnZSk7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnJHJlZicpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgcmVmOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdjYW5cXFxcXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKGZhbHNlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXQub3B0cy5taXNzaW5nUmVmcyA9PSAnaWdub3JlJykge1xuICAgICAgICBpdC5sb2dnZXIud2FybigkbWVzc2FnZSk7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IGl0Lk1pc3NpbmdSZWZFcnJvcihpdC5iYXNlSWQsICRzY2hlbWEsICRtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRyZWZWYWwuaW5saW5lKSB7XG4gICAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICAgICRpdC5sZXZlbCsrO1xuICAgICAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICAgICAgJGl0LnNjaGVtYSA9ICRyZWZWYWwuc2NoZW1hO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSAnJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJHNjaGVtYTtcbiAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCkucmVwbGFjZSgvdmFsaWRhdGVcXC5zY2hlbWEvZywgJHJlZlZhbC5jb2RlKTtcbiAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRhc3luYyA9ICRyZWZWYWwuJGFzeW5jID09PSB0cnVlIHx8IChpdC5hc3luYyAmJiAkcmVmVmFsLiRhc3luYyAhPT0gZmFsc2UpO1xuICAgICAgJHJlZkNvZGUgPSAkcmVmVmFsLmNvZGU7XG4gICAgfVxuICB9XG4gIGlmICgkcmVmQ29kZSkge1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJztcbiAgICBpZiAoaXQub3B0cy5wYXNzQ29udGV4dCkge1xuICAgICAgb3V0ICs9ICcgJyArICgkcmVmQ29kZSkgKyAnLmNhbGwodGhpcywgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgJyArICgkcmVmQ29kZSkgKyAnKCAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcsIChkYXRhUGF0aCB8fCBcXCdcXCcpJztcbiAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgb3V0ICs9ICcgKyAnICsgKGl0LmVycm9yUGF0aCk7XG4gICAgfVxuICAgIHZhciAkcGFyZW50RGF0YSA9ICRkYXRhTHZsID8gJ2RhdGEnICsgKCgkZGF0YUx2bCAtIDEpIHx8ICcnKSA6ICdwYXJlbnREYXRhJyxcbiAgICAgICRwYXJlbnREYXRhUHJvcGVydHkgPSAkZGF0YUx2bCA/IGl0LmRhdGFQYXRoQXJyWyRkYXRhTHZsXSA6ICdwYXJlbnREYXRhUHJvcGVydHknO1xuICAgIG91dCArPSAnICwgJyArICgkcGFyZW50RGF0YSkgKyAnICwgJyArICgkcGFyZW50RGF0YVByb3BlcnR5KSArICcsIHJvb3REYXRhKSAgJztcbiAgICB2YXIgX19jYWxsVmFsaWRhdGUgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoJGFzeW5jKSB7XG4gICAgICBpZiAoIWl0LmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hJyk7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkdmFsaWQpICsgJzsgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIHRyeSB7IGF3YWl0ICcgKyAoX19jYWxsVmFsaWRhdGUpICsgJzsgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSBjYXRjaCAoZSkgeyBpZiAoIShlIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSkgdGhyb3cgZTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBlLmVycm9yczsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoZS5lcnJvcnMpOyBlcnJvcnMgPSB2RXJyb3JzLmxlbmd0aDsgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCR2YWxpZCkgKyAnKSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGlmICghJyArIChfX2NhbGxWYWxpZGF0ZSkgKyAnKSB7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gJyArICgkcmVmQ29kZSkgKyAnLmVycm9yczsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoJyArICgkcmVmQ29kZSkgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYWxsT2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZCxcbiAgICAkYWxsU2NoZW1hc0VtcHR5ID0gdHJ1ZTtcbiAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICBpZiAoYXJyMSkge1xuICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAkYWxsU2NoZW1hc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGggKyAnLycgKyAkaTtcbiAgICAgICAgb3V0ICs9ICcgICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBpZiAoJGFsbFNjaGVtYXNFbXB0eSkge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcy5zbGljZSgwLCAtMSkpICsgJyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbnlPZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJG5vRW1wdHlTY2hlbWEgPSAkc2NoZW1hLmV2ZXJ5KGZ1bmN0aW9uKCRzY2gpIHtcbiAgICByZXR1cm4gKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCkgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpO1xuICB9KTtcbiAgaWYgKCRub0VtcHR5U2NoZW1hKSB7XG4gICAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyB2YXIgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAgJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgaWYgKGFycjEpIHtcbiAgICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICdbJyArICRpICsgJ10nO1xuICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgJGk7XG4gICAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCR2YWxpZCkgKyAnIHx8ICcgKyAoJG5leHRWYWxpZCkgKyAnOyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgIH1cbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2FueU9mJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczoge30gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBzb21lIHNjaGVtYSBpbiBhbnlPZlxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB7fSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZFcnJvcnMpOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gJyB9IGVsc2UgeyAgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfY29tbWVudChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkY29tbWVudCA9IGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSk7XG4gIGlmIChpdC5vcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgb3V0ICs9ICcgY29uc29sZS5sb2coJyArICgkY29tbWVudCkgKyAnKTsnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpdC5vcHRzLiRjb21tZW50ID09ICdmdW5jdGlvbicpIHtcbiAgICBvdXQgKz0gJyBzZWxmLl9vcHRzLiRjb21tZW50KCcgKyAoJGNvbW1lbnQpICsgJywgJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnLCB2YWxpZGF0ZS5yb290LnNjaGVtYSk7JztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb25zdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoISRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7JztcbiAgfVxuICBvdXQgKz0gJ3ZhciAnICsgKCR2YWxpZCkgKyAnID0gZXF1YWwoJyArICgkZGF0YSkgKyAnLCBzY2hlbWEnICsgKCRsdmwpICsgJyk7IGlmICghJyArICgkdmFsaWQpICsgJykgeyAgICc7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnY29uc3QnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGFsbG93ZWRWYWx1ZTogc2NoZW1hJyArICgkbHZsKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgZXF1YWwgdG8gY29uc3RhbnRcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJyB9JztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb250YWlucyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJGlkeCA9ICdpJyArICRsdmwsXG4gICAgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSxcbiAgICAkbmV4dERhdGEgPSAnZGF0YScgKyAkZGF0YU54dCxcbiAgICAkY3VycmVudEJhc2VJZCA9IGl0LmJhc2VJZCxcbiAgICAkbm9uRW1wdHlTY2hlbWEgPSAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaGVtYSA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoZW1hKS5sZW5ndGggPiAwKSB8fCAkc2NoZW1hID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKSk7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoJG5vbkVtcHR5U2NoZW1hKSB7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0VmFsaWQpICsgJyA9IGZhbHNlOyBmb3IgKHZhciAnICsgKCRpZHgpICsgJyA9IDA7ICcgKyAoJGlkeCkgKyAnIDwgJyArICgkZGF0YSkgKyAnLmxlbmd0aDsgJyArICgkaWR4KSArICcrKykgeyAnO1xuICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGlkeCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpZHggKyAnXSc7XG4gICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRpZHg7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyB9ICAnO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhKSArICcubGVuZ3RoID09IDApIHsnO1xuICB9XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnY29udGFpbnMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgY29udGFpbiBhIHZhbGlkIGl0ZW1cXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJyB9IGVsc2UgeyAnO1xuICBpZiAoJG5vbkVtcHR5U2NoZW1hKSB7XG4gICAgb3V0ICs9ICcgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gJztcbiAgfVxuICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICBvdXQgKz0gJyB9ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZGVwZW5kZW5jaWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJHNjaGVtYURlcHMgPSB7fSxcbiAgICAkcHJvcGVydHlEZXBzID0ge30sXG4gICAgJG93blByb3BlcnRpZXMgPSBpdC5vcHRzLm93blByb3BlcnRpZXM7XG4gIGZvciAoJHByb3BlcnR5IGluICRzY2hlbWEpIHtcbiAgICBpZiAoJHByb3BlcnR5ID09ICdfX3Byb3RvX18nKSBjb250aW51ZTtcbiAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5XTtcbiAgICB2YXIgJGRlcHMgPSBBcnJheS5pc0FycmF5KCRzY2gpID8gJHByb3BlcnR5RGVwcyA6ICRzY2hlbWFEZXBzO1xuICAgICRkZXBzWyRwcm9wZXJ0eV0gPSAkc2NoO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsnO1xuICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gIG91dCArPSAndmFyIG1pc3NpbmcnICsgKCRsdmwpICsgJzsnO1xuICBmb3IgKHZhciAkcHJvcGVydHkgaW4gJHByb3BlcnR5RGVwcykge1xuICAgICRkZXBzID0gJHByb3BlcnR5RGVwc1skcHJvcGVydHldO1xuICAgIGlmICgkZGVwcy5sZW5ndGgpIHtcbiAgICAgIG91dCArPSAnIGlmICggJyArICgkZGF0YSkgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpKSArICcgIT09IHVuZGVmaW5lZCAnO1xuICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIG91dCArPSAnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnKSAnO1xuICAgICAgfVxuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJiYgKCAnO1xuICAgICAgICB2YXIgYXJyMSA9ICRkZXBzO1xuICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksICRpID0gLTEsXG4gICAgICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkaSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBvdXQgKz0gJyAoICggJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcpICYmIChtaXNzaW5nJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoaXQub3B0cy5qc29uUG9pbnRlcnMgPyAkcHJvcGVydHlLZXkgOiAkcHJvcCkpICsgJykgKSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJykpIHsgICc7XG4gICAgICAgIHZhciAkcHJvcGVydHlQYXRoID0gJ21pc3NpbmcnICsgJGx2bCxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC5vcHRzLmpzb25Qb2ludGVycyA/IGl0LnV0aWwuZ2V0UGF0aEV4cHIoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eVBhdGgsIHRydWUpIDogJGN1cnJlbnRFcnJvclBhdGggKyAnICsgJyArICRwcm9wZXJ0eVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHByb3BlcnR5OiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJ1xcJywgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJywgZGVwc0NvdW50OiAnICsgKCRkZXBzLmxlbmd0aCkgKyAnLCBkZXBzOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmxlbmd0aCA9PSAxID8gJGRlcHNbMF0gOiAkZGVwcy5qb2luKFwiLCBcIikpKSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgaGF2ZSAnO1xuICAgICAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgIG91dCArPSAncHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0aWVzICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyB3aGVuIHByb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnIGlzIHByZXNlbnRcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgKSB7ICc7XG4gICAgICAgIHZhciBhcnIyID0gJGRlcHM7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTIgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpMiA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIyW2kyICs9IDFdO1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICAgJHVzZURhdGEgPSAkZGF0YSArICRwcm9wO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgeyAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnZGVwZW5kZW5jaWVzJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBwcm9wZXJ0eTogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcsIG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcsIGRlcHNDb3VudDogJyArICgkZGVwcy5sZW5ndGgpICsgJywgZGVwczogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5sZW5ndGggPT0gMSA/ICRkZXBzWzBdIDogJGRlcHMuam9pbihcIiwgXCIpKSkgKyAnXFwnIH0gJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgaGF2ZSAnO1xuICAgICAgICAgICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAncHJvcGVydGllcyAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB3aGVuIHByb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnIGlzIHByZXNlbnRcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAgICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZDtcbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRzY2hlbWFEZXBzKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hRGVwc1skcHJvcGVydHldO1xuICAgIGlmICgoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaCA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoKS5sZW5ndGggPiAwKSB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCAnICsgKCRkYXRhKSArIChpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSkpICsgJyAhPT0gdW5kZWZpbmVkICc7XG4gICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgb3V0ICs9ICcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcpICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgeyAnO1xuICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArIGl0LnV0aWwuZXNjYXBlRnJhZ21lbnQoJHByb3BlcnR5KTtcbiAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgICAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2VudW0oaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICRpID0gJ2knICsgJGx2bCxcbiAgICAkdlNjaGVtYSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgaWYgKCEkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJHZTY2hlbWEpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsnO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJHZhbGlkKSArICc7JztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyBpZiAoc2NoZW1hJyArICgkbHZsKSArICcgPT09IHVuZGVmaW5lZCkgJyArICgkdmFsaWQpICsgJyA9IHRydWU7IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYScgKyAoJGx2bCkgKyAnKSkgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsnO1xuICB9XG4gIG91dCArPSAnJyArICgkdmFsaWQpICsgJyA9IGZhbHNlO2ZvciAodmFyICcgKyAoJGkpICsgJz0wOyAnICsgKCRpKSArICc8JyArICgkdlNjaGVtYSkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIGlmIChlcXVhbCgnICsgKCRkYXRhKSArICcsICcgKyAoJHZTY2hlbWEpICsgJ1snICsgKCRpKSArICddKSkgeyAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgYnJlYWs7IH0nO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICB9ICAnO1xuICB9XG4gIG91dCArPSAnIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgICc7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnZW51bScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlczogc2NoZW1hJyArICgkbHZsKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0nO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2Zvcm1hdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICBpZiAoaXQub3B0cy5mb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkdW5rbm93bkZvcm1hdHMgPSBpdC5vcHRzLnVua25vd25Gb3JtYXRzLFxuICAgICRhbGxvd1Vua25vd24gPSBBcnJheS5pc0FycmF5KCR1bmtub3duRm9ybWF0cyk7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgdmFyICRmb3JtYXQgPSAnZm9ybWF0JyArICRsdmwsXG4gICAgICAkaXNPYmplY3QgPSAnaXNPYmplY3QnICsgJGx2bCxcbiAgICAgICRmb3JtYXRUeXBlID0gJ2Zvcm1hdFR5cGUnICsgJGx2bDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZm9ybWF0KSArICcgPSBmb3JtYXRzWycgKyAoJHNjaGVtYVZhbHVlKSArICddOyB2YXIgJyArICgkaXNPYmplY3QpICsgJyA9IHR5cGVvZiAnICsgKCRmb3JtYXQpICsgJyA9PSBcXCdvYmplY3RcXCcgJiYgISgnICsgKCRmb3JtYXQpICsgJyBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgJyArICgkZm9ybWF0KSArICcudmFsaWRhdGU7IHZhciAnICsgKCRmb3JtYXRUeXBlKSArICcgPSAnICsgKCRpc09iamVjdCkgKyAnICYmICcgKyAoJGZvcm1hdCkgKyAnLnR5cGUgfHwgXFwnc3RyaW5nXFwnOyBpZiAoJyArICgkaXNPYmplY3QpICsgJykgeyAnO1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdmFyIGFzeW5jJyArICgkbHZsKSArICcgPSAnICsgKCRmb3JtYXQpICsgJy5hc3luYzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgJyArICgkZm9ybWF0KSArICcgPSAnICsgKCRmb3JtYXQpICsgJy52YWxpZGF0ZTsgfSBpZiAoICAnO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ3N0cmluZ1xcJykgfHwgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgKCc7XG4gICAgaWYgKCR1bmtub3duRm9ybWF0cyAhPSAnaWdub3JlJykge1xuICAgICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgJiYgIScgKyAoJGZvcm1hdCkgKyAnICc7XG4gICAgICBpZiAoJGFsbG93VW5rbm93bikge1xuICAgICAgICBvdXQgKz0gJyAmJiBzZWxmLl9vcHRzLnVua25vd25Gb3JtYXRzLmluZGV4T2YoJyArICgkc2NoZW1hVmFsdWUpICsgJykgPT0gLTEgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSB8fCAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAoJyArICgkZm9ybWF0KSArICcgJiYgJyArICgkZm9ybWF0VHlwZSkgKyAnID09IFxcJycgKyAoJHJ1bGVUeXBlKSArICdcXCcgJiYgISh0eXBlb2YgJyArICgkZm9ybWF0KSArICcgPT0gXFwnZnVuY3Rpb25cXCcgPyAnO1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgKGFzeW5jJyArICgkbHZsKSArICcgPyBhd2FpdCAnICsgKCRmb3JtYXQpICsgJygnICsgKCRkYXRhKSArICcpIDogJyArICgkZm9ybWF0KSArICcoJyArICgkZGF0YSkgKyAnKSkgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgJyArICgkZm9ybWF0KSArICcoJyArICgkZGF0YSkgKyAnKSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyA6ICcgKyAoJGZvcm1hdCkgKyAnLnRlc3QoJyArICgkZGF0YSkgKyAnKSkpKSkgeyc7XG4gIH0gZWxzZSB7XG4gICAgdmFyICRmb3JtYXQgPSBpdC5mb3JtYXRzWyRzY2hlbWFdO1xuICAgIGlmICghJGZvcm1hdCkge1xuICAgICAgaWYgKCR1bmtub3duRm9ybWF0cyA9PSAnaWdub3JlJykge1xuICAgICAgICBpdC5sb2dnZXIud2FybigndW5rbm93biBmb3JtYXQgXCInICsgJHNjaGVtYSArICdcIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJyArIGl0LmVyclNjaGVtYVBhdGggKyAnXCInKTtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9IGVsc2UgaWYgKCRhbGxvd1Vua25vd24gJiYgJHVua25vd25Gb3JtYXRzLmluZGV4T2YoJHNjaGVtYSkgPj0gMCkge1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQgXCInICsgJHNjaGVtYSArICdcIiBpcyB1c2VkIGluIHNjaGVtYSBhdCBwYXRoIFwiJyArIGl0LmVyclNjaGVtYVBhdGggKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyICRpc09iamVjdCA9IHR5cGVvZiAkZm9ybWF0ID09ICdvYmplY3QnICYmICEoJGZvcm1hdCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgJGZvcm1hdC52YWxpZGF0ZTtcbiAgICB2YXIgJGZvcm1hdFR5cGUgPSAkaXNPYmplY3QgJiYgJGZvcm1hdC50eXBlIHx8ICdzdHJpbmcnO1xuICAgIGlmICgkaXNPYmplY3QpIHtcbiAgICAgIHZhciAkYXN5bmMgPSAkZm9ybWF0LmFzeW5jID09PSB0cnVlO1xuICAgICAgJGZvcm1hdCA9ICRmb3JtYXQudmFsaWRhdGU7XG4gICAgfVxuICAgIGlmICgkZm9ybWF0VHlwZSAhPSAkcnVsZVR5cGUpIHtcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBpZiAoJGFzeW5jKSB7XG4gICAgICBpZiAoIWl0LmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYScpO1xuICAgICAgdmFyICRmb3JtYXRSZWYgPSAnZm9ybWF0cycgKyBpdC51dGlsLmdldFByb3BlcnR5KCRzY2hlbWEpICsgJy52YWxpZGF0ZSc7XG4gICAgICBvdXQgKz0gJyBpZiAoIShhd2FpdCAnICsgKCRmb3JtYXRSZWYpICsgJygnICsgKCRkYXRhKSArICcpKSkgeyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyBpZiAoISAnO1xuICAgICAgdmFyICRmb3JtYXRSZWYgPSAnZm9ybWF0cycgKyBpdC51dGlsLmdldFByb3BlcnR5KCRzY2hlbWEpO1xuICAgICAgaWYgKCRpc09iamVjdCkgJGZvcm1hdFJlZiArPSAnLnZhbGlkYXRlJztcbiAgICAgIGlmICh0eXBlb2YgJGZvcm1hdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoJGZvcm1hdFJlZikgKyAnKCcgKyAoJGRhdGEpICsgJykgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoJGZvcm1hdFJlZikgKyAnLnRlc3QoJyArICgkZGF0YSkgKyAnKSAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpIHsgJztcbiAgICB9XG4gIH1cbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdmb3JtYXQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGZvcm1hdDogICc7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnJyArICgkc2NoZW1hVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSk7XG4gICAgfVxuICAgIG91dCArPSAnICB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBmb3JtYXQgXCInO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICsgXFwnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9pZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkdGhlblNjaCA9IGl0LnNjaGVtYVsndGhlbiddLFxuICAgICRlbHNlU2NoID0gaXQuc2NoZW1hWydlbHNlJ10sXG4gICAgJHRoZW5QcmVzZW50ID0gJHRoZW5TY2ggIT09IHVuZGVmaW5lZCAmJiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHRoZW5TY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHRoZW5TY2gpLmxlbmd0aCA+IDApIHx8ICR0aGVuU2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHRoZW5TY2gsIGl0LlJVTEVTLmFsbCkpLFxuICAgICRlbHNlUHJlc2VudCA9ICRlbHNlU2NoICE9PSB1bmRlZmluZWQgJiYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRlbHNlU2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRlbHNlU2NoKS5sZW5ndGggPiAwKSB8fCAkZWxzZVNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRlbHNlU2NoLCBpdC5SVUxFUy5hbGwpKSxcbiAgICAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQ7XG4gIGlmICgkdGhlblByZXNlbnQgfHwgJGVsc2VQcmVzZW50KSB7XG4gICAgdmFyICRpZkNsYXVzZTtcbiAgICAkaXQuY3JlYXRlRXJyb3JzID0gZmFsc2U7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7IHZhciAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgb3V0ICs9ICcgICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICRpdC5jcmVhdGVFcnJvcnMgPSB0cnVlO1xuICAgIG91dCArPSAnICBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9ICAnO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgaWYgKCR0aGVuUHJlc2VudCkge1xuICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICAnO1xuICAgICAgJGl0LnNjaGVtYSA9IGl0LnNjaGVtYVsndGhlbiddO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy50aGVuJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvdGhlbic7XG4gICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRuZXh0VmFsaWQpICsgJzsgJztcbiAgICAgIGlmICgkdGhlblByZXNlbnQgJiYgJGVsc2VQcmVzZW50KSB7XG4gICAgICAgICRpZkNsYXVzZSA9ICdpZkNsYXVzZScgKyAkbHZsO1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkaWZDbGF1c2UpICsgJyA9IFxcJ3RoZW5cXCc7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaWZDbGF1c2UgPSAnXFwndGhlblxcJyc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICBpZiAoJGVsc2VQcmVzZW50KSB7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgfVxuICAgIGlmICgkZWxzZVByZXNlbnQpIHtcbiAgICAgICRpdC5zY2hlbWEgPSBpdC5zY2hlbWFbJ2Vsc2UnXTtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuZWxzZSc7XG4gICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2Vsc2UnO1xuICAgICAgb3V0ICs9ICcgICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkbmV4dFZhbGlkKSArICc7ICc7XG4gICAgICBpZiAoJHRoZW5QcmVzZW50ICYmICRlbHNlUHJlc2VudCkge1xuICAgICAgICAkaWZDbGF1c2UgPSAnaWZDbGF1c2UnICsgJGx2bDtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJGlmQ2xhdXNlKSArICcgPSBcXCdlbHNlXFwnOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGlmQ2xhdXNlID0gJ1xcJ2Vsc2VcXCcnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2lmJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBmYWlsaW5nS2V5d29yZDogJyArICgkaWZDbGF1c2UpICsgJyB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggXCJcXCcgKyAnICsgKCRpZkNsYXVzZSkgKyAnICsgXFwnXCIgc2NoZW1hXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSAnIH0gICAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2l0ZW1zKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkaWR4ID0gJ2knICsgJGx2bCxcbiAgICAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7dmFyICcgKyAoJHZhbGlkKSArICc7JztcbiAgaWYgKEFycmF5LmlzQXJyYXkoJHNjaGVtYSkpIHtcbiAgICB2YXIgJGFkZGl0aW9uYWxJdGVtcyA9IGl0LnNjaGVtYS5hZGRpdGlvbmFsSXRlbXM7XG4gICAgaWYgKCRhZGRpdGlvbmFsSXRlbXMgPT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkZGF0YSkgKyAnLmxlbmd0aCA8PSAnICsgKCRzY2hlbWEubGVuZ3RoKSArICc7ICc7XG4gICAgICB2YXIgJGN1cnJFcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2FkZGl0aW9uYWxJdGVtcyc7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgJztcbiAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2FkZGl0aW9uYWxJdGVtcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbGltaXQ6ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyB9ICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcgaXRlbXNcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICB9XG4gICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICRlcnJTY2hlbWFQYXRoID0gJGN1cnJFcnJTY2hlbWFQYXRoO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRpKSArICcpIHsgJztcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGksIGl0Lm9wdHMuanNvblBvaW50ZXJzLCB0cnVlKTtcbiAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkYWRkaXRpb25hbEl0ZW1zID09ICdvYmplY3QnICYmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkYWRkaXRpb25hbEl0ZW1zID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRhZGRpdGlvbmFsSXRlbXMpLmxlbmd0aCA+IDApIHx8ICRhZGRpdGlvbmFsSXRlbXMgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkYWRkaXRpb25hbEl0ZW1zLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgJGl0LnNjaGVtYSA9ICRhZGRpdGlvbmFsSXRlbXM7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxJdGVtcyc7XG4gICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2FkZGl0aW9uYWxJdGVtcyc7XG4gICAgICBvdXQgKz0gJyAnICsgKCRuZXh0VmFsaWQpICsgJyA9IHRydWU7IGlmICgnICsgKCRkYXRhKSArICcubGVuZ3RoID4gJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnKSB7ICBmb3IgKHZhciAnICsgKCRpZHgpICsgJyA9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgJyArICgkaWR4KSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7ICc7XG4gICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRpZHgsIGl0Lm9wdHMuanNvblBvaW50ZXJzLCB0cnVlKTtcbiAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpZHggKyAnXSc7XG4gICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGlkeDtcbiAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSBicmVhazsgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoZW1hID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2hlbWEpLmxlbmd0aCA+IDApIHx8ICRzY2hlbWEgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICRpdC5zY2hlbWEgPSAkc2NoZW1hO1xuICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGg7XG4gICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICBvdXQgKz0gJyAgZm9yICh2YXIgJyArICgkaWR4KSArICcgPSAnICsgKDApICsgJzsgJyArICgkaWR4KSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7ICc7XG4gICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaWR4LCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGlkeCArICddJztcbiAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGlkeDtcbiAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSBicmVhazsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSc7XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkaXNNYXggPSAka2V5d29yZCA9PSAnbWF4aW11bScsXG4gICAgJGV4Y2x1c2l2ZUtleXdvcmQgPSAkaXNNYXggPyAnZXhjbHVzaXZlTWF4aW11bScgOiAnZXhjbHVzaXZlTWluaW11bScsXG4gICAgJHNjaGVtYUV4Y2wgPSBpdC5zY2hlbWFbJGV4Y2x1c2l2ZUtleXdvcmRdLFxuICAgICRpc0RhdGFFeGNsID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hRXhjbCAmJiAkc2NoZW1hRXhjbC4kZGF0YSxcbiAgICAkb3AgPSAkaXNNYXggPyAnPCcgOiAnPicsXG4gICAgJG5vdE9wID0gJGlzTWF4ID8gJz4nIDogJzwnLFxuICAgICRlcnJvcktleXdvcmQgPSB1bmRlZmluZWQ7XG4gIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gJ251bWJlcicgfHwgJHNjaGVtYSA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArICcgbXVzdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAoISgkaXNEYXRhRXhjbCB8fCAkc2NoZW1hRXhjbCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiAkc2NoZW1hRXhjbCA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgJHNjaGVtYUV4Y2wgPT0gJ2Jvb2xlYW4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigkZXhjbHVzaXZlS2V5d29yZCArICcgbXVzdCBiZSBudW1iZXIgb3IgYm9vbGVhbicpO1xuICB9XG4gIGlmICgkaXNEYXRhRXhjbCkge1xuICAgIHZhciAkc2NoZW1hVmFsdWVFeGNsID0gaXQudXRpbC5nZXREYXRhKCRzY2hlbWFFeGNsLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpLFxuICAgICAgJGV4Y2x1c2l2ZSA9ICdleGNsdXNpdmUnICsgJGx2bCxcbiAgICAgICRleGNsVHlwZSA9ICdleGNsVHlwZScgKyAkbHZsLFxuICAgICAgJGV4Y2xJc051bWJlciA9ICdleGNsSXNOdW1iZXInICsgJGx2bCxcbiAgICAgICRvcEV4cHIgPSAnb3AnICsgJGx2bCxcbiAgICAgICRvcFN0ciA9ICdcXCcgKyAnICsgJG9wRXhwciArICcgKyBcXCcnO1xuICAgIG91dCArPSAnIHZhciBzY2hlbWFFeGNsJyArICgkbHZsKSArICcgPSAnICsgKCRzY2hlbWFWYWx1ZUV4Y2wpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWVFeGNsID0gJ3NjaGVtYUV4Y2wnICsgJGx2bDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZXhjbHVzaXZlKSArICc7IHZhciAnICsgKCRleGNsVHlwZSkgKyAnID0gdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlRXhjbCkgKyAnOyBpZiAoJyArICgkZXhjbFR5cGUpICsgJyAhPSBcXCdib29sZWFuXFwnICYmICcgKyAoJGV4Y2xUeXBlKSArICcgIT0gXFwndW5kZWZpbmVkXFwnICYmICcgKyAoJGV4Y2xUeXBlKSArICcgIT0gXFwnbnVtYmVyXFwnKSB7ICc7XG4gICAgdmFyICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfZXhjbHVzaXZlTGltaXQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJyArICgkZXhjbHVzaXZlS2V5d29yZCkgKyAnIHNob3VsZCBiZSBib29sZWFuXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIGlmICggJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gICAgfVxuICAgIG91dCArPSAnICcgKyAoJGV4Y2xUeXBlKSArICcgPT0gXFwnbnVtYmVyXFwnID8gKCAoJyArICgkZXhjbHVzaXZlKSArICcgPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID09PSB1bmRlZmluZWQgfHwgJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICcgJyArICgkb3ApICsgJz0gJyArICgkc2NoZW1hVmFsdWUpICsgJykgPyAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJz0gJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICcgOiAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICkgOiAoICgnICsgKCRleGNsdXNpdmUpICsgJyA9ICcgKyAoJHNjaGVtYVZhbHVlRXhjbCkgKyAnID09PSB0cnVlKSA/ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIDogJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hVmFsdWUpICsgJyApIHx8ICcgKyAoJGRhdGEpICsgJyAhPT0gJyArICgkZGF0YSkgKyAnKSB7IHZhciBvcCcgKyAoJGx2bCkgKyAnID0gJyArICgkZXhjbHVzaXZlKSArICcgPyBcXCcnICsgKCRvcCkgKyAnXFwnIDogXFwnJyArICgkb3ApICsgJz1cXCc7ICc7XG4gICAgaWYgKCRzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hVmFsdWVFeGNsO1xuICAgICAgJGlzRGF0YSA9ICRpc0RhdGFFeGNsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJGV4Y2xJc051bWJlciA9IHR5cGVvZiAkc2NoZW1hRXhjbCA9PSAnbnVtYmVyJyxcbiAgICAgICRvcFN0ciA9ICRvcDtcbiAgICBpZiAoJGV4Y2xJc051bWJlciAmJiAkaXNEYXRhKSB7XG4gICAgICB2YXIgJG9wRXhwciA9ICdcXCcnICsgJG9wU3RyICsgJ1xcJyc7XG4gICAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICggJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gdW5kZWZpbmVkIHx8ICcgKyAoJHNjaGVtYUV4Y2wpICsgJyAnICsgKCRvcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID8gJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICc9ICcgKyAoJHNjaGVtYUV4Y2wpICsgJyA6ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKSB8fCAnICsgKCRkYXRhKSArICcgIT09ICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJGV4Y2xJc051bWJlciAmJiAkc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgJGV4Y2x1c2l2ZSA9IHRydWU7XG4gICAgICAgICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWFFeGNsO1xuICAgICAgICAkbm90T3AgKz0gJz0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRleGNsSXNOdW1iZXIpICRzY2hlbWFWYWx1ZSA9IE1hdGhbJGlzTWF4ID8gJ21pbicgOiAnbWF4J10oJHNjaGVtYUV4Y2wsICRzY2hlbWEpO1xuICAgICAgICBpZiAoJHNjaGVtYUV4Y2wgPT09ICgkZXhjbElzTnVtYmVyID8gJHNjaGVtYVZhbHVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICAkZXhjbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAkZXJyb3JLZXl3b3JkID0gJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICAgJG5vdE9wICs9ICc9JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZXhjbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgJG9wU3RyICs9ICc9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyICRvcEV4cHIgPSAnXFwnJyArICRvcFN0ciArICdcXCcnO1xuICAgICAgb3V0ICs9ICcgaWYgKCAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIHx8ICcgKyAoJGRhdGEpICsgJyAhPT0gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgfVxuICB9XG4gICRlcnJvcktleXdvcmQgPSAkZXJyb3JLZXl3b3JkIHx8ICRrZXl3b3JkO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAnX2xpbWl0JykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBjb21wYXJpc29uOiAnICsgKCRvcEV4cHIpICsgJywgbGltaXQ6ICcgKyAoJHNjaGVtYVZhbHVlKSArICcsIGV4Y2x1c2l2ZTogJyArICgkZXhjbHVzaXZlKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJyArICgkb3BTdHIpICsgJyAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYVZhbHVlKSArICdcXCcnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJyB9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfX2xpbWl0SXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRlcnJvcktleXdvcmQ7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoISgkaXNEYXRhIHx8IHR5cGVvZiAkc2NoZW1hID09ICdudW1iZXInKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArICcgbXVzdCBiZSBudW1iZXInKTtcbiAgfVxuICB2YXIgJG9wID0gJGtleXdvcmQgPT0gJ21heEl0ZW1zJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgJyArICgkZGF0YSkgKyAnLmxlbmd0aCAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcpIHsgJztcbiAgdmFyICRlcnJvcktleXdvcmQgPSAka2V5d29yZDtcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ19saW1pdEl0ZW1zJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hVmFsdWUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhJdGVtcycpIHtcbiAgICAgICAgb3V0ICs9ICdtb3JlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnZmV3ZXInO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgdGhhbiAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICsgXFwnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdExlbmd0aChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gJ251bWJlcicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgJyBtdXN0IGJlIG51bWJlcicpO1xuICB9XG4gIHZhciAkb3AgPSAka2V5d29yZCA9PSAnbWF4TGVuZ3RoJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgaWYgKGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdWNzMmxlbmd0aCgnICsgKCRkYXRhKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSB7ICc7XG4gIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfbGltaXRMZW5ndGgnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGxpbWl0OiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhMZW5ndGgnKSB7XG4gICAgICAgIG91dCArPSAnbG9uZ2VyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnc2hvcnRlcic7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB0aGFuICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9fbGltaXRQcm9wZXJ0aWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgaWYgKCEoJGlzRGF0YSB8fCB0eXBlb2YgJHNjaGVtYSA9PSAnbnVtYmVyJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJGtleXdvcmQgKyAnIG11c3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgdmFyICRvcCA9ICRrZXl3b3JkID09ICdtYXhQcm9wZXJ0aWVzJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSB7ICc7XG4gIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfbGltaXRQcm9wZXJ0aWVzJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hVmFsdWUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhQcm9wZXJ0aWVzJykge1xuICAgICAgICBvdXQgKz0gJ21vcmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdmZXdlcic7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB0aGFuICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tdWx0aXBsZU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoISgkaXNEYXRhIHx8IHR5cGVvZiAkc2NoZW1hID09ICdudW1iZXInKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArICcgbXVzdCBiZSBudW1iZXInKTtcbiAgfVxuICBvdXQgKz0gJ3ZhciBkaXZpc2lvbicgKyAoJGx2bCkgKyAnO2lmICgnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiAoIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJyB8fCAnO1xuICB9XG4gIG91dCArPSAnIChkaXZpc2lvbicgKyAoJGx2bCkgKyAnID0gJyArICgkZGF0YSkgKyAnIC8gJyArICgkc2NoZW1hVmFsdWUpICsgJywgJztcbiAgaWYgKGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbikge1xuICAgIG91dCArPSAnIE1hdGguYWJzKE1hdGgucm91bmQoZGl2aXNpb24nICsgKCRsdmwpICsgJykgLSBkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSA+IDFlLScgKyAoaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uKSArICcgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyBkaXZpc2lvbicgKyAoJGx2bCkgKyAnICE9PSBwYXJzZUludChkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSAnO1xuICB9XG4gIG91dCArPSAnICkgJztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyAgKSAgJztcbiAgfVxuICBvdXQgKz0gJyApIHsgICAnO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ211bHRpcGxlT2YnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG11bHRpcGxlT2Y6ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgbXVsdGlwbGUgb2YgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAnXFwnICsgJyArICgkc2NoZW1hVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSkgKyAnXFwnJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbm90KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIGlmICgoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaGVtYSA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoZW1hKS5sZW5ndGggPiAwKSB8fCAkc2NoZW1hID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgJGl0LmNyZWF0ZUVycm9ycyA9IGZhbHNlO1xuICAgIHZhciAkYWxsRXJyb3JzT3B0aW9uO1xuICAgIGlmICgkaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgICRhbGxFcnJvcnNPcHRpb24gPSAkaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgICAkaXQub3B0cy5hbGxFcnJvcnMgPSBmYWxzZTtcbiAgICB9XG4gICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAkaXQuY3JlYXRlRXJyb3JzID0gdHJ1ZTtcbiAgICBpZiAoJGFsbEVycm9yc09wdGlvbikgJGl0Lm9wdHMuYWxsRXJyb3JzID0gJGFsbEVycm9yc09wdGlvbjtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAgICc7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIHZhbGlkXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIHsgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gJztcbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnbm90JykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczoge30gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgdmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKGZhbHNlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX29uZU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQsXG4gICAgJHByZXZWYWxpZCA9ICdwcmV2VmFsaWQnICsgJGx2bCxcbiAgICAkcGFzc2luZ1NjaGVtYXMgPSAncGFzc2luZ1NjaGVtYXMnICsgJGx2bDtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzICwgJyArICgkcHJldlZhbGlkKSArICcgPSBmYWxzZSAsICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZSAsICcgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcgPSBudWxsOyAnO1xuICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgIGlmICgoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaCA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoKS5sZW5ndGggPiAwKSB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgIH1cbiAgICAgIGlmICgkaSkge1xuICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcgJiYgJyArICgkcHJldlZhbGlkKSArICcpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnID0gWycgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcsICcgKyAoJGkpICsgJ107IH0gZWxzZSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkcHJldlZhbGlkKSArICcgPSB0cnVlOyAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnID0gJyArICgkaSkgKyAnOyB9JztcbiAgICB9XG4gIH1cbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgb3V0ICs9ICcnICsgKCRjbG9zaW5nQnJhY2VzKSArICdpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnb25lT2YnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHBhc3NpbmdTY2hlbWFzOiAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gJ30gZWxzZSB7ICBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9JztcbiAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3BhdHRlcm4oaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkcmVnZXhwID0gJGlzRGF0YSA/ICcobmV3IFJlZ0V4cCgnICsgJHNjaGVtYVZhbHVlICsgJykpJyA6IGl0LnVzZVBhdHRlcm4oJHNjaGVtYSk7XG4gIG91dCArPSAnaWYgKCAnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnc3RyaW5nXFwnKSB8fCAnO1xuICB9XG4gIG91dCArPSAnICEnICsgKCRyZWdleHApICsgJy50ZXN0KCcgKyAoJGRhdGEpICsgJykgKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdwYXR0ZXJuJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBwYXR0ZXJuOiAgJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICB9XG4gICAgb3V0ICs9ICcgIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHBhdHRlcm4gXCInO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICsgXFwnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnRpZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAka2V5ID0gJ2tleScgKyAkbHZsLFxuICAgICRpZHggPSAnaWR4JyArICRsdmwsXG4gICAgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSxcbiAgICAkbmV4dERhdGEgPSAnZGF0YScgKyAkZGF0YU54dCxcbiAgICAkZGF0YVByb3BlcnRpZXMgPSAnZGF0YVByb3BlcnRpZXMnICsgJGx2bDtcbiAgdmFyICRzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoJHNjaGVtYSB8fCB7fSkuZmlsdGVyKG5vdFByb3RvKSxcbiAgICAkcFByb3BlcnRpZXMgPSBpdC5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgfHwge30sXG4gICAgJHBQcm9wZXJ0eUtleXMgPSBPYmplY3Qua2V5cygkcFByb3BlcnRpZXMpLmZpbHRlcihub3RQcm90byksXG4gICAgJGFQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICRzb21lUHJvcGVydGllcyA9ICRzY2hlbWFLZXlzLmxlbmd0aCB8fCAkcFByb3BlcnR5S2V5cy5sZW5ndGgsXG4gICAgJG5vQWRkaXRpb25hbCA9ICRhUHJvcGVydGllcyA9PT0gZmFsc2UsXG4gICAgJGFkZGl0aW9uYWxJc1NjaGVtYSA9IHR5cGVvZiAkYVByb3BlcnRpZXMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJGFQcm9wZXJ0aWVzKS5sZW5ndGgsXG4gICAgJHJlbW92ZUFkZGl0aW9uYWwgPSBpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwsXG4gICAgJGNoZWNrQWRkaXRpb25hbCA9ICRub0FkZGl0aW9uYWwgfHwgJGFkZGl0aW9uYWxJc1NjaGVtYSB8fCAkcmVtb3ZlQWRkaXRpb25hbCxcbiAgICAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcyxcbiAgICAkY3VycmVudEJhc2VJZCA9IGl0LmJhc2VJZDtcbiAgdmFyICRyZXF1aXJlZCA9IGl0LnNjaGVtYS5yZXF1aXJlZDtcbiAgaWYgKCRyZXF1aXJlZCAmJiAhKGl0Lm9wdHMuJGRhdGEgJiYgJHJlcXVpcmVkLiRkYXRhKSAmJiAkcmVxdWlyZWQubGVuZ3RoIDwgaXQub3B0cy5sb29wUmVxdWlyZWQpIHtcbiAgICB2YXIgJHJlcXVpcmVkSGFzaCA9IGl0LnV0aWwudG9IYXNoKCRyZXF1aXJlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RQcm90byhwKSB7XG4gICAgcmV0dXJuIHAgIT09ICdfX3Byb3RvX18nO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyc7XG4gIGlmICgkb3duUHJvcGVydGllcykge1xuICAgIG91dCArPSAnIHZhciAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnID0gdW5kZWZpbmVkOyc7XG4gIH1cbiAgaWYgKCRjaGVja0FkZGl0aW9uYWwpIHtcbiAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgPSAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnIHx8IE9iamVjdC5rZXlzKCcgKyAoJGRhdGEpICsgJyk7IGZvciAodmFyICcgKyAoJGlkeCkgKyAnPTA7ICcgKyAoJGlkeCkgKyAnPCcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7IHZhciAnICsgKCRrZXkpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICdbJyArICgkaWR4KSArICddOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyBmb3IgKHZhciAnICsgKCRrZXkpICsgJyBpbiAnICsgKCRkYXRhKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRzb21lUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgdmFyIGlzQWRkaXRpb25hbCcgKyAoJGx2bCkgKyAnID0gIShmYWxzZSAnO1xuICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoID4gOCkge1xuICAgICAgICAgIG91dCArPSAnIHx8IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJy5oYXNPd25Qcm9wZXJ0eSgnICsgKCRrZXkpICsgJykgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyMSA9ICRzY2hlbWFLZXlzO1xuICAgICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMSA9IC0xLFxuICAgICAgICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjFbaTEgKz0gMV07XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoJGtleSkgKyAnID09ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkcHJvcGVydHlLZXkpKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkcFByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycjIgPSAkcFByb3BlcnR5S2V5cztcbiAgICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgICB2YXIgJHBQcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcFByb3BlcnR5ID0gYXJyMlskaSArPSAxXTtcbiAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoaXQudXNlUGF0dGVybigkcFByb3BlcnR5KSkgKyAnLnRlc3QoJyArICgka2V5KSArICcpICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyApOyBpZiAoaXNBZGRpdGlvbmFsJyArICgkbHZsKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsID09ICdhbGwnKSB7XG4gICAgICBvdXQgKz0gJyBkZWxldGUgJyArICgkZGF0YSkgKyAnWycgKyAoJGtleSkgKyAnXTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoO1xuICAgICAgdmFyICRhZGRpdGlvbmFsUHJvcGVydHkgPSAnXFwnICsgJyArICRrZXkgKyAnICsgXFwnJztcbiAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRrZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmICgkbm9BZGRpdGlvbmFsKSB7XG4gICAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCkge1xuICAgICAgICAgIG91dCArPSAnIGRlbGV0ZSAnICsgKCRkYXRhKSArICdbJyArICgka2V5KSArICddOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gICAgICAgICAgdmFyICRjdXJyRXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsUHJvcGVydGllcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgYWRkaXRpb25hbFByb3BlcnR5OiBcXCcnICsgKCRhZGRpdGlvbmFsUHJvcGVydHkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhbiBpbnZhbGlkIGFkZGl0aW9uYWwgcHJvcGVydHknO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllcyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgICRlcnJTY2hlbWFQYXRoID0gJGN1cnJFcnJTY2hlbWFQYXRoO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBicmVhazsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJGFkZGl0aW9uYWxJc1NjaGVtYSkge1xuICAgICAgICBpZiAoJHJlbW92ZUFkZGl0aW9uYWwgPT0gJ2ZhaWxpbmcnKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgICc7XG4gICAgICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRhUHJvcGVydGllcztcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2FkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5ID8gaXQuZXJyb3JQYXRoIDogaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRrZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAka2V5ICsgJ10nO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAka2V5O1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgeyBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2YWxpZGF0ZS5lcnJvcnMgIT09IG51bGwpIHsgaWYgKGVycm9ycykgdmFsaWRhdGUuZXJyb3JzLmxlbmd0aCA9IGVycm9yczsgZWxzZSB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsOyB9IGRlbGV0ZSAnICsgKCRkYXRhKSArICdbJyArICgka2V5KSArICddOyB9ICAnO1xuICAgICAgICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRhUHJvcGVydGllcztcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2FkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5ID8gaXQuZXJyb3JQYXRoIDogaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRrZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAka2V5ICsgJ10nO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAka2V5O1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gICAgfVxuICAgIGlmICgkc29tZVByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgfVxuICB9XG4gIHZhciAkdXNlRGVmYXVsdHMgPSBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlO1xuICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGFycjMgPSAkc2NoZW1hS2V5cztcbiAgICBpZiAoYXJyMykge1xuICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSxcbiAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTMgPCBsMykge1xuICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5S2V5XTtcbiAgICAgICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAgIHZhciAkcHJvcCA9IGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICRwYXNzRGF0YSA9ICRkYXRhICsgJHByb3AsXG4gICAgICAgICAgICAkaGFzRGVmYXVsdCA9ICR1c2VEZWZhdWx0cyAmJiAkc2NoLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJHByb3A7XG4gICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArIGl0LnV0aWwuZXNjYXBlRnJhZ21lbnQoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKGl0LmVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9IGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgJGNvZGUgPSBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKTtcbiAgICAgICAgICAgIHZhciAkdXNlRGF0YSA9ICRwYXNzRGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyICR1c2VEYXRhID0gJG5leHREYXRhO1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoJHJlcXVpcmVkSGFzaCAmJiAkcmVxdWlyZWRIYXNoWyRwcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnKSB7ICcgKyAoJG5leHRWYWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gICAgICAgICAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aCxcbiAgICAgICAgICAgICAgICAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy9yZXF1aXJlZCc7XG4gICAgICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSAkY3VyckVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgICAgICAgICAgICBvdXQgKz0gJyB9IGVsc2UgeyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoICcgKyAoJHVzZURhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJykgeyAnICsgKCRuZXh0VmFsaWQpICsgJyA9IHRydWU7IH0gZWxzZSB7ICc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHVzZURhdGEpICsgJyAhPT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAmJiAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJyApIHsgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnIH0gJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRwUHJvcGVydHlLZXlzLmxlbmd0aCkge1xuICAgIHZhciBhcnI0ID0gJHBQcm9wZXJ0eUtleXM7XG4gICAgaWYgKGFycjQpIHtcbiAgICAgIHZhciAkcFByb3BlcnR5LCBpNCA9IC0xLFxuICAgICAgICBsNCA9IGFycjQubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpNCA8IGw0KSB7XG4gICAgICAgICRwUHJvcGVydHkgPSBhcnI0W2k0ICs9IDFdO1xuICAgICAgICB2YXIgJHNjaCA9ICRwUHJvcGVydGllc1skcFByb3BlcnR5XTtcbiAgICAgICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcucGF0dGVyblByb3BlcnRpZXMnICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcFByb3BlcnR5KTtcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL3BhdHRlcm5Qcm9wZXJ0aWVzLycgKyBpdC51dGlsLmVzY2FwZUZyYWdtZW50KCRwUHJvcGVydHkpO1xuICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgfHwgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKTsgZm9yICh2YXIgJyArICgkaWR4KSArICc9MDsgJyArICgkaWR4KSArICc8JyArICgkZGF0YVByb3BlcnRpZXMpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgdmFyICcgKyAoJGtleSkgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJ1snICsgKCRpZHgpICsgJ107ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGtleSkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51c2VQYXR0ZXJuKCRwUHJvcGVydHkpKSArICcudGVzdCgnICsgKCRrZXkpICsgJykpIHsgJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRrZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAka2V5ICsgJ10nO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAka2V5O1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGVsc2UgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnR5TmFtZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsnO1xuICBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2hlbWEgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaGVtYSkubGVuZ3RoID4gMCkgfHwgJHNjaGVtYSA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIHZhciAka2V5ID0gJ2tleScgKyAkbHZsLFxuICAgICAgJGlkeCA9ICdpZHgnICsgJGx2bCxcbiAgICAgICRpID0gJ2knICsgJGx2bCxcbiAgICAgICRpbnZhbGlkTmFtZSA9ICdcXCcgKyAnICsgJGtleSArICcgKyBcXCcnLFxuICAgICAgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSxcbiAgICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICAgJGRhdGFQcm9wZXJ0aWVzID0gJ2RhdGFQcm9wZXJ0aWVzJyArICRsdmwsXG4gICAgICAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcyxcbiAgICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgPSB1bmRlZmluZWQ7ICc7XG4gICAgfVxuICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgfHwgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKTsgZm9yICh2YXIgJyArICgkaWR4KSArICc9MDsgJyArICgkaWR4KSArICc8JyArICgkZGF0YVByb3BlcnRpZXMpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgdmFyICcgKyAoJGtleSkgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJ1snICsgKCRpZHgpICsgJ107ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGtleSkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB2YXIgc3RhcnRFcnJzJyArICgkbHZsKSArICcgPSBlcnJvcnM7ICc7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRrZXk7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgIH1cbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsgZm9yICh2YXIgJyArICgkaSkgKyAnPXN0YXJ0RXJycycgKyAoJGx2bCkgKyAnOyAnICsgKCRpKSArICc8ZXJyb3JzOyAnICsgKCRpKSArICcrKykgeyB2RXJyb3JzWycgKyAoJGkpICsgJ10ucHJvcGVydHlOYW1lID0gJyArICgka2V5KSArICc7IH0gICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3Byb3BlcnR5TmFtZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHByb3BlcnR5TmFtZTogXFwnJyArICgkaW52YWxpZE5hbWUpICsgJ1xcJyB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdwcm9wZXJ0eSBuYW1lIFxcXFxcXCcnICsgKCRpbnZhbGlkTmFtZSkgKyAnXFxcXFxcJyBpcyBpbnZhbGlkXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBicmVhazsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSB9JztcbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVxdWlyZWQoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICR2U2NoZW1hID0gJ3NjaGVtYScgKyAkbHZsO1xuICBpZiAoISRpc0RhdGEpIHtcbiAgICBpZiAoJHNjaGVtYS5sZW5ndGggPCBpdC5vcHRzLmxvb3BSZXF1aXJlZCAmJiBpdC5zY2hlbWEucHJvcGVydGllcyAmJiBPYmplY3Qua2V5cyhpdC5zY2hlbWEucHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICB2YXIgJHJlcXVpcmVkID0gW107XG4gICAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgICBpZiAoYXJyMSkge1xuICAgICAgICB2YXIgJHByb3BlcnR5LCBpMSA9IC0xLFxuICAgICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgICAgICRwcm9wZXJ0eSA9IGFycjFbaTEgKz0gMV07XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eVNjaCA9IGl0LnNjaGVtYS5wcm9wZXJ0aWVzWyRwcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKCEoJHByb3BlcnR5U2NoICYmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkcHJvcGVydHlTY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHByb3BlcnR5U2NoKS5sZW5ndGggPiAwKSB8fCAkcHJvcGVydHlTY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkcHJvcGVydHlTY2gsIGl0LlJVTEVTLmFsbCkpKSkge1xuICAgICAgICAgICAgJHJlcXVpcmVkWyRyZXF1aXJlZC5sZW5ndGhdID0gJHByb3BlcnR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgJHJlcXVpcmVkID0gJHNjaGVtYTtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0RhdGEgfHwgJHJlcXVpcmVkLmxlbmd0aCkge1xuICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aCxcbiAgICAgICRsb29wUmVxdWlyZWQgPSAkaXNEYXRhIHx8ICRyZXF1aXJlZC5sZW5ndGggPj0gaXQub3B0cy5sb29wUmVxdWlyZWQsXG4gICAgICAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFyIG1pc3NpbmcnICsgKCRsdmwpICsgJzsgJztcbiAgICAgIGlmICgkbG9vcFJlcXVpcmVkKSB7XG4gICAgICAgIGlmICghJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2U2NoZW1hKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICRpID0gJ2knICsgJGx2bCxcbiAgICAgICAgICAkcHJvcGVydHlQYXRoID0gJ3NjaGVtYScgKyAkbHZsICsgJ1snICsgJGkgKyAnXScsXG4gICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9ICdcXCcgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcXCcnO1xuICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoc2NoZW1hJyArICgkbHZsKSArICcgPT09IHVuZGVmaW5lZCkgJyArICgkdmFsaWQpICsgJyA9IHRydWU7IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYScgKyAoJGx2bCkgKyAnKSkgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8ICcgKyAoJHZTY2hlbWEpICsgJy5sZW5ndGg7ICcgKyAoJGkpICsgJysrKSB7ICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICdbJyArICgkdlNjaGVtYSkgKyAnWycgKyAoJGkpICsgJ11dICE9PSB1bmRlZmluZWQgJztcbiAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJiYgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCAnICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXSkgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJzsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSBicmVhazsgfSAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnICB9ICAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICAnO1xuICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhIHJlcXVpcmVkIHByb3BlcnR5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFxcXFxcJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgICAgIHZhciBhcnIyID0gJHJlcXVpcmVkO1xuICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksICRpID0gLTEsXG4gICAgICAgICAgICBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMikge1xuICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyMlskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkaSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBvdXQgKz0gJyAoICggJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcpICYmIChtaXNzaW5nJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoaXQub3B0cy5qc29uUG9pbnRlcnMgPyAkcHJvcGVydHlLZXkgOiAkcHJvcCkpICsgJykgKSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJykgeyAgJztcbiAgICAgICAgdmFyICRwcm9wZXJ0eVBhdGggPSAnbWlzc2luZycgKyAkbHZsLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgJyArICRwcm9wZXJ0eVBhdGggKyAnICsgXFwnJztcbiAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuanNvblBvaW50ZXJzID8gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgdHJ1ZSkgOiAkY3VycmVudEVycm9yUGF0aCArICcgKyAnICsgJHByb3BlcnR5UGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhIHJlcXVpcmVkIHByb3BlcnR5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFxcXFxcJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkbG9vcFJlcXVpcmVkKSB7XG4gICAgICAgIGlmICghJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2U2NoZW1hKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICRpID0gJ2knICsgJGx2bCxcbiAgICAgICAgICAkcHJvcGVydHlQYXRoID0gJ3NjaGVtYScgKyAkbHZsICsgJ1snICsgJGkgKyAnXScsXG4gICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9ICdcXCcgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcXCcnO1xuICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHZTY2hlbWEpICsgJyAmJiAhQXJyYXkuaXNBcnJheSgnICsgKCR2U2NoZW1hKSArICcpKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJyc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFxcXFxcJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSBlbHNlIGlmICgnICsgKCR2U2NoZW1hKSArICcgIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8ICcgKyAoJHZTY2hlbWEpICsgJy5sZW5ndGg7ICcgKyAoJGkpICsgJysrKSB7IGlmICgnICsgKCRkYXRhKSArICdbJyArICgkdlNjaGVtYSkgKyAnWycgKyAoJGkpICsgJ11dID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCAnICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXSkgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJykgeyAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhIHJlcXVpcmVkIHByb3BlcnR5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFxcXFxcJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9IH0gJztcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJyAgfSAgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycjMgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIzKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSxcbiAgICAgICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpMyA8IGwzKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICAgJHVzZURhdGEgPSAkZGF0YSArICRwcm9wO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgeyAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJyc7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhIHJlcXVpcmVkIHByb3BlcnR5JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgfSBlbHNlIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgaWYgKHRydWUpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3VuaXF1ZUl0ZW1zKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICgoJHNjaGVtYSB8fCAkaXNEYXRhKSAmJiBpdC5vcHRzLnVuaXF1ZUl0ZW1zICE9PSBmYWxzZSkge1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkdmFsaWQpICsgJzsgaWYgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgPT09IGZhbHNlIHx8ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgPT09IHVuZGVmaW5lZCkgJyArICgkdmFsaWQpICsgJyA9IHRydWU7IGVsc2UgaWYgKHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ2Jvb2xlYW5cXCcpICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgZWxzZSB7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIHZhciBpID0gJyArICgkZGF0YSkgKyAnLmxlbmd0aCAsICcgKyAoJHZhbGlkKSArICcgPSB0cnVlICwgajsgaWYgKGkgPiAxKSB7ICc7XG4gICAgdmFyICRpdGVtVHlwZSA9IGl0LnNjaGVtYS5pdGVtcyAmJiBpdC5zY2hlbWEuaXRlbXMudHlwZSxcbiAgICAgICR0eXBlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoJGl0ZW1UeXBlKTtcbiAgICBpZiAoISRpdGVtVHlwZSB8fCAkaXRlbVR5cGUgPT0gJ29iamVjdCcgfHwgJGl0ZW1UeXBlID09ICdhcnJheScgfHwgKCR0eXBlSXNBcnJheSAmJiAoJGl0ZW1UeXBlLmluZGV4T2YoJ29iamVjdCcpID49IDAgfHwgJGl0ZW1UeXBlLmluZGV4T2YoJ2FycmF5JykgPj0gMCkpKSB7XG4gICAgICBvdXQgKz0gJyBvdXRlcjogZm9yICg7aS0tOykgeyBmb3IgKGogPSBpOyBqLS07KSB7IGlmIChlcXVhbCgnICsgKCRkYXRhKSArICdbaV0sICcgKyAoJGRhdGEpICsgJ1tqXSkpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBicmVhayBvdXRlcjsgfSB9IH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyIGl0ZW1JbmRpY2VzID0ge30sIGl0ZW07IGZvciAoO2ktLTspIHsgdmFyIGl0ZW0gPSAnICsgKCRkYXRhKSArICdbaV07ICc7XG4gICAgICB2YXIgJG1ldGhvZCA9ICdjaGVja0RhdGFUeXBlJyArICgkdHlwZUlzQXJyYXkgPyAncycgOiAnJyk7XG4gICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsWyRtZXRob2RdKCRpdGVtVHlwZSwgJ2l0ZW0nLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIHRydWUpKSArICcpIGNvbnRpbnVlOyAnO1xuICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICBvdXQgKz0gJyBpZiAodHlwZW9mIGl0ZW0gPT0gXFwnc3RyaW5nXFwnKSBpdGVtID0gXFwnXCJcXCcgKyBpdGVtOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaWYgKHR5cGVvZiBpdGVtSW5kaWNlc1tpdGVtXSA9PSBcXCdudW1iZXJcXCcpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBqID0gaXRlbUluZGljZXNbaXRlbV07IGJyZWFrOyB9IGl0ZW1JbmRpY2VzW2l0ZW1dID0gaTsgfSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnICB9ICAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICAnO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCd1bmlxdWVJdGVtcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgaTogaSwgajogaiB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyBcXCcgKyBqICsgXFwnIGFuZCBcXCcgKyBpICsgXFwnIGFyZSBpZGVudGljYWwpXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB7fSAnO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgS0VZV09SRFMgPSBbXG4gICdtdWx0aXBsZU9mJyxcbiAgJ21heGltdW0nLFxuICAnZXhjbHVzaXZlTWF4aW11bScsXG4gICdtaW5pbXVtJyxcbiAgJ2V4Y2x1c2l2ZU1pbmltdW0nLFxuICAnbWF4TGVuZ3RoJyxcbiAgJ21pbkxlbmd0aCcsXG4gICdwYXR0ZXJuJyxcbiAgJ2FkZGl0aW9uYWxJdGVtcycsXG4gICdtYXhJdGVtcycsXG4gICdtaW5JdGVtcycsXG4gICd1bmlxdWVJdGVtcycsXG4gICdtYXhQcm9wZXJ0aWVzJyxcbiAgJ21pblByb3BlcnRpZXMnLFxuICAncmVxdWlyZWQnLFxuICAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAnZW51bScsXG4gICdmb3JtYXQnLFxuICAnY29uc3QnXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRhU2NoZW1hLCBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICBmb3IgKHZhciBpPTA7IGk8a2V5d29yZHNKc29uUG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBtZXRhU2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhU2NoZW1hKSk7XG4gICAgdmFyIHNlZ21lbnRzID0ga2V5d29yZHNKc29uUG9pbnRlcnNbaV0uc3BsaXQoJy8nKTtcbiAgICB2YXIga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgIHZhciBqO1xuICAgIGZvciAoaj0xOyBqPHNlZ21lbnRzLmxlbmd0aDsgaisrKVxuICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWdtZW50c1tqXV07XG5cbiAgICBmb3IgKGo9MDsgajxLRVlXT1JEUy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGtleSA9IEtFWVdPUkRTW2pdO1xuICAgICAgdmFyIHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIGtleXdvcmRzW2tleV0gPSB7XG4gICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHsgJHJlZjogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uIycgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0YVNjaGVtYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNaXNzaW5nUmVmRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yX2NsYXNzZXMnKS5NaXNzaW5nUmVmO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVBc3luYztcblxuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYSB3aXRoIGFzeW5jaHJvbm91cyBsb2FkaW5nIG9mIG1pc3Npbmcgc2NoZW1hcy5cbiAqIGBsb2FkU2NoZW1hYCBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHNjaGVtYSB1cmkgYW5kIHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHNjaGVtYS5cbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59ICBtZXRhIG9wdGlvbmFsIHRydWUgdG8gY29tcGlsZSBtZXRhLXNjaGVtYTsgdGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHNraXBwZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2ssIGl0IGlzIGNhbGxlZCB3aXRoIDIgcGFyYW1ldGVyczogZXJyb3IgKG9yIG51bGwpIGFuZCB2YWxpZGF0aW5nIGZ1bmN0aW9uLlxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSB2YWxpZGF0aW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhLCBjYWxsYmFjaykge1xuICAvKiBlc2xpbnQgbm8tc2hhZG93OiAwICovXG4gIC8qIGdsb2JhbCBQcm9taXNlICovXG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodHlwZW9mIHRoaXMuX29wdHMubG9hZFNjaGVtYSAhPSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKHR5cGVvZiBtZXRhID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1ldGE7XG4gICAgbWV0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBwID0gbG9hZE1ldGFTY2hlbWFPZihzY2hlbWEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlbWFPYmogPSBzZWxmLl9hZGRTY2hlbWEoc2NoZW1hLCB1bmRlZmluZWQsIG1ldGEpO1xuICAgIHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopO1xuICB9KTtcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBwLnRoZW4oXG4gICAgICBmdW5jdGlvbih2KSB7IGNhbGxiYWNrKG51bGwsIHYpOyB9LFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHA7XG5cblxuICBmdW5jdGlvbiBsb2FkTWV0YVNjaGVtYU9mKHNjaCkge1xuICAgIHZhciAkc2NoZW1hID0gc2NoLiRzY2hlbWE7XG4gICAgcmV0dXJuICRzY2hlbWEgJiYgIXNlbGYuZ2V0U2NoZW1hKCRzY2hlbWEpXG4gICAgICAgICAgICA/IGNvbXBpbGVBc3luYy5jYWxsKHNlbGYsIHsgJHJlZjogJHNjaGVtYSB9LCB0cnVlKVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopIHtcbiAgICB0cnkgeyByZXR1cm4gc2VsZi5fY29tcGlsZShzY2hlbWFPYmopOyB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNaXNzaW5nUmVmRXJyb3IpIHJldHVybiBsb2FkTWlzc2luZ1NjaGVtYShlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShlKSB7XG4gICAgICB2YXIgcmVmID0gZS5taXNzaW5nU2NoZW1hO1xuICAgICAgaWYgKGFkZGVkKHJlZikpIHRocm93IG5ldyBFcnJvcignU2NoZW1hICcgKyByZWYgKyAnIGlzIGxvYWRlZCBidXQgJyArIGUubWlzc2luZ1JlZiArICcgY2Fubm90IGJlIHJlc29sdmVkJyk7XG5cbiAgICAgIHZhciBzY2hlbWFQcm9taXNlID0gc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgIGlmICghc2NoZW1hUHJvbWlzZSkge1xuICAgICAgICBzY2hlbWFQcm9taXNlID0gc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXSA9IHNlbGYuX29wdHMubG9hZFNjaGVtYShyZWYpO1xuICAgICAgICBzY2hlbWFQcm9taXNlLnRoZW4ocmVtb3ZlUHJvbWlzZSwgcmVtb3ZlUHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2hlbWFQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHNjaCkge1xuICAgICAgICBpZiAoIWFkZGVkKHJlZikpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZE1ldGFTY2hlbWFPZihzY2gpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFhZGRlZChyZWYpKSBzZWxmLmFkZFNjaGVtYShzY2gsIHJlZiwgdW5kZWZpbmVkLCBtZXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMoc2NoZW1hT2JqKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVQcm9taXNlKCkge1xuICAgICAgICBkZWxldGUgc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkZWQocmVmKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZWZzW3JlZl0gfHwgc2VsZi5fc2NoZW1hc1tyZWZdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSURFTlRJRklFUiA9IC9eW2Etel8kXVthLXowLTlfJC1dKiQvaTtcbnZhciBjdXN0b21SdWxlQ29kZSA9IHJlcXVpcmUoJy4vZG90anMvY3VzdG9tJyk7XG52YXIgZGVmaW5pdGlvblNjaGVtYSA9IHJlcXVpcmUoJy4vZGVmaW5pdGlvbl9zY2hlbWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkS2V5d29yZCxcbiAgZ2V0OiBnZXRLZXl3b3JkLFxuICByZW1vdmU6IHJlbW92ZUtleXdvcmQsXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZUtleXdvcmRcbn07XG5cblxuLyoqXG4gKiBEZWZpbmUgY3VzdG9tIGtleXdvcmRcbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXl3b3JkIGN1c3RvbSBrZXl3b3JkLCBzaG91bGQgYmUgdW5pcXVlIChpbmNsdWRpbmcgZGlmZmVyZW50IGZyb20gYWxsIHN0YW5kYXJkLCBjdXN0b20gYW5kIG1hY3JvIGtleXdvcmRzKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGtleXdvcmQgZGVmaW5pdGlvbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGB0eXBlYCAodHlwZShzKSB3aGljaCB0aGUga2V5d29yZCBhcHBsaWVzIHRvKSwgYHZhbGlkYXRlYCBvciBgY29tcGlsZWAuXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRLZXl3b3JkKGtleXdvcmQsIGRlZmluaXRpb24pIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAvKiBlc2xpbnQgbm8tc2hhZG93OiAwICovXG4gIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG4gIGlmIChSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXdvcmQgJyArIGtleXdvcmQgKyAnIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuXG4gIGlmICghSURFTlRJRklFUi50ZXN0KGtleXdvcmQpKVxuICAgIHRocm93IG5ldyBFcnJvcignS2V5d29yZCAnICsga2V5d29yZCArICcgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllcicpO1xuXG4gIGlmIChkZWZpbml0aW9uKSB7XG4gICAgdGhpcy52YWxpZGF0ZUtleXdvcmQoZGVmaW5pdGlvbiwgdHJ1ZSk7XG5cbiAgICB2YXIgZGF0YVR5cGUgPSBkZWZpbml0aW9uLnR5cGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVR5cGUpKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YVR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgIF9hZGRSdWxlKGtleXdvcmQsIGRhdGFUeXBlW2ldLCBkZWZpbml0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFJ1bGUoa2V5d29yZCwgZGF0YVR5cGUsIGRlZmluaXRpb24pO1xuICAgIH1cblxuICAgIHZhciBtZXRhU2NoZW1hID0gZGVmaW5pdGlvbi5tZXRhU2NoZW1hO1xuICAgIGlmIChtZXRhU2NoZW1hKSB7XG4gICAgICBpZiAoZGVmaW5pdGlvbi4kZGF0YSAmJiB0aGlzLl9vcHRzLiRkYXRhKSB7XG4gICAgICAgIG1ldGFTY2hlbWEgPSB7XG4gICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgIG1ldGFTY2hlbWEsXG4gICAgICAgICAgICB7ICckcmVmJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uIycgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmluaXRpb24udmFsaWRhdGVTY2hlbWEgPSB0aGlzLmNvbXBpbGUobWV0YVNjaGVtYSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSBSVUxFUy5hbGxba2V5d29yZF0gPSB0cnVlO1xuXG5cbiAgZnVuY3Rpb24gX2FkZFJ1bGUoa2V5d29yZCwgZGF0YVR5cGUsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgcnVsZUdyb3VwO1xuICAgIGZvciAodmFyIGk9MDsgaTxSVUxFUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJnID0gUlVMRVNbaV07XG4gICAgICBpZiAocmcudHlwZSA9PSBkYXRhVHlwZSkge1xuICAgICAgICBydWxlR3JvdXAgPSByZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgUlVMRVMucHVzaChydWxlR3JvdXApO1xuICAgIH1cblxuICAgIHZhciBydWxlID0ge1xuICAgICAga2V5d29yZDoga2V5d29yZCxcbiAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24sXG4gICAgICBjdXN0b206IHRydWUsXG4gICAgICBjb2RlOiBjdXN0b21SdWxlQ29kZSxcbiAgICAgIGltcGxlbWVudHM6IGRlZmluaXRpb24uaW1wbGVtZW50c1xuICAgIH07XG4gICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgUlVMRVMuY3VzdG9tW2tleXdvcmRdID0gcnVsZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogR2V0IGtleXdvcmRcbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXl3b3JkIHByZS1kZWZpbmVkIG9yIGN1c3RvbSBrZXl3b3JkLlxuICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IGN1c3RvbSBrZXl3b3JkIGRlZmluaXRpb24sIGB0cnVlYCBpZiBpdCBpcyBhIHByZWRlZmluZWQga2V5d29yZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGdldEtleXdvcmQoa2V5d29yZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBydWxlID0gdGhpcy5SVUxFUy5jdXN0b21ba2V5d29yZF07XG4gIHJldHVybiBydWxlID8gcnVsZS5kZWZpbml0aW9uIDogdGhpcy5SVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSB8fCBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFJlbW92ZSBrZXl3b3JkXG4gKiBAdGhpcyAgQWp2XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5d29yZCBwcmUtZGVmaW5lZCBvciBjdXN0b20ga2V5d29yZC5cbiAqIEByZXR1cm4ge0Fqdn0gdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUtleXdvcmQoa2V5d29yZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG4gIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgZGVsZXRlIFJVTEVTLmN1c3RvbVtrZXl3b3JkXTtcbiAgZm9yICh2YXIgaT0wOyBpPFJVTEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ1bGVzID0gUlVMRVNbaV0ucnVsZXM7XG4gICAgZm9yICh2YXIgaj0wOyBqPHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAocnVsZXNbal0ua2V5d29yZCA9PSBrZXl3b3JkKSB7XG4gICAgICAgIHJ1bGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogVmFsaWRhdGUga2V5d29yZCBkZWZpbml0aW9uXG4gKiBAdGhpcyAgQWp2XG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBrZXl3b3JkIGRlZmluaXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSB0aHJvd0Vycm9yIHRydWUgdG8gdGhyb3cgZXhjZXB0aW9uIGlmIGRlZmluaXRpb24gaXMgaW52YWxpZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKGRlZmluaXRpb24sIHRocm93RXJyb3IpIHtcbiAgdmFsaWRhdGVLZXl3b3JkLmVycm9ycyA9IG51bGw7XG4gIHZhciB2ID0gdGhpcy5fdmFsaWRhdGVLZXl3b3JkID0gdGhpcy5fdmFsaWRhdGVLZXl3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5jb21waWxlKGRlZmluaXRpb25TY2hlbWEsIHRydWUpO1xuXG4gIGlmICh2KGRlZmluaXRpb24pKSByZXR1cm4gdHJ1ZTtcbiAgdmFsaWRhdGVLZXl3b3JkLmVycm9ycyA9IHYuZXJyb3JzO1xuICBpZiAodGhyb3dFcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1c3RvbSBrZXl3b3JkIGRlZmluaXRpb24gaXMgaW52YWxpZDogJyAgKyB0aGlzLmVycm9yc1RleHQodi5lcnJvcnMpKTtcbiAgZWxzZVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfY3VzdG9tKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkcnVsZSA9IHRoaXMsXG4gICAgJGRlZmluaXRpb24gPSAnZGVmaW5pdGlvbicgKyAkbHZsLFxuICAgICRyRGVmID0gJHJ1bGUuZGVmaW5pdGlvbixcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICB2YXIgJGNvbXBpbGUsICRpbmxpbmUsICRtYWNybywgJHJ1bGVWYWxpZGF0ZSwgJHZhbGlkYXRlQ29kZTtcbiAgaWYgKCRpc0RhdGEgJiYgJHJEZWYuJGRhdGEpIHtcbiAgICAkdmFsaWRhdGVDb2RlID0gJ2tleXdvcmRWYWxpZGF0ZScgKyAkbHZsO1xuICAgIHZhciAkdmFsaWRhdGVTY2hlbWEgPSAkckRlZi52YWxpZGF0ZVNjaGVtYTtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZGVmaW5pdGlvbikgKyAnID0gUlVMRVMuY3VzdG9tW1xcJycgKyAoJGtleXdvcmQpICsgJ1xcJ10uZGVmaW5pdGlvbjsgdmFyICcgKyAoJHZhbGlkYXRlQ29kZSkgKyAnID0gJyArICgkZGVmaW5pdGlvbikgKyAnLnZhbGlkYXRlOyc7XG4gIH0gZWxzZSB7XG4gICAgJHJ1bGVWYWxpZGF0ZSA9IGl0LnVzZUN1c3RvbVJ1bGUoJHJ1bGUsICRzY2hlbWEsIGl0LnNjaGVtYSwgaXQpO1xuICAgIGlmICghJHJ1bGVWYWxpZGF0ZSkgcmV0dXJuO1xuICAgICRzY2hlbWFWYWx1ZSA9ICd2YWxpZGF0ZS5zY2hlbWEnICsgJHNjaGVtYVBhdGg7XG4gICAgJHZhbGlkYXRlQ29kZSA9ICRydWxlVmFsaWRhdGUuY29kZTtcbiAgICAkY29tcGlsZSA9ICRyRGVmLmNvbXBpbGU7XG4gICAgJGlubGluZSA9ICRyRGVmLmlubGluZTtcbiAgICAkbWFjcm8gPSAkckRlZi5tYWNybztcbiAgfVxuICB2YXIgJHJ1bGVFcnJzID0gJHZhbGlkYXRlQ29kZSArICcuZXJyb3JzJyxcbiAgICAkaSA9ICdpJyArICRsdmwsXG4gICAgJHJ1bGVFcnIgPSAncnVsZUVycicgKyAkbHZsLFxuICAgICRhc3luY0tleXdvcmQgPSAkckRlZi5hc3luYztcbiAgaWYgKCRhc3luY0tleXdvcmQgJiYgIWl0LmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWEnKTtcbiAgaWYgKCEoJGlubGluZSB8fCAkbWFjcm8pKSB7XG4gICAgb3V0ICs9ICcnICsgKCRydWxlRXJycykgKyAnID0gbnVsbDsnO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoJGlzRGF0YSAmJiAkckRlZi4kZGF0YSkge1xuICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICBvdXQgKz0gJyBpZiAoJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gdW5kZWZpbmVkKSB7ICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyB9IGVsc2UgeyAnO1xuICAgIGlmICgkdmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkZWZpbml0aW9uKSArICcudmFsaWRhdGVTY2hlbWEoJyArICgkc2NoZW1hVmFsdWUpICsgJyk7IGlmICgnICsgKCR2YWxpZCkgKyAnKSB7ICc7XG4gICAgfVxuICB9XG4gIGlmICgkaW5saW5lKSB7XG4gICAgaWYgKCRyRGVmLnN0YXRlbWVudHMpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHJ1bGVWYWxpZGF0ZS52YWxpZGF0ZSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRydWxlVmFsaWRhdGUudmFsaWRhdGUpICsgJzsgJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoJG1hY3JvKSB7XG4gICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICAgJGl0LmxldmVsKys7XG4gICAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICAgICRpdC5zY2hlbWEgPSAkcnVsZVZhbGlkYXRlLnZhbGlkYXRlO1xuICAgICRpdC5zY2hlbWFQYXRoID0gJyc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KS5yZXBsYWNlKC92YWxpZGF0ZVxcLnNjaGVtYS9nLCAkdmFsaWRhdGVDb2RlKTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnICcgKyAoJGNvZGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJztcbiAgICBvdXQgKz0gJyAgJyArICgkdmFsaWRhdGVDb2RlKSArICcuY2FsbCggJztcbiAgICBpZiAoaXQub3B0cy5wYXNzQ29udGV4dCkge1xuICAgICAgb3V0ICs9ICd0aGlzJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICdzZWxmJztcbiAgICB9XG4gICAgaWYgKCRjb21waWxlIHx8ICRyRGVmLnNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgJyArICgkZGF0YSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnICwgJyArICgkc2NoZW1hVmFsdWUpICsgJyAsICcgKyAoJGRhdGEpICsgJyAsIHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICwgKGRhdGFQYXRoIHx8IFxcJ1xcJyknO1xuICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICB9XG4gICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyAnZGF0YScgKyAoKCRkYXRhTHZsIC0gMSkgfHwgJycpIDogJ3BhcmVudERhdGEnLFxuICAgICAgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogJ3BhcmVudERhdGFQcm9wZXJ0eSc7XG4gICAgb3V0ICs9ICcgLCAnICsgKCRwYXJlbnREYXRhKSArICcgLCAnICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJyAsIHJvb3REYXRhICkgICc7XG4gICAgdmFyIGRlZl9jYWxsUnVsZVZhbGlkYXRlID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCRyRGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnO1xuICAgICAgaWYgKCRhc3luY0tleXdvcmQpIHtcbiAgICAgICAgb3V0ICs9ICdhd2FpdCAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcnICsgKGRlZl9jYWxsUnVsZVZhbGlkYXRlKSArICc7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkYXN5bmNLZXl3b3JkKSB7XG4gICAgICAgICRydWxlRXJycyA9ICdjdXN0b21FcnJvcnMnICsgJGx2bDtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHJ1bGVFcnJzKSArICcgPSBudWxsOyB0cnkgeyAnICsgKCR2YWxpZCkgKyAnID0gYXdhaXQgJyArIChkZWZfY2FsbFJ1bGVWYWxpZGF0ZSkgKyAnOyB9IGNhdGNoIChlKSB7ICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgaWYgKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpICcgKyAoJHJ1bGVFcnJzKSArICcgPSBlLmVycm9yczsgZWxzZSB0aHJvdyBlOyB9ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAnICsgKCRydWxlRXJycykgKyAnID0gbnVsbDsgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoZGVmX2NhbGxSdWxlVmFsaWRhdGUpICsgJzsgJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRyRGVmLm1vZGlmeWluZykge1xuICAgIG91dCArPSAnIGlmICgnICsgKCRwYXJlbnREYXRhKSArICcpICcgKyAoJGRhdGEpICsgJyA9ICcgKyAoJHBhcmVudERhdGEpICsgJ1snICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJ107JztcbiAgfVxuICBvdXQgKz0gJycgKyAoJGNsb3NpbmdCcmFjZXMpO1xuICBpZiAoJHJEZWYudmFsaWQpIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgaWYgKCAnO1xuICAgIGlmICgkckRlZi52YWxpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvdXQgKz0gJyAhJztcbiAgICAgIGlmICgkbWFjcm8pIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRuZXh0VmFsaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCR2YWxpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnICcgKyAoISRyRGVmLnZhbGlkKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcpIHsgJztcbiAgICAkZXJyb3JLZXl3b3JkID0gJHJ1bGUua2V5d29yZDtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAnY3VzdG9tJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBrZXl3b3JkOiBcXCcnICsgKCRydWxlLmtleXdvcmQpICsgJ1xcJyB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgcGFzcyBcIicgKyAoJHJ1bGUua2V5d29yZCkgKyAnXCIga2V5d29yZCB2YWxpZGF0aW9uXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgdmFyIGRlZl9jdXN0b21FcnJvciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICgkaW5saW5lKSB7XG4gICAgICBpZiAoJHJEZWYuZXJyb3JzKSB7XG4gICAgICAgIGlmICgkckRlZi5lcnJvcnMgIT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgb3V0ICs9ICcgIGZvciAodmFyICcgKyAoJGkpICsgJz0nICsgKCRlcnJzKSArICc7ICcgKyAoJGkpICsgJzxlcnJvcnM7ICcgKyAoJGkpICsgJysrKSB7IHZhciAnICsgKCRydWxlRXJyKSArICcgPSB2RXJyb3JzWycgKyAoJGkpICsgJ107IGlmICgnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPT09IHVuZGVmaW5lZCkgJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID0gKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnOyBpZiAoJyArICgkcnVsZUVycikgKyAnLnNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCkgeyAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hUGF0aCA9IFwiJyArICgkZXJyU2NoZW1hUGF0aCkgKyAnXCI7IH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hID0gJyArICgkc2NoZW1hVmFsdWUpICsgJzsgJyArICgkcnVsZUVycikgKyAnLmRhdGEgPSAnICsgKCRkYXRhKSArICc7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRyRGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKGRlZl9jdXN0b21FcnJvcikgKyAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsgJyArIChkZWZfY3VzdG9tRXJyb3IpICsgJyB9IGVsc2UgeyAgZm9yICh2YXIgJyArICgkaSkgKyAnPScgKyAoJGVycnMpICsgJzsgJyArICgkaSkgKyAnPGVycm9yczsgJyArICgkaSkgKyAnKyspIHsgdmFyICcgKyAoJHJ1bGVFcnIpICsgJyA9IHZFcnJvcnNbJyArICgkaSkgKyAnXTsgaWYgKCcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9PT0gdW5kZWZpbmVkKSAnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPSAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICc7IGlmICgnICsgKCRydWxlRXJyKSArICcuc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkKSB7ICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWFQYXRoID0gXCInICsgKCRlcnJTY2hlbWFQYXRoKSArICdcIjsgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWEgPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnOyAnICsgKCRydWxlRXJyKSArICcuZGF0YSA9ICcgKyAoJGRhdGEpICsgJzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSB9ICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRtYWNybykge1xuICAgICAgb3V0ICs9ICcgICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ2N1c3RvbScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsga2V5d29yZDogXFwnJyArICgkcnVsZS5rZXl3b3JkKSArICdcXCcgfSAnO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBwYXNzIFwiJyArICgkcnVsZS5rZXl3b3JkKSArICdcIiBrZXl3b3JkIHZhbGlkYXRpb25cXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZFcnJvcnMpOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJHJEZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAnICsgKGRlZl9jdXN0b21FcnJvcikgKyAnICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyBpZiAoQXJyYXkuaXNBcnJheSgnICsgKCRydWxlRXJycykgKyAnKSkgeyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9ICcgKyAoJHJ1bGVFcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJHJ1bGVFcnJzKSArICcpOyBlcnJvcnMgPSB2RXJyb3JzLmxlbmd0aDsgIGZvciAodmFyICcgKyAoJGkpICsgJz0nICsgKCRlcnJzKSArICc7ICcgKyAoJGkpICsgJzxlcnJvcnM7ICcgKyAoJGkpICsgJysrKSB7IHZhciAnICsgKCRydWxlRXJyKSArICcgPSB2RXJyb3JzWycgKyAoJGkpICsgJ107IGlmICgnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPT09IHVuZGVmaW5lZCkgJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID0gKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnOyAgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYVBhdGggPSBcIicgKyAoJGVyclNjaGVtYVBhdGgpICsgJ1wiOyAgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWEgPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnOyAnICsgKCRydWxlRXJyKSArICcuZGF0YSA9ICcgKyAoJGRhdGEpICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9IH0gZWxzZSB7ICcgKyAoZGVmX2N1c3RvbUVycm9yKSArICcgfSAnO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWV0YVNjaGVtYSA9IHJlcXVpcmUoJy4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAkaWQ6ICdodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvYmxvYi9tYXN0ZXIvbGliL2RlZmluaXRpb25fc2NoZW1hLmpzJyxcbiAgZGVmaW5pdGlvbnM6IHtcbiAgICBzaW1wbGVUeXBlczogbWV0YVNjaGVtYS5kZWZpbml0aW9ucy5zaW1wbGVUeXBlc1xuICB9LFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgc2NoZW1hOiBbJ3ZhbGlkYXRlJ10sXG4gICAgJGRhdGE6IFsndmFsaWRhdGUnXSxcbiAgICBzdGF0ZW1lbnRzOiBbJ2lubGluZSddLFxuICAgIHZhbGlkOiB7bm90OiB7cmVxdWlyZWQ6IFsnbWFjcm8nXX19XG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiBtZXRhU2NoZW1hLnByb3BlcnRpZXMudHlwZSxcbiAgICBzY2hlbWE6IHt0eXBlOiAnYm9vbGVhbid9LFxuICAgIHN0YXRlbWVudHM6IHt0eXBlOiAnYm9vbGVhbid9LFxuICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9XG4gICAgfSxcbiAgICBtZXRhU2NoZW1hOiB7dHlwZTogJ29iamVjdCd9LFxuICAgIG1vZGlmeWluZzoge3R5cGU6ICdib29sZWFuJ30sXG4gICAgdmFsaWQ6IHt0eXBlOiAnYm9vbGVhbid9LFxuICAgICRkYXRhOiB7dHlwZTogJ2Jvb2xlYW4nfSxcbiAgICBhc3luYzoge3R5cGU6ICdib29sZWFuJ30sXG4gICAgZXJyb3JzOiB7XG4gICAgICBhbnlPZjogW1xuICAgICAgICB7dHlwZTogJ2Jvb2xlYW4nfSxcbiAgICAgICAge2NvbnN0OiAnZnVsbCd9XG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuIiwie1xuICAgIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgXCJ0aXRsZVwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwiaXRlbXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgICAgICB9LFxuICAgICAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIjogMFxuICAgICAgICB9LFxuICAgICAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgICAgICAgIFwiYWxsT2ZcIjogW1xuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICAgICAgICAgIHsgXCJkZWZhdWx0XCI6IDAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICAgICAgXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIFwibnVsbFwiLFxuICAgICAgICAgICAgICAgIFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RyaW5nQXJyYXlcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidHlwZVwiOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiJGlkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkc2NoZW1hXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgICAgICB9LFxuICAgICAgICBcIiRyZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgICAgICB9LFxuICAgICAgICBcIiRjb21tZW50XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGl0bGVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgICAgXCJyZWFkT25seVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJleGFtcGxlc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwibXVsdGlwbGVPZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4aW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtaW5pbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1heExlbmd0aFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCIgfSxcbiAgICAgICAgXCJtaW5MZW5ndGhcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCIgfSxcbiAgICAgICAgXCJwYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJyZWdleFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWRkaXRpb25hbEl0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhJdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCIgfSxcbiAgICAgICAgXCJtaW5JdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImNvbnRhaW5zXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgIFwibWF4UHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCIgfSxcbiAgICAgICAgXCJtaW5Qcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiIH0sXG4gICAgICAgIFwicmVxdWlyZWRcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfSxcbiAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICBcImRlZmluaXRpb25zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgICAgICB9LFxuICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHsgXCJmb3JtYXRcIjogXCJyZWdleFwiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHRydWUsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcImZvcm1hdFwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXG4gICAgICAgIFwiY29udGVudE1lZGlhVHlwZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXG4gICAgICAgIFwiY29udGVudEVuY29kaW5nXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXCJpZlwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgICAgXCJ0aGVuXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICAgIFwiYWxsT2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgICAgXCJhbnlPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgICBcIm9uZU9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICAgIFwibm90XCI6IHsgXCIkcmVmXCI6IFwiI1wiIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB0cnVlXG59XG4iLCJ7XG4gICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgXCIkaWRcIjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWV0YS1zY2hlbWEgZm9yICRkYXRhIHJlZmVyZW5jZSAoSlNPTiBTY2hlbWEgZXh0ZW5zaW9uIHByb3Bvc2FsKVwiLFxuICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgIFwicmVxdWlyZWRcIjogWyBcIiRkYXRhXCIgXSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcIiRkYXRhXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcImZvcm1hdFwiOiBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiIH0sIFxuICAgICAgICAgICAgICAgIHsgXCJmb3JtYXRcIjogXCJqc29uLXBvaW50ZXJcIiB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TU0VDbGllbnRUcmFuc3BvcnQgPSBleHBvcnRzLlNzZUVycm9yID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzb3VyY2VfMSA9IHJlcXVpcmUoXCJldmVudHNvdXJjZVwiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmpzXCIpO1xuY2xhc3MgU3NlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZXZlbnQpIHtcbiAgICAgICAgc3VwZXIoYFNTRSBlcnJvcjogJHttZXNzYWdlfWApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5Tc2VFcnJvciA9IFNzZUVycm9yO1xuLyoqXG4gKiBDbGllbnQgdHJhbnNwb3J0IGZvciBTU0U6IHRoaXMgd2lsbCBjb25uZWN0IHRvIGEgc2VydmVyIHVzaW5nIFNlcnZlci1TZW50IEV2ZW50cyBmb3IgcmVjZWl2aW5nXG4gKiBtZXNzYWdlcyBhbmQgbWFrZSBzZXBhcmF0ZSBQT1NUIHJlcXVlc3RzIGZvciBzZW5kaW5nIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBTU0VDbGllbnRUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlTWV0YWRhdGFVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2V2ZW50U291cmNlSW5pdCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudFNvdXJjZUluaXQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJbml0ID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RJbml0O1xuICAgICAgICB0aGlzLl9hdXRoUHJvdmlkZXIgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYXV0aFByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9mZXRjaCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mZXRjaDtcbiAgICB9XG4gICAgYXN5bmMgX2F1dGhUaGVuU3RhcnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRoUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhdXRoX2pzXzEuVW5hdXRob3JpemVkRXJyb3IoJ05vIGF1dGggcHJvdmlkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgKDAsIGF1dGhfanNfMS5hdXRoKSh0aGlzLl9hdXRoUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJVcmw6IHRoaXMuX3VybCxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU1ldGFkYXRhVXJsOiB0aGlzLl9yZXNvdXJjZU1ldGFkYXRhVXJsLFxuICAgICAgICAgICAgICAgIGZldGNoRm46IHRoaXMuX2ZldGNoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMub25lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gJ0FVVEhPUklaRUQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYXV0aF9qc18xLlVuYXV0aG9yaXplZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3N0YXJ0T3JBdXRoKCk7XG4gICAgfVxuICAgIGFzeW5jIF9jb21tb25IZWFkZXJzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5fYXV0aFByb3ZpZGVyLnRva2VucygpO1xuICAgICAgICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbnMuYWNjZXNzX3Rva2VufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgICAgaGVhZGVyc1snbWNwLXByb3RvY29sLXZlcnNpb24nXSA9IHRoaXMuX3Byb3RvY29sVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlYWRlcnMoeyAuLi5oZWFkZXJzLCAuLi4oX2EgPSB0aGlzLl9yZXF1ZXN0SW5pdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMgfSk7XG4gICAgfVxuICAgIF9zdGFydE9yQXV0aCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGZldGNoSW1wbCA9ICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuX2V2ZW50U291cmNlSW5pdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZldGNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLl9mZXRjaCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmV0Y2gpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2UgPSBuZXcgZXZlbnRzb3VyY2VfMS5FdmVudFNvdXJjZSh0aGlzLl91cmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2V2ZW50U291cmNlSW5pdCxcbiAgICAgICAgICAgICAgICBmZXRjaDogYXN5bmMgKHVybCwgaW5pdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5fY29tbW9uSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQWNjZXB0JywgJ3RleHQvZXZlbnQtc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiByZXNwb25zZS5oZWFkZXJzLmhhcygnd3d3LWF1dGhlbnRpY2F0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvdXJjZU1ldGFkYXRhVXJsID0gKDAsIGF1dGhfanNfMS5leHRyYWN0UmVzb3VyY2VNZXRhZGF0YVVybCkocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U291cmNlLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb2RlID09PSA0MDEgJiYgdGhpcy5fYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhUaGVuU3RhcnQoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU3NlRXJyb3IoZXZlbnQuY29kZSwgZXZlbnQubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4sIGJ1dCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBlbmRwb2ludCB0byBiZSByZWNlaXZlZC5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlbmRwb2ludCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmRwb2ludCA9IG5ldyBVUkwobWVzc2FnZUV2ZW50LmRhdGEsIHRoaXMuX3VybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmRwb2ludC5vcmlnaW4gIT09IHRoaXMuX3VybC5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5kcG9pbnQgb3JpZ2luIGRvZXMgbm90IG1hdGNoIGNvbm5lY3Rpb24gb3JpZ2luOiAke3RoaXMuX2VuZHBvaW50Lm9yaWdpbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdHlwZXNfanNfMS5KU09OUlBDTWVzc2FnZVNjaGVtYS5wYXJzZShKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLm9ubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudFNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTU0VDbGllbnRUcmFuc3BvcnQgYWxyZWFkeSBzdGFydGVkISBJZiB1c2luZyBDbGllbnQgY2xhc3MsIG5vdGUgdGhhdCBjb25uZWN0KCkgY2FsbHMgc3RhcnQoKSBhdXRvbWF0aWNhbGx5LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zdGFydE9yQXV0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGFmdGVyIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBhdXRob3JpemluZyB2aWEgdGhlaXIgdXNlciBhZ2VudCBhbmQgaXMgcmVkaXJlY3RlZCBiYWNrIHRvIHRoZSBNQ1AgY2xpZW50IGFwcGxpY2F0aW9uLiBUaGlzIHdpbGwgZXhjaGFuZ2UgdGhlIGF1dGhvcml6YXRpb24gY29kZSBmb3IgYW4gYWNjZXNzIHRva2VuLCBlbmFibGluZyB0aGUgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgdG8gc3VjY2Vzc2Z1bGx5IGF1dGguXG4gICAgICovXG4gICAgYXN5bmMgZmluaXNoQXV0aChhdXRob3JpemF0aW9uQ29kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2F1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGF1dGhfanNfMS5VbmF1dGhvcml6ZWRFcnJvcignTm8gYXV0aCBwcm92aWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBhdXRoX2pzXzEuYXV0aCkodGhpcy5fYXV0aFByb3ZpZGVyLCB7XG4gICAgICAgICAgICBzZXJ2ZXJVcmw6IHRoaXMuX3VybCxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Db2RlLFxuICAgICAgICAgICAgcmVzb3VyY2VNZXRhZGF0YVVybDogdGhpcy5fcmVzb3VyY2VNZXRhZGF0YVVybCxcbiAgICAgICAgICAgIGZldGNoRm46IHRoaXMuX2ZldGNoXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSAnQVVUSE9SSVpFRCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhdXRoX2pzXzEuVW5hdXRob3JpemVkRXJyb3IoJ0ZhaWxlZCB0byBhdXRob3JpemUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIChfYSA9IHRoaXMuX2Fib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuX2V2ZW50U291cmNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xvc2UoKTtcbiAgICAgICAgKF9jID0gdGhpcy5vbmNsb3NlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoIXRoaXMuX2VuZHBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMuX2NvbW1vbkhlYWRlcnMoKTtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgY29uc3QgaW5pdCA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9yZXF1ZXN0SW5pdCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogKF9hID0gdGhpcy5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoKF9iID0gdGhpcy5fZmV0Y2gpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZldGNoKSh0aGlzLl9lbmRwb2ludCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIHRoaXMuX2F1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvdXJjZU1ldGFkYXRhVXJsID0gKDAsIGF1dGhfanNfMS5leHRyYWN0UmVzb3VyY2VNZXRhZGF0YVVybCkocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgYXV0aF9qc18xLmF1dGgpKHRoaXMuX2F1dGhQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyVXJsOiB0aGlzLl91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZU1ldGFkYXRhVXJsOiB0aGlzLl9yZXNvdXJjZU1ldGFkYXRhVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hGbjogdGhpcy5fZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09ICdBVVRIT1JJWkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGF1dGhfanNfMS5VbmF1dGhvcml6ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFB1cnBvc2VseSBfbm90XyBhd2FpdGVkLCBzbyB3ZSBkb24ndCBjYWxsIG9uZXJyb3IgdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIFBPU1RpbmcgdG8gZW5kcG9pbnQgKEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9KTogJHt0ZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQcm90b2NvbFZlcnNpb24odmVyc2lvbikge1xuICAgICAgICB0aGlzLl9wcm90b2NvbFZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuU1NFQ2xpZW50VHJhbnNwb3J0ID0gU1NFQ2xpZW50VHJhbnNwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3NlLmpzLm1hcCIsbnVsbCwiaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYEVycm9yRXZlbnRgIGluc3RhbmNlLiBUaGlzIGlzIHR5cGljYWxseSBub3QgY2FsbGVkIGRpcmVjdGx5LFxuICAgKiBidXQgcmF0aGVyIGVtaXR0ZWQgYnkgdGhlIGBFdmVudFNvdXJjZWAgb2JqZWN0IHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoc2hvdWxkIGJlIFwiZXJyb3JcIilcbiAgICogQHBhcmFtIGVycm9yRXZlbnRJbml0RGljdCAtIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGVycm9yRXZlbnRJbml0RGljdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgc3VwZXIodHlwZSksIHRoaXMuY29kZSA9IChfYSA9IGVycm9yRXZlbnRJbml0RGljdCA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JFdmVudEluaXREaWN0LmNvZGUpICE9IG51bGwgPyBfYSA6IHZvaWQgMCwgdGhpcy5tZXNzYWdlID0gKF9iID0gZXJyb3JFdmVudEluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckV2ZW50SW5pdERpY3QubWVzc2FnZSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBOb2RlLmpzIFwiaGlkZXNcIiB0aGUgYG1lc3NhZ2VgIGFuZCBgY29kZWAgcHJvcGVydGllcyBvZiB0aGUgYEVycm9yRXZlbnRgIGluc3RhbmNlLFxuICAgKiB3aGVuIGl0IGlzIGBjb25zb2xlLmxvZ2AnZWQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGRlYnVnIGVycm9ycy4gVG8gZWFzZSBkZWJ1Z2dpbmcsXG4gICAqIHdlIGV4cGxpY2l0bHkgaW5jbHVkZSB0aGUgcHJvcGVydGllcyBpbiB0aGUgYGluc3BlY3RgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBOb2RlLmpzIHdoZW4geW91IGBjb25zb2xlLmxvZ2AgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIF9kZXB0aCAtIFRoZSBjdXJyZW50IGRlcHRoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGB1dGlsLmluc3BlY3RgXG4gICAqIEBwYXJhbSBpbnNwZWN0IC0gVGhlIGluc3BlY3QgZnVuY3Rpb24gdG8gdXNlIChwcmV2ZW50cyBoYXZpbmcgdG8gaW1wb3J0IGl0IGZyb20gYHV0aWxgKVxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3JcbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKF9kZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgIHJldHVybiBpbnNwZWN0KGluc3BlY3RhYmxlRXJyb3IodGhpcyksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZW5vIFwiaGlkZXNcIiB0aGUgYG1lc3NhZ2VgIGFuZCBgY29kZWAgcHJvcGVydGllcyBvZiB0aGUgYEVycm9yRXZlbnRgIGluc3RhbmNlLFxuICAgKiB3aGVuIGl0IGlzIGBjb25zb2xlLmxvZ2AnZWQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGRlYnVnIGVycm9ycy4gVG8gZWFzZSBkZWJ1Z2dpbmcsXG4gICAqIHdlIGV4cGxpY2l0bHkgaW5jbHVkZSB0aGUgcHJvcGVydGllcyBpbiB0aGUgYGluc3BlY3RgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBEZW5vIHdoZW4geW91IGBjb25zb2xlLmxvZ2AgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIGluc3BlY3QgLSBUaGUgaW5zcGVjdCBmdW5jdGlvbiB0byB1c2UgKHByZXZlbnRzIGhhdmluZyB0byBpbXBvcnQgaXQgZnJvbSBgdXRpbGApXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGBEZW5vLmluc3BlY3RgXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJEZW5vLmN1c3RvbUluc3BlY3RcIildKGluc3BlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zcGVjdChpbnNwZWN0YWJsZUVycm9yKHRoaXMpLCBvcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gc3ludGF4RXJyb3IobWVzc2FnZSkge1xuICBjb25zdCBEb21FeGNlcHRpb24gPSBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbjtcbiAgcmV0dXJuIHR5cGVvZiBEb21FeGNlcHRpb24gPT0gXCJmdW5jdGlvblwiID8gbmV3IERvbUV4Y2VwdGlvbihtZXNzYWdlLCBcIlN5bnRheEVycm9yXCIpIDogbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkVycm9yKGVycikge1xuICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yc1wiIGluIGVyciAmJiBBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpID8gZXJyLmVycm9ycy5tYXAoZmxhdHRlbkVycm9yKS5qb2luKFwiLCBcIikgOiBcImNhdXNlXCIgaW4gZXJyICYmIGVyci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyfTogJHtmbGF0dGVuRXJyb3IoZXJyLmNhdXNlKX1gIDogZXJyLm1lc3NhZ2UgOiBgJHtlcnJ9YDtcbn1cbmZ1bmN0aW9uIGluc3BlY3RhYmxlRXJyb3IoZXJyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXJyLnR5cGUsXG4gICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgY29kZTogZXJyLmNvZGUsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZXJyLmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgY2FuY2VsYWJsZTogZXJyLmNhbmNlbGFibGUsXG4gICAgdGltZVN0YW1wOiBlcnIudGltZVN0YW1wXG4gIH07XG59XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufSwgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpLCBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpLCBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSksIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCksIF9yZWFkeVN0YXRlLCBfdXJsLCBfcmVkaXJlY3RVcmwsIF93aXRoQ3JlZGVudGlhbHMsIF9mZXRjaCwgX3JlY29ubmVjdEludGVydmFsLCBfcmVjb25uZWN0VGltZXIsIF9sYXN0RXZlbnRJZCwgX2NvbnRyb2xsZXIsIF9wYXJzZXIsIF9vbkVycm9yLCBfb25NZXNzYWdlLCBfb25PcGVuLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBjb25uZWN0X2ZuLCBfb25GZXRjaFJlc3BvbnNlLCBfb25GZXRjaEVycm9yLCBnZXRSZXF1ZXN0T3B0aW9uc19mbiwgX29uRXZlbnQsIF9vblJldHJ5Q2hhbmdlLCBmYWlsQ29ubmVjdGlvbl9mbiwgc2NoZWR1bGVSZWNvbm5lY3RfZm4sIF9yZWNvbm5lY3Q7XG5jbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IodXJsLCBldmVudFNvdXJjZUluaXREaWN0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdXBlcigpLCBfX3ByaXZhdGVBZGQodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcyksIHRoaXMuQ09OTkVDVElORyA9IDAsIHRoaXMuT1BFTiA9IDEsIHRoaXMuQ0xPU0VEID0gMiwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWFkeVN0YXRlKSwgX19wcml2YXRlQWRkKHRoaXMsIF91cmwpLCBfX3ByaXZhdGVBZGQodGhpcywgX3JlZGlyZWN0VXJsKSwgX19wcml2YXRlQWRkKHRoaXMsIF93aXRoQ3JlZGVudGlhbHMpLCBfX3ByaXZhdGVBZGQodGhpcywgX2ZldGNoKSwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWNvbm5lY3RJbnRlcnZhbCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmVjb25uZWN0VGltZXIpLCBfX3ByaXZhdGVBZGQodGhpcywgX2xhc3RFdmVudElkLCBudWxsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9jb250cm9sbGVyKSwgX19wcml2YXRlQWRkKHRoaXMsIF9wYXJzZXIpLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRXJyb3IsIG51bGwpLCBfX3ByaXZhdGVBZGQodGhpcywgX29uTWVzc2FnZSwgbnVsbCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25PcGVuLCBudWxsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9vbkZldGNoUmVzcG9uc2UsIGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyc2VyKS5yZXNldCgpO1xuICAgICAgY29uc3QgeyBib2R5LCByZWRpcmVjdGVkLCBzdGF0dXMsIGhlYWRlcnMgfSA9IHJlc3BvbnNlO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBmYWlsQ29ubmVjdGlvbl9mbikuY2FsbCh0aGlzLCBcIlNlcnZlciBzZW50IEhUVFAgMjA0LCBub3QgcmVjb25uZWN0aW5nXCIsIDIwNCksIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlZGlyZWN0ZWQgPyBfX3ByaXZhdGVTZXQodGhpcywgX3JlZGlyZWN0VXJsLCBuZXcgVVJMKHJlc3BvbnNlLnVybCkpIDogX19wcml2YXRlU2V0KHRoaXMsIF9yZWRpcmVjdFVybCwgdm9pZCAwKSwgc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGZhaWxDb25uZWN0aW9uX2ZuKS5jYWxsKHRoaXMsIGBOb24tMjAwIHN0YXR1cyBjb2RlICgke3N0YXR1c30pYCwgc3RhdHVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuc3RhcnRzV2l0aChcInRleHQvZXZlbnQtc3RyZWFtXCIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBmYWlsQ29ubmVjdGlvbl9mbikuY2FsbCh0aGlzLCAnSW52YWxpZCBjb250ZW50IHR5cGUsIGV4cGVjdGVkIFwidGV4dC9ldmVudC1zdHJlYW1cIicsIHN0YXR1cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpID09PSB0aGlzLkNMT1NFRClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWFkeVN0YXRlLCB0aGlzLk9QRU4pO1xuICAgICAgY29uc3Qgb3BlbkV2ZW50ID0gbmV3IEV2ZW50KFwib3BlblwiKTtcbiAgICAgIGlmICgoX2EyID0gX19wcml2YXRlR2V0KHRoaXMsIF9vbk9wZW4pKSA9PSBudWxsIHx8IF9hMi5jYWxsKHRoaXMsIG9wZW5FdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChvcGVuRXZlbnQpLCB0eXBlb2YgYm9keSAhPSBcIm9iamVjdFwiIHx8ICFib2R5IHx8ICEoXCJnZXRSZWFkZXJcIiBpbiBib2R5KSkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgZmFpbENvbm5lY3Rpb25fZm4pLmNhbGwodGhpcywgXCJJbnZhbGlkIHJlc3BvbnNlIGJvZHksIGV4cGVjdGVkIGEgd2ViIFJlYWRhYmxlU3RyZWFtXCIsIHN0YXR1cyksIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICAgICAgbGV0IG9wZW4gPSAhMDtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgdmFsdWUgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJzZXIpLmZlZWQoZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiAhZG9uZSB9KSksIGRvbmUgJiYgKG9wZW4gPSAhMSwgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJzZXIpLnJlc2V0KCksIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBzY2hlZHVsZVJlY29ubmVjdF9mbikuY2FsbCh0aGlzKSk7XG4gICAgICB9IHdoaWxlIChvcGVuKTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9vbkZldGNoRXJyb3IsIChlcnIpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29udHJvbGxlciwgdm9pZCAwKSwgIShlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyLnR5cGUgPT09IFwiYWJvcnRlZFwiKSAmJiBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgc2NoZWR1bGVSZWNvbm5lY3RfZm4pLmNhbGwodGhpcywgZmxhdHRlbkVycm9yKGVycikpO1xuICAgIH0pLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRXZlbnQsIChldmVudCkgPT4ge1xuICAgICAgdHlwZW9mIGV2ZW50LmlkID09IFwic3RyaW5nXCIgJiYgX19wcml2YXRlU2V0KHRoaXMsIF9sYXN0RXZlbnRJZCwgZXZlbnQuaWQpO1xuICAgICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChldmVudC5ldmVudCB8fCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICBvcmlnaW46IF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVkaXJlY3RVcmwpID8gX19wcml2YXRlR2V0KHRoaXMsIF9yZWRpcmVjdFVybCkub3JpZ2luIDogX19wcml2YXRlR2V0KHRoaXMsIF91cmwpLm9yaWdpbixcbiAgICAgICAgbGFzdEV2ZW50SWQ6IGV2ZW50LmlkIHx8IFwiXCJcbiAgICAgIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9vbk1lc3NhZ2UpICYmICghZXZlbnQuZXZlbnQgfHwgZXZlbnQuZXZlbnQgPT09IFwibWVzc2FnZVwiKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX29uTWVzc2FnZSkuY2FsbCh0aGlzLCBtZXNzYWdlRXZlbnQpLCB0aGlzLmRpc3BhdGNoRXZlbnQobWVzc2FnZUV2ZW50KTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9vblJldHJ5Q2hhbmdlLCAodmFsdWUpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0SW50ZXJ2YWwsIHZhbHVlKTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWNvbm5lY3QsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0VGltZXIsIHZvaWQgMCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVhZHlTdGF0ZSkgPT09IHRoaXMuQ09OTkVDVElORyAmJiBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgY29ubmVjdF9mbikuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFVSTClcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIHVybCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdXJsID09IFwic3RyaW5nXCIpXG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdXJsLCBuZXcgVVJMKHVybCwgZ2V0QmFzZVVSTCgpKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVJMXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGFyc2VyLCBjcmVhdGVQYXJzZXIoe1xuICAgICAgb25FdmVudDogX19wcml2YXRlR2V0KHRoaXMsIF9vbkV2ZW50KSxcbiAgICAgIG9uUmV0cnk6IF9fcHJpdmF0ZUdldCh0aGlzLCBfb25SZXRyeUNoYW5nZSlcbiAgICB9KSksIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVhZHlTdGF0ZSwgdGhpcy5DT05ORUNUSU5HKSwgX19wcml2YXRlU2V0KHRoaXMsIF9yZWNvbm5lY3RJbnRlcnZhbCwgM2UzKSwgX19wcml2YXRlU2V0KHRoaXMsIF9mZXRjaCwgKF9hID0gZXZlbnRTb3VyY2VJbml0RGljdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRTb3VyY2VJbml0RGljdC5mZXRjaCkgIT0gbnVsbCA/IF9hIDogZ2xvYmFsVGhpcy5mZXRjaCksIF9fcHJpdmF0ZVNldCh0aGlzLCBfd2l0aENyZWRlbnRpYWxzLCAoX2IgPSBldmVudFNvdXJjZUluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscykgIT0gbnVsbCA/IF9iIDogITEpLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgY29ubmVjdF9mbikuY2FsbCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhpcyBFdmVudFNvdXJjZSBvYmplY3QncyBjb25uZWN0aW9uLiBJdCBjYW4gaGF2ZSB0aGUgdmFsdWVzIGRlc2NyaWJlZCBiZWxvdy5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9yZWFkeVN0YXRlKVxuICAgKlxuICAgKiBOb3RlOiB0eXBlZCBhcyBgbnVtYmVyYCBpbnN0ZWFkIG9mIGAwIHwgMSB8IDJgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGBFdmVudFNvdXJjZWAgaW50ZXJmYWNlLFxuICAgKiBkZWZpbmVkIGluIHRoZSBUeXBlU2NyaXB0IGBkb21gIGxpYnJhcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0uXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvdXJsKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3VybCkuaHJlZjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjcmVkZW50aWFscyBtb2RlIGZvciBjb25uZWN0aW9uIHJlcXVlc3RzIHRvIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0gaXMgc2V0IHRvIFwiaW5jbHVkZVwiLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL3dpdGhDcmVkZW50aWFscylcbiAgICovXG4gIGdldCB3aXRoQ3JlZGVudGlhbHMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfd2l0aENyZWRlbnRpYWxzKTtcbiAgfVxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9lcnJvcl9ldmVudCkgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25FcnJvcik7XG4gIH1cbiAgc2V0IG9uZXJyb3IodmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29uRXJyb3IsIHZhbHVlKTtcbiAgfVxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9tZXNzYWdlX2V2ZW50KSAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29uTWVzc2FnZSk7XG4gIH1cbiAgc2V0IG9ubWVzc2FnZSh2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb25NZXNzYWdlLCB2YWx1ZSk7XG4gIH1cbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2Uvb3Blbl9ldmVudCkgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9vbk9wZW4pO1xuICB9XG4gIHNldCBvbm9wZW4odmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29uT3BlbiwgdmFsdWUpO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaXN0ZW4gPSBsaXN0ZW5lcjtcbiAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3Rlbiwgb3B0aW9ucyk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpc3RlbiA9IGxpc3RlbmVyO1xuICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQWJvcnRzIGFueSBpbnN0YW5jZXMgb2YgdGhlIGZldGNoIGFsZ29yaXRobSBzdGFydGVkIGZvciB0aGlzIEV2ZW50U291cmNlIG9iamVjdCwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFRC5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9jbG9zZSlcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9yZWNvbm5lY3RUaW1lcikgJiYgY2xlYXJUaW1lb3V0KF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVjb25uZWN0VGltZXIpKSwgX19wcml2YXRlR2V0KHRoaXMsIF9yZWFkeVN0YXRlKSAhPT0gdGhpcy5DTE9TRUQgJiYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKS5hYm9ydCgpLCBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ0xPU0VEKSwgX19wcml2YXRlU2V0KHRoaXMsIF9jb250cm9sbGVyLCB2b2lkIDApKTtcbiAgfVxufVxuX3JlYWR5U3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3VybCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfcmVkaXJlY3RVcmwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3dpdGhDcmVkZW50aWFscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfZmV0Y2ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3JlY29ubmVjdEludGVydmFsID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9yZWNvbm5lY3RUaW1lciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfbGFzdEV2ZW50SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX2NvbnRyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3BhcnNlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25NZXNzYWdlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9vbk9wZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U291cmNlX2luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpLCAvKipcbiogQ29ubmVjdCB0byB0aGUgZ2l2ZW4gVVJMIGFuZCBzdGFydCByZWNlaXZpbmcgZXZlbnRzXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmNvbm5lY3RfZm4gPSBmdW5jdGlvbigpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWFkeVN0YXRlLCB0aGlzLkNPTk5FQ1RJTkcpLCBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIG5ldyBBYm9ydENvbnRyb2xsZXIoKSksIF9fcHJpdmF0ZUdldCh0aGlzLCBfZmV0Y2gpKF9fcHJpdmF0ZUdldCh0aGlzLCBfdXJsKSwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGdldFJlcXVlc3RPcHRpb25zX2ZuKS5jYWxsKHRoaXMpKS50aGVuKF9fcHJpdmF0ZUdldCh0aGlzLCBfb25GZXRjaFJlc3BvbnNlKSkuY2F0Y2goX19wcml2YXRlR2V0KHRoaXMsIF9vbkZldGNoRXJyb3IpKTtcbn0sIF9vbkZldGNoUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX29uRmV0Y2hFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAvKipcbiogR2V0IHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIGBmZXRjaCgpYCByZXF1ZXN0XG4qXG4qIEByZXR1cm5zIFRoZSByZXF1ZXN0IG9wdGlvbnNcbiogQGludGVybmFsXG4qL1xuZ2V0UmVxdWVzdE9wdGlvbnNfZm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBpbml0ID0ge1xuICAgIC8vIFtzcGVjXSBMZXQgYGNvcnNBdHRyaWJ1dGVTdGF0ZWAgYmUgYEFub255bW91c2DigKZcbiAgICAvLyBbc3BlY10g4oCmd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wi4oCmXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgaGVhZGVyczogeyBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIiwgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9sYXN0RXZlbnRJZCkgPyB7IFwiTGFzdC1FdmVudC1JRFwiOiBfX3ByaXZhdGVHZXQodGhpcywgX2xhc3RFdmVudElkKSB9IDogdm9pZCAwIH0sXG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICBzaWduYWw6IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWxcbiAgfTtcbiAgcmV0dXJuIFwid2luZG93XCIgaW4gZ2xvYmFsVGhpcyAmJiAoaW5pdC5jcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIpLCBpbml0O1xufSwgX29uRXZlbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX29uUmV0cnlDaGFuZ2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgLyoqXG4qIEhhbmRsZXMgdGhlIHByb2Nlc3MgcmVmZXJyZWQgdG8gaW4gdGhlIEV2ZW50U291cmNlIHNwZWNpZmljYXRpb24gYXMgXCJmYWlsaW5nIGEgY29ubmVjdGlvblwiLlxuKlxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsXG4qIEBwYXJhbSBjb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGUsIGlmIGF2YWlsYWJsZVxuKiBAaW50ZXJuYWxcbiovXG5mYWlsQ29ubmVjdGlvbl9mbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdmFyIF9hO1xuICBfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpICE9PSB0aGlzLkNMT1NFRCAmJiBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ0xPU0VEKTtcbiAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBjb2RlLCBtZXNzYWdlIH0pO1xuICAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX29uRXJyb3IpKSA9PSBudWxsIHx8IF9hLmNhbGwodGhpcywgZXJyb3JFdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcbn0sIC8qKlxuKiBTY2hlZHVsZXMgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBhZ2FpbnN0IHRoZSBFdmVudFNvdXJjZSBlbmRwb2ludC5cbipcbiogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsXG4qIEBwYXJhbSBjb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGUsIGlmIGF2YWlsYWJsZVxuKiBAaW50ZXJuYWxcbiovXG5zY2hlZHVsZVJlY29ubmVjdF9mbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdmFyIF9hO1xuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9yZWFkeVN0YXRlKSA9PT0gdGhpcy5DTE9TRUQpXG4gICAgcmV0dXJuO1xuICBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ09OTkVDVElORyk7XG4gIGNvbnN0IGVycm9yRXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHsgY29kZSwgbWVzc2FnZSB9KTtcbiAgKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9vbkVycm9yKSkgPT0gbnVsbCB8fCBfYS5jYWxsKHRoaXMsIGVycm9yRXZlbnQpLCB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudCksIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0VGltZXIsIHNldFRpbWVvdXQoX19wcml2YXRlR2V0KHRoaXMsIF9yZWNvbm5lY3QpLCBfX3ByaXZhdGVHZXQodGhpcywgX3JlY29ubmVjdEludGVydmFsKSkpO1xufSwgX3JlY29ubmVjdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAvKipcbiogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4qXG4qIEBwdWJsaWNcbiovXG5FdmVudFNvdXJjZS5DT05ORUNUSU5HID0gMCwgLyoqXG4qIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBvcGVuIChlZyBjb25uZWN0ZWQpXG4qXG4qIEBwdWJsaWNcbiovXG5FdmVudFNvdXJjZS5PUEVOID0gMSwgLyoqXG4qIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBjbG9zZWQgKGVnIGRpc2Nvbm5lY3RlZClcbipcbiogQHB1YmxpY1xuKi9cbkV2ZW50U291cmNlLkNMT1NFRCA9IDI7XG5mdW5jdGlvbiBnZXRCYXNlVVJMKCkge1xuICBjb25zdCBkb2MgPSBcImRvY3VtZW50XCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuZG9jdW1lbnQgOiB2b2lkIDA7XG4gIHJldHVybiBkb2MgJiYgdHlwZW9mIGRvYyA9PSBcIm9iamVjdFwiICYmIFwiYmFzZVVSSVwiIGluIGRvYyAmJiB0eXBlb2YgZG9jLmJhc2VVUkkgPT0gXCJzdHJpbmdcIiA/IGRvYy5iYXNlVVJJIDogdm9pZCAwO1xufVxuZXhwb3J0IHtcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnRTb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIi8qKlxuICogQW4gZXh0ZW5kZWQgdmVyc2lvbiBvZiB0aGUgYEV2ZW50YCBlbWl0dGVkIGJ5IHRoZSBgRXZlbnRTb3VyY2VgIG9iamVjdCB3aGVuIGFuIGVycm9yIG9jY3Vycy5cbiAqIFdoaWxlIHRoZSBzcGVjIGRvZXMgbm90IGluY2x1ZGUgYW55IGFkZGl0aW9uYWwgcHJvcGVydGllcywgd2UgaW50ZW50aW9uYWxseSBnbyBiZXlvbmQgdGhlIHNwZWNcbiAqIGFuZCBwcm92aWRlIHNvbWUgKG1pbmltYWwpIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gYWlkIGluIGRlYnVnZ2luZy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogSFRUUCBzdGF0dXMgY29kZSwgaWYgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGFuIEhUVFAgZXJyb3JcbiAgICogTm90ZTogdGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYywgYnV0IGlzIGluY2x1ZGVkIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHB1YmxpYyBjb2RlPzogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG1lc3NhZ2UgYXR0YWNoZWQgdG8gdGhlIGVycm9yLlxuICAgKiBOb3RlOiB0aGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjLCBidXQgaXMgaW5jbHVkZWQgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcHVibGljIG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRXJyb3JFdmVudGAgaW5zdGFuY2UuIFRoaXMgaXMgdHlwaWNhbGx5IG5vdCBjYWxsZWQgZGlyZWN0bHksXG4gICAqIGJ1dCByYXRoZXIgZW1pdHRlZCBieSB0aGUgYEV2ZW50U291cmNlYCBvYmplY3Qgd2hlbiBhbiBlcnJvciBvY2N1cnMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IChzaG91bGQgYmUgXCJlcnJvclwiKVxuICAgKiBAcGFyYW0gZXJyb3JFdmVudEluaXREaWN0IC0gT3B0aW9uYWwgcHJvcGVydGllcyB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGVycm9yRXZlbnRJbml0RGljdD86IHttZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkOyBjb2RlPzogbnVtYmVyIHwgdW5kZWZpbmVkfSxcbiAgKSB7XG4gICAgc3VwZXIodHlwZSlcbiAgICB0aGlzLmNvZGUgPSBlcnJvckV2ZW50SW5pdERpY3Q/LmNvZGUgPz8gdW5kZWZpbmVkXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JFdmVudEluaXREaWN0Py5tZXNzYWdlID8/IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIE5vZGUuanMgXCJoaWRlc1wiIHRoZSBgbWVzc2FnZWAgYW5kIGBjb2RlYCBwcm9wZXJ0aWVzIG9mIHRoZSBgRXJyb3JFdmVudGAgaW5zdGFuY2UsXG4gICAqIHdoZW4gaXQgaXMgYGNvbnNvbGUubG9nYCdlZC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gZGVidWcgZXJyb3JzLiBUbyBlYXNlIGRlYnVnZ2luZyxcbiAgICogd2UgZXhwbGljaXRseSBpbmNsdWRlIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBgaW5zcGVjdGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IE5vZGUuanMgd2hlbiB5b3UgYGNvbnNvbGUubG9nYCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gX2RlcHRoIC0gVGhlIGN1cnJlbnQgZGVwdGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gYHV0aWwuaW5zcGVjdGBcbiAgICogQHBhcmFtIGluc3BlY3QgLSBUaGUgaW5zcGVjdCBmdW5jdGlvbiB0byB1c2UgKHByZXZlbnRzIGhhdmluZyB0byBpbXBvcnQgaXQgZnJvbSBgdXRpbGApXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICAgKi9cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKFxuICAgIF9kZXB0aDogbnVtYmVyLFxuICAgIG9wdGlvbnM6IHtjb2xvcnM6IGJvb2xlYW59LFxuICAgIGluc3BlY3Q6IChvYmo6IHVua25vd24sIGluc3BlY3RPcHRpb25zOiB7Y29sb3JzOiBib29sZWFufSkgPT4gc3RyaW5nLFxuICApOiBzdHJpbmcge1xuICAgIHJldHVybiBpbnNwZWN0KGluc3BlY3RhYmxlRXJyb3IodGhpcyksIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVubyBcImhpZGVzXCIgdGhlIGBtZXNzYWdlYCBhbmQgYGNvZGVgIHByb3BlcnRpZXMgb2YgdGhlIGBFcnJvckV2ZW50YCBpbnN0YW5jZSxcbiAgICogd2hlbiBpdCBpcyBgY29uc29sZS5sb2dgJ2VkLiBUaGlzIG1ha2VzIGl0IGhhcmRlciB0byBkZWJ1ZyBlcnJvcnMuIFRvIGVhc2UgZGVidWdnaW5nLFxuICAgKiB3ZSBleHBsaWNpdGx5IGluY2x1ZGUgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGBpbnNwZWN0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgRGVubyB3aGVuIHlvdSBgY29uc29sZS5sb2dgIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBpbnNwZWN0IC0gVGhlIGluc3BlY3QgZnVuY3Rpb24gdG8gdXNlIChwcmV2ZW50cyBoYXZpbmcgdG8gaW1wb3J0IGl0IGZyb20gYHV0aWxgKVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBgRGVuby5pbnNwZWN0YFxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3JcbiAgICovXG4gIFtTeW1ib2wuZm9yKCdEZW5vLmN1c3RvbUluc3BlY3QnKV0oXG4gICAgaW5zcGVjdDogKG9iajogdW5rbm93biwgaW5zcGVjdE9wdGlvbnM6IHtjb2xvcnM6IGJvb2xlYW59KSA9PiBzdHJpbmcsXG4gICAgb3B0aW9uczoge2NvbG9yczogYm9vbGVhbn0sXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGluc3BlY3QoaW5zcGVjdGFibGVFcnJvcih0aGlzKSwgb3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqIEZvciBlbnZpcm9ubWVudHMgd2hlcmUgRE9NRXhjZXB0aW9uIG1heSBub3QgZXhpc3QsIHdlIHdpbGwgdXNlIGEgU3ludGF4RXJyb3IgaW5zdGVhZC5cbiAqIFdoaWxlIHRoaXMgaXNuJ3Qgc3RyaWN0bHkgYWNjb3JkaW5nIHRvIHNwZWMsIGl0IGlzIHZlcnkgY2xvc2UuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvclxuICogQHJldHVybnMgQSBgRE9NRXhjZXB0aW9uYCBvciBgU3ludGF4RXJyb3JgIGluc3RhbmNlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN5bnRheEVycm9yKG1lc3NhZ2U6IHN0cmluZyk6IFN5bnRheEVycm9yIHtcbiAgLy8gSWYgc29tZW9uZSBjYW4gZmlndXJlIG91dCBhIHdheSB0byBtYWtlIHRoaXMgd29yayB3aXRob3V0IGRlcGVuZGluZyBvbiBET00vTm9kZS5qcyB0eXBpbmdzLFxuICAvLyBhbmQgd2l0aG91dCBjYXN0aW5nIHRvIGBhbnlgLCBwbGVhc2Ugc2VuZCBhIFBSIPCfmY9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBEb21FeGNlcHRpb24gPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkRPTUV4Y2VwdGlvblxuICBpZiAodHlwZW9mIERvbUV4Y2VwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgRG9tRXhjZXB0aW9uKG1lc3NhZ2UsICdTeW50YXhFcnJvcicpXG4gIH1cblxuICByZXR1cm4gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogRmxhdHRlbiBhbiBlcnJvciBpbnRvIGEgc2luZ2xlIGVycm9yIG1lc3NhZ2Ugc3RyaW5nLlxuICogVW53cmFwcyBuZXN0ZWQgZXJyb3JzIGFuZCBqb2lucyB0aGVtIHdpdGggYSBjb21tYS5cbiAqXG4gKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIHRvIGZsYXR0ZW5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuRXJyb3IoZXJyOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgcmV0dXJuIGAke2Vycn1gXG4gIH1cblxuICBpZiAoJ2Vycm9ycycgaW4gZXJyICYmIEFycmF5LmlzQXJyYXkoZXJyLmVycm9ycykpIHtcbiAgICByZXR1cm4gZXJyLmVycm9ycy5tYXAoZmxhdHRlbkVycm9yKS5qb2luKCcsICcpXG4gIH1cblxuICBpZiAoJ2NhdXNlJyBpbiBlcnIgJiYgZXJyLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gYCR7ZXJyfTogJHtmbGF0dGVuRXJyb3IoZXJyLmNhdXNlKX1gXG4gIH1cblxuICByZXR1cm4gZXJyLm1lc3NhZ2Vcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGBFcnJvckV2ZW50YCBpbnN0YW5jZSBpbnRvIGEgcGxhaW4gb2JqZWN0IGZvciBpbnNwZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBUaGUgYEVycm9yRXZlbnRgIGluc3RhbmNlIHRvIGluc3BlY3RcbiAqIEByZXR1cm5zIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3RhYmxlRXJyb3IoZXJyOiBFcnJvckV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXJyLnR5cGUsXG4gICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgY29kZTogZXJyLmNvZGUsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZXJyLmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgY2FuY2VsYWJsZTogZXJyLmNhbmNlbGFibGUsXG4gICAgdGltZVN0YW1wOiBlcnIudGltZVN0YW1wLFxuICB9XG59XG4iLCJpbXBvcnQge2NyZWF0ZVBhcnNlciwgdHlwZSBFdmVudFNvdXJjZU1lc3NhZ2UsIHR5cGUgRXZlbnRTb3VyY2VQYXJzZXJ9IGZyb20gJ2V2ZW50c291cmNlLXBhcnNlcidcblxuaW1wb3J0IHtFcnJvckV2ZW50LCBmbGF0dGVuRXJyb3IsIHN5bnRheEVycm9yfSBmcm9tICcuL2Vycm9ycy5qcydcbmltcG9ydCB0eXBlIHtcbiAgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gIEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LFxuICBFdmVudFNvdXJjZUV2ZW50TWFwLFxuICBFdmVudFNvdXJjZUZldGNoSW5pdCxcbiAgRXZlbnRTb3VyY2VJbml0LFxuICBGZXRjaExpa2UsXG4gIEZldGNoTGlrZVJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG4vKipcbiAqIEFuIGBFdmVudFNvdXJjZWAgaW5zdGFuY2Ugb3BlbnMgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gdG8gYW4gSFRUUCBzZXJ2ZXIsIHdoaWNoIHNlbmRzIGV2ZW50c1xuICogaW4gYHRleHQvZXZlbnQtc3RyZWFtYCBmb3JtYXQuIFRoZSBjb25uZWN0aW9uIHJlbWFpbnMgb3BlbiB1bnRpbCBjbG9zZWQgYnkgY2FsbGluZyBgLmNsb3NlKClgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJ2h0dHBzOi8vZXhhbXBsZS5jb20vc3RyZWFtJylcbiAqIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gKiAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gKiB9KVxuICogZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICogIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlOicsIGV2ZW50LmRhdGEpXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGN1cnJlbnRseSB0cnlpbmcgdG8gY29ubmVjdFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgQ09OTkVDVElORyA9IDAgYXMgY29uc3RcblxuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIG9wZW4gKGVnIGNvbm5lY3RlZClcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIE9QRU4gPSAxIGFzIGNvbnN0XG5cbiAgLyoqXG4gICAqIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBjbG9zZWQgKGVnIGRpc2Nvbm5lY3RlZClcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIENMT1NFRCA9IDIgYXMgY29uc3RcblxuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlYWRvbmx5IENPTk5FQ1RJTkcgPSAwIGFzIGNvbnN0XG5cbiAgLyoqXG4gICAqIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBvcGVuIChlZyBjb25uZWN0ZWQpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlYWRvbmx5IE9QRU4gPSAxIGFzIGNvbnN0XG5cbiAgLyoqXG4gICAqIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBjbG9zZWQgKGVnIGRpc2Nvbm5lY3RlZClcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVhZG9ubHkgQ0xPU0VEID0gMiBhcyBjb25zdFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGlzIEV2ZW50U291cmNlIG9iamVjdCdzIGNvbm5lY3Rpb24uIEl0IGNhbiBoYXZlIHRoZSB2YWx1ZXMgZGVzY3JpYmVkIGJlbG93LlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL3JlYWR5U3RhdGUpXG4gICAqXG4gICAqIE5vdGU6IHR5cGVkIGFzIGBudW1iZXJgIGluc3RlYWQgb2YgYDAgfCAxIHwgMmAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYEV2ZW50U291cmNlYCBpbnRlcmZhY2UsXG4gICAqIGRlZmluZWQgaW4gdGhlIFR5cGVTY3JpcHQgYGRvbWAgbGlicmFyeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcHVibGljIGdldCByZWFkeVN0YXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWR5U3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0uXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvdXJsKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwdWJsaWMgZ2V0IHVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLiN1cmwuaHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3JlZGVudGlhbHMgbW9kZSBmb3IgY29ubmVjdGlvbiByZXF1ZXN0cyB0byB0aGUgVVJMIHByb3ZpZGluZyB0aGUgZXZlbnQgc3RyZWFtIGlzIHNldCB0byBcImluY2x1ZGVcIiwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS93aXRoQ3JlZGVudGlhbHMpXG4gICAqL1xuICBwdWJsaWMgZ2V0IHdpdGhDcmVkZW50aWFscygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jd2l0aENyZWRlbnRpYWxzXG4gIH1cblxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9lcnJvcl9ldmVudCkgKi9cbiAgcHVibGljIGdldCBvbmVycm9yKCk6ICgoZXY6IEVycm9yRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuI29uRXJyb3JcbiAgfVxuICBwdWJsaWMgc2V0IG9uZXJyb3IodmFsdWU6ICgoZXY6IEVycm9yRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCkge1xuICAgIHRoaXMuI29uRXJyb3IgPSB2YWx1ZVxuICB9XG5cbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvbWVzc2FnZV9ldmVudCkgKi9cbiAgcHVibGljIGdldCBvbm1lc3NhZ2UoKTogKChldjogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duKSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLiNvbk1lc3NhZ2VcbiAgfVxuICBwdWJsaWMgc2V0IG9ubWVzc2FnZSh2YWx1ZTogKChldjogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duKSB8IG51bGwpIHtcbiAgICB0aGlzLiNvbk1lc3NhZ2UgPSB2YWx1ZVxuICB9XG5cbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2Uvb3Blbl9ldmVudCkgKi9cbiAgcHVibGljIGdldCBvbm9wZW4oKTogKChldjogRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuI29uT3BlblxuICB9XG4gIHB1YmxpYyBzZXQgb25vcGVuKHZhbHVlOiAoKGV2OiBFdmVudCkgPT4gdW5rbm93bikgfCBudWxsKSB7XG4gICAgdGhpcy4jb25PcGVuID0gdmFsdWVcbiAgfVxuXG4gIG92ZXJyaWRlIGFkZEV2ZW50TGlzdGVuZXI8SyBleHRlbmRzIGtleW9mIEV2ZW50U291cmNlRXZlbnRNYXA+KFxuICAgIHR5cGU6IEssXG4gICAgbGlzdGVuZXI6ICh0aGlzOiBFdmVudFNvdXJjZSwgZXY6IEV2ZW50U291cmNlRXZlbnRNYXBbS10pID0+IHVua25vd24sXG4gICAgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgKTogdm9pZFxuICBvdmVycmlkZSBhZGRFdmVudExpc3RlbmVyKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBsaXN0ZW5lcjogKHRoaXM6IEV2ZW50U291cmNlLCBldmVudDogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duLFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICk6IHZvaWRcbiAgb3ZlcnJpZGUgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QsXG4gICAgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgKTogdm9pZFxuICBvdmVycmlkZSBhZGRFdmVudExpc3RlbmVyKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBsaXN0ZW5lcjpcbiAgICAgIHwgKCh0aGlzOiBFdmVudFNvdXJjZSwgZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdW5rbm93bilcbiAgICAgIHwgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCxcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBsaXN0ZW4gPSBsaXN0ZW5lciBhcyAodGhpczogRXZlbnRTb3VyY2UsIGV2ZW50OiBFdmVudCkgPT4gdW5rbm93blxuICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuLCBvcHRpb25zKVxuICB9XG5cbiAgb3ZlcnJpZGUgcmVtb3ZlRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgRXZlbnRTb3VyY2VFdmVudE1hcD4oXG4gICAgdHlwZTogSyxcbiAgICBsaXN0ZW5lcjogKHRoaXM6IEV2ZW50U291cmNlLCBldjogRXZlbnRTb3VyY2VFdmVudE1hcFtLXSkgPT4gdW5rbm93bixcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkXG4gIG92ZXJyaWRlIHJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiAodGhpczogRXZlbnRTb3VyY2UsIGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24sXG4gICAgb3B0aW9ucz86IGJvb2xlYW4gfCBFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgKTogdm9pZFxuICBvdmVycmlkZSByZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCxcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkXG4gIG92ZXJyaWRlIHJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOlxuICAgICAgfCAoKHRoaXM6IEV2ZW50U291cmNlLCBldmVudDogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duKVxuICAgICAgfCBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbiA9IGxpc3RlbmVyIGFzICh0aGlzOiBFdmVudFNvdXJjZSwgZXZlbnQ6IEV2ZW50KSA9PiB1bmtub3duXG4gICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW4sIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZyB8IFVSTCwgZXZlbnRTb3VyY2VJbml0RGljdD86IEV2ZW50U291cmNlSW5pdCkge1xuICAgIHN1cGVyKClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodXJsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLiN1cmwgPSBuZXcgVVJMKHVybCwgZ2V0QmFzZVVSTCgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVSTCcpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkJylcbiAgICB9XG5cbiAgICB0aGlzLiNwYXJzZXIgPSBjcmVhdGVQYXJzZXIoe1xuICAgICAgb25FdmVudDogdGhpcy4jb25FdmVudCxcbiAgICAgIG9uUmV0cnk6IHRoaXMuI29uUmV0cnlDaGFuZ2UsXG4gICAgfSlcblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkdcbiAgICB0aGlzLiNyZWNvbm5lY3RJbnRlcnZhbCA9IDMwMDBcbiAgICB0aGlzLiNmZXRjaCA9IGV2ZW50U291cmNlSW5pdERpY3Q/LmZldGNoID8/IGdsb2JhbFRoaXMuZmV0Y2hcbiAgICB0aGlzLiN3aXRoQ3JlZGVudGlhbHMgPSBldmVudFNvdXJjZUluaXREaWN0Py53aXRoQ3JlZGVudGlhbHMgPz8gZmFsc2VcblxuICAgIHRoaXMuI2Nvbm5lY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0cyBhbnkgaW5zdGFuY2VzIG9mIHRoZSBmZXRjaCBhbGdvcml0aG0gc3RhcnRlZCBmb3IgdGhpcyBFdmVudFNvdXJjZSBvYmplY3QsIGFuZCBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDTE9TRUQuXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvY2xvc2UpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLiNyZWNvbm5lY3RUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuI3JlY29ubmVjdFRpbWVyKVxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSB0aGlzLkNMT1NFRCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuI2NvbnRyb2xsZXIpIHRoaXMuI2NvbnRyb2xsZXIuYWJvcnQoKVxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSB0aGlzLkNMT1NFRFxuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIFBSSVZBVEVTIEZPTExPV1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGVcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjcmVhZHlTdGF0ZTogbnVtYmVyXG5cbiAgLyoqXG4gICAqIE9yaWdpbmFsIFVSTCB1c2VkIHRvIGNvbm5lY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgc3RheSB0aGUgc2FtZSBldmVuIGFmdGVyIGEgcmVkaXJlY3QuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3VybDogVVJMXG5cbiAgLyoqXG4gICAqIFRoZSBkZXN0aW5hdGlvbiBVUkwgYWZ0ZXIgYSByZWRpcmVjdC4gSXMgcmVzZXQgb24gcmVjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNyZWRpcmVjdFVybDogVVJMIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaW5jbHVkZSBjcmVkZW50aWFscyBpbiB0aGUgcmVxdWVzdFxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICN3aXRoQ3JlZGVudGlhbHM6IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNmZXRjaDogRmV0Y2hMaWtlXG5cbiAgLyoqXG4gICAqIFRoZSByZWNvbm5lY3Rpb24gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjcmVjb25uZWN0SW50ZXJ2YWw6IG51bWJlclxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gYW4gb25nb2luZyByZWNvbm5lY3QgYXR0ZW1wdCwgaWYgYW55XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3JlY29ubmVjdFRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBldmVudCBJRCBzZWVuIGJ5IHRoZSBFdmVudFNvdXJjZSwgd2hpY2ggd2lsbCBiZSBzZW50IGFzIGBMYXN0LUV2ZW50LUlEYCBpbiB0aGVcbiAgICogcmVxdWVzdCBoZWFkZXJzIG9uIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI2xhc3RFdmVudElkOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgQWJvcnRDb250cm9sbGVyIGluc3RhbmNlIHVzZWQgdG8gYWJvcnQgdGhlIGZldGNoIHJlcXVlc3RcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIGFuIEV2ZW50U291cmNlIHBhcnNlciAoYGV2ZW50c291cmNlLXBhcnNlcmAgbnBtIG1vZHVsZSlcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjcGFyc2VyOiBFdmVudFNvdXJjZVBhcnNlclxuXG4gIC8qKlxuICAgKiBIb2xkcyB0aGUgY3VycmVudCBlcnJvciBoYW5kbGVyLCBhdHRhY2hlZCB0aHJvdWdoIGBvbmVycm9yYCBwcm9wZXJ0eSBkaXJlY3RseS5cbiAgICogTm90ZSB0aGF0IGBhZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIOKApilgIHdpbGwgbm90IGJlIHN0b3JlZCBoZXJlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNvbkVycm9yOiAoKGV2OiBFcnJvckV2ZW50KSA9PiB1bmtub3duKSB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBjdXJyZW50IG1lc3NhZ2UgaGFuZGxlciwgYXR0YWNoZWQgdGhyb3VnaCBgb25tZXNzYWdlYCBwcm9wZXJ0eSBkaXJlY3RseS5cbiAgICogTm90ZSB0aGF0IGBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywg4oCmKWAgd2lsbCBub3QgYmUgc3RvcmVkIGhlcmUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uTWVzc2FnZTogKChldjogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duKSB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBjdXJyZW50IG9wZW4gaGFuZGxlciwgYXR0YWNoZWQgdGhyb3VnaCBgb25vcGVuYCBwcm9wZXJ0eSBkaXJlY3RseS5cbiAgICogTm90ZSB0aGF0IGBhZGRFdmVudExpc3RlbmVyKCdvcGVuJywg4oCmKWAgd2lsbCBub3QgYmUgc3RvcmVkIGhlcmUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uT3BlbjogKChldjogRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogQ29ubmVjdCB0byB0aGUgZ2l2ZW4gVVJMIGFuZCBzdGFydCByZWNlaXZpbmcgZXZlbnRzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI2Nvbm5lY3QoKSB7XG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuQ09OTkVDVElOR1xuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgIC8vIEJyb3dzZXIgdGVzdHMgYXJlIGZhaWxpbmcgaWYgd2UgZGlyZWN0bHkgY2FsbCBgdGhpcy4jZmV0Y2goKWAsIHRodXMgdGhlIGluZGlyZWN0aW9uLlxuICAgIGNvbnN0IGZldGNoID0gdGhpcy4jZmV0Y2hcbiAgICBmZXRjaCh0aGlzLiN1cmwsIHRoaXMuI2dldFJlcXVlc3RPcHRpb25zKCkpXG4gICAgICAudGhlbih0aGlzLiNvbkZldGNoUmVzcG9uc2UpXG4gICAgICAuY2F0Y2godGhpcy4jb25GZXRjaEVycm9yKVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGZldGNoIHJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBGZXRjaChpc2gpIHJlc3BvbnNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uRmV0Y2hSZXNwb25zZSA9IGFzeW5jIChyZXNwb25zZTogRmV0Y2hMaWtlUmVzcG9uc2UpID0+IHtcbiAgICB0aGlzLiNwYXJzZXIucmVzZXQoKVxuXG4gICAgY29uc3Qge2JvZHksIHJlZGlyZWN0ZWQsIHN0YXR1cywgaGVhZGVyc30gPSByZXNwb25zZVxuXG4gICAgLy8gW3NwZWNdIGEgY2xpZW50IGNhbiBiZSB0b2xkIHRvIHN0b3AgcmVjb25uZWN0aW5nIHVzaW5nIHRoZSBIVFRQIDIwNCBObyBDb250ZW50IHJlc3BvbnNlIGNvZGUuXG4gICAgaWYgKHN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIGVtaXQgYW4gZXJyb3IgZXZlbnQgLSB0aGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIgYmVoYXZpb3IsXG4gICAgICAvLyBhbmQgd2l0aG91dCBpdCB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCB0aGUgdXNlciB0aGF0IHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQuXG4gICAgICB0aGlzLiNmYWlsQ29ubmVjdGlvbignU2VydmVyIHNlbnQgSFRUUCAyMDQsIG5vdCByZWNvbm5lY3RpbmcnLCAyMDQpXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFtzcGVjXSDigKZFdmVudCBzdHJlYW0gcmVxdWVzdHMgY2FuIGJlIHJlZGlyZWN0ZWQgdXNpbmcgSFRUUCAzMDEgYW5kIDMwNyByZWRpcmVjdHMgYXMgd2l0aFxuICAgIC8vIFtzcGVjXSBub3JtYWwgSFRUUCByZXF1ZXN0cy5cbiAgICAvLyBTcGVjIGRvZXMgbm90IHNheSBhbnl0aGluZyBhYm91dCBvdGhlciByZWRpcmVjdCBjb2RlcyAoMzAyLCAzMDgpLCBidXQgdGhpcyBzZWVtcyBhblxuICAgIC8vIHVuaW50ZW5kZWQgb21pc3Npb24sIHJhdGhlciB0aGFuIGEgZmVhdHVyZS4gQnJvd3NlcnMgd2lsbCBoYXBwaWx5IHJlZGlyZWN0IG9uIG90aGVyIDN4eHMncy5cbiAgICBpZiAocmVkaXJlY3RlZCkge1xuICAgICAgdGhpcy4jcmVkaXJlY3RVcmwgPSBuZXcgVVJMKHJlc3BvbnNlLnVybClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVkaXJlY3RVcmwgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvLyBbc3BlY10gaWYgcmVzJ3Mgc3RhdHVzIGlzIG5vdCAyMDAsIOKApiwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhpcy4jZmFpbENvbm5lY3Rpb24oYE5vbi0yMDAgc3RhdHVzIGNvZGUgKCR7c3RhdHVzfSlgLCBzdGF0dXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBbc3BlY10g4oCmb3IgaWYgcmVzJ3MgYENvbnRlbnQtVHlwZWAgaXMgbm90IGB0ZXh0L2V2ZW50LXN0cmVhbWAsIHRoZW4gZmFpbCB0aGUgY29ubmVjdGlvbi5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJ1xuICAgIGlmICghY29udGVudFR5cGUuc3RhcnRzV2l0aCgndGV4dC9ldmVudC1zdHJlYW0nKSkge1xuICAgICAgdGhpcy4jZmFpbENvbm5lY3Rpb24oJ0ludmFsaWQgY29udGVudCB0eXBlLCBleHBlY3RlZCBcInRleHQvZXZlbnQtc3RyZWFtXCInLCBzdGF0dXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBbc3BlY10g4oCmaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhIHZhbHVlIG90aGVyIHRoYW4gQ0xPU0VE4oCmXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0VEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBbc3BlY10g4oCmc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gT1BFTiBhbmQgZmlyZXMgYW4gZXZlbnRcbiAgICAvLyBbc3BlY10g4oCmbmFtZWQgb3BlbiBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSB0aGlzLk9QRU5cblxuICAgIGNvbnN0IG9wZW5FdmVudCA9IG5ldyBFdmVudCgnb3BlbicpXG4gICAgdGhpcy4jb25PcGVuPy4ob3BlbkV2ZW50KVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvcGVuRXZlbnQpXG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcmVzcG9uc2Ugc3RyZWFtIGlzIGEgd2ViIHN0cmVhbVxuICAgIGlmICh0eXBlb2YgYm9keSAhPT0gJ29iamVjdCcgfHwgIWJvZHkgfHwgISgnZ2V0UmVhZGVyJyBpbiBib2R5KSkge1xuICAgICAgdGhpcy4jZmFpbENvbm5lY3Rpb24oJ0ludmFsaWQgcmVzcG9uc2UgYm9keSwgZXhwZWN0ZWQgYSB3ZWIgUmVhZGFibGVTdHJlYW0nLCBzdGF0dXMpXG4gICAgICB0aGlzLmNsb3NlKCkgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgYGZldGNoYCBwcm92aWRlZCBpcyBcImZhdWx0eVwiIC0gZG9uJ3QgcmVjb25uZWN0XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuICAgIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKClcbiAgICBsZXQgb3BlbiA9IHRydWVcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jcGFyc2VyLmZlZWQoZGVjb2Rlci5kZWNvZGUodmFsdWUsIHtzdHJlYW06ICFkb25lfSkpXG4gICAgICB9XG5cbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBvcGVuID0gZmFsc2VcbiAgICAgIHRoaXMuI3BhcnNlci5yZXNldCgpXG5cbiAgICAgIHRoaXMuI3NjaGVkdWxlUmVjb25uZWN0KClcbiAgICB9IHdoaWxlIChvcGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgcmVqZWN0ZWQgcmVxdWVzdHMgZm9yIHRoZSBFdmVudFNvdXJjZSBlbmRwb2ludFxuICAgKlxuICAgKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIGZyb20gYGZldGNoKClgXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uRmV0Y2hFcnJvciA9IChlcnI6IEVycm9yICYge3R5cGU/OiBzdHJpbmd9KSA9PiB7XG4gICAgdGhpcy4jY29udHJvbGxlciA9IHVuZGVmaW5lZFxuXG4gICAgLy8gV2UgZXhwZWN0IGFib3J0IGVycm9ycyB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5IGNhbGxzIGBjbG9zZSgpYCAtIGlnbm9yZSB0aG9zZVxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVyci50eXBlID09PSAnYWJvcnRlZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuI3NjaGVkdWxlUmVjb25uZWN0KGZsYXR0ZW5FcnJvcihlcnIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByZXF1ZXN0IG9wdGlvbnMgZm9yIHRoZSBgZmV0Y2goKWAgcmVxdWVzdFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgcmVxdWVzdCBvcHRpb25zXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI2dldFJlcXVlc3RPcHRpb25zKCk6IEV2ZW50U291cmNlRmV0Y2hJbml0IHtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSB0aGlzLiNsYXN0RXZlbnRJZCA/IHsnTGFzdC1FdmVudC1JRCc6IHRoaXMuI2xhc3RFdmVudElkfSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgaW5pdDogRXZlbnRTb3VyY2VGZXRjaEluaXQgPSB7XG4gICAgICAvLyBbc3BlY10gTGV0IGBjb3JzQXR0cmlidXRlU3RhdGVgIGJlIGBBbm9ueW1vdXNg4oCmXG4gICAgICAvLyBbc3BlY10g4oCmd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wi4oCmXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICBoZWFkZXJzOiB7QWNjZXB0OiAndGV4dC9ldmVudC1zdHJlYW0nLCAuLi5sYXN0RXZlbnR9LFxuICAgICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgICBzaWduYWw6IHRoaXMuI2NvbnRyb2xsZXI/LnNpZ25hbCxcbiAgICB9XG5cbiAgICAvLyBTb21lIGVudmlyb25tZW50cyBjcmFzaCBpZiBhdHRlbXB0aW5nIHRvIHNldCBgY3JlZGVudGlhbHNgIHdoZXJlIGl0IGlzIG5vdCBzdXBwb3J0ZWQsXG4gICAgLy8gZWcgb24gQ2xvdWRmbGFyZSBXb3JrZXJzLiBUbyBhdm9pZCB0aGlzLCB3ZSBvbmx5IHNldCBpdCBpbiBicm93c2VyLWxpa2UgZW52aXJvbm1lbnRzLlxuICAgIGlmICgnd2luZG93JyBpbiBnbG9iYWxUaGlzKSB7XG4gICAgICAvLyBbc3BlY10g4oCmYW5kIHRoZWlyIGNyZWRlbnRpYWxzIG1vZGUgc2V0IHRvIFwic2FtZS1vcmlnaW5cIlxuICAgICAgLy8gW3NwZWNdIOKApmlmIHRoZSBgd2l0aENyZWRlbnRpYWxzYCBhdHRyaWJ1dGUgaXMgYHRydWVgLCBzZXQgdGhlIGNyZWRlbnRpYWxzIG1vZGUgdG8gXCJpbmNsdWRlXCLigKZcbiAgICAgIGluaXQuY3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbidcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdFxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBFdmVudFNvdXJjZVBhcnNlciBpbnN0YW5jZSB3aGVuIGFuIGV2ZW50IGhhcyBzdWNjZXNzZnVsbHkgYmVlbiBwYXJzZWRcbiAgICogYW5kIGlzIHJlYWR5IHRvIGJlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHBhcnNlZCBldmVudFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNvbkV2ZW50ID0gKGV2ZW50OiBFdmVudFNvdXJjZU1lc3NhZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmlkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy4jbGFzdEV2ZW50SWQgPSBldmVudC5pZFxuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoZXZlbnQuZXZlbnQgfHwgJ21lc3NhZ2UnLCB7XG4gICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgb3JpZ2luOiB0aGlzLiNyZWRpcmVjdFVybCA/IHRoaXMuI3JlZGlyZWN0VXJsLm9yaWdpbiA6IHRoaXMuI3VybC5vcmlnaW4sXG4gICAgICBsYXN0RXZlbnRJZDogZXZlbnQuaWQgfHwgJycsXG4gICAgfSlcblxuICAgIC8vIFRoZSBgb25tZXNzYWdlYCBwcm9wZXJ0eSBvZiB0aGUgRXZlbnRTb3VyY2UgaW5zdGFuY2Ugb25seSB0cmlnZ2VycyBvbiBtZXNzYWdlcyB3aXRob3V0IGFuXG4gICAgLy8gYGV2ZW50YCBmaWVsZCwgb3Igb25lcyB0aGF0IGV4cGxpY2l0bHkgc2V0IGBtZXNzYWdlYC5cbiAgICBpZiAodGhpcy4jb25NZXNzYWdlICYmICghZXZlbnQuZXZlbnQgfHwgZXZlbnQuZXZlbnQgPT09ICdtZXNzYWdlJykpIHtcbiAgICAgIHRoaXMuI29uTWVzc2FnZShtZXNzYWdlRXZlbnQpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG1lc3NhZ2VFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgRXZlbnRTb3VyY2VQYXJzZXIgaW5zdGFuY2Ugd2hlbiBhIG5ldyByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaXMgcmVjZWl2ZWRcbiAgICogZnJvbSB0aGUgRXZlbnRTb3VyY2UgZW5kcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBuZXcgcmVjb25uZWN0aW9uIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNvblJldHJ5Q2hhbmdlID0gKHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICB0aGlzLiNyZWNvbm5lY3RJbnRlcnZhbCA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgcHJvY2VzcyByZWZlcnJlZCB0byBpbiB0aGUgRXZlbnRTb3VyY2Ugc3BlY2lmaWNhdGlvbiBhcyBcImZhaWxpbmcgYSBjb25uZWN0aW9uXCIuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBjYXVzaW5nIHRoZSBjb25uZWN0aW9uIHRvIGZhaWxcbiAgICogQHBhcmFtIGNvZGUgLSBUaGUgSFRUUCBzdGF0dXMgY29kZSwgaWYgYXZhaWxhYmxlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI2ZhaWxDb25uZWN0aW9uKG1lc3NhZ2U/OiBzdHJpbmcsIGNvZGU/OiBudW1iZXIpIHtcbiAgICAvLyBbc3BlY10g4oCmaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhIHZhbHVlIG90aGVyIHRoYW4gQ0xPU0VELFxuICAgIC8vIFtzcGVjXSBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDTE9TRUTigKZcbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSAhPT0gdGhpcy5DTE9TRUQpIHtcbiAgICAgIHRoaXMuI3JlYWR5U3RhdGUgPSB0aGlzLkNMT1NFRFxuICAgIH1cblxuICAgIC8vIFtzcGVjXSDigKZhbmQgZmlyZXMgYW4gZXZlbnQgbmFtZWQgYGVycm9yYCBhdCB0aGUgYEV2ZW50U291cmNlYCBvYmplY3QuXG4gICAgLy8gW3NwZWNdIE9uY2UgdGhlIHVzZXIgYWdlbnQgaGFzIGZhaWxlZCB0aGUgY29ubmVjdGlvbiwgaXQgZG9lcyBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QuXG4gICAgLy8gW3NwZWNdID4gSW1wbGVtZW50YXRpb25zIGFyZSBlc3BlY2lhbGx5IGVuY291cmFnZWQgdG8gcmVwb3J0IGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgLy8gW3NwZWNdID4gdG8gdGhlaXIgZGV2ZWxvcG1lbnQgY29uc29sZXMgd2hlbmV2ZXIgYW4gZXJyb3IgZXZlbnQgaXMgZmlyZWQsIHNpbmNlIGxpdHRsZVxuICAgIC8vIFtzcGVjXSA+IHRvIG5vIGluZm9ybWF0aW9uIGNhbiBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgZXZlbnRzIHRoZW1zZWx2ZXMuXG4gICAgLy8gUHJpbnRpbmcgdG8gY29uc29sZSBpcyBub3QgdmVyeSBwcm9ncmFtYXRpY2FsbHkgaGVscGZ1bCwgdGhvdWdoLCBzbyB3ZSBlbWl0IGEgY3VzdG9tIGV2ZW50LlxuICAgIGNvbnN0IGVycm9yRXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7Y29kZSwgbWVzc2FnZX0pXG5cbiAgICB0aGlzLiNvbkVycm9yPy4oZXJyb3JFdmVudClcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBhZ2FpbnN0IHRoZSBFdmVudFNvdXJjZSBlbmRwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsXG4gICAqIEBwYXJhbSBjb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGUsIGlmIGF2YWlsYWJsZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNzY2hlZHVsZVJlY29ubmVjdChtZXNzYWdlPzogc3RyaW5nLCBjb2RlPzogbnVtYmVyKSB7XG4gICAgLy8gW3NwZWNdIElmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gQ0xPU0VELCBhYm9ydCB0aGUgdGFzay5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gdGhpcy5DTE9TRUQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFtzcGVjXSBTZXQgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENPTk5FQ1RJTkcuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuQ09OTkVDVElOR1xuXG4gICAgLy8gW3NwZWNdIEZpcmUgYW4gZXZlbnQgbmFtZWQgYGVycm9yYCBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIGNvbnN0IGVycm9yRXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7Y29kZSwgbWVzc2FnZX0pXG4gICAgdGhpcy4jb25FcnJvcj8uKGVycm9yRXZlbnQpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yRXZlbnQpXG5cbiAgICAvLyBbc3BlY10gV2FpdCBhIGRlbGF5IGVxdWFsIHRvIHRoZSByZWNvbm5lY3Rpb24gdGltZSBvZiB0aGUgZXZlbnQgc291cmNlLlxuICAgIHRoaXMuI3JlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dCh0aGlzLiNyZWNvbm5lY3QsIHRoaXMuI3JlY29ubmVjdEludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY29ubmVjdHMgdG8gdGhlIEV2ZW50U291cmNlIGVuZHBvaW50IGFmdGVyIGEgZGlzY29ubmVjdC9mYWlsdXJlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3JlY29ubmVjdCA9ICgpID0+IHtcbiAgICB0aGlzLiNyZWNvbm5lY3RUaW1lciA9IHVuZGVmaW5lZFxuXG4gICAgLy8gW3NwZWNdIElmIHRoZSBFdmVudFNvdXJjZSdzIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIG5vdCBzZXQgdG8gQ09OTkVDVElORywgdGhlbiByZXR1cm4uXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgIT09IHRoaXMuQ09OTkVDVElORykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jY29ubmVjdCgpXG4gIH1cbn1cblxuLyoqXG4gKiBBY2NvcmRpbmcgdG8gc3BlYywgd2hlbiBjb25zdHJ1Y3RpbmcgYSBVUkw6XG4gKiA+IDEuIExldCBiYXNlVVJMIGJlIGVudmlyb25tZW50J3MgYmFzZSBVUkwsIGlmIGVudmlyb25tZW50IGlzIGEgRG9jdW1lbnQgb2JqZWN0XG4gKiA+IDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBVUkwgcGFyc2VyIHRvIHVybCwgd2l0aCBiYXNlVVJMLlxuICpcbiAqIFRodXMgd2Ugc2hvdWxkIHVzZSBgZG9jdW1lbnQuYmFzZVVSSWAgaWYgYXZhaWxhYmxlLCBzaW5jZSBpdCBjYW4gYmUgc2V0IHRocm91Z2ggYSBiYXNlIHRhZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYmFzZSBVUkwsIGlmIGF2YWlsYWJsZSAtIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVUkwoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgZG9jID0gJ2RvY3VtZW50JyBpbiBnbG9iYWxUaGlzID8gKGdsb2JhbFRoaXMgYXMgYW55KS5kb2N1bWVudCA6IHVuZGVmaW5lZFxuICByZXR1cm4gZG9jICYmIHR5cGVvZiBkb2MgPT09ICdvYmplY3QnICYmICdiYXNlVVJJJyBpbiBkb2MgJiYgdHlwZW9mIGRvYy5iYXNlVVJJID09PSAnc3RyaW5nJ1xuICAgID8gZG9jLmJhc2VVUklcbiAgICA6IHVuZGVmaW5lZFxufVxuIiwiY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UpLCB0aGlzLm5hbWUgPSBcIlBhcnNlRXJyb3JcIiwgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlLCB0aGlzLmZpZWxkID0gb3B0aW9ucy5maWVsZCwgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWUsIHRoaXMubGluZSA9IG9wdGlvbnMubGluZTtcbiAgfVxufVxuZnVuY3Rpb24gbm9vcChfYXJnKSB7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIoY2FsbGJhY2tzKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2tzID09IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJgY2FsbGJhY2tzYCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IGEgZnVuY3Rpb24gaW5zdGVhZC4gRGlkIHlvdSBtZWFuIGB7b25FdmVudDogZm59YD9cIlxuICAgICk7XG4gIGNvbnN0IHsgb25FdmVudCA9IG5vb3AsIG9uRXJyb3IgPSBub29wLCBvblJldHJ5ID0gbm9vcCwgb25Db21tZW50IH0gPSBjYWxsYmFja3M7XG4gIGxldCBpbmNvbXBsZXRlTGluZSA9IFwiXCIsIGlzRmlyc3RDaHVuayA9ICEwLCBpZCwgZGF0YSA9IFwiXCIsIGV2ZW50VHlwZSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGZlZWQobmV3Q2h1bmspIHtcbiAgICBjb25zdCBjaHVuayA9IGlzRmlyc3RDaHVuayA/IG5ld0NodW5rLnJlcGxhY2UoL15cXHhFRlxceEJCXFx4QkYvLCBcIlwiKSA6IG5ld0NodW5rLCBbY29tcGxldGUsIGluY29tcGxldGVdID0gc3BsaXRMaW5lcyhgJHtpbmNvbXBsZXRlTGluZX0ke2NodW5rfWApO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBjb21wbGV0ZSlcbiAgICAgIHBhcnNlTGluZShsaW5lKTtcbiAgICBpbmNvbXBsZXRlTGluZSA9IGluY29tcGxldGUsIGlzRmlyc3RDaHVuayA9ICExO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgIG9uQ29tbWVudCAmJiBvbkNvbW1lbnQobGluZS5zbGljZShsaW5lLnN0YXJ0c1dpdGgoXCI6IFwiKSA/IDIgOiAxKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkU2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChmaWVsZFNlcGFyYXRvckluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGZpZWxkU2VwYXJhdG9ySW5kZXgpLCBvZmZzZXQgPSBsaW5lW2ZpZWxkU2VwYXJhdG9ySW5kZXggKyAxXSA9PT0gXCIgXCIgPyAyIDogMSwgdmFsdWUgPSBsaW5lLnNsaWNlKGZpZWxkU2VwYXJhdG9ySW5kZXggKyBvZmZzZXQpO1xuICAgICAgcHJvY2Vzc0ZpZWxkKGZpZWxkLCB2YWx1ZSwgbGluZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NGaWVsZChsaW5lLCBcIlwiLCBsaW5lKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzRmllbGQoZmllbGQsIHZhbHVlLCBsaW5lKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgIGV2ZW50VHlwZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEgPSBgJHtkYXRhfSR7dmFsdWV9XG5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICBpZCA9IHZhbHVlLmluY2x1ZGVzKFwiXFwwXCIpID8gdm9pZCAwIDogdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIC9eXFxkKyQvLnRlc3QodmFsdWUpID8gb25SZXRyeShwYXJzZUludCh2YWx1ZSwgMTApKSA6IG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgXFxgcmV0cnlcXGAgdmFsdWU6IFwiJHt2YWx1ZX1cImAsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZC1yZXRyeVwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gZmllbGQgXCIke2ZpZWxkLmxlbmd0aCA+IDIwID8gYCR7ZmllbGQuc2xpY2UoMCwgMjApfVxcdTIwMjZgIDogZmllbGR9XCJgLFxuICAgICAgICAgICAgeyB0eXBlOiBcInVua25vd24tZmllbGRcIiwgZmllbGQsIHZhbHVlLCBsaW5lIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgIGRhdGEubGVuZ3RoID4gMCAmJiBvbkV2ZW50KHtcbiAgICAgIGlkLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSB8fCB2b2lkIDAsXG4gICAgICAvLyBJZiB0aGUgZGF0YSBidWZmZXIncyBsYXN0IGNoYXJhY3RlciBpcyBhIFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXIsXG4gICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZGF0YSBidWZmZXIuXG4gICAgICBkYXRhOiBkYXRhLmVuZHNXaXRoKGBcbmApID8gZGF0YS5zbGljZSgwLCAtMSkgOiBkYXRhXG4gICAgfSksIGlkID0gdm9pZCAwLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiByZXNldChvcHRpb25zID0ge30pIHtcbiAgICBpbmNvbXBsZXRlTGluZSAmJiBvcHRpb25zLmNvbnN1bWUgJiYgcGFyc2VMaW5lKGluY29tcGxldGVMaW5lKSwgaXNGaXJzdENodW5rID0gITAsIGlkID0gdm9pZCAwLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIiwgaW5jb21wbGV0ZUxpbmUgPSBcIlwiO1xuICB9XG4gIHJldHVybiB7IGZlZWQsIHJlc2V0IH07XG59XG5mdW5jdGlvbiBzcGxpdExpbmVzKGNodW5rKSB7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGxldCBpbmNvbXBsZXRlTGluZSA9IFwiXCIsIHNlYXJjaEluZGV4ID0gMDtcbiAgZm9yICg7IHNlYXJjaEluZGV4IDwgY2h1bmsubGVuZ3RoOyApIHtcbiAgICBjb25zdCBjckluZGV4ID0gY2h1bmsuaW5kZXhPZihcIlxcclwiLCBzZWFyY2hJbmRleCksIGxmSW5kZXggPSBjaHVuay5pbmRleE9mKGBcbmAsIHNlYXJjaEluZGV4KTtcbiAgICBsZXQgbGluZUVuZCA9IC0xO1xuICAgIGlmIChjckluZGV4ICE9PSAtMSAmJiBsZkluZGV4ICE9PSAtMSA/IGxpbmVFbmQgPSBNYXRoLm1pbihjckluZGV4LCBsZkluZGV4KSA6IGNySW5kZXggIT09IC0xID8gY3JJbmRleCA9PT0gY2h1bmsubGVuZ3RoIC0gMSA/IGxpbmVFbmQgPSAtMSA6IGxpbmVFbmQgPSBjckluZGV4IDogbGZJbmRleCAhPT0gLTEgJiYgKGxpbmVFbmQgPSBsZkluZGV4KSwgbGluZUVuZCA9PT0gLTEpIHtcbiAgICAgIGluY29tcGxldGVMaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjaHVuay5zbGljZShzZWFyY2hJbmRleCwgbGluZUVuZCk7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUpLCBzZWFyY2hJbmRleCA9IGxpbmVFbmQgKyAxLCBjaHVua1tzZWFyY2hJbmRleCAtIDFdID09PSBcIlxcclwiICYmIGNodW5rW3NlYXJjaEluZGV4XSA9PT0gYFxuYCAmJiBzZWFyY2hJbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2xpbmVzLCBpbmNvbXBsZXRlTGluZV07XG59XG5leHBvcnQge1xuICBQYXJzZUVycm9yLFxuICBjcmVhdGVQYXJzZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIi8qKlxuICogVGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRXJyb3JUeXBlID0gJ2ludmFsaWQtcmV0cnknIHwgJ3Vua25vd24tZmllbGQnXG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gZW5jb3VudGVyaW5nIGFuIGlzc3VlIGR1cmluZyBwYXJzaW5nLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgdHlwZTogRXJyb3JUeXBlXG5cbiAgLyoqXG4gICAqIEluIHRoZSBjYXNlIG9mIGFuIHVua25vd24gZmllbGQgZW5jb3VudGVyZWQgaW4gdGhlIHN0cmVhbSwgdGhpcyB3aWxsIGJlIHRoZSBmaWVsZCBuYW1lLlxuICAgKi9cbiAgZmllbGQ/OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogSW4gdGhlIGNhc2Ugb2YgYW4gdW5rbm93biBmaWVsZCBlbmNvdW50ZXJlZCBpbiB0aGUgc3RyZWFtLCB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZC5cbiAgICovXG4gIHZhbHVlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIFRoZSBsaW5lIHRoYXQgY2F1c2VkIHRoZSBlcnJvciwgaWYgYXZhaWxhYmxlLlxuICAgKi9cbiAgbGluZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7dHlwZTogRXJyb3JUeXBlOyBmaWVsZD86IHN0cmluZzsgdmFsdWU/OiBzdHJpbmc7IGxpbmU/OiBzdHJpbmd9LFxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdQYXJzZUVycm9yJ1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZVxuICAgIHRoaXMuZmllbGQgPSBvcHRpb25zLmZpZWxkXG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWVcbiAgICB0aGlzLmxpbmUgPSBvcHRpb25zLmxpbmVcbiAgfVxufVxuIiwiLyoqXG4gKiBFdmVudFNvdXJjZS9TZXJ2ZXItU2VudCBFdmVudHMgcGFyc2VyXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4gKi9cbmltcG9ydCB7UGFyc2VFcnJvcn0gZnJvbSAnLi9lcnJvcnMudHMnXG5pbXBvcnQgdHlwZSB7RXZlbnRTb3VyY2VQYXJzZXIsIFBhcnNlckNhbGxiYWNrc30gZnJvbSAnLi90eXBlcy50cydcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZnVuY3Rpb24gbm9vcChfYXJnOiB1bmtub3duKSB7XG4gIC8vIGludGVudGlvbmFsIG5vb3Bcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2tzIC0gQ2FsbGJhY2tzIHRvIGludm9rZSBvbiBkaWZmZXJlbnQgcGFyc2luZyBldmVudHM6XG4gKiAgIC0gYG9uRXZlbnRgIHdoZW4gYSBuZXcgZXZlbnQgaXMgcGFyc2VkXG4gKiAgIC0gYG9uRXJyb3JgIHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gKiAgIC0gYG9uUmV0cnlgIHdoZW4gYSBuZXcgcmVjb25uZWN0aW9uIGludGVydmFsIGhhcyBiZWVuIHNlbnQgZnJvbSB0aGUgc2VydmVyXG4gKiAgIC0gYG9uQ29tbWVudGAgd2hlbiBhIGNvbW1lbnQgaXMgZW5jb3VudGVyZWQgaW4gdGhlIHN0cmVhbVxuICpcbiAqIEByZXR1cm5zIEEgbmV3IEV2ZW50U291cmNlIHBhcnNlciwgd2l0aCBgcGFyc2VgIGFuZCBgcmVzZXRgIG1ldGhvZHMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXJzZXIoY2FsbGJhY2tzOiBQYXJzZXJDYWxsYmFja3MpOiBFdmVudFNvdXJjZVBhcnNlciB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2tzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdgY2FsbGJhY2tzYCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IGEgZnVuY3Rpb24gaW5zdGVhZC4gRGlkIHlvdSBtZWFuIGB7b25FdmVudDogZm59YD8nLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHtvbkV2ZW50ID0gbm9vcCwgb25FcnJvciA9IG5vb3AsIG9uUmV0cnkgPSBub29wLCBvbkNvbW1lbnR9ID0gY2FsbGJhY2tzXG5cbiAgbGV0IGluY29tcGxldGVMaW5lID0gJydcblxuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZVxuICBsZXQgaWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBsZXQgZGF0YSA9ICcnXG4gIGxldCBldmVudFR5cGUgPSAnJ1xuXG4gIGZ1bmN0aW9uIGZlZWQobmV3Q2h1bms6IHN0cmluZykge1xuICAgIC8vIFN0cmlwIGFueSBVVEY4IGJ5dGUgb3JkZXIgbWFyayAoQk9NKSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmVhbVxuICAgIGNvbnN0IGNodW5rID0gaXNGaXJzdENodW5rID8gbmV3Q2h1bmsucmVwbGFjZSgvXlxceEVGXFx4QkJcXHhCRi8sICcnKSA6IG5ld0NodW5rXG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBpbmNvbXBsZXRlIGxpbmUsIGFwcGVuZCBpdCB0byB0aGUgbmV3IGNodW5rLFxuICAgIC8vIHNvIHdlIG1heSBwcm9jZXNzIGl0IHRvZ2V0aGVyIGFzIGEgbmV3IChob3BlZnVsbHkgY29tcGxldGUpIGNodW5rLlxuICAgIGNvbnN0IFtjb21wbGV0ZSwgaW5jb21wbGV0ZV0gPSBzcGxpdExpbmVzKGAke2luY29tcGxldGVMaW5lfSR7Y2h1bmt9YClcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBjb21wbGV0ZSkge1xuICAgICAgcGFyc2VMaW5lKGxpbmUpXG4gICAgfVxuXG4gICAgaW5jb21wbGV0ZUxpbmUgPSBpbmNvbXBsZXRlXG4gICAgaXNGaXJzdENodW5rID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lOiBzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgbGluZSBpcyBlbXB0eSAoYSBibGFuayBsaW5lKSwgZGlzcGF0Y2ggdGhlIGV2ZW50XG4gICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICBkaXNwYXRjaEV2ZW50KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOiksIGlnbm9yZSB0aGUgbGluZS5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgIGlmIChvbkNvbW1lbnQpIHtcbiAgICAgICAgb25Db21tZW50KGxpbmUuc2xpY2UobGluZS5zdGFydHNXaXRoKCc6ICcpID8gMiA6IDEpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxpbmUgY29udGFpbnMgYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIGNvbnN0IGZpZWxkU2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKVxuICAgIGlmIChmaWVsZFNlcGFyYXRvckluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBiZWZvcmUgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTiBjaGFyYWN0ZXIgKDopLFxuICAgICAgLy8gYW5kIGxldCBgZmllbGRgIGJlIHRoYXQgc3RyaW5nLlxuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGZpZWxkU2VwYXJhdG9ySW5kZXgpXG5cbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYWZ0ZXIgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTiBjaGFyYWN0ZXIgKDopLFxuICAgICAgLy8gYW5kIGxldCBgdmFsdWVgIGJlIHRoYXQgc3RyaW5nLiBJZiB2YWx1ZSBzdGFydHMgd2l0aCBhIFUrMDAyMCBTUEFDRSBjaGFyYWN0ZXIsXG4gICAgICAvLyByZW1vdmUgaXQgZnJvbSB2YWx1ZS5cbiAgICAgIGNvbnN0IG9mZnNldCA9IGxpbmVbZmllbGRTZXBhcmF0b3JJbmRleCArIDFdID09PSAnICcgPyAyIDogMVxuICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnNsaWNlKGZpZWxkU2VwYXJhdG9ySW5kZXggKyBvZmZzZXQpXG5cbiAgICAgIHByb2Nlc3NGaWVsZChmaWVsZCwgdmFsdWUsIGxpbmUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHRoZSBzdHJpbmcgaXMgbm90IGVtcHR5IGJ1dCBkb2VzIG5vdCBjb250YWluIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICAvLyBQcm9jZXNzIHRoZSBmaWVsZCB1c2luZyB0aGUgd2hvbGUgbGluZSBhcyB0aGUgZmllbGQgbmFtZSwgYW5kIGFuIGVtcHR5IHN0cmluZyBhcyB0aGUgZmllbGQgdmFsdWUuXG4gICAgLy8g8J+RhiBUaGlzIGlzIGFjY29yZGluZyB0byBzcGVjLiBUaGF0IG1lYW5zIHRoYXQgYSBsaW5lIHRoYXQgaGFzIHRoZSB2YWx1ZSBgZGF0YWAgd2lsbCByZXN1bHQgaW5cbiAgICAvLyBhIG5ld2xpbmUgYmVpbmcgYWRkZWQgdG8gdGhlIGN1cnJlbnQgYGRhdGFgIGJ1ZmZlciwgZm9yIGluc3RhbmNlLlxuICAgIHByb2Nlc3NGaWVsZChsaW5lLCAnJywgbGluZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChmaWVsZDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBsaW5lOiBzdHJpbmcpIHtcbiAgICAvLyBGaWVsZCBuYW1lcyBtdXN0IGJlIGNvbXBhcmVkIGxpdGVyYWxseSwgd2l0aCBubyBjYXNlIGZvbGRpbmcgcGVyZm9ybWVkLlxuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgLy8gU2V0IHRoZSBgZXZlbnQgdHlwZWAgYnVmZmVyIHRvIGZpZWxkIHZhbHVlXG4gICAgICAgIGV2ZW50VHlwZSA9IHZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBmaWVsZCB2YWx1ZSB0byB0aGUgYGRhdGFgIGJ1ZmZlciwgdGhlbiBhcHBlbmQgYSBzaW5nbGUgVSswMDBBIExJTkUgRkVFRChMRilcbiAgICAgICAgLy8gY2hhcmFjdGVyIHRvIHRoZSBgZGF0YWAgYnVmZmVyLlxuICAgICAgICBkYXRhID0gYCR7ZGF0YX0ke3ZhbHVlfVxcbmBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gVSswMDAwIE5VTEwsIHRoZW4gc2V0IHRoZSBgSURgIGJ1ZmZlciB0b1xuICAgICAgICAvLyB0aGUgZmllbGQgdmFsdWUuIE90aGVyd2lzZSwgaWdub3JlIHRoZSBmaWVsZC5cbiAgICAgICAgaWQgPSB2YWx1ZS5pbmNsdWRlcygnXFwwJykgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmV0cnknOlxuICAgICAgICAvLyBJZiB0aGUgZmllbGQgdmFsdWUgY29uc2lzdHMgb2Ygb25seSBBU0NJSSBkaWdpdHMsIHRoZW4gaW50ZXJwcmV0IHRoZSBmaWVsZCB2YWx1ZSBhcyBhblxuICAgICAgICAvLyBpbnRlZ2VyIGluIGJhc2UgdGVuLCBhbmQgc2V0IHRoZSBldmVudCBzdHJlYW0ncyByZWNvbm5lY3Rpb24gdGltZSB0byB0aGF0IGludGVnZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWdub3JlIHRoZSBmaWVsZC5cbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgb25SZXRyeShwYXJzZUludCh2YWx1ZSwgMTApKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgICBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBcXGByZXRyeVxcYCB2YWx1ZTogXCIke3ZhbHVlfVwiYCwge1xuICAgICAgICAgICAgICB0eXBlOiAnaW52YWxpZC1yZXRyeScsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBmaWVsZCBpcyBpZ25vcmVkLlxuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gZmllbGQgXCIke2ZpZWxkLmxlbmd0aCA+IDIwID8gYCR7ZmllbGQuc2xpY2UoMCwgMjApfeKApmAgOiBmaWVsZH1cImAsXG4gICAgICAgICAgICB7dHlwZTogJ3Vua25vd24tZmllbGQnLCBmaWVsZCwgdmFsdWUsIGxpbmV9LFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgIGNvbnN0IHNob3VsZERpc3BhdGNoID0gZGF0YS5sZW5ndGggPiAwXG4gICAgaWYgKHNob3VsZERpc3BhdGNoKSB7XG4gICAgICBvbkV2ZW50KHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV2ZW50OiBldmVudFR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAvLyBJZiB0aGUgZGF0YSBidWZmZXIncyBsYXN0IGNoYXJhY3RlciBpcyBhIFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXIsXG4gICAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBmcm9tIHRoZSBkYXRhIGJ1ZmZlci5cbiAgICAgICAgZGF0YTogZGF0YS5lbmRzV2l0aCgnXFxuJykgPyBkYXRhLnNsaWNlKDAsIC0xKSA6IGRhdGEsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGZvciB0aGUgbmV4dCBldmVudFxuICAgIGlkID0gdW5kZWZpbmVkXG4gICAgZGF0YSA9ICcnXG4gICAgZXZlbnRUeXBlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KG9wdGlvbnM6IHtjb25zdW1lPzogYm9vbGVhbn0gPSB7fSkge1xuICAgIGlmIChpbmNvbXBsZXRlTGluZSAmJiBvcHRpb25zLmNvbnN1bWUpIHtcbiAgICAgIHBhcnNlTGluZShpbmNvbXBsZXRlTGluZSlcbiAgICB9XG5cbiAgICBpc0ZpcnN0Q2h1bmsgPSB0cnVlXG4gICAgaWQgPSB1bmRlZmluZWRcbiAgICBkYXRhID0gJydcbiAgICBldmVudFR5cGUgPSAnJ1xuICAgIGluY29tcGxldGVMaW5lID0gJydcbiAgfVxuXG4gIHJldHVybiB7ZmVlZCwgcmVzZXR9XG59XG5cbi8qKlxuICogRm9yIHRoZSBnaXZlbiBgY2h1bmtgLCBzcGxpdCBpdCBpbnRvIGxpbmVzIGFjY29yZGluZyB0byBzcGVjLCBhbmQgcmV0dXJuIGFueSByZW1haW5pbmcgaW5jb21wbGV0ZSBsaW5lLlxuICpcbiAqIEBwYXJhbSBjaHVuayAtIFRoZSBjaHVuayB0byBzcGxpdCBpbnRvIGxpbmVzXG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgY29tcGxldGUgbGluZXMsIGFuZCBhbnkgcmVtYWluaW5nIGluY29tcGxldGUgbGluZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY2h1bms6IHN0cmluZyk6IFtjb21wbGV0ZTogQXJyYXk8c3RyaW5nPiwgaW5jb21wbGV0ZTogc3RyaW5nXSB7XG4gIC8qKlxuICAgKiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIGEgbGluZSBpcyB0ZXJtaW5hdGVkIGJ5IGVpdGhlcjpcbiAgICogLSBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIFUrMDAwQSBMSU5FIEZFRUQgKENSTEYpIGNoYXJhY3RlciBwYWlyXG4gICAqIC0gYSBzaW5nbGUgVSswMDBBIExJTkUgRkVFRChMRikgY2hhcmFjdGVyIG5vdCBwcmVjZWRlZCBieSBhIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4oQ1IpIGNoYXJhY3RlclxuICAgKiAtIGEgc2luZ2xlIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4oQ1IpIGNoYXJhY3RlciBub3QgZm9sbG93ZWQgYnkgYSBVKzAwMEEgTElORSBGRUVEKExGKSBjaGFyYWN0ZXJcbiAgICovXG4gIGNvbnN0IGxpbmVzOiBBcnJheTxzdHJpbmc+ID0gW11cbiAgbGV0IGluY29tcGxldGVMaW5lID0gJydcbiAgbGV0IHNlYXJjaEluZGV4ID0gMFxuXG4gIHdoaWxlIChzZWFyY2hJbmRleCA8IGNodW5rLmxlbmd0aCkge1xuICAgIC8vIEZpbmQgbmV4dCBsaW5lIHRlcm1pbmF0b3JcbiAgICBjb25zdCBjckluZGV4ID0gY2h1bmsuaW5kZXhPZignXFxyJywgc2VhcmNoSW5kZXgpXG4gICAgY29uc3QgbGZJbmRleCA9IGNodW5rLmluZGV4T2YoJ1xcbicsIHNlYXJjaEluZGV4KVxuXG4gICAgLy8gRGV0ZXJtaW5lIGxpbmUgZW5kXG4gICAgbGV0IGxpbmVFbmQgPSAtMVxuICAgIGlmIChjckluZGV4ICE9PSAtMSAmJiBsZkluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gQ1JMRiBjYXNlXG4gICAgICBsaW5lRW5kID0gTWF0aC5taW4oY3JJbmRleCwgbGZJbmRleClcbiAgICB9IGVsc2UgaWYgKGNySW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBDUiBhdCB0aGUgZW5kIG9mIGEgY2h1bmsgbWlnaHQgYmUgcGFydCBvZiBhIENSTEYgc2VxdWVuY2UgdGhhdCBzcGFucyBjaHVua3MsXG4gICAgICAvLyBzbyB3ZSBzaG91bGRuJ3QgdHJlYXQgaXQgYXMgYSBsaW5lIHRlcm1pbmF0b3IgKHlldClcbiAgICAgIGlmIChjckluZGV4ID09PSBjaHVuay5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmVFbmQgPSAtMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUVuZCA9IGNySW5kZXhcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxmSW5kZXggIT09IC0xKSB7XG4gICAgICBsaW5lRW5kID0gbGZJbmRleFxuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgbGluZSBpZiB0ZXJtaW5hdG9yIGZvdW5kXG4gICAgaWYgKGxpbmVFbmQgPT09IC0xKSB7XG4gICAgICAvLyBObyB0ZXJtaW5hdG9yIGZvdW5kLCByZXN0IGlzIGluY29tcGxldGVcbiAgICAgIGluY29tcGxldGVMaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgpXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgsIGxpbmVFbmQpXG4gICAgICBsaW5lcy5wdXNoKGxpbmUpXG5cbiAgICAgIC8vIE1vdmUgcGFzdCBsaW5lIHRlcm1pbmF0b3JcbiAgICAgIHNlYXJjaEluZGV4ID0gbGluZUVuZCArIDFcbiAgICAgIGlmIChjaHVua1tzZWFyY2hJbmRleCAtIDFdID09PSAnXFxyJyAmJiBjaHVua1tzZWFyY2hJbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgIHNlYXJjaEluZGV4KytcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2xpbmVzLCBpbmNvbXBsZXRlTGluZV1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmF1dGhvcml6ZWRFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2VFcnJvclJlc3BvbnNlID0gcGFyc2VFcnJvclJlc3BvbnNlO1xuZXhwb3J0cy5hdXRoID0gYXV0aDtcbmV4cG9ydHMuc2VsZWN0UmVzb3VyY2VVUkwgPSBzZWxlY3RSZXNvdXJjZVVSTDtcbmV4cG9ydHMuZXh0cmFjdFJlc291cmNlTWV0YWRhdGFVcmwgPSBleHRyYWN0UmVzb3VyY2VNZXRhZGF0YVVybDtcbmV4cG9ydHMuZGlzY292ZXJPQXV0aFByb3RlY3RlZFJlc291cmNlTWV0YWRhdGEgPSBkaXNjb3Zlck9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YTtcbmV4cG9ydHMuZGlzY292ZXJPQXV0aE1ldGFkYXRhID0gZGlzY292ZXJPQXV0aE1ldGFkYXRhO1xuZXhwb3J0cy5idWlsZERpc2NvdmVyeVVybHMgPSBidWlsZERpc2NvdmVyeVVybHM7XG5leHBvcnRzLmRpc2NvdmVyQXV0aG9yaXphdGlvblNlcnZlck1ldGFkYXRhID0gZGlzY292ZXJBdXRob3JpemF0aW9uU2VydmVyTWV0YWRhdGE7XG5leHBvcnRzLnN0YXJ0QXV0aG9yaXphdGlvbiA9IHN0YXJ0QXV0aG9yaXphdGlvbjtcbmV4cG9ydHMuZXhjaGFuZ2VBdXRob3JpemF0aW9uID0gZXhjaGFuZ2VBdXRob3JpemF0aW9uO1xuZXhwb3J0cy5yZWZyZXNoQXV0aG9yaXphdGlvbiA9IHJlZnJlc2hBdXRob3JpemF0aW9uO1xuZXhwb3J0cy5yZWdpc3RlckNsaWVudCA9IHJlZ2lzdGVyQ2xpZW50O1xuY29uc3QgcGtjZV9jaGFsbGVuZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGtjZS1jaGFsbGVuZ2VcIikpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXV0aC5qc1wiKTtcbmNvbnN0IGF1dGhfanNfMiA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXV0aC5qc1wiKTtcbmNvbnN0IGF1dGhfdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXV0aC11dGlscy5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL3NlcnZlci9hdXRoL2Vycm9ycy5qc1wiKTtcbmNsYXNzIFVuYXV0aG9yaXplZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ1VuYXV0aG9yaXplZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5hdXRob3JpemVkRXJyb3IgPSBVbmF1dGhvcml6ZWRFcnJvcjtcbmNvbnN0IEFVVEhPUklaQVRJT05fQ09ERV9SRVNQT05TRV9UWVBFID0gJ2NvZGUnO1xuY29uc3QgQVVUSE9SSVpBVElPTl9DT0RFX0NIQUxMRU5HRV9NRVRIT0QgPSAnUzI1Nic7XG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCB0byB1c2UgYmFzZWQgb24gc2VydmVyIHN1cHBvcnQgYW5kIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICpcbiAqIFByaW9yaXR5IG9yZGVyIChoaWdoZXN0IHRvIGxvd2VzdCk6XG4gKiAxLiBjbGllbnRfc2VjcmV0X2Jhc2ljIChpZiBjbGllbnQgc2VjcmV0IGlzIGF2YWlsYWJsZSlcbiAqIDIuIGNsaWVudF9zZWNyZXRfcG9zdCAoaWYgY2xpZW50IHNlY3JldCBpcyBhdmFpbGFibGUpXG4gKiAzLiBub25lIChmb3IgcHVibGljIGNsaWVudHMpXG4gKlxuICogQHBhcmFtIGNsaWVudEluZm9ybWF0aW9uIC0gT0F1dGggY2xpZW50IGluZm9ybWF0aW9uIGNvbnRhaW5pbmcgY3JlZGVudGlhbHNcbiAqIEBwYXJhbSBzdXBwb3J0ZWRNZXRob2RzIC0gQXV0aGVudGljYXRpb24gbWV0aG9kcyBzdXBwb3J0ZWQgYnkgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgYXV0aGVudGljYXRpb24gbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdENsaWVudEF1dGhNZXRob2QoY2xpZW50SW5mb3JtYXRpb24sIHN1cHBvcnRlZE1ldGhvZHMpIHtcbiAgICBjb25zdCBoYXNDbGllbnRTZWNyZXQgPSBjbGllbnRJbmZvcm1hdGlvbi5jbGllbnRfc2VjcmV0ICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gSWYgc2VydmVyIGRvZXNuJ3Qgc3BlY2lmeSBzdXBwb3J0ZWQgbWV0aG9kcywgdXNlIFJGQyA2NzQ5IGRlZmF1bHRzXG4gICAgaWYgKHN1cHBvcnRlZE1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXNDbGllbnRTZWNyZXQgPyAnY2xpZW50X3NlY3JldF9wb3N0JyA6ICdub25lJztcbiAgICB9XG4gICAgLy8gVHJ5IG1ldGhvZHMgaW4gcHJpb3JpdHkgb3JkZXIgKG1vc3Qgc2VjdXJlIGZpcnN0KVxuICAgIGlmIChoYXNDbGllbnRTZWNyZXQgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygnY2xpZW50X3NlY3JldF9iYXNpYycpKSB7XG4gICAgICAgIHJldHVybiAnY2xpZW50X3NlY3JldF9iYXNpYyc7XG4gICAgfVxuICAgIGlmIChoYXNDbGllbnRTZWNyZXQgJiYgc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygnY2xpZW50X3NlY3JldF9wb3N0JykpIHtcbiAgICAgICAgcmV0dXJuICdjbGllbnRfc2VjcmV0X3Bvc3QnO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydGVkTWV0aG9kcy5pbmNsdWRlcygnbm9uZScpKSB7XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiB1c2Ugd2hhdCB3ZSBoYXZlXG4gICAgcmV0dXJuIGhhc0NsaWVudFNlY3JldCA/ICdjbGllbnRfc2VjcmV0X3Bvc3QnIDogJ25vbmUnO1xufVxuLyoqXG4gKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiB0byB0aGUgcmVxdWVzdCBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIG1ldGhvZC5cbiAqXG4gKiBJbXBsZW1lbnRzIE9BdXRoIDIuMSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kczpcbiAqIC0gY2xpZW50X3NlY3JldF9iYXNpYzogSFRUUCBCYXNpYyBhdXRoZW50aWNhdGlvbiAoUkZDIDY3NDkgU2VjdGlvbiAyLjMuMSlcbiAqIC0gY2xpZW50X3NlY3JldF9wb3N0OiBDcmVkZW50aWFscyBpbiByZXF1ZXN0IGJvZHkgKFJGQyA2NzQ5IFNlY3Rpb24gMi4zLjEpXG4gKiAtIG5vbmU6IFB1YmxpYyBjbGllbnQgYXV0aGVudGljYXRpb24gKFJGQyA2NzQ5IFNlY3Rpb24gMi4xKVxuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBUaGUgYXV0aGVudGljYXRpb24gbWV0aG9kIHRvIHVzZVxuICogQHBhcmFtIGNsaWVudEluZm9ybWF0aW9uIC0gT0F1dGggY2xpZW50IGluZm9ybWF0aW9uIGNvbnRhaW5pbmcgY3JlZGVudGlhbHNcbiAqIEBwYXJhbSBoZWFkZXJzIC0gSFRUUCBoZWFkZXJzIG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSBwYXJhbXMgLSBVUkwgc2VhcmNoIHBhcmFtZXRlcnMgdG8gbW9kaWZ5XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiByZXF1aXJlZCBjcmVkZW50aWFscyBhcmUgbWlzc2luZ1xuICovXG5mdW5jdGlvbiBhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uKG1ldGhvZCwgY2xpZW50SW5mb3JtYXRpb24sIGhlYWRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0IH0gPSBjbGllbnRJbmZvcm1hdGlvbjtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X2Jhc2ljJzpcbiAgICAgICAgICAgIGFwcGx5QmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCwgaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfcG9zdCc6XG4gICAgICAgICAgICBhcHBseVBvc3RBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICBhcHBseVB1YmxpY0F1dGgoY2xpZW50X2lkLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgSFRUUCBCYXNpYyBhdXRoZW50aWNhdGlvbiAoUkZDIDY3NDkgU2VjdGlvbiAyLjMuMSlcbiAqL1xuZnVuY3Rpb24gYXBwbHlCYXNpY0F1dGgoY2xpZW50SWQsIGNsaWVudFNlY3JldCwgaGVhZGVycykge1xuICAgIGlmICghY2xpZW50U2VjcmV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2xpZW50X3NlY3JldF9iYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIGNsaWVudF9zZWNyZXQnKTtcbiAgICB9XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBidG9hKGAke2NsaWVudElkfToke2NsaWVudFNlY3JldH1gKTtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2NyZWRlbnRpYWxzfWApO1xufVxuLyoqXG4gKiBBcHBsaWVzIFBPU1QgYm9keSBhdXRoZW50aWNhdGlvbiAoUkZDIDY3NDkgU2VjdGlvbiAyLjMuMSlcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb3N0QXV0aChjbGllbnRJZCwgY2xpZW50U2VjcmV0LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnRJZCk7XG4gICAgaWYgKGNsaWVudFNlY3JldCkge1xuICAgICAgICBwYXJhbXMuc2V0KCdjbGllbnRfc2VjcmV0JywgY2xpZW50U2VjcmV0KTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgcHVibGljIGNsaWVudCBhdXRoZW50aWNhdGlvbiAoUkZDIDY3NDkgU2VjdGlvbiAyLjEpXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHVibGljQXV0aChjbGllbnRJZCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLnNldCgnY2xpZW50X2lkJywgY2xpZW50SWQpO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gT0F1dGggZXJyb3IgcmVzcG9uc2UgZnJvbSBhIHN0cmluZyBvciBSZXNwb25zZSBvYmplY3QuXG4gKlxuICogSWYgdGhlIGlucHV0IGlzIGEgc3RhbmRhcmQgT0F1dGgyLjAgZXJyb3IgcmVzcG9uc2UsIGl0IHdpbGwgYmUgcGFyc2VkIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICogYW5kIGFuIGluc3RhbmNlIG9mIHRoZSBhcHByb3ByaWF0ZSBPQXV0aEVycm9yIHN1YmNsYXNzIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBJZiBwYXJzaW5nIGZhaWxzLCBpdCBmYWxscyBiYWNrIHRvIGEgZ2VuZXJpYyBTZXJ2ZXJFcnJvciB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgcmVzcG9uc2Ugc3RhdHVzIChpZiBhdmFpbGFibGUpIGFuZCBvcmlnaW5hbCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIEEgUmVzcG9uc2Ugb2JqZWN0IG9yIHN0cmluZyBjb250YWluaW5nIHRoZSBlcnJvciByZXNwb25zZVxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gT0F1dGhFcnJvciBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUVycm9yUmVzcG9uc2UoaW5wdXQpIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gaW5wdXQgaW5zdGFuY2VvZiBSZXNwb25zZSA/IGlucHV0LnN0YXR1cyA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBib2R5ID0gaW5wdXQgaW5zdGFuY2VvZiBSZXNwb25zZSA/IGF3YWl0IGlucHV0LnRleHQoKSA6IGlucHV0O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF1dGhfanNfMS5PQXV0aEVycm9yUmVzcG9uc2VTY2hlbWEucGFyc2UoSlNPTi5wYXJzZShib2R5KSk7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IsIGVycm9yX2Rlc2NyaXB0aW9uLCBlcnJvcl91cmkgfSA9IHJlc3VsdDtcbiAgICAgICAgY29uc3QgZXJyb3JDbGFzcyA9IGVycm9yc19qc18xLk9BVVRIX0VSUk9SU1tlcnJvcl0gfHwgZXJyb3JzX2pzXzEuU2VydmVyRXJyb3I7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JDbGFzcyhlcnJvcl9kZXNjcmlwdGlvbiB8fCAnJywgZXJyb3JfdXJpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIE5vdCBhIHZhbGlkIE9BdXRoIGVycm9yIHJlc3BvbnNlLCBidXQgdHJ5IHRvIGluZm9ybSB0aGUgdXNlciBvZiB0aGUgcmF3IGRhdGEgYW55d2F5XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGAke3N0YXR1c0NvZGUgPyBgSFRUUCAke3N0YXR1c0NvZGV9OiBgIDogJyd9SW52YWxpZCBPQXV0aCBlcnJvciByZXNwb25zZTogJHtlcnJvcn0uIFJhdyBib2R5OiAke2JvZHl9YDtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcnNfanNfMS5TZXJ2ZXJFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogT3JjaGVzdHJhdGVzIHRoZSBmdWxsIGF1dGggZmxvdyB3aXRoIGEgc2VydmVyLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBzaW5nbGUgZW50cnkgcG9pbnQgZm9yIGFsbCBhdXRob3JpemF0aW9uIGZ1bmN0aW9uYWxpdHksXG4gKiBpbnN0ZWFkIG9mIGxpbmtpbmcgdG9nZXRoZXIgdGhlIG90aGVyIGxvd2VyLWxldmVsIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXV0aChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGF1dGhJbnRlcm5hbChwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBIYW5kbGUgcmVjb3ZlcmFibGUgZXJyb3IgdHlwZXMgYnkgaW52YWxpZGF0aW5nIGNyZWRlbnRpYWxzIGFuZCByZXRyeWluZ1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfanNfMS5JbnZhbGlkQ2xpZW50RXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfanNfMS5VbmF1dGhvcml6ZWRDbGllbnRFcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgKChfYSA9IHByb3ZpZGVyLmludmFsaWRhdGVDcmVkZW50aWFscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvdmlkZXIsICdhbGwnKSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXV0aEludGVybmFsKHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc19qc18xLkludmFsaWRHcmFudEVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gcHJvdmlkZXIuaW52YWxpZGF0ZUNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChwcm92aWRlciwgJ3Rva2VucycpKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhdXRoSW50ZXJuYWwocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRocm93IG90aGVyd2lzZVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhdXRoSW50ZXJuYWwocHJvdmlkZXIsIHsgc2VydmVyVXJsLCBhdXRob3JpemF0aW9uQ29kZSwgc2NvcGUsIHJlc291cmNlTWV0YWRhdGFVcmwsIGZldGNoRm4gfSkge1xuICAgIGxldCByZXNvdXJjZU1ldGFkYXRhO1xuICAgIGxldCBhdXRob3JpemF0aW9uU2VydmVyVXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc291cmNlTWV0YWRhdGEgPSBhd2FpdCBkaXNjb3Zlck9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YShzZXJ2ZXJVcmwsIHsgcmVzb3VyY2VNZXRhZGF0YVVybCB9LCBmZXRjaEZuKTtcbiAgICAgICAgaWYgKHJlc291cmNlTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9zZXJ2ZXJzICYmIHJlc291cmNlTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9zZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgPSByZXNvdXJjZU1ldGFkYXRhLmF1dGhvcml6YXRpb25fc2VydmVyc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gSWdub3JlIGVycm9ycyBhbmQgZmFsbCBiYWNrIHRvIC8ud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlclxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBnZXQgYSB2YWxpZCBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSBmcm9tIHByb3RlY3RlZCByZXNvdXJjZSBtZXRhZGF0YSxcbiAgICAgKiBmYWxsYmFjayB0byB0aGUgbGVnYWN5IE1DUCBzcGVjJ3MgaW1wbGVtZW50YXRpb24gKHZlcnNpb24gMjAyNS0wMy0yNik6IE1DUCBzZXJ2ZXIgYWN0cyBhcyB0aGUgQXV0aG9yaXphdGlvbiBzZXJ2ZXIuXG4gICAgICovXG4gICAgaWYgKCFhdXRob3JpemF0aW9uU2VydmVyVXJsKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgPSBzZXJ2ZXJVcmw7XG4gICAgfVxuICAgIGNvbnN0IHJlc291cmNlID0gYXdhaXQgc2VsZWN0UmVzb3VyY2VVUkwoc2VydmVyVXJsLCBwcm92aWRlciwgcmVzb3VyY2VNZXRhZGF0YSk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBkaXNjb3ZlckF1dGhvcml6YXRpb25TZXJ2ZXJNZXRhZGF0YShhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7XG4gICAgICAgIGZldGNoRm5cbiAgICB9KTtcbiAgICAvLyBIYW5kbGUgY2xpZW50IHJlZ2lzdHJhdGlvbiBpZiBuZWVkZWRcbiAgICBsZXQgY2xpZW50SW5mb3JtYXRpb24gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUocHJvdmlkZXIuY2xpZW50SW5mb3JtYXRpb24oKSk7XG4gICAgaWYgKCFjbGllbnRJbmZvcm1hdGlvbikge1xuICAgICAgICBpZiAoYXV0aG9yaXphdGlvbkNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGlzdGluZyBPQXV0aCBjbGllbnQgaW5mb3JtYXRpb24gaXMgcmVxdWlyZWQgd2hlbiBleGNoYW5naW5nIGFuIGF1dGhvcml6YXRpb24gY29kZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdmlkZXIuc2F2ZUNsaWVudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09BdXRoIGNsaWVudCBpbmZvcm1hdGlvbiBtdXN0IGJlIHNhdmVhYmxlIGZvciBkeW5hbWljIHJlZ2lzdHJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxJbmZvcm1hdGlvbiA9IGF3YWl0IHJlZ2lzdGVyQ2xpZW50KGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgY2xpZW50TWV0YWRhdGE6IHByb3ZpZGVyLmNsaWVudE1ldGFkYXRhLFxuICAgICAgICAgICAgZmV0Y2hGblxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIuc2F2ZUNsaWVudEluZm9ybWF0aW9uKGZ1bGxJbmZvcm1hdGlvbik7XG4gICAgICAgIGNsaWVudEluZm9ybWF0aW9uID0gZnVsbEluZm9ybWF0aW9uO1xuICAgIH1cbiAgICAvLyBFeGNoYW5nZSBhdXRob3JpemF0aW9uIGNvZGUgZm9yIHRva2Vuc1xuICAgIGlmIChhdXRob3JpemF0aW9uQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGF3YWl0IHByb3ZpZGVyLmNvZGVWZXJpZmllcigpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBleGNoYW5nZUF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvblNlcnZlclVybCwge1xuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBjbGllbnRJbmZvcm1hdGlvbixcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Db2RlLFxuICAgICAgICAgICAgY29kZVZlcmlmaWVyLFxuICAgICAgICAgICAgcmVkaXJlY3RVcmk6IHByb3ZpZGVyLnJlZGlyZWN0VXJsLFxuICAgICAgICAgICAgcmVzb3VyY2UsXG4gICAgICAgICAgICBhZGRDbGllbnRBdXRoZW50aWNhdGlvbjogcHJvdmlkZXIuYWRkQ2xpZW50QXV0aGVudGljYXRpb24sXG4gICAgICAgICAgICBmZXRjaEZuOiBmZXRjaEZuXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwcm92aWRlci5zYXZlVG9rZW5zKHRva2Vucyk7XG4gICAgICAgIHJldHVybiAnQVVUSE9SSVpFRCc7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHByb3ZpZGVyLnRva2VucygpO1xuICAgIC8vIEhhbmRsZSB0b2tlbiByZWZyZXNoIG9yIG5ldyBhdXRob3JpemF0aW9uXG4gICAgaWYgKHRva2VucyA9PT0gbnVsbCB8fCB0b2tlbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2Vucy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlZnJlc2ggdGhlIHRva2VuXG4gICAgICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSBhd2FpdCByZWZyZXNoQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgY2xpZW50SW5mb3JtYXRpb24sXG4gICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiB0b2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgICAgICAgICBhZGRDbGllbnRBdXRoZW50aWNhdGlvbjogcHJvdmlkZXIuYWRkQ2xpZW50QXV0aGVudGljYXRpb24sXG4gICAgICAgICAgICAgICAgZmV0Y2hGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBwcm92aWRlci5zYXZlVG9rZW5zKG5ld1Rva2Vucyk7XG4gICAgICAgICAgICByZXR1cm4gJ0FVVEhPUklaRUQnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIFNlcnZlckVycm9yLCBvciBhbiB1bmtub3duIHR5cGUsIGxvZyBpdCBvdXQgYW5kIHRyeSB0byBjb250aW51ZS4gT3RoZXJ3aXNlLCBlc2NhbGF0ZSBzbyB3ZSBjYW4gZml4IHRoaW5ncyBhbmQgcmV0cnkuXG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIGVycm9yc19qc18xLk9BdXRoRXJyb3IpIHx8IGVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuU2VydmVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBub3QgcmVmcmVzaCBPQXV0aCB0b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggZmFpbGVkIGZvciBhbm90aGVyIHJlYXNvbiwgcmUtdGhyb3dcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHByb3ZpZGVyLnN0YXRlID8gYXdhaXQgcHJvdmlkZXIuc3RhdGUoKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBTdGFydCBuZXcgYXV0aG9yaXphdGlvbiBmbG93XG4gICAgY29uc3QgeyBhdXRob3JpemF0aW9uVXJsLCBjb2RlVmVyaWZpZXIgfSA9IGF3YWl0IHN0YXJ0QXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7XG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBjbGllbnRJbmZvcm1hdGlvbixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlZGlyZWN0VXJsOiBwcm92aWRlci5yZWRpcmVjdFVybCxcbiAgICAgICAgc2NvcGU6IHNjb3BlIHx8IHByb3ZpZGVyLmNsaWVudE1ldGFkYXRhLnNjb3BlLFxuICAgICAgICByZXNvdXJjZVxuICAgIH0pO1xuICAgIGF3YWl0IHByb3ZpZGVyLnNhdmVDb2RlVmVyaWZpZXIoY29kZVZlcmlmaWVyKTtcbiAgICBhd2FpdCBwcm92aWRlci5yZWRpcmVjdFRvQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uVXJsKTtcbiAgICByZXR1cm4gJ1JFRElSRUNUJztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbGVjdFJlc291cmNlVVJMKHNlcnZlclVybCwgcHJvdmlkZXIsIHJlc291cmNlTWV0YWRhdGEpIHtcbiAgICBjb25zdCBkZWZhdWx0UmVzb3VyY2UgPSAoMCwgYXV0aF91dGlsc19qc18xLnJlc291cmNlVXJsRnJvbVNlcnZlclVybCkoc2VydmVyVXJsKTtcbiAgICAvLyBJZiBwcm92aWRlciBoYXMgY3VzdG9tIHZhbGlkYXRpb24sIGRlbGVnYXRlIHRvIGl0XG4gICAgaWYgKHByb3ZpZGVyLnZhbGlkYXRlUmVzb3VyY2VVUkwpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnZhbGlkYXRlUmVzb3VyY2VVUkwoZGVmYXVsdFJlc291cmNlLCByZXNvdXJjZU1ldGFkYXRhID09PSBudWxsIHx8IHJlc291cmNlTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc291cmNlTWV0YWRhdGEucmVzb3VyY2UpO1xuICAgIH1cbiAgICAvLyBPbmx5IGluY2x1ZGUgcmVzb3VyY2UgcGFyYW1ldGVyIHdoZW4gUHJvdGVjdGVkIFJlc291cmNlIE1ldGFkYXRhIGlzIHByZXNlbnRcbiAgICBpZiAoIXJlc291cmNlTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgbWV0YWRhdGEncyByZXNvdXJjZSBpcyBjb21wYXRpYmxlIHdpdGggb3VyIHJlcXVlc3RcbiAgICBpZiAoISgwLCBhdXRoX3V0aWxzX2pzXzEuY2hlY2tSZXNvdXJjZUFsbG93ZWQpKHsgcmVxdWVzdGVkUmVzb3VyY2U6IGRlZmF1bHRSZXNvdXJjZSwgY29uZmlndXJlZFJlc291cmNlOiByZXNvdXJjZU1ldGFkYXRhLnJlc291cmNlIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdGVjdGVkIHJlc291cmNlICR7cmVzb3VyY2VNZXRhZGF0YS5yZXNvdXJjZX0gZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgJHtkZWZhdWx0UmVzb3VyY2V9IChvciBvcmlnaW4pYCk7XG4gICAgfVxuICAgIC8vIFByZWZlciB0aGUgcmVzb3VyY2UgZnJvbSBtZXRhZGF0YSBzaW5jZSBpdCdzIHdoYXQgdGhlIHNlcnZlciBpcyB0ZWxsaW5nIHVzIHRvIHJlcXVlc3RcbiAgICByZXR1cm4gbmV3IFVSTChyZXNvdXJjZU1ldGFkYXRhLnJlc291cmNlKTtcbn1cbi8qKlxuICogRXh0cmFjdCByZXNvdXJjZV9tZXRhZGF0YSBmcm9tIHJlc3BvbnNlIGhlYWRlci5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJlc291cmNlTWV0YWRhdGFVcmwocmVzKSB7XG4gICAgY29uc3QgYXV0aGVudGljYXRlSGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KCdXV1ctQXV0aGVudGljYXRlJyk7XG4gICAgaWYgKCFhdXRoZW50aWNhdGVIZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgW3R5cGUsIHNjaGVtZV0gPSBhdXRoZW50aWNhdGVIZWFkZXIuc3BsaXQoJyAnKTtcbiAgICBpZiAodHlwZS50b0xvd2VyQ2FzZSgpICE9PSAnYmVhcmVyJyB8fCAhc2NoZW1lKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2V4ID0gL3Jlc291cmNlX21ldGFkYXRhPVwiKFteXCJdKilcIi87XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGF1dGhlbnRpY2F0ZUhlYWRlcik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChtYXRjaFsxXSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogTG9va3MgdXAgUkZDIDk3MjggT0F1dGggMi4wIFByb3RlY3RlZCBSZXNvdXJjZSBNZXRhZGF0YS5cbiAqXG4gKiBJZiB0aGUgc2VydmVyIHJldHVybnMgYSA0MDQgZm9yIHRoZSB3ZWxsLWtub3duIGVuZHBvaW50LCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHJldHVybiBgdW5kZWZpbmVkYC4gQW55IG90aGVyIGVycm9ycyB3aWxsIGJlIHRocm93biBhcyBleGNlcHRpb25zLlxuICovXG5hc3luYyBmdW5jdGlvbiBkaXNjb3Zlck9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YShzZXJ2ZXJVcmwsIG9wdHMsIGZldGNoRm4gPSBmZXRjaCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGlzY292ZXJNZXRhZGF0YVdpdGhGYWxsYmFjayhzZXJ2ZXJVcmwsICdvYXV0aC1wcm90ZWN0ZWQtcmVzb3VyY2UnLCBmZXRjaEZuLCB7XG4gICAgICAgIHByb3RvY29sVmVyc2lvbjogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAgICAgbWV0YWRhdGFVcmw6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5yZXNvdXJjZU1ldGFkYXRhVXJsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHNlcnZlciBkb2VzIG5vdCBpbXBsZW1lbnQgT0F1dGggMi4wIFByb3RlY3RlZCBSZXNvdXJjZSBNZXRhZGF0YS5gKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IHRyeWluZyB0byBsb2FkIHdlbGwta25vd24gT0F1dGggcHJvdGVjdGVkIHJlc291cmNlIG1ldGFkYXRhLmApO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aF9qc18yLk9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YVNjaGVtYS5wYXJzZShhd2FpdCByZXNwb25zZS5qc29uKCkpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGZldGNoIHdpdGggQ09SUyByZXRyeSBsb2dpY1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhDb3JzUmV0cnkodXJsLCBoZWFkZXJzLCBmZXRjaEZuID0gZmV0Y2gpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2hGbih1cmwsIHsgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBDT1JTIGVycm9ycyBjb21lIGJhY2sgYXMgVHlwZUVycm9yLCByZXRyeSB3aXRob3V0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hXaXRoQ29yc1JldHJ5KHVybCwgdW5kZWZpbmVkLCBmZXRjaEZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGdldHRpbmcgQ09SUyBlcnJvcnMgb24gcmV0cnkgdG9vLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIHdlbGwta25vd24gcGF0aCBmb3IgYXV0aC1yZWxhdGVkIG1ldGFkYXRhIGRpc2NvdmVyeVxuICovXG5mdW5jdGlvbiBidWlsZFdlbGxLbm93blBhdGgod2VsbEtub3duUHJlZml4LCBwYXRobmFtZSA9ICcnLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBTdHJpcCB0cmFpbGluZyBzbGFzaCBmcm9tIHBhdGhuYW1lIHRvIGF2b2lkIGRvdWJsZSBzbGFzaGVzXG4gICAgaWYgKHBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLnByZXBlbmRQYXRobmFtZSA/IGAke3BhdGhuYW1lfS8ud2VsbC1rbm93bi8ke3dlbGxLbm93blByZWZpeH1gIDogYC8ud2VsbC1rbm93bi8ke3dlbGxLbm93blByZWZpeH0ke3BhdGhuYW1lfWA7XG59XG4vKipcbiAqIFRyaWVzIHRvIGRpc2NvdmVyIE9BdXRoIG1ldGFkYXRhIGF0IGEgc3BlY2lmaWMgVVJMXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyeU1ldGFkYXRhRGlzY292ZXJ5KHVybCwgcHJvdG9jb2xWZXJzaW9uLCBmZXRjaEZuID0gZmV0Y2gpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAnTUNQLVByb3RvY29sLVZlcnNpb24nOiBwcm90b2NvbFZlcnNpb25cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBmZXRjaFdpdGhDb3JzUmV0cnkodXJsLCBoZWFkZXJzLCBmZXRjaEZuKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBmYWxsYmFjayB0byByb290IGRpc2NvdmVyeSBzaG91bGQgYmUgYXR0ZW1wdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEF0dGVtcHRGYWxsYmFjayhyZXNwb25zZSwgcGF0aG5hbWUpIHtcbiAgICByZXR1cm4gIXJlc3BvbnNlIHx8IChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCAmJiBwYXRobmFtZSAhPT0gJy8nKTtcbn1cbi8qKlxuICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgZGlzY292ZXJpbmcgT0F1dGggbWV0YWRhdGEgd2l0aCBmYWxsYmFjayBzdXBwb3J0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyTWV0YWRhdGFXaXRoRmFsbGJhY2soc2VydmVyVXJsLCB3ZWxsS25vd25UeXBlLCBmZXRjaEZuLCBvcHRzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpc3N1ZXIgPSBuZXcgVVJMKHNlcnZlclVybCk7XG4gICAgY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnByb3RvY29sVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZXNfanNfMS5MQVRFU1RfUFJPVE9DT0xfVkVSU0lPTjtcbiAgICBsZXQgdXJsO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWV0YWRhdGFVcmwpIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChvcHRzLm1ldGFkYXRhVXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRyeSBwYXRoLWF3YXJlIGRpc2NvdmVyeSBmaXJzdFxuICAgICAgICBjb25zdCB3ZWxsS25vd25QYXRoID0gYnVpbGRXZWxsS25vd25QYXRoKHdlbGxLbm93blR5cGUsIGlzc3Vlci5wYXRobmFtZSk7XG4gICAgICAgIHVybCA9IG5ldyBVUkwod2VsbEtub3duUGF0aCwgKF9iID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLm1ldGFkYXRhU2VydmVyVXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpc3N1ZXIpO1xuICAgICAgICB1cmwuc2VhcmNoID0gaXNzdWVyLnNlYXJjaDtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdHJ5TWV0YWRhdGFEaXNjb3ZlcnkodXJsLCBwcm90b2NvbFZlcnNpb24sIGZldGNoRm4pO1xuICAgIC8vIElmIHBhdGgtYXdhcmUgZGlzY292ZXJ5IGZhaWxzIHdpdGggNDA0IGFuZCB3ZSdyZSBub3QgYWxyZWFkeSBhdCByb290LCB0cnkgZmFsbGJhY2sgdG8gcm9vdCBkaXNjb3ZlcnlcbiAgICBpZiAoIShvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWV0YWRhdGFVcmwpICYmIHNob3VsZEF0dGVtcHRGYWxsYmFjayhyZXNwb25zZSwgaXNzdWVyLnBhdGhuYW1lKSkge1xuICAgICAgICBjb25zdCByb290VXJsID0gbmV3IFVSTChgLy53ZWxsLWtub3duLyR7d2VsbEtub3duVHlwZX1gLCBpc3N1ZXIpO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRyeU1ldGFkYXRhRGlzY292ZXJ5KHJvb3RVcmwsIHByb3RvY29sVmVyc2lvbiwgZmV0Y2hGbik7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbi8qKlxuICogTG9va3MgdXAgUkZDIDg0MTQgT0F1dGggMi4wIEF1dGhvcml6YXRpb24gU2VydmVyIE1ldGFkYXRhLlxuICpcbiAqIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhIDQwNCBmb3IgdGhlIHdlbGwta25vd24gZW5kcG9pbnQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogcmV0dXJuIGB1bmRlZmluZWRgLiBBbnkgb3RoZXIgZXJyb3JzIHdpbGwgYmUgdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGBkaXNjb3ZlckF1dGhvcml6YXRpb25TZXJ2ZXJNZXRhZGF0YWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyT0F1dGhNZXRhZGF0YShpc3N1ZXIsIHsgYXV0aG9yaXphdGlvblNlcnZlclVybCwgcHJvdG9jb2xWZXJzaW9uIH0gPSB7fSwgZmV0Y2hGbiA9IGZldGNoKSB7XG4gICAgaWYgKHR5cGVvZiBpc3N1ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlzc3VlciA9IG5ldyBVUkwoaXNzdWVyKTtcbiAgICB9XG4gICAgaWYgKCFhdXRob3JpemF0aW9uU2VydmVyVXJsKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgPSBpc3N1ZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvblNlcnZlclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblNlcnZlclVybCA9IG5ldyBVUkwoYXV0aG9yaXphdGlvblNlcnZlclVybCk7XG4gICAgfVxuICAgIHByb3RvY29sVmVyc2lvbiAhPT0gbnVsbCAmJiBwcm90b2NvbFZlcnNpb24gIT09IHZvaWQgMCA/IHByb3RvY29sVmVyc2lvbiA6IChwcm90b2NvbFZlcnNpb24gPSB0eXBlc19qc18xLkxBVEVTVF9QUk9UT0NPTF9WRVJTSU9OKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRpc2NvdmVyTWV0YWRhdGFXaXRoRmFsbGJhY2soYXV0aG9yaXphdGlvblNlcnZlclVybCwgJ29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyJywgZmV0Y2hGbiwge1xuICAgICAgICBwcm90b2NvbFZlcnNpb24sXG4gICAgICAgIG1ldGFkYXRhU2VydmVyVXJsOiBhdXRob3JpemF0aW9uU2VydmVyVXJsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gdHJ5aW5nIHRvIGxvYWQgd2VsbC1rbm93biBPQXV0aCBtZXRhZGF0YWApO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aF9qc18yLk9BdXRoTWV0YWRhdGFTY2hlbWEucGFyc2UoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgbGlzdCBvZiBkaXNjb3ZlcnkgVVJMcyB0byB0cnkgZm9yIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhLlxuICogVVJMcyBhcmUgcmV0dXJuZWQgaW4gcHJpb3JpdHkgb3JkZXI6XG4gKiAxLiBPQXV0aCBtZXRhZGF0YSBhdCB0aGUgZ2l2ZW4gVVJMXG4gKiAyLiBPQXV0aCBtZXRhZGF0YSBhdCByb290IChpZiBVUkwgaGFzIHBhdGgpXG4gKiAzLiBPSURDIG1ldGFkYXRhIGVuZHBvaW50c1xuICovXG5mdW5jdGlvbiBidWlsZERpc2NvdmVyeVVybHMoYXV0aG9yaXphdGlvblNlcnZlclVybCkge1xuICAgIGNvbnN0IHVybCA9IHR5cGVvZiBhdXRob3JpemF0aW9uU2VydmVyVXJsID09PSAnc3RyaW5nJyA/IG5ldyBVUkwoYXV0aG9yaXphdGlvblNlcnZlclVybCkgOiBhdXRob3JpemF0aW9uU2VydmVyVXJsO1xuICAgIGNvbnN0IGhhc1BhdGggPSB1cmwucGF0aG5hbWUgIT09ICcvJztcbiAgICBjb25zdCB1cmxzVG9UcnkgPSBbXTtcbiAgICBpZiAoIWhhc1BhdGgpIHtcbiAgICAgICAgLy8gUm9vdCBwYXRoOiBodHRwczovL2V4YW1wbGUuY29tLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyXG4gICAgICAgIHVybHNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgIHVybDogbmV3IFVSTCgnLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyJywgdXJsLm9yaWdpbiksXG4gICAgICAgICAgICB0eXBlOiAnb2F1dGgnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPSURDOiBodHRwczovL2V4YW1wbGUuY29tLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uXG4gICAgICAgIHVybHNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgIHVybDogbmV3IFVSTChgLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYCwgdXJsLm9yaWdpbiksXG4gICAgICAgICAgICB0eXBlOiAnb2lkYydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmxzVG9Ucnk7XG4gICAgfVxuICAgIC8vIFN0cmlwIHRyYWlsaW5nIHNsYXNoIGZyb20gcGF0aG5hbWUgdG8gYXZvaWQgZG91YmxlIHNsYXNoZXNcbiAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWU7XG4gICAgaWYgKHBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8vIDEuIE9BdXRoIG1ldGFkYXRhIGF0IHRoZSBnaXZlbiBVUkxcbiAgICAvLyBJbnNlcnQgd2VsbC1rbm93biBiZWZvcmUgdGhlIHBhdGg6IGh0dHBzOi8vZXhhbXBsZS5jb20vLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXIvdGVuYW50MVxuICAgIHVybHNUb1RyeS5wdXNoKHtcbiAgICAgICAgdXJsOiBuZXcgVVJMKGAvLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXIke3BhdGhuYW1lfWAsIHVybC5vcmlnaW4pLFxuICAgICAgICB0eXBlOiAnb2F1dGgnXG4gICAgfSk7XG4gICAgLy8gUm9vdCBwYXRoOiBodHRwczovL2V4YW1wbGUuY29tLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyXG4gICAgdXJsc1RvVHJ5LnB1c2goe1xuICAgICAgICB1cmw6IG5ldyBVUkwoJy8ud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlcicsIHVybC5vcmlnaW4pLFxuICAgICAgICB0eXBlOiAnb2F1dGgnXG4gICAgfSk7XG4gICAgLy8gMy4gT0lEQyBtZXRhZGF0YSBlbmRwb2ludHNcbiAgICAvLyBSRkMgODQxNCBzdHlsZTogSW5zZXJ0IC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbiBiZWZvcmUgdGhlIHBhdGhcbiAgICB1cmxzVG9UcnkucHVzaCh7XG4gICAgICAgIHVybDogbmV3IFVSTChgLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJHtwYXRobmFtZX1gLCB1cmwub3JpZ2luKSxcbiAgICAgICAgdHlwZTogJ29pZGMnXG4gICAgfSk7XG4gICAgLy8gT0lEQyBEaXNjb3ZlcnkgMS4wIHN0eWxlOiBBcHBlbmQgLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uIGFmdGVyIHRoZSBwYXRoXG4gICAgdXJsc1RvVHJ5LnB1c2goe1xuICAgICAgICB1cmw6IG5ldyBVUkwoYCR7cGF0aG5hbWV9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYCwgdXJsLm9yaWdpbiksXG4gICAgICAgIHR5cGU6ICdvaWRjJ1xuICAgIH0pO1xuICAgIHJldHVybiB1cmxzVG9Ucnk7XG59XG4vKipcbiAqIERpc2NvdmVycyBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSB3aXRoIHN1cHBvcnQgZm9yIFJGQyA4NDE0IE9BdXRoIDIuMCBBdXRob3JpemF0aW9uIFNlcnZlciBNZXRhZGF0YVxuICogYW5kIE9wZW5JRCBDb25uZWN0IERpc2NvdmVyeSAxLjAgc3BlY2lmaWNhdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIGEgZmFsbGJhY2sgc3RyYXRlZ3kgZm9yIGF1dGhvcml6YXRpb24gc2VydmVyIGRpc2NvdmVyeTpcbiAqIDEuIEF0dGVtcHRzIFJGQyA4NDE0IE9BdXRoIG1ldGFkYXRhIGRpc2NvdmVyeSBmaXJzdFxuICogMi4gSWYgT0F1dGggZGlzY292ZXJ5IGZhaWxzLCBmYWxscyBiYWNrIHRvIE9wZW5JRCBDb25uZWN0IERpc2NvdmVyeVxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uU2VydmVyVXJsIC0gVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIFVSTCBvYnRhaW5lZCBmcm9tIHRoZSBNQ1AgU2VydmVyJ3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHJlc291cmNlIG1ldGFkYXRhLCBvciB0aGUgTUNQIHNlcnZlcidzIFVSTCBpZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgd2FzIG5vdCBmb3VuZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy5mZXRjaEZuIC0gT3B0aW9uYWwgZmV0Y2ggZnVuY3Rpb24gZm9yIG1ha2luZyBIVFRQIHJlcXVlc3RzLCBkZWZhdWx0cyB0byBnbG9iYWwgZmV0Y2hcbiAqIEBwYXJhbSBvcHRpb25zLnByb3RvY29sVmVyc2lvbiAtIE1DUCBwcm90b2NvbCB2ZXJzaW9uIHRvIHVzZSwgZGVmYXVsdHMgdG8gTEFURVNUX1BST1RPQ09MX1ZFUlNJT05cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhLCBvciB1bmRlZmluZWQgaWYgZGlzY292ZXJ5IGZhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyQXV0aG9yaXphdGlvblNlcnZlck1ldGFkYXRhKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHsgZmV0Y2hGbiA9IGZldGNoLCBwcm90b2NvbFZlcnNpb24gPSB0eXBlc19qc18xLkxBVEVTVF9QUk9UT0NPTF9WRVJTSU9OIH0gPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdNQ1AtUHJvdG9jb2wtVmVyc2lvbic6IHByb3RvY29sVmVyc2lvbiB9O1xuICAgIC8vIEdldCB0aGUgbGlzdCBvZiBVUkxzIHRvIHRyeVxuICAgIGNvbnN0IHVybHNUb1RyeSA9IGJ1aWxkRGlzY292ZXJ5VXJscyhhdXRob3JpemF0aW9uU2VydmVyVXJsKTtcbiAgICAvLyBUcnkgZWFjaCBVUkwgaW4gb3JkZXJcbiAgICBmb3IgKGNvbnN0IHsgdXJsOiBlbmRwb2ludFVybCwgdHlwZSB9IG9mIHVybHNUb1RyeSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aENvcnNSZXRyeShlbmRwb2ludFVybCwgaGVhZGVycywgZmV0Y2hGbik7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ09SUyBlcnJvciBvY2N1cnJlZCAtIGRvbid0IHRocm93IGFzIHRoZSBlbmRwb2ludCBtYXkgbm90IGFsbG93IENPUlMsXG4gICAgICAgICAgICAgKiBjb250aW51ZSB0cnlpbmcgb3RoZXIgcG9zc2libGUgZW5kcG9pbnRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGxvb2tpbmcgZm9yIGFueSA0eHggcmVzcG9uc2UgY29kZS5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBUcnkgbmV4dCBVUkxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gdHJ5aW5nIHRvIGxvYWQgJHt0eXBlID09PSAnb2F1dGgnID8gJ09BdXRoJyA6ICdPcGVuSUQgcHJvdmlkZXInfSBtZXRhZGF0YSBmcm9tICR7ZW5kcG9pbnRVcmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgYW5kIHZhbGlkYXRlIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYXV0aCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRoX2pzXzIuT0F1dGhNZXRhZGF0YVNjaGVtYS5wYXJzZShhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhfanNfMS5PcGVuSWRQcm92aWRlckRpc2NvdmVyeU1ldGFkYXRhU2NoZW1hLnBhcnNlKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQmVnaW5zIHRoZSBhdXRob3JpemF0aW9uIGZsb3cgd2l0aCB0aGUgZ2l2ZW4gc2VydmVyLCBieSBnZW5lcmF0aW5nIGEgUEtDRSBjaGFsbGVuZ2UgYW5kIGNvbnN0cnVjdGluZyB0aGUgYXV0aG9yaXphdGlvbiBVUkwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0QXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7IG1ldGFkYXRhLCBjbGllbnRJbmZvcm1hdGlvbiwgcmVkaXJlY3RVcmwsIHNjb3BlLCBzdGF0ZSwgcmVzb3VyY2UgfSkge1xuICAgIGxldCBhdXRob3JpemF0aW9uVXJsO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsID0gbmV3IFVSTChtZXRhZGF0YS5hdXRob3JpemF0aW9uX2VuZHBvaW50KTtcbiAgICAgICAgaWYgKCFtZXRhZGF0YS5yZXNwb25zZV90eXBlc19zdXBwb3J0ZWQuaW5jbHVkZXMoQVVUSE9SSVpBVElPTl9DT0RFX1JFU1BPTlNFX1RZUEUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBhdXRoIHNlcnZlcjogZG9lcyBub3Qgc3VwcG9ydCByZXNwb25zZSB0eXBlICR7QVVUSE9SSVpBVElPTl9DT0RFX1JFU1BPTlNFX1RZUEV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkICYmXG4gICAgICAgICAgICAhbWV0YWRhdGEuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQuaW5jbHVkZXMoQVVUSE9SSVpBVElPTl9DT0RFX0NIQUxMRU5HRV9NRVRIT0QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBhdXRoIHNlcnZlcjogZG9lcyBub3Qgc3VwcG9ydCBjb2RlIGNoYWxsZW5nZSBtZXRob2QgJHtBVVRIT1JJWkFUSU9OX0NPREVfQ0hBTExFTkdFX01FVEhPRH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybCA9IG5ldyBVUkwoJy9hdXRob3JpemUnLCBhdXRob3JpemF0aW9uU2VydmVyVXJsKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgUEtDRSBjaGFsbGVuZ2VcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBhd2FpdCAoMCwgcGtjZV9jaGFsbGVuZ2VfMS5kZWZhdWx0KSgpO1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGNoYWxsZW5nZS5jb2RlX3ZlcmlmaWVyO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBjaGFsbGVuZ2UuY29kZV9jaGFsbGVuZ2U7XG4gICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZXNwb25zZV90eXBlJywgQVVUSE9SSVpBVElPTl9DT0RFX1JFU1BPTlNFX1RZUEUpO1xuICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnY2xpZW50X2lkJywgY2xpZW50SW5mb3JtYXRpb24uY2xpZW50X2lkKTtcbiAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvZGVfY2hhbGxlbmdlJywgY29kZUNoYWxsZW5nZSk7XG4gICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2RlX2NoYWxsZW5nZV9tZXRob2QnLCBBVVRIT1JJWkFUSU9OX0NPREVfQ0hBTExFTkdFX01FVEhPRCk7XG4gICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZWRpcmVjdF91cmknLCBTdHJpbmcocmVkaXJlY3RVcmwpKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdzdGF0ZScsIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnc2NvcGUnLCBzY29wZSk7XG4gICAgfVxuICAgIGlmIChzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuaW5jbHVkZXMoJ29mZmxpbmVfYWNjZXNzJykpIHtcbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3QgaW5jbHVkZXMgdGhlIE9JREMtb25seSBcIm9mZmxpbmVfYWNjZXNzXCIgc2NvcGUsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoZSBwcm9tcHQgdG8gXCJjb25zZW50XCIgdG8gZW5zdXJlIHRoZSB1c2VyIGlzIHByb21wdGVkIHRvIGdyYW50IG9mZmxpbmUgYWNjZXNzXG4gICAgICAgIC8vIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1jb3JlLTFfMC5odG1sI09mZmxpbmVBY2Nlc3NcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwcm9tcHQnLCAnY29uc2VudCcpO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZXNvdXJjZScsIHJlc291cmNlLmhyZWYpO1xuICAgIH1cbiAgICByZXR1cm4geyBhdXRob3JpemF0aW9uVXJsLCBjb2RlVmVyaWZpZXIgfTtcbn1cbi8qKlxuICogRXhjaGFuZ2VzIGFuIGF1dGhvcml6YXRpb24gY29kZSBmb3IgYW4gYWNjZXNzIHRva2VuIHdpdGggdGhlIGdpdmVuIHNlcnZlci5cbiAqXG4gKiBTdXBwb3J0cyBtdWx0aXBsZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhcyBzcGVjaWZpZWQgaW4gT0F1dGggMi4xOlxuICogLSBBdXRvbWF0aWNhbGx5IHNlbGVjdHMgdGhlIGJlc3QgYXV0aGVudGljYXRpb24gbWV0aG9kIGJhc2VkIG9uIHNlcnZlciBzdXBwb3J0XG4gKiAtIEZhbGxzIGJhY2sgdG8gYXBwcm9wcmlhdGUgZGVmYXVsdHMgd2hlbiBzZXJ2ZXIgbWV0YWRhdGEgaXMgdW5hdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvblNlcnZlclVybCAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlcidzIGJhc2UgVVJMXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgY2xpZW50IGluZm8sIGF1dGggY29kZSwgZXRjLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gT0F1dGggdG9rZW5zXG4gKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiB0b2tlbiBleGNoYW5nZSBmYWlscyBvciBhdXRoZW50aWNhdGlvbiBpcyBpbnZhbGlkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4Y2hhbmdlQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7IG1ldGFkYXRhLCBjbGllbnRJbmZvcm1hdGlvbiwgYXV0aG9yaXphdGlvbkNvZGUsIGNvZGVWZXJpZmllciwgcmVkaXJlY3RVcmksIHJlc291cmNlLCBhZGRDbGllbnRBdXRoZW50aWNhdGlvbiwgZmV0Y2hGbiB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGdyYW50VHlwZSA9ICdhdXRob3JpemF0aW9uX2NvZGUnO1xuICAgIGNvbnN0IHRva2VuVXJsID0gKG1ldGFkYXRhID09PSBudWxsIHx8IG1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhZGF0YS50b2tlbl9lbmRwb2ludCkgPyBuZXcgVVJMKG1ldGFkYXRhLnRva2VuX2VuZHBvaW50KSA6IG5ldyBVUkwoJy90b2tlbicsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpO1xuICAgIGlmICgobWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLmdyYW50X3R5cGVzX3N1cHBvcnRlZCkgJiYgIW1ldGFkYXRhLmdyYW50X3R5cGVzX3N1cHBvcnRlZC5pbmNsdWRlcyhncmFudFR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGF1dGggc2VydmVyOiBkb2VzIG5vdCBzdXBwb3J0IGdyYW50IHR5cGUgJHtncmFudFR5cGV9YCk7XG4gICAgfVxuICAgIC8vIEV4Y2hhbmdlIGNvZGUgZm9yIHRva2Vuc1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbidcbiAgICB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgZ3JhbnRfdHlwZTogZ3JhbnRUeXBlLFxuICAgICAgICBjb2RlOiBhdXRob3JpemF0aW9uQ29kZSxcbiAgICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgICByZWRpcmVjdF91cmk6IFN0cmluZyhyZWRpcmVjdFVyaSlcbiAgICB9KTtcbiAgICBpZiAoYWRkQ2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgYWRkQ2xpZW50QXV0aGVudGljYXRpb24oaGVhZGVycywgcGFyYW1zLCBhdXRob3JpemF0aW9uU2VydmVyVXJsLCBtZXRhZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEZXRlcm1pbmUgYW5kIGFwcGx5IGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkTWV0aG9kcyA9IChfYSA9IG1ldGFkYXRhID09PSBudWxsIHx8IG1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhZGF0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgY29uc3QgYXV0aE1ldGhvZCA9IHNlbGVjdENsaWVudEF1dGhNZXRob2QoY2xpZW50SW5mb3JtYXRpb24sIHN1cHBvcnRlZE1ldGhvZHMpO1xuICAgICAgICBhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uKGF1dGhNZXRob2QsIGNsaWVudEluZm9ybWF0aW9uLCBoZWFkZXJzLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgcGFyYW1zLnNldCgncmVzb3VyY2UnLCByZXNvdXJjZS5ocmVmKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoZmV0Y2hGbiAhPT0gbnVsbCAmJiBmZXRjaEZuICE9PSB2b2lkIDAgPyBmZXRjaEZuIDogZmV0Y2gpKHRva2VuVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBwYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IGF3YWl0IHBhcnNlRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoX2pzXzIuT0F1dGhUb2tlbnNTY2hlbWEucGFyc2UoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbn1cbi8qKlxuICogRXhjaGFuZ2UgYSByZWZyZXNoIHRva2VuIGZvciBhbiB1cGRhdGVkIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiBTdXBwb3J0cyBtdWx0aXBsZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhcyBzcGVjaWZpZWQgaW4gT0F1dGggMi4xOlxuICogLSBBdXRvbWF0aWNhbGx5IHNlbGVjdHMgdGhlIGJlc3QgYXV0aGVudGljYXRpb24gbWV0aG9kIGJhc2VkIG9uIHNlcnZlciBzdXBwb3J0XG4gKiAtIFByZXNlcnZlcyB0aGUgb3JpZ2luYWwgcmVmcmVzaCB0b2tlbiBpZiBhIG5ldyBvbmUgaXMgbm90IHJldHVybmVkXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgLSBUaGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIncyBiYXNlIFVSTFxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIGNsaWVudCBpbmZvLCByZWZyZXNoIHRva2VuLCBldGMuXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBPQXV0aCB0b2tlbnMgKHByZXNlcnZlcyBvcmlnaW5hbCByZWZyZXNoX3Rva2VuIGlmIG5vdCByZXBsYWNlZClcbiAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHRva2VuIHJlZnJlc2ggZmFpbHMgb3IgYXV0aGVudGljYXRpb24gaXMgaW52YWxpZFxuICovXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7IG1ldGFkYXRhLCBjbGllbnRJbmZvcm1hdGlvbiwgcmVmcmVzaFRva2VuLCByZXNvdXJjZSwgYWRkQ2xpZW50QXV0aGVudGljYXRpb24sIGZldGNoRm4gfSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBncmFudFR5cGUgPSAncmVmcmVzaF90b2tlbic7XG4gICAgbGV0IHRva2VuVXJsO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICB0b2tlblVybCA9IG5ldyBVUkwobWV0YWRhdGEudG9rZW5fZW5kcG9pbnQpO1xuICAgICAgICBpZiAobWV0YWRhdGEuZ3JhbnRfdHlwZXNfc3VwcG9ydGVkICYmICFtZXRhZGF0YS5ncmFudF90eXBlc19zdXBwb3J0ZWQuaW5jbHVkZXMoZ3JhbnRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgYXV0aCBzZXJ2ZXI6IGRvZXMgbm90IHN1cHBvcnQgZ3JhbnQgdHlwZSAke2dyYW50VHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdG9rZW5VcmwgPSBuZXcgVVJMKCcvdG9rZW4nLCBhdXRob3JpemF0aW9uU2VydmVyVXJsKTtcbiAgICB9XG4gICAgLy8gRXhjaGFuZ2UgcmVmcmVzaCB0b2tlblxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBncmFudF90eXBlOiBncmFudFR5cGUsXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlblxuICAgIH0pO1xuICAgIGlmIChhZGRDbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBhZGRDbGllbnRBdXRoZW50aWNhdGlvbihoZWFkZXJzLCBwYXJhbXMsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERldGVybWluZSBhbmQgYXBwbHkgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZFxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRNZXRob2RzID0gKF9hID0gbWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gc2VsZWN0Q2xpZW50QXV0aE1ldGhvZChjbGllbnRJbmZvcm1hdGlvbiwgc3VwcG9ydGVkTWV0aG9kcyk7XG4gICAgICAgIGFwcGx5Q2xpZW50QXV0aGVudGljYXRpb24oYXV0aE1ldGhvZCwgY2xpZW50SW5mb3JtYXRpb24sIGhlYWRlcnMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICBwYXJhbXMuc2V0KCdyZXNvdXJjZScsIHJlc291cmNlLmhyZWYpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChmZXRjaEZuICE9PSBudWxsICYmIGZldGNoRm4gIT09IHZvaWQgMCA/IGZldGNoRm4gOiBmZXRjaCkodG9rZW5VcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHBhcmFtc1xuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgcGFyc2VFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhfanNfMi5PQXV0aFRva2Vuc1NjaGVtYS5wYXJzZSh7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiwgLi4uKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgfSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIE9BdXRoIDIuMCBEeW5hbWljIENsaWVudCBSZWdpc3RyYXRpb24gYWNjb3JkaW5nIHRvIFJGQyA3NTkxLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWdpc3RlckNsaWVudChhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7IG1ldGFkYXRhLCBjbGllbnRNZXRhZGF0YSwgZmV0Y2hGbiB9KSB7XG4gICAgbGV0IHJlZ2lzdHJhdGlvblVybDtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKCFtZXRhZGF0YS5yZWdpc3RyYXRpb25fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGF1dGggc2VydmVyOiBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgY2xpZW50IHJlZ2lzdHJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdHJhdGlvblVybCA9IG5ldyBVUkwobWV0YWRhdGEucmVnaXN0cmF0aW9uX2VuZHBvaW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvblVybCA9IG5ldyBVUkwoJy9yZWdpc3RlcicsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChmZXRjaEZuICE9PSBudWxsICYmIGZldGNoRm4gIT09IHZvaWQgMCA/IGZldGNoRm4gOiBmZXRjaCkocmVnaXN0cmF0aW9uVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNsaWVudE1ldGFkYXRhKVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgcGFyc2VFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhfanNfMi5PQXV0aENsaWVudEluZm9ybWF0aW9uRnVsbFNjaGVtYS5wYXJzZShhd2FpdCByZXNwb25zZS5qc29uKCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiLG51bGwsImxldCBjcnlwdG87XG5jcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0bzsgLy8gd2ViIGJyb3dzZXJzXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbGVuZ3RoIGBzaXplYCBvZiByYW5kb20gYnl0ZXNcbiAqIEBwYXJhbSBzaXplXG4gKiBAcmV0dXJucyBBcnJheSBvZiByYW5kb20gaW50cyAoMCB0byAyNTUpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJhbmRvbVZhbHVlcyhzaXplKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG59XG4vKiogR2VuZXJhdGUgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIHJhbmRvbSBzdHJpbmdcbiAqIEBwYXJhbSBzaXplIFRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gKiBAcmV0dXJucyBUaGUgcmFuZG9tIHN0cmluZ1xuICovXG5hc3luYyBmdW5jdGlvbiByYW5kb20oc2l6ZSkge1xuICAgIGNvbnN0IG1hc2sgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5LS5fflwiO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IHJhbmRvbVVpbnRzID0gYXdhaXQgZ2V0UmFuZG9tVmFsdWVzKHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIC8vIGNhcCB0aGUgdmFsdWUgb2YgdGhlIHJhbmRvbUluZGV4IHRvIG1hc2subGVuZ3RoIC0gMVxuICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IHJhbmRvbVVpbnRzW2ldICUgbWFzay5sZW5ndGg7XG4gICAgICAgIHJlc3VsdCArPSBtYXNrW3JhbmRvbUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBHZW5lcmF0ZSBhIFBLQ0UgY2hhbGxlbmdlIHZlcmlmaWVyXG4gKiBAcGFyYW0gbGVuZ3RoIExlbmd0aCBvZiB0aGUgdmVyaWZpZXJcbiAqIEByZXR1cm5zIEEgcmFuZG9tIHZlcmlmaWVyIGBsZW5ndGhgIGNoYXJhY3RlcnMgbG9uZ1xuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVZlcmlmaWVyKGxlbmd0aCkge1xuICAgIHJldHVybiBhd2FpdCByYW5kb20obGVuZ3RoKTtcbn1cbi8qKiBHZW5lcmF0ZSBhIFBLQ0UgY29kZSBjaGFsbGVuZ2UgZnJvbSBhIGNvZGUgdmVyaWZpZXJcbiAqIEBwYXJhbSBjb2RlX3ZlcmlmaWVyXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IHVybCBlbmNvZGVkIGNvZGUgY2hhbGxlbmdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNoYWxsZW5nZShjb2RlX3ZlcmlmaWVyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgKGF3YWl0IGNyeXB0bykuc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNvZGVfdmVyaWZpZXIpKTtcbiAgICAvLyBHZW5lcmF0ZSBiYXNlNjR1cmwgc3RyaW5nXG4gICAgLy8gYnRvYSBpcyBkZXByZWNhdGVkIGluIE5vZGUuanMgYnV0IGlzIHVzZWQgaGVyZSBmb3Igd2ViIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgIC8vICh3aGljaCBoYXMgbm8gZ29vZCByZXBsYWNlbWVudCB5ZXQsIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvNjgxMSlcbiAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KGJ1ZmZlcikpKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgIC5yZXBsYWNlKC89L2csICcnKTtcbn1cbi8qKiBHZW5lcmF0ZSBhIFBLQ0UgY2hhbGxlbmdlIHBhaXJcbiAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIG9mIHRoZSB2ZXJpZmVyIChiZXR3ZWVuIDQzLTEyOCkuIERlZmF1bHRzIHRvIDQzLlxuICogQHJldHVybnMgUEtDRSBjaGFsbGVuZ2UgcGFpclxuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwa2NlQ2hhbGxlbmdlKGxlbmd0aCkge1xuICAgIGlmICghbGVuZ3RoKVxuICAgICAgICBsZW5ndGggPSA0MztcbiAgICBpZiAobGVuZ3RoIDwgNDMgfHwgbGVuZ3RoID4gMTI4KSB7XG4gICAgICAgIHRocm93IGBFeHBlY3RlZCBhIGxlbmd0aCBiZXR3ZWVuIDQzIGFuZCAxMjguIFJlY2VpdmVkICR7bGVuZ3RofS5gO1xuICAgIH1cbiAgICBjb25zdCB2ZXJpZmllciA9IGF3YWl0IGdlbmVyYXRlVmVyaWZpZXIobGVuZ3RoKTtcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZUNoYWxsZW5nZSh2ZXJpZmllcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZV92ZXJpZmllcjogdmVyaWZpZXIsXG4gICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjaGFsbGVuZ2UsXG4gICAgfTtcbn1cbi8qKiBWZXJpZnkgdGhhdCBhIGNvZGVfdmVyaWZpZXIgcHJvZHVjZXMgdGhlIGV4cGVjdGVkIGNvZGUgY2hhbGxlbmdlXG4gKiBAcGFyYW0gY29kZV92ZXJpZmllclxuICogQHBhcmFtIGV4cGVjdGVkQ2hhbGxlbmdlIFRoZSBjb2RlIGNoYWxsZW5nZSB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIFRydWUgaWYgY2hhbGxlbmdlcyBhcmUgZXF1YWwuIEZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUNoYWxsZW5nZShjb2RlX3ZlcmlmaWVyLCBleHBlY3RlZENoYWxsZW5nZSkge1xuICAgIGNvbnN0IGFjdHVhbENoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlQ2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIpO1xuICAgIHJldHVybiBhY3R1YWxDaGFsbGVuZ2UgPT09IGV4cGVjdGVkQ2hhbGxlbmdlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9BdXRoVG9rZW5SZXZvY2F0aW9uUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuT0F1dGhDbGllbnRSZWdpc3RyYXRpb25FcnJvclNjaGVtYSA9IGV4cG9ydHMuT0F1dGhDbGllbnRJbmZvcm1hdGlvbkZ1bGxTY2hlbWEgPSBleHBvcnRzLk9BdXRoQ2xpZW50SW5mb3JtYXRpb25TY2hlbWEgPSBleHBvcnRzLk9BdXRoQ2xpZW50TWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLk9BdXRoRXJyb3JSZXNwb25zZVNjaGVtYSA9IGV4cG9ydHMuT0F1dGhUb2tlbnNTY2hlbWEgPSBleHBvcnRzLk9wZW5JZFByb3ZpZGVyRGlzY292ZXJ5TWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLk9wZW5JZFByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLk9BdXRoTWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLk9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuU2FmZVVybFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogUmV1c2FibGUgVVJMIHZhbGlkYXRpb24gdGhhdCBkaXNhbGxvd3MgamF2YXNjcmlwdDogc2NoZW1lXG4gKi9cbmV4cG9ydHMuU2FmZVVybFNjaGVtYSA9IHpvZF8xLnpcbiAgICAuc3RyaW5nKClcbiAgICAudXJsKClcbiAgICAuc3VwZXJSZWZpbmUoKHZhbCwgY3R4KSA9PiB7XG4gICAgaWYgKCFVUkwuY2FuUGFyc2UodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgY29kZTogem9kXzEuei5ab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1VSTCBtdXN0IGJlIHBhcnNlYWJsZScsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHpvZF8xLnouTkVWRVI7XG4gICAgfVxufSlcbiAgICAucmVmaW5lKHVybCA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gdS5wcm90b2NvbCAhPT0gJ2phdmFzY3JpcHQ6JyAmJiB1LnByb3RvY29sICE9PSAnZGF0YTonICYmIHUucHJvdG9jb2wgIT09ICd2YnNjcmlwdDonO1xufSwgeyBtZXNzYWdlOiAnVVJMIGNhbm5vdCB1c2UgamF2YXNjcmlwdDosIGRhdGE6LCBvciB2YnNjcmlwdDogc2NoZW1lJyB9KTtcbi8qKlxuICogUkZDIDk3MjggT0F1dGggUHJvdGVjdGVkIFJlc291cmNlIE1ldGFkYXRhXG4gKi9cbmV4cG9ydHMuT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHJlc291cmNlOiB6b2RfMS56LnN0cmluZygpLnVybCgpLFxuICAgIGF1dGhvcml6YXRpb25fc2VydmVyczogem9kXzEuei5hcnJheShleHBvcnRzLlNhZmVVcmxTY2hlbWEpLm9wdGlvbmFsKCksXG4gICAgandrc191cmk6IHpvZF8xLnouc3RyaW5nKCkudXJsKCkub3B0aW9uYWwoKSxcbiAgICBzY29wZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgYmVhcmVyX21ldGhvZHNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVzb3VyY2Vfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHJlc291cmNlX25hbWU6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICByZXNvdXJjZV9kb2N1bWVudGF0aW9uOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcmVzb3VyY2VfcG9saWN5X3VyaTogem9kXzEuei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpLFxuICAgIHJlc291cmNlX3Rvc191cmk6IHpvZF8xLnouc3RyaW5nKCkudXJsKCkub3B0aW9uYWwoKSxcbiAgICB0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnM6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgYXV0aG9yaXphdGlvbl9kZXRhaWxzX3R5cGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGRwb3Bfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGRwb3BfYm91bmRfYWNjZXNzX3Rva2Vuc19yZXF1aXJlZDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogUkZDIDg0MTQgT0F1dGggMi4wIEF1dGhvcml6YXRpb24gU2VydmVyIE1ldGFkYXRhXG4gKi9cbmV4cG9ydHMuT0F1dGhNZXRhZGF0YVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBpc3N1ZXI6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLFxuICAgIHRva2VuX2VuZHBvaW50OiBleHBvcnRzLlNhZmVVcmxTY2hlbWEsXG4gICAgcmVnaXN0cmF0aW9uX2VuZHBvaW50OiBleHBvcnRzLlNhZmVVcmxTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBzY29wZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVzcG9uc2VfdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIHJlc3BvbnNlX21vZGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGdyYW50X3R5cGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBzZXJ2aWNlX2RvY3VtZW50YXRpb246IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIHJldm9jYXRpb25fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIHJldm9jYXRpb25fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHJldm9jYXRpb25fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgaW50cm9zcGVjdGlvbl9lbmRwb2ludDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGludHJvc3BlY3Rpb25fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGludHJvc3BlY3Rpb25fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogT3BlbklEIENvbm5lY3QgRGlzY292ZXJ5IDEuMCBQcm92aWRlciBNZXRhZGF0YVxuICogc2VlOiBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtZGlzY292ZXJ5LTFfMC5odG1sI1Byb3ZpZGVyTWV0YWRhdGFcbiAqL1xuZXhwb3J0cy5PcGVuSWRQcm92aWRlck1ldGFkYXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGlzc3Vlcjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiBleHBvcnRzLlNhZmVVcmxTY2hlbWEsXG4gICAgdG9rZW5fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYSxcbiAgICB1c2VyaW5mb19lbmRwb2ludDogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgandrc191cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYSxcbiAgICByZWdpc3RyYXRpb25fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIHNjb3Blc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXNwb25zZV90eXBlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSksXG4gICAgcmVzcG9uc2VfbW9kZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZ3JhbnRfdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgYWNyX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBzdWJqZWN0X3R5cGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKSxcbiAgICBpZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGlkX3Rva2VuX2VuY3J5cHRpb25fYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBpZF90b2tlbl9lbmNyeXB0aW9uX2VuY192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdXNlcmluZm9fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHVzZXJpbmZvX2VuY3J5cHRpb25fYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB1c2VyaW5mb19lbmNyeXB0aW9uX2VuY192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVxdWVzdF9vYmplY3Rfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXF1ZXN0X29iamVjdF9lbmNyeXB0aW9uX2VuY192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGRpc3BsYXlfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGNsYWltX3R5cGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGNsYWltc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBzZXJ2aWNlX2RvY3VtZW50YXRpb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBjbGFpbXNfbG9jYWxlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB1aV9sb2NhbGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGNsYWltc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHJlcXVlc3RfcGFyYW1ldGVyX3N1cHBvcnRlZDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICByZXF1ZXN0X3VyaV9wYXJhbWV0ZXJfc3VwcG9ydGVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHJlcXVpcmVfcmVxdWVzdF91cmlfcmVnaXN0cmF0aW9uOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIG9wX3BvbGljeV91cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIG9wX3Rvc191cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBPcGVuSUQgQ29ubmVjdCBEaXNjb3ZlcnkgbWV0YWRhdGEgdGhhdCBtYXkgaW5jbHVkZSBPQXV0aCAyLjAgZmllbGRzXG4gKiBUaGlzIHNjaGVtYSByZXByZXNlbnRzIHRoZSByZWFsLXdvcmxkIHNjZW5hcmlvIHdoZXJlIE9JREMgcHJvdmlkZXJzXG4gKiByZXR1cm4gYSBtaXggb2YgT3BlbklEIENvbm5lY3QgYW5kIE9BdXRoIDIuMCBtZXRhZGF0YSBmaWVsZHNcbiAqL1xuZXhwb3J0cy5PcGVuSWRQcm92aWRlckRpc2NvdmVyeU1ldGFkYXRhU2NoZW1hID0gZXhwb3J0cy5PcGVuSWRQcm92aWRlck1ldGFkYXRhU2NoZW1hLm1lcmdlKGV4cG9ydHMuT0F1dGhNZXRhZGF0YVNjaGVtYS5waWNrKHtcbiAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZDogdHJ1ZVxufSkpO1xuLyoqXG4gKiBPQXV0aCAyLjEgdG9rZW4gcmVzcG9uc2VcbiAqL1xuZXhwb3J0cy5PQXV0aFRva2Vuc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhY2Nlc3NfdG9rZW46IHpvZF8xLnouc3RyaW5nKCksXG4gICAgaWRfdG9rZW46IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSwgLy8gT3B0aW9uYWwgZm9yIE9BdXRoIDIuMSwgYnV0IG5lY2Vzc2FyeSBpbiBPcGVuSUQgQ29ubmVjdFxuICAgIHRva2VuX3R5cGU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgZXhwaXJlc19pbjogem9kXzEuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIHNjb3BlOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcmVmcmVzaF90b2tlbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KVxuICAgIC5zdHJpcCgpO1xuLyoqXG4gKiBPQXV0aCAyLjEgZXJyb3IgcmVzcG9uc2VcbiAqL1xuZXhwb3J0cy5PQXV0aEVycm9yUmVzcG9uc2VTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgZXJyb3JfZGVzY3JpcHRpb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBlcnJvcl91cmk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG4vKipcbiAqIFJGQyA3NTkxIE9BdXRoIDIuMCBEeW5hbWljIENsaWVudCBSZWdpc3RyYXRpb24gbWV0YWRhdGFcbiAqL1xuZXhwb3J0cy5PQXV0aENsaWVudE1ldGFkYXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHJlZGlyZWN0X3VyaXM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5TYWZlVXJsU2NoZW1hKSxcbiAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGdyYW50X3R5cGVzOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVzcG9uc2VfdHlwZXM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBjbGllbnRfbmFtZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNsaWVudF91cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIGxvZ29fdXJpOiBleHBvcnRzLlNhZmVVcmxTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBzY29wZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNvbnRhY3RzOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdG9zX3VyaTogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgcG9saWN5X3VyaTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGp3a3NfdXJpOiBleHBvcnRzLlNhZmVVcmxTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBqd2tzOiB6b2RfMS56LmFueSgpLm9wdGlvbmFsKCksXG4gICAgc29mdHdhcmVfaWQ6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBzb2Z0d2FyZV92ZXJzaW9uOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgc29mdHdhcmVfc3RhdGVtZW50OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pXG4gICAgLnN0cmlwKCk7XG4vKipcbiAqIFJGQyA3NTkxIE9BdXRoIDIuMCBEeW5hbWljIENsaWVudCBSZWdpc3RyYXRpb24gY2xpZW50IGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydHMuT0F1dGhDbGllbnRJbmZvcm1hdGlvblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBjbGllbnRfaWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgY2xpZW50X3NlY3JldDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNsaWVudF9pZF9pc3N1ZWRfYXQ6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBjbGllbnRfc2VjcmV0X2V4cGlyZXNfYXQ6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKVxufSlcbiAgICAuc3RyaXAoKTtcbi8qKlxuICogUkZDIDc1OTEgT0F1dGggMi4wIER5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBmdWxsIHJlc3BvbnNlIChjbGllbnQgaW5mb3JtYXRpb24gcGx1cyBtZXRhZGF0YSlcbiAqL1xuZXhwb3J0cy5PQXV0aENsaWVudEluZm9ybWF0aW9uRnVsbFNjaGVtYSA9IGV4cG9ydHMuT0F1dGhDbGllbnRNZXRhZGF0YVNjaGVtYS5tZXJnZShleHBvcnRzLk9BdXRoQ2xpZW50SW5mb3JtYXRpb25TY2hlbWEpO1xuLyoqXG4gKiBSRkMgNzU5MSBPQXV0aCAyLjAgRHluYW1pYyBDbGllbnQgUmVnaXN0cmF0aW9uIGVycm9yIHJlc3BvbnNlXG4gKi9cbmV4cG9ydHMuT0F1dGhDbGllbnRSZWdpc3RyYXRpb25FcnJvclNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBlcnJvcjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBlcnJvcl9kZXNjcmlwdGlvbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KVxuICAgIC5zdHJpcCgpO1xuLyoqXG4gKiBSRkMgNzAwOSBPQXV0aCAyLjAgVG9rZW4gUmV2b2NhdGlvbiByZXF1ZXN0XG4gKi9cbmV4cG9ydHMuT0F1dGhUb2tlblJldm9jYXRpb25SZXF1ZXN0U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHRva2VuOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHRva2VuX3R5cGVfaGludDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KVxuICAgIC5zdHJpcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiLG51bGwsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGhhbmRsaW5nIE9BdXRoIHJlc291cmNlIFVSSXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb3VyY2VVcmxGcm9tU2VydmVyVXJsID0gcmVzb3VyY2VVcmxGcm9tU2VydmVyVXJsO1xuZXhwb3J0cy5jaGVja1Jlc291cmNlQWxsb3dlZCA9IGNoZWNrUmVzb3VyY2VBbGxvd2VkO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHNlcnZlciBVUkwgdG8gYSByZXNvdXJjZSBVUkwgYnkgcmVtb3ZpbmcgdGhlIGZyYWdtZW50LlxuICogUkZDIDg3MDcgc2VjdGlvbiAyIHN0YXRlcyB0aGF0IHJlc291cmNlIFVSSXMgXCJNVVNUIE5PVCBpbmNsdWRlIGEgZnJhZ21lbnQgY29tcG9uZW50XCIuXG4gKiBLZWVwcyBldmVyeXRoaW5nIGVsc2UgdW5jaGFuZ2VkIChzY2hlbWUsIGRvbWFpbiwgcG9ydCwgcGF0aCwgcXVlcnkpLlxuICovXG5mdW5jdGlvbiByZXNvdXJjZVVybEZyb21TZXJ2ZXJVcmwodXJsKSB7XG4gICAgY29uc3QgcmVzb3VyY2VVUkwgPSB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyA/IG5ldyBVUkwodXJsKSA6IG5ldyBVUkwodXJsLmhyZWYpO1xuICAgIHJlc291cmNlVVJMLmhhc2ggPSAnJzsgLy8gUmVtb3ZlIGZyYWdtZW50XG4gICAgcmV0dXJuIHJlc291cmNlVVJMO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSByZXF1ZXN0ZWQgcmVzb3VyY2UgVVJMIG1hdGNoZXMgYSBjb25maWd1cmVkIHJlc291cmNlIFVSTC5cbiAqIEEgcmVxdWVzdGVkIHJlc291cmNlIG1hdGNoZXMgaWYgaXQgaGFzIHRoZSBzYW1lIHNjaGVtZSwgZG9tYWluLCBwb3J0LFxuICogYW5kIGl0cyBwYXRoIHN0YXJ0cyB3aXRoIHRoZSBjb25maWd1cmVkIHJlc291cmNlJ3MgcGF0aC5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdGVkUmVzb3VyY2UgVGhlIHJlc291cmNlIFVSTCBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSBjb25maWd1cmVkUmVzb3VyY2UgVGhlIHJlc291cmNlIFVSTCB0aGF0IGhhcyBiZWVuIGNvbmZpZ3VyZWRcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBtYXRjaGVzIHRoZSBjb25maWd1cmVkIHJlc291cmNlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZXNvdXJjZUFsbG93ZWQoeyByZXF1ZXN0ZWRSZXNvdXJjZSwgY29uZmlndXJlZFJlc291cmNlIH0pIHtcbiAgICBjb25zdCByZXF1ZXN0ZWQgPSB0eXBlb2YgcmVxdWVzdGVkUmVzb3VyY2UgPT09ICdzdHJpbmcnID8gbmV3IFVSTChyZXF1ZXN0ZWRSZXNvdXJjZSkgOiBuZXcgVVJMKHJlcXVlc3RlZFJlc291cmNlLmhyZWYpO1xuICAgIGNvbnN0IGNvbmZpZ3VyZWQgPSB0eXBlb2YgY29uZmlndXJlZFJlc291cmNlID09PSAnc3RyaW5nJyA/IG5ldyBVUkwoY29uZmlndXJlZFJlc291cmNlKSA6IG5ldyBVUkwoY29uZmlndXJlZFJlc291cmNlLmhyZWYpO1xuICAgIC8vIENvbXBhcmUgdGhlIG9yaWdpbiAoc2NoZW1lLCBkb21haW4sIGFuZCBwb3J0KVxuICAgIGlmIChyZXF1ZXN0ZWQub3JpZ2luICE9PSBjb25maWd1cmVkLm9yaWdpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBjYXNlcyBsaWtlIHJlcXVlc3RlZD0vZm9vIGFuZCBjb25maWd1cmVkPS9mb28vXG4gICAgaWYgKHJlcXVlc3RlZC5wYXRobmFtZS5sZW5ndGggPCBjb25maWd1cmVkLnBhdGhuYW1lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSByZXF1ZXN0ZWQgcGF0aCBzdGFydHMgd2l0aCB0aGUgY29uZmlndXJlZCBwYXRoXG4gICAgLy8gRW5zdXJlIGJvdGggcGF0aHMgZW5kIHdpdGggLyBmb3IgcHJvcGVyIGNvbXBhcmlzb25cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiB3ZSBoYXZlIHBhdGhzIGxpa2UgXCIvYXBpXCIgYW5kIFwiL2FwaS91c2Vyc1wiLFxuICAgIC8vIHdlIHByb3Blcmx5IGRldGVjdCB0aGF0IFwiL2FwaS91c2Vyc1wiIGlzIGEgc3VicGF0aCBvZiBcIi9hcGlcIlxuICAgIC8vIEJ5IGFkZGluZyBhIHRyYWlsaW5nIHNsYXNoIGlmIG1pc3NpbmcsIHdlIGF2b2lkIGZhbHNlIHBvc2l0aXZlc1xuICAgIC8vIHdoZXJlIHBhdGhzIGxpa2UgXCIvYXBpMTIzXCIgd291bGQgaW5jb3JyZWN0bHkgbWF0Y2ggXCIvYXBpXCJcbiAgICBjb25zdCByZXF1ZXN0ZWRQYXRoID0gcmVxdWVzdGVkLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykgPyByZXF1ZXN0ZWQucGF0aG5hbWUgOiByZXF1ZXN0ZWQucGF0aG5hbWUgKyAnLyc7XG4gICAgY29uc3QgY29uZmlndXJlZFBhdGggPSBjb25maWd1cmVkLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykgPyBjb25maWd1cmVkLnBhdGhuYW1lIDogY29uZmlndXJlZC5wYXRobmFtZSArICcvJztcbiAgICByZXR1cm4gcmVxdWVzdGVkUGF0aC5zdGFydHNXaXRoKGNvbmZpZ3VyZWRQYXRoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGgtdXRpbHMuanMubWFwIixudWxsLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0FVVEhfRVJST1JTID0gZXhwb3J0cy5DdXN0b21PQXV0aEVycm9yID0gZXhwb3J0cy5JbnN1ZmZpY2llbnRTY29wZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2xpZW50TWV0YWRhdGFFcnJvciA9IGV4cG9ydHMuVG9vTWFueVJlcXVlc3RzRXJyb3IgPSBleHBvcnRzLk1ldGhvZE5vdEFsbG93ZWRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFRva2VuRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkVG9rZW5UeXBlRXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkUmVzcG9uc2VUeXBlRXJyb3IgPSBleHBvcnRzLlRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvciA9IGV4cG9ydHMuU2VydmVyRXJyb3IgPSBleHBvcnRzLkFjY2Vzc0RlbmllZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkU2NvcGVFcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRHcmFudFR5cGVFcnJvciA9IGV4cG9ydHMuVW5hdXRob3JpemVkQ2xpZW50RXJyb3IgPSBleHBvcnRzLkludmFsaWRHcmFudEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2xpZW50RXJyb3IgPSBleHBvcnRzLkludmFsaWRSZXF1ZXN0RXJyb3IgPSBleHBvcnRzLk9BdXRoRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBPQXV0aCBlcnJvcnNcbiAqL1xuY2xhc3MgT0F1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvclVyaSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lcnJvclVyaSA9IGVycm9yVXJpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBlcnJvciB0byBhIHN0YW5kYXJkIE9BdXRoIGVycm9yIHJlc3BvbnNlIG9iamVjdFxuICAgICAqL1xuICAgIHRvUmVzcG9uc2VPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3JDb2RlLFxuICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IHRoaXMubWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5lcnJvclVyaSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuZXJyb3JfdXJpID0gdGhpcy5lcnJvclVyaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGdldCBlcnJvckNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmVycm9yQ29kZTtcbiAgICB9XG59XG5leHBvcnRzLk9BdXRoRXJyb3IgPSBPQXV0aEVycm9yO1xuLyoqXG4gKiBJbnZhbGlkIHJlcXVlc3QgZXJyb3IgLSBUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIGEgcmVxdWlyZWQgcGFyYW1ldGVyLFxuICogaW5jbHVkZXMgYW4gaW52YWxpZCBwYXJhbWV0ZXIgdmFsdWUsIGluY2x1ZGVzIGEgcGFyYW1ldGVyIG1vcmUgdGhhbiBvbmNlLFxuICogb3IgaXMgb3RoZXJ3aXNlIG1hbGZvcm1lZC5cbiAqL1xuY2xhc3MgSW52YWxpZFJlcXVlc3RFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkUmVxdWVzdEVycm9yID0gSW52YWxpZFJlcXVlc3RFcnJvcjtcbkludmFsaWRSZXF1ZXN0RXJyb3IuZXJyb3JDb2RlID0gJ2ludmFsaWRfcmVxdWVzdCc7XG4vKipcbiAqIEludmFsaWQgY2xpZW50IGVycm9yIC0gQ2xpZW50IGF1dGhlbnRpY2F0aW9uIGZhaWxlZCAoZS5nLiwgdW5rbm93biBjbGllbnQsIG5vIGNsaWVudFxuICogYXV0aGVudGljYXRpb24gaW5jbHVkZWQsIG9yIHVuc3VwcG9ydGVkIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCkuXG4gKi9cbmNsYXNzIEludmFsaWRDbGllbnRFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkQ2xpZW50RXJyb3IgPSBJbnZhbGlkQ2xpZW50RXJyb3I7XG5JbnZhbGlkQ2xpZW50RXJyb3IuZXJyb3JDb2RlID0gJ2ludmFsaWRfY2xpZW50Jztcbi8qKlxuICogSW52YWxpZCBncmFudCBlcnJvciAtIFRoZSBwcm92aWRlZCBhdXRob3JpemF0aW9uIGdyYW50IG9yIHJlZnJlc2ggdG9rZW4gaXNcbiAqIGludmFsaWQsIGV4cGlyZWQsIHJldm9rZWQsIGRvZXMgbm90IG1hdGNoIHRoZSByZWRpcmVjdGlvbiBVUkkgdXNlZCBpbiB0aGVcbiAqIGF1dGhvcml6YXRpb24gcmVxdWVzdCwgb3Igd2FzIGlzc3VlZCB0byBhbm90aGVyIGNsaWVudC5cbiAqL1xuY2xhc3MgSW52YWxpZEdyYW50RXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEdyYW50RXJyb3IgPSBJbnZhbGlkR3JhbnRFcnJvcjtcbkludmFsaWRHcmFudEVycm9yLmVycm9yQ29kZSA9ICdpbnZhbGlkX2dyYW50Jztcbi8qKlxuICogVW5hdXRob3JpemVkIGNsaWVudCBlcnJvciAtIFRoZSBhdXRoZW50aWNhdGVkIGNsaWVudCBpcyBub3QgYXV0aG9yaXplZCB0byB1c2VcbiAqIHRoaXMgYXV0aG9yaXphdGlvbiBncmFudCB0eXBlLlxuICovXG5jbGFzcyBVbmF1dGhvcml6ZWRDbGllbnRFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5VbmF1dGhvcml6ZWRDbGllbnRFcnJvciA9IFVuYXV0aG9yaXplZENsaWVudEVycm9yO1xuVW5hdXRob3JpemVkQ2xpZW50RXJyb3IuZXJyb3JDb2RlID0gJ3VuYXV0aG9yaXplZF9jbGllbnQnO1xuLyoqXG4gKiBVbnN1cHBvcnRlZCBncmFudCB0eXBlIGVycm9yIC0gVGhlIGF1dGhvcml6YXRpb24gZ3JhbnQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkXG4gKiBieSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIuXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkR3JhbnRUeXBlRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRHcmFudFR5cGVFcnJvciA9IFVuc3VwcG9ydGVkR3JhbnRUeXBlRXJyb3I7XG5VbnN1cHBvcnRlZEdyYW50VHlwZUVycm9yLmVycm9yQ29kZSA9ICd1bnN1cHBvcnRlZF9ncmFudF90eXBlJztcbi8qKlxuICogSW52YWxpZCBzY29wZSBlcnJvciAtIFRoZSByZXF1ZXN0ZWQgc2NvcGUgaXMgaW52YWxpZCwgdW5rbm93biwgbWFsZm9ybWVkLCBvclxuICogZXhjZWVkcyB0aGUgc2NvcGUgZ3JhbnRlZCBieSB0aGUgcmVzb3VyY2Ugb3duZXIuXG4gKi9cbmNsYXNzIEludmFsaWRTY29wZUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTY29wZUVycm9yID0gSW52YWxpZFNjb3BlRXJyb3I7XG5JbnZhbGlkU2NvcGVFcnJvci5lcnJvckNvZGUgPSAnaW52YWxpZF9zY29wZSc7XG4vKipcbiAqIEFjY2VzcyBkZW5pZWQgZXJyb3IgLSBUaGUgcmVzb3VyY2Ugb3duZXIgb3IgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgZGVuaWVkIHRoZSByZXF1ZXN0LlxuICovXG5jbGFzcyBBY2Nlc3NEZW5pZWRFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5BY2Nlc3NEZW5pZWRFcnJvciA9IEFjY2Vzc0RlbmllZEVycm9yO1xuQWNjZXNzRGVuaWVkRXJyb3IuZXJyb3JDb2RlID0gJ2FjY2Vzc19kZW5pZWQnO1xuLyoqXG4gKiBTZXJ2ZXIgZXJyb3IgLSBUaGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgZW5jb3VudGVyZWQgYW4gdW5leHBlY3RlZCBjb25kaXRpb25cbiAqIHRoYXQgcHJldmVudGVkIGl0IGZyb20gZnVsZmlsbGluZyB0aGUgcmVxdWVzdC5cbiAqL1xuY2xhc3MgU2VydmVyRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcblNlcnZlckVycm9yLmVycm9yQ29kZSA9ICdzZXJ2ZXJfZXJyb3InO1xuLyoqXG4gKiBUZW1wb3JhcmlseSB1bmF2YWlsYWJsZSBlcnJvciAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlciBpcyBjdXJyZW50bHkgdW5hYmxlIHRvXG4gKiBoYW5kbGUgdGhlIHJlcXVlc3QgZHVlIHRvIGEgdGVtcG9yYXJ5IG92ZXJsb2FkaW5nIG9yIG1haW50ZW5hbmNlIG9mIHRoZSBzZXJ2ZXIuXG4gKi9cbmNsYXNzIFRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5UZW1wb3JhcmlseVVuYXZhaWxhYmxlRXJyb3IgPSBUZW1wb3JhcmlseVVuYXZhaWxhYmxlRXJyb3I7XG5UZW1wb3JhcmlseVVuYXZhaWxhYmxlRXJyb3IuZXJyb3JDb2RlID0gJ3RlbXBvcmFyaWx5X3VuYXZhaWxhYmxlJztcbi8qKlxuICogVW5zdXBwb3J0ZWQgcmVzcG9uc2UgdHlwZSBlcnJvciAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0XG4gKiBvYnRhaW5pbmcgYW4gYXV0aG9yaXphdGlvbiBjb2RlIHVzaW5nIHRoaXMgbWV0aG9kLlxuICovXG5jbGFzcyBVbnN1cHBvcnRlZFJlc3BvbnNlVHlwZUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkUmVzcG9uc2VUeXBlRXJyb3IgPSBVbnN1cHBvcnRlZFJlc3BvbnNlVHlwZUVycm9yO1xuVW5zdXBwb3J0ZWRSZXNwb25zZVR5cGVFcnJvci5lcnJvckNvZGUgPSAndW5zdXBwb3J0ZWRfcmVzcG9uc2VfdHlwZSc7XG4vKipcbiAqIFVuc3VwcG9ydGVkIHRva2VuIHR5cGUgZXJyb3IgLSBUaGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIHJlcXVlc3RlZCB0b2tlbiB0eXBlLlxuICovXG5jbGFzcyBVbnN1cHBvcnRlZFRva2VuVHlwZUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkVG9rZW5UeXBlRXJyb3IgPSBVbnN1cHBvcnRlZFRva2VuVHlwZUVycm9yO1xuVW5zdXBwb3J0ZWRUb2tlblR5cGVFcnJvci5lcnJvckNvZGUgPSAndW5zdXBwb3J0ZWRfdG9rZW5fdHlwZSc7XG4vKipcbiAqIEludmFsaWQgdG9rZW4gZXJyb3IgLSBUaGUgYWNjZXNzIHRva2VuIHByb3ZpZGVkIGlzIGV4cGlyZWQsIHJldm9rZWQsIG1hbGZvcm1lZCxcbiAqIG9yIGludmFsaWQgZm9yIG90aGVyIHJlYXNvbnMuXG4gKi9cbmNsYXNzIEludmFsaWRUb2tlbkVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUb2tlbkVycm9yID0gSW52YWxpZFRva2VuRXJyb3I7XG5JbnZhbGlkVG9rZW5FcnJvci5lcnJvckNvZGUgPSAnaW52YWxpZF90b2tlbic7XG4vKipcbiAqIE1ldGhvZCBub3QgYWxsb3dlZCBlcnJvciAtIFRoZSBIVFRQIG1ldGhvZCB1c2VkIGlzIG5vdCBhbGxvd2VkIGZvciB0aGlzIGVuZHBvaW50LlxuICogKEN1c3RvbSwgbm9uLXN0YW5kYXJkIGVycm9yKVxuICovXG5jbGFzcyBNZXRob2ROb3RBbGxvd2VkRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuTWV0aG9kTm90QWxsb3dlZEVycm9yID0gTWV0aG9kTm90QWxsb3dlZEVycm9yO1xuTWV0aG9kTm90QWxsb3dlZEVycm9yLmVycm9yQ29kZSA9ICdtZXRob2Rfbm90X2FsbG93ZWQnO1xuLyoqXG4gKiBUb28gbWFueSByZXF1ZXN0cyBlcnJvciAtIFJhdGUgbGltaXQgZXhjZWVkZWQuXG4gKiAoQ3VzdG9tLCBub24tc3RhbmRhcmQgZXJyb3IgYmFzZWQgb24gUkZDIDY1ODUpXG4gKi9cbmNsYXNzIFRvb01hbnlSZXF1ZXN0c0Vycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLlRvb01hbnlSZXF1ZXN0c0Vycm9yID0gVG9vTWFueVJlcXVlc3RzRXJyb3I7XG5Ub29NYW55UmVxdWVzdHNFcnJvci5lcnJvckNvZGUgPSAndG9vX21hbnlfcmVxdWVzdHMnO1xuLyoqXG4gKiBJbnZhbGlkIGNsaWVudCBtZXRhZGF0YSBlcnJvciAtIFRoZSBjbGllbnQgbWV0YWRhdGEgaXMgaW52YWxpZC5cbiAqIChDdXN0b20gZXJyb3IgZm9yIGR5bmFtaWMgY2xpZW50IHJlZ2lzdHJhdGlvbiAtIFJGQyA3NTkxKVxuICovXG5jbGFzcyBJbnZhbGlkQ2xpZW50TWV0YWRhdGFFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkQ2xpZW50TWV0YWRhdGFFcnJvciA9IEludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yO1xuSW52YWxpZENsaWVudE1ldGFkYXRhRXJyb3IuZXJyb3JDb2RlID0gJ2ludmFsaWRfY2xpZW50X21ldGFkYXRhJztcbi8qKlxuICogSW5zdWZmaWNpZW50IHNjb3BlIGVycm9yIC0gVGhlIHJlcXVlc3QgcmVxdWlyZXMgaGlnaGVyIHByaXZpbGVnZXMgdGhhbiBwcm92aWRlZCBieSB0aGUgYWNjZXNzIHRva2VuLlxuICovXG5jbGFzcyBJbnN1ZmZpY2llbnRTY29wZUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkluc3VmZmljaWVudFNjb3BlRXJyb3IgPSBJbnN1ZmZpY2llbnRTY29wZUVycm9yO1xuSW5zdWZmaWNpZW50U2NvcGVFcnJvci5lcnJvckNvZGUgPSAnaW5zdWZmaWNpZW50X3Njb3BlJztcbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIGZvciBkZWZpbmluZyBvbmUtb2ZmIGVycm9yIGNvZGVzXG4gKi9cbmNsYXNzIEN1c3RvbU9BdXRoRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjdXN0b21FcnJvckNvZGUsIG1lc3NhZ2UsIGVycm9yVXJpKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGVycm9yVXJpKTtcbiAgICAgICAgdGhpcy5jdXN0b21FcnJvckNvZGUgPSBjdXN0b21FcnJvckNvZGU7XG4gICAgfVxuICAgIGdldCBlcnJvckNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUVycm9yQ29kZTtcbiAgICB9XG59XG5leHBvcnRzLkN1c3RvbU9BdXRoRXJyb3IgPSBDdXN0b21PQXV0aEVycm9yO1xuLyoqXG4gKiBBIGZ1bGwgbGlzdCBvZiBhbGwgT0F1dGhFcnJvcnMsIGVuYWJsaW5nIHBhcnNpbmcgZnJvbSBlcnJvciByZXNwb25zZXNcbiAqL1xuZXhwb3J0cy5PQVVUSF9FUlJPUlMgPSB7XG4gICAgW0ludmFsaWRSZXF1ZXN0RXJyb3IuZXJyb3JDb2RlXTogSW52YWxpZFJlcXVlc3RFcnJvcixcbiAgICBbSW52YWxpZENsaWVudEVycm9yLmVycm9yQ29kZV06IEludmFsaWRDbGllbnRFcnJvcixcbiAgICBbSW52YWxpZEdyYW50RXJyb3IuZXJyb3JDb2RlXTogSW52YWxpZEdyYW50RXJyb3IsXG4gICAgW1VuYXV0aG9yaXplZENsaWVudEVycm9yLmVycm9yQ29kZV06IFVuYXV0aG9yaXplZENsaWVudEVycm9yLFxuICAgIFtVbnN1cHBvcnRlZEdyYW50VHlwZUVycm9yLmVycm9yQ29kZV06IFVuc3VwcG9ydGVkR3JhbnRUeXBlRXJyb3IsXG4gICAgW0ludmFsaWRTY29wZUVycm9yLmVycm9yQ29kZV06IEludmFsaWRTY29wZUVycm9yLFxuICAgIFtBY2Nlc3NEZW5pZWRFcnJvci5lcnJvckNvZGVdOiBBY2Nlc3NEZW5pZWRFcnJvcixcbiAgICBbU2VydmVyRXJyb3IuZXJyb3JDb2RlXTogU2VydmVyRXJyb3IsXG4gICAgW1RlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvci5lcnJvckNvZGVdOiBUZW1wb3JhcmlseVVuYXZhaWxhYmxlRXJyb3IsXG4gICAgW1Vuc3VwcG9ydGVkUmVzcG9uc2VUeXBlRXJyb3IuZXJyb3JDb2RlXTogVW5zdXBwb3J0ZWRSZXNwb25zZVR5cGVFcnJvcixcbiAgICBbVW5zdXBwb3J0ZWRUb2tlblR5cGVFcnJvci5lcnJvckNvZGVdOiBVbnN1cHBvcnRlZFRva2VuVHlwZUVycm9yLFxuICAgIFtJbnZhbGlkVG9rZW5FcnJvci5lcnJvckNvZGVdOiBJbnZhbGlkVG9rZW5FcnJvcixcbiAgICBbTWV0aG9kTm90QWxsb3dlZEVycm9yLmVycm9yQ29kZV06IE1ldGhvZE5vdEFsbG93ZWRFcnJvcixcbiAgICBbVG9vTWFueVJlcXVlc3RzRXJyb3IuZXJyb3JDb2RlXTogVG9vTWFueVJlcXVlc3RzRXJyb3IsXG4gICAgW0ludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yLmVycm9yQ29kZV06IEludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yLFxuICAgIFtJbnN1ZmZpY2llbnRTY29wZUVycm9yLmVycm9yQ29kZV06IEluc3VmZmljaWVudFNjb3BlRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIixudWxsLCIvKipcclxuICogTm90aW9uIE1DUCBTU0UgQ2xpZW50XHJcbiAqIEhhbmRsZXMgU2VydmVyLVNlbnQgRXZlbnRzIGNvbm5lY3Rpb24gdG8gTm90aW9uJ3MgaG9zdGVkIE1DUCBzZXJ2ZXJcclxuICovXHJcblxyXG5pbXBvcnQgeyBOT1RJT05fQ09ORklHIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gICAgTWNwTWVzc2FnZSxcclxuICAgIE1jcEluaXRpYWxpemVSZXF1ZXN0LFxyXG4gICAgTWNwVG9vbHNMaXN0UmVzcG9uc2UsXHJcbiAgICBNY3BUb29sQ2FsbFJlcXVlc3QsXHJcbiAgICBOb3Rpb25NY3BTdGF0dXMsXHJcbiAgICBNY3BDb25uZWN0aW9uU3RhdGVcclxufSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBFdmVudFNvdXJjZS1saWtlIGludGVyZmFjZSBmb3IgU1NFIGluIGV4dGVuc2lvbiBjb250ZXh0XHJcbiAqIENocm9tZSBleHRlbnNpb25zIG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgU1NFXHJcbiAqL1xyXG5jbGFzcyBNY3BTU0VDbGllbnQge1xyXG4gICAgcHJpdmF0ZSBzc2VVcmw6IHN0cmluZztcclxuICAgIHByaXZhdGUgYWNjZXNzVG9rZW46IHN0cmluZztcclxuICAgIHByaXZhdGUgc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDsgLy8gTUNQIHNlc3Npb24gSUQgZnJvbSBpbml0aWFsaXphdGlvblxyXG4gICAgcHJpdmF0ZSBzc2VTZXNzaW9uSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBTU0Ugc3RyZWFtIHNlc3Npb24gSUQgZm9yIHJlc3VtYWJpbGl0eVxyXG4gICAgcHJpdmF0ZSBtZXNzYWdlRW5kcG9pbnQ6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBQT1NUIGVuZHBvaW50IGZyb20gU1NFICdlbmRwb2ludCcgZXZlbnRcclxuICAgIHByaXZhdGUgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgIHByaXZhdGUgcmVjb25uZWN0VGltZW91dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIG1lc3NhZ2VJZCA9IDA7XHJcbiAgICBwcml2YXRlIHBlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXA8c3RyaW5nIHwgbnVtYmVyLCB7XHJcbiAgICAgICAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XHJcbiAgICAgICAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZDtcclxuICAgIH0+KCk7XHJcblxyXG4gICAgcHJpdmF0ZSBvblN0YXR1c0NoYW5nZTogKHN0YXR1czogTm90aW9uTWNwU3RhdHVzKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBvbk1lc3NhZ2U6IChtZXNzYWdlOiBNY3BNZXNzYWdlKSA9PiB2b2lkO1xyXG5cclxuICAgIHByaXZhdGUgY3VycmVudFN0YXR1czogTm90aW9uTWNwU3RhdHVzID0ge1xyXG4gICAgICAgIHN0YXRlOiAnZGlzY29ubmVjdGVkJ1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBzc2VVcmw6IHN0cmluZyxcclxuICAgICAgICBhY2Nlc3NUb2tlbjogc3RyaW5nLFxyXG4gICAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgICAgICBvblN0YXR1c0NoYW5nZTogKHN0YXR1czogTm90aW9uTWNwU3RhdHVzKSA9PiB2b2lkO1xyXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlOiBNY3BNZXNzYWdlKSA9PiB2b2lkO1xyXG4gICAgICAgIH1cclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuc3NlVXJsID0gc3NlVXJsO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcclxuICAgICAgICB0aGlzLm9uU3RhdHVzQ2hhbmdlID0gY2FsbGJhY2tzLm9uU3RhdHVzQ2hhbmdlO1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gY2FsbGJhY2tzLm9uTWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3QgdG8gdGhlIFNTRSBlbmRwb2ludFxyXG4gICAgICovXHJcbiAgICBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdjb25uZWN0aW5nJyk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBNVjMgZXh0ZW5zaW9ucywgd2UgbmVlZCB0byB1c2UgZmV0Y2ggd2l0aCBSZWFkYWJsZVN0cmVhbVxyXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIEV2ZW50U291cmNlIGR1ZSB0byBDU1AgcmVzdHJpY3Rpb25zXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdFdpdGhGZXRjaCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIENvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnZXJyb3InLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDb25uZWN0aW9uIGZhaWxlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdCB1c2luZyBmZXRjaCBhbmQgUmVhZGFibGVTdHJlYW0gKE1WMyBjb21wYXRpYmxlKVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGNvbm5lY3RXaXRoRmV0Y2goKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIENvbm5lY3RpbmcgdG8gU1NFIGVuZHBvaW50OicsIHRoaXMuc3NlVXJsKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gVXNpbmcgYWNjZXNzIHRva2VuIChmaXJzdCAyMCBjaGFycyk6JywgdGhpcy5hY2Nlc3NUb2tlbi5zdWJzdHJpbmcoMCwgMjApICsgJy4uLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5zc2VVcmwsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2V2ZW50LXN0cmVhbSwgYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXHJcbiAgICAgICAgICAgICAgICAnTUNQLVByb3RvY29sLVZlcnNpb24nOiAnMjAyNS0wNi0xOCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gU1NFIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTU0UgcmVzcG9uc2UgaGVhZGVyczonLCBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIFNTRSBjb25uZWN0aW9uIGZhaWxlZDonLCByZXNwb25zZS5zdGF0dXMsIGVycm9yVGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGVycm9yIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gZm9ybWF0IGFuZCBleHBpcnkgaXNzdWVzXHJcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JEYXRhO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSB7IGVycm9yOiAndW5rbm93bicsIGVycm9yX2Rlc2NyaXB0aW9uOiBlcnJvclRleHQgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yRGF0YS5lcnJvciA9PT0gJ2ludmFsaWRfdG9rZW4nICYmIGVycm9yRGF0YS5lcnJvcl9kZXNjcmlwdGlvbj8uaW5jbHVkZXMoJ0ludmFsaWQgdG9rZW4gZm9ybWF0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUb2tlbiBmb3JtYXQgaXMgd3JvbmcgLSBkb24ndCB0cnkgdG8gcmVmcmVzaCwgbmVlZCByZS1hdXRoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2ludmFsaWQtdG9rZW4nLCAnSW52YWxpZCB0b2tlbiBmb3JtYXQgLSBwbGVhc2UgcmUtYXV0aGVudGljYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRva2VuIGZvcm1hdDogJHtlcnJvckRhdGEuZXJyb3JfZGVzY3JpcHRpb259YCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRva2VuIGV4cGlyZWQgb3Igb3RoZXIgYXV0aCBpc3N1ZSAtIG1pZ2h0IGJlIHJlZnJlc2hhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ25lZWRzLWF1dGgnLCAnVG9rZW4gZXhwaXJlZCBvciBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRoZW50aWNhdGlvbiByZXF1aXJlZDogJHtlcnJvclRleHR9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBib2R5IGlzIG51bGwnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdjb25uZWN0ZWQnKTtcclxuXHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgc3RyZWFtIGluIHRoZSBiYWNrZ3JvdW5kIChkb24ndCBhd2FpdClcclxuICAgICAgICB0aGlzLnByb2Nlc3NTdHJlYW0ocmVzcG9uc2UuYm9keSk7XHJcblxyXG4gICAgICAgIC8vIE5vdGU6IE1DUCBzZXNzaW9uIElEIGNvbWVzIGZyb20gaW5pdGlhbGl6YXRpb24gcmVzcG9uc2UgaGVhZGVycyxcclxuICAgICAgICAvLyBub3QgZnJvbSB0aGUgU1NFIHN0cmVhbS4gVGhlIFNTRSBlbmRwb2ludCBldmVudCBwcm92aWRlcyBhIHNlcGFyYXRlXHJcbiAgICAgICAgLy8gc2Vzc2lvbiBJRCBmb3Igc3RyZWFtIHJlc3VtYWJpbGl0eS5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIFNTRSBzdHJlYW0gaW4gdGhlIGJhY2tncm91bmRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzU3RyZWFtKGJvZHk6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcclxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xyXG4gICAgICAgIGxldCBjdXJyZW50RXZlbnQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTdHJlYW0gZW5kZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZXZlbnQ6ICcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBTU0UgZXZlbnQgdHlwZXMgKGUuZy4sIFwiZXZlbnQ6IGVuZHBvaW50XCIsIFwiZXZlbnQ6IG1lc3NhZ2VcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEV2ZW50ID0gbGluZS5zbGljZSg3KS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTU0UgZXZlbnQgdHlwZTonLCBjdXJyZW50RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICdbRE9ORV0nKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBlbmRwb2ludCBldmVudCAtIGV4dHJhY3QgbWVzc2FnZSBlbmRwb2ludCBmb3IgUE9TVCByZXF1ZXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEV2ZW50ID09PSAnZW5kcG9pbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXIgTUNQIHNwZWM6IHNlcnZlciBzZW5kcyBlbmRwb2ludCBVUkkgZm9yIGNsaWVudCB0byB1c2UgZm9yIFBPU1QgcmVxdWVzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgZm9ybWF0OiAvc3NlL21lc3NhZ2U/c2Vzc2lvbklkPS4uLiAocmVsYXRpdmUgVVJJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlRW5kcG9pbnQgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNlc3Npb24gSUQgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBkYXRhLm1hdGNoKC9zZXNzaW9uSWQ9KFthLWYwLTktXSspLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNzZVNlc3Npb25JZCA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gTWVzc2FnZSBlbmRwb2ludCByZWNlaXZlZDonLCB0aGlzLm1lc3NhZ2VFbmRwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gU1NFIFNlc3Npb24gSUQ6JywgdGhpcy5zc2VTZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGRhdGEgb3Igbm9uLUpTT04gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEgfHwgKCFkYXRhLnN0YXJ0c1dpdGgoJ3snKSAmJiAhZGF0YS5zdGFydHNXaXRoKCdbJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gTm9uLUpTT04gU1NFIGRhdGE6JywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlOiBNY3BNZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTm90aW9uTUNQXSBGYWlsZWQgdG8gcGFyc2UgbWVzc2FnZTonLCBlcnIsICdEYXRhOicsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIFN0cmVhbSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XHJcbiAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gY2xvc2VkLCBhdHRlbXB0IHJlY29ubmVjdFxyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGluY29taW5nIFNTRSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlTWVzc2FnZShtZXNzYWdlOiBNY3BNZXNzYWdlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UobWVzc2FnZSk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSByZXNwb25zZXMgdG8gb3VyIHJlcXVlc3RzXHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWQgJiYgdGhpcy5wZW5kaW5nUmVxdWVzdHMuaGFzKG1lc3NhZ2UuaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5nZXQobWVzc2FnZS5pZCkhO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5kZWxldGUobWVzc2FnZS5pZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZy5yZWplY3QobmV3IEVycm9yKG1lc3NhZ2UuZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZy5yZXNvbHZlKG1lc3NhZ2UucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZnVsbCBQT1NUIGVuZHBvaW50IFVSTFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFBvc3RVcmwoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZUVuZHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBlbmRwb2ludCBub3QgYXZhaWxhYmxlLiBTU0UgY29ubmVjdGlvbiBtYXkgbm90IGJlIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBlbmRwb2ludCBpcyByZWxhdGl2ZSwgY29uc3RydWN0IGZ1bGwgVVJMXHJcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZUVuZHBvaW50LnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMuc3NlVXJsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGAke3VybC5vcmlnaW59JHt0aGlzLm1lc3NhZ2VFbmRwb2ludH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBlbmRwb2ludCBpcyBhbHJlYWR5IGFic29sdXRlLCB1c2UgaXQgYXMtaXNcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlRW5kcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbm90aWZpY2F0aW9uIChubyByZXNwb25zZSBleHBlY3RlZClcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2VuZE5vdGlmaWNhdGlvbihtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZTogTWNwTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcGFyYW1zXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQnVpbGQgaGVhZGVyc1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuYWNjZXNzVG9rZW59YCxcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2V2ZW50LXN0cmVhbScsXHJcbiAgICAgICAgICAgICdNQ1AtUHJvdG9jb2wtVmVyc2lvbic6ICcyMDI1LTA2LTE4J1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEluY2x1ZGUgc2Vzc2lvbiBJRCBpZiBhdmFpbGFibGVcclxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1snTWNwLVNlc3Npb24tSWQnXSA9IHRoaXMuc2Vzc2lvbklkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGVyIE1DUCBzcGVjOiB1c2UgdGhlIGVuZHBvaW50IGZyb20gU1NFICdlbmRwb2ludCcgZXZlbnQgZm9yIFBPU1QgcmVxdWVzdHNcclxuICAgICAgICBjb25zdCBwb3N0VXJsID0gdGhpcy5nZXRQb3N0VXJsKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNlbmRpbmcgbm90aWZpY2F0aW9uIHRvOicsIHBvc3RVcmwpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIG5vdGlmaWNhdGlvbiAtIG5vIHJlc3BvbnNlIGV4cGVjdGVkIChzaG91bGQgcmV0dXJuIDIwMiBBY2NlcHRlZClcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHBvc3RVcmwsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTm90aW9uTUNQXSBOb3RpZmljYXRpb24gZmFpbGVkOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gTm90aWZpY2F0aW9uIHNlbnQ6JywgbWV0aG9kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSByZXF1ZXN0IG92ZXIgU1NFICh2aWEgUE9TVCB0byBlbmRwb2ludCBmcm9tIFNTRSAnZW5kcG9pbnQnIGV2ZW50KVxyXG4gICAgICogUGVyIE1DUCBzcGVjOiBTU0UgZm9yIHJlY2VpdmluZywgUE9TVCB0byBlbmRwb2ludCBwcm92aWRlZCBieSBzZXJ2ZXIgZm9yIHNlbmRpbmdcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2VuZFJlcXVlc3QobWV0aG9kOiBzdHJpbmcsIHBhcmFtcz86IGFueSwgb3B0aW9ucz86IHsgc2tpcFNlc3Npb25JZD86IGJvb2xlYW4gfSk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgY29uc3QgaWQgPSArK3RoaXMubWVzc2FnZUlkO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IE1jcE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICBwYXJhbXNcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgaGVhZGVyc1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9ldmVudC1zdHJlYW0nLFxyXG4gICAgICAgICAgICAgICAgJ01DUC1Qcm90b2NvbC1WZXJzaW9uJzogJzIwMjUtMDYtMTgnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBJbmNsdWRlIHNlc3Npb24gSUQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbGl6ZSA9IG1ldGhvZCA9PT0gJ2luaXRpYWxpemUnO1xyXG4gICAgICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZSAmJiB0aGlzLnNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1snTWNwLVNlc3Npb24tSWQnXSA9IHRoaXMuc2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXIgTUNQIHNwZWM6IHVzZSB0aGUgZW5kcG9pbnQgZnJvbSBTU0UgJ2VuZHBvaW50JyBldmVudCBmb3IgUE9TVCByZXF1ZXN0c1xyXG4gICAgICAgICAgICBjb25zdCBwb3N0VXJsID0gdGhpcy5nZXRQb3N0VXJsKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTZW5kaW5nIHJlcXVlc3QgdG86JywgcG9zdFVybCwgJ01ldGhvZDonLCBtZXRob2QpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VuZCB2aWEgUE9TVCB0byB0aGUgbWVzc2FnZSBlbmRwb2ludCAoZnJvbSBTU0UgZW5kcG9pbnQgZXZlbnQpXHJcbiAgICAgICAgICAgIGZldGNoKHBvc3RVcmwsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyByZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIFJlcXVlc3QgZmFpbGVkOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNlc3Npb24gSUQgZnJvbSByZXNwb25zZSBoZWFkZXJzIGlmIHRoaXMgaXMgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdNY3AtU2Vzc2lvbi1JZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbklkSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZEhlYWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTZXNzaW9uIElEIGZyb20gaW5pdCByZXNwb25zZTonLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGNvbnRlbnQgdHlwZSB0byBkZXRlcm1pbmUgaG93IHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9ldmVudC1zdHJlYW0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBpcyBTU0UgZm9ybWF0IC0gcGFyc2UgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgKGRhdGEuc3RhcnRzV2l0aCgneycpIHx8IGRhdGEuc3RhcnRzV2l0aCgnWycpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIEZhaWxlZCB0byBwYXJzZSBTU0UgZGF0YTonLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGlzIEpTT04gLSBwYXJzZSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjb250ZW50IHR5cGU6ICR7Y29udGVudFR5cGV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaW1lb3V0IGFmdGVyIDMwIHNlY29uZHNcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVxdWVzdHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAzMDAwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBtZXNzYWdlIGVuZHBvaW50IHRvIGJlIGF2YWlsYWJsZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHdhaXRGb3JFbmRwb2ludCh0aW1lb3V0TXM6IG51bWJlciA9IDEwMDAwKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB3aGlsZSAoIXRoaXMubWVzc2FnZUVuZHBvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gdGltZW91dE1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgbWVzc2FnZSBlbmRwb2ludCBmcm9tIFNTRScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBNQ1AgY29ubmVjdGlvblxyXG4gICAgICogTXVzdCBiZSBjYWxsZWQgQUZURVIgU1NFIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYW5kIGVuZHBvaW50IGV2ZW50IGlzIHJlY2VpdmVkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gUGVyIE1DUCBzcGVjOiBXYWl0IGZvciBTU0UgJ2VuZHBvaW50JyBldmVudCBiZWZvcmUgc2VuZGluZyByZXF1ZXN0c1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBXYWl0aW5nIGZvciBtZXNzYWdlIGVuZHBvaW50IGZyb20gU1NFLi4uJyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yRW5kcG9pbnQoKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gTWVzc2FnZSBlbmRwb2ludCByZWFkeSwgc2VuZGluZyBpbml0aWFsaXplIHJlcXVlc3QnKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFyYW1zOiBNY3BJbml0aWFsaXplUmVxdWVzdFsncGFyYW1zJ10gPSB7XHJcbiAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogJzIwMjUtMDYtMTgnLFxyXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHtcclxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbDoge30sXHJcbiAgICAgICAgICAgICAgICByb290czogeyBsaXN0Q2hhbmdlZDogdHJ1ZSB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsaWVudEluZm86IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdjaHJvbWUtYWktZXh0ZW5zaW9uJyxcclxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcwLjAuMSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNlbmQgaW5pdGlhbGl6ZSByZXF1ZXN0XHJcbiAgICAgICAgLy8gU2Vzc2lvbiBJRCB3aWxsIGJlIGV4dHJhY3RlZCBmcm9tIHJlc3BvbnNlIGhlYWRlcnNcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KCdpbml0aWFsaXplJywgcGFyYW1zKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gSW5pdGlhbGl6ZWQ6JywgcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8gVmVyaWZ5IHNlc3Npb24gSUQgd2FzIHJlY2VpdmVkIChpZiBzZXJ2ZXIgdXNlcyBzZXNzaW9ucylcclxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNlc3Npb24gZXN0YWJsaXNoZWQ6JywgdGhpcy5zZXNzaW9uSWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTZXJ2ZXIgZG9lcyBub3QgdXNlIHNlc3Npb24gbWFuYWdlbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWZ0ZXIgaW5pdGlhbGl6YXRpb24sIHNlbmQgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIChubyByZXNwb25zZSBleHBlY3RlZClcclxuICAgICAgICBhd2FpdCB0aGlzLnNlbmROb3RpZmljYXRpb24oJ25vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWQnKTtcclxuXHJcbiAgICAgICAgLy8gRmV0Y2ggYXZhaWxhYmxlIHRvb2xzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5mZXRjaFRvb2xzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhdmFpbGFibGUgdG9vbHMgZnJvbSBNQ1Agc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGZldGNoVG9vbHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBNY3BUb29sc0xpc3RSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ3Rvb2xzL2xpc3QnKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzLnRvb2xzID0gcmVzdWx0LnRvb2xzO1xyXG4gICAgICAgICAgICB0aGlzLm9uU3RhdHVzQ2hhbmdlKHRoaXMuY3VycmVudFN0YXR1cyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBUb29sczonLCByZXN1bHQudG9vbHMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIEZhaWxlZCB0byBmZXRjaCB0b29sczonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBhIHRvb2xcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY2FsbFRvb2wobmFtZTogc3RyaW5nLCBhcmdzPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoJ3Rvb2xzL2NhbGwnLCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBjb25uZWN0aW9uIHN0YXR1c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVN0YXR1cyhzdGF0ZTogTWNwQ29ubmVjdGlvblN0YXRlLCBlcnJvcj86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXR1cyA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5jdXJyZW50U3RhdHVzLFxyXG4gICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIGxhc3RDb25uZWN0ZWQ6IHN0YXRlID09PSAnY29ubmVjdGVkJyA/IERhdGUubm93KCkgOiB0aGlzLmN1cnJlbnRTdGF0dXMubGFzdENvbm5lY3RlZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblN0YXR1c0NoYW5nZSh0aGlzLmN1cnJlbnRTdGF0dXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGUgcmVjb25uZWN0aW9uIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNjaGVkdWxlUmVjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgTk9USU9OX0NPTkZJRy5SRUNPTk5FQ1RfTUlOX0RFTEFZICogTWF0aC5wb3coTk9USU9OX0NPTkZJRy5SRUNPTk5FQ1RfTVVMVElQTElFUiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksXHJcbiAgICAgICAgICAgIE5PVElPTl9DT05GSUcuUkVDT05ORUNUX01BWF9ERUxBWVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnY29ubmVjdGluZycsIGBSZWNvbm5lY3RpbmcgaW4gJHtNYXRoLnJvdW5kKGRlbGF5IC8gMTAwMCl9cy4uLmApO1xyXG5cclxuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgICAgIH0sIGRlbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2Nvbm5lY3QgYW5kIGNsZWFudXBcclxuICAgICAqL1xyXG4gICAgZGlzY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZS5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlamVjdCBhbGwgcGVuZGluZyByZXF1ZXN0c1xyXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBwZW5kaW5nXSBvZiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICBwZW5kaW5nLnJlamVjdChuZXcgRXJyb3IoJ0Rpc2Nvbm5lY3RlZCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGN1cnJlbnQgc3RhdHVzXHJcbiAgICAgKi9cclxuICAgIGdldFN0YXR1cygpOiBOb3Rpb25NY3BTdGF0dXMge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0dXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IE1jcFNTRUNsaWVudCB9O1xyXG4iLCIvKipcclxuICogQ29uZmlndXJhdGlvbiBjb25zdGFudHMgZm9yIHRoZSBleHRlbnNpb25cclxuICovXHJcblxyXG4vLyBDaHJvbWUgQnVpbHQtaW4gQUkgKEdlbWluaSBOYW5vKSBsaW1pdHNcclxuLy8gQmFzZWQgb24gQ2hyb21lIEFJIGRvY3VtZW50YXRpb24gYW5kIGNvbW11bml0eSByZXBvcnRzXHJcbmV4cG9ydCBjb25zdCBDSFJPTUVfQUlfTElNSVRTID0ge1xyXG4gICAgLyoqIE1heGltdW0gdG9rZW5zIHBlciBzaW5nbGUgcHJvbXB0IHRvIEdlbWluaSBOYW5vIChvbi1kZXZpY2UgbW9kZWwpICovXHJcbiAgICBNQVhfVE9LRU5TX1BFUl9QUk9NUFQ6IDEwMjQsXHJcblxyXG4gICAgLyoqIE1heGltdW0gdG9rZW5zIGZvciBzZXNzaW9uIHJldGVudGlvbiAoc2xpZGluZyB3aW5kb3cpICovXHJcbiAgICBNQVhfVE9LRU5TX1BFUl9TRVNTSU9OOiA0MDk2LFxyXG5cclxuICAgIC8qKiBSZWNvbW1lbmRlZCBjaHVuayBzaXplIGZvciB0ZXh0IHByb2Nlc3NpbmcgdG8gc3RheSB3ZWxsIHVuZGVyIHByb21wdCBsaW1pdCAqL1xyXG4gICAgUkVDT01NRU5ERURfQ0hVTktfVE9LRU5TOiA4MDAsXHJcblxyXG4gICAgLyoqIE1heGltdW0gb3V0cHV0IHRva2VucyBwZXIgcmVzcG9uc2UgKi9cclxuICAgIE1BWF9PVVRQVVRfVE9LRU5TOiAxMDI0LFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLyoqXHJcbiAqIENvcGlsb3RLaXQgQ29uZmlndXJhdGlvblxyXG4gKiBFZGl0IHRoaXMgVVJMIHRvIHBvaW50IHRvIHlvdXIgaG9zdGVkIENvcGlsb3QgUnVudGltZSBlbmRwb2ludFxyXG4gKiBFeGFtcGxlOiBcImh0dHBzOi8veW91ci1ydW50aW1lLmV4YW1wbGUuY29tL2FwaS9jb3BpbG90a2l0XCJcclxuICovXHJcbmV4cG9ydCBjb25zdCBDT1BJTE9UX1JVTlRJTUVfVVJMID0gXCIgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaVwiIGFzIHN0cmluZzsgLy8gVE9ETzogRWRpdCB0aGlzIFVSTFxyXG5leHBvcnQgY29uc3QgQ09QSUxPVF9SVU5USU1FX1VSTF9ERUZBVUxUID0gXCIgaHR0cDovL2xvY2FsaG9zdDozMDAwL1wiO1xyXG5cclxuLyoqXHJcbiAqIE5vdGlvbiBNQ1AgQ29uZmlndXJhdGlvblxyXG4gKiBPQXV0aCB3aXRoIER5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBmb3IgTm90aW9uIGhvc3RlZCBNQ1Agc2VydmVyXHJcbiAqIFxyXG4gKiBJTVBPUlRBTlQ6IFRoaXMgdXNlcyBkeW5hbWljIGNsaWVudCByZWdpc3RyYXRpb24gKFJGQyA3NTkxKVxyXG4gKiBDbGllbnQgY3JlZGVudGlhbHMgYXJlIG9idGFpbmVkIGF0IHJ1bnRpbWUgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25uZWN0XCJcclxuICovXHJcbmV4cG9ydCBjb25zdCBOT1RJT05fQ09ORklHID0ge1xyXG4gICAgLyoqIE9BdXRoIHJlZGlyZWN0IFVSSSAtIENocm9tZSBleHRlbnNpb24gaWRlbnRpdHkgcmVkaXJlY3QgKi9cclxuICAgIE9BVVRIX1JFRElSRUNUX1VSSTogXCJodHRwczovL2ZpbmZua2hjaGVsZm9mbG9vY2lkcGVwYWNmYmFqbWxoLmNocm9taXVtYXBwLm9yZy9cIixcclxuXHJcbiAgICAvKiogT0F1dGggZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uIGVuZHBvaW50ICovXHJcbiAgICBPQVVUSF9SRUdJU1RFUl9VUkw6IFwiaHR0cHM6Ly9tY3Aubm90aW9uLmNvbS9yZWdpc3RlclwiLFxyXG5cclxuICAgIC8qKiBPQXV0aCBhdXRob3JpemF0aW9uIGVuZHBvaW50IC0gU3RhbmRhcmQgTm90aW9uIE9BdXRoICovXHJcbiAgICBPQVVUSF9BVVRIX1VSTDogXCJodHRwczovL21jcC5ub3Rpb24uY29tL2F1dGhvcml6ZVwiLFxyXG5cclxuICAgIC8qKiBPQXV0aCB0b2tlbiBlbmRwb2ludCAtIFN0YW5kYXJkIE5vdGlvbiBPQXV0aCAqL1xyXG4gICAgT0FVVEhfVE9LRU5fVVJMOiBcImh0dHBzOi8vbWNwLm5vdGlvbi5jb20vdG9rZW5cIixcclxuXHJcbiAgICAvKiogT0F1dGggdG9rZW4gaW50cm9zcGVjdGlvbiBlbmRwb2ludCAqL1xyXG4gICAgT0FVVEhfSU5UUk9TUEVDVF9VUkw6IFwiaHR0cHM6Ly9hcGkubm90aW9uLmNvbS92MS9vYXV0aC9pbnRyb3NwZWN0XCIsXHJcblxyXG4gICAgLyoqIE1DUCByZXNvdXJjZSBpZGVudGlmaWVyIGZvciBPQXV0aCBzY29wZSAqL1xyXG4gICAgTUNQX1JFU09VUkNFOiBcImh0dHBzOi8vbWNwLm5vdGlvbi5jb20vXCIsXHJcblxyXG4gICAgLyoqIE5vdGlvbiBNQ1AgU1NFIGVuZHBvaW50IChmb3IgZXN0YWJsaXNoaW5nIFNTRSBjb25uZWN0aW9uIGFuZCByZWNlaXZpbmcgZXZlbnRzKSAqL1xyXG4gICAgTUNQX1NTRV9VUkw6IFwiaHR0cHM6Ly9tY3Aubm90aW9uLmNvbS9zc2VcIixcclxuXHJcbiAgICAvKiogVG9rZW4gc3RvcmFnZSBrZXkgcHJlZml4ICovXHJcbiAgICBTVE9SQUdFX0tFWV9QUkVGSVg6IFwib2F1dGgubm90aW9uLm1jcFwiLFxyXG5cclxuICAgIC8qKiBSZWNvbm5lY3Rpb24gc2V0dGluZ3MgKi9cclxuICAgIFJFQ09OTkVDVF9NSU5fREVMQVk6IDUwMCwgLy8gMC41c1xyXG4gICAgUkVDT05ORUNUX01BWF9ERUxBWTogMzAwMDAsIC8vIDMwc1xyXG4gICAgUkVDT05ORUNUX01VTFRJUExJRVI6IDIsXHJcbn0gYXMgY29uc3Q7XHJcbiIsIi8qKlxyXG4gKiBPQXV0aCB1dGlsaXRpZXMgZm9yIE5vdGlvbiBNQ1AgYXV0aGVudGljYXRpb25cclxuICogSW1wbGVtZW50cyBPQXV0aCAyLjAgUEtDRSAoUHJvb2YgS2V5IGZvciBDb2RlIEV4Y2hhbmdlKSBmbG93XHJcbiAqIGZvciBOb3Rpb24ncyBob3N0ZWQgTUNQIHNlcnZlciAobm8gY2xpZW50IHNlY3JldClcclxuICovXHJcblxyXG5pbXBvcnQgeyBidWZmZXIgfSBmcm9tICdub2RlOnN0cmVhbS9jb25zdW1lcnMnO1xyXG5pbXBvcnQgeyBOT1RJT05fQ09ORklHIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHR5cGUgeyBOb3Rpb25PQXV0aFRva2VucyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIER5bmFtaWMgY2xpZW50IGNyZWRlbnRpYWxzIGZyb20gcmVnaXN0cmF0aW9uXHJcbiAqL1xyXG5pbnRlcmZhY2UgRHluYW1pY0NsaWVudENyZWRlbnRpYWxzIHtcclxuICAgIGNsaWVudF9pZDogc3RyaW5nO1xyXG4gICAgY2xpZW50X3NlY3JldDogc3RyaW5nO1xyXG4gICAgcmVkaXJlY3RfdXJpczogc3RyaW5nW107XHJcbiAgICBjbGllbnRfbmFtZTogc3RyaW5nO1xyXG4gICAgZ3JhbnRfdHlwZXM6IHN0cmluZ1tdO1xyXG4gICAgcmVzcG9uc2VfdHlwZXM6IHN0cmluZ1tdO1xyXG4gICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q6IHN0cmluZztcclxuICAgIHJlZ2lzdHJhdGlvbl9jbGllbnRfdXJpPzogc3RyaW5nO1xyXG4gICAgY2xpZW50X2lkX2lzc3VlZF9hdD86IG51bWJlcjtcclxuICAgIGNyZWF0ZWRfYXQ6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgZHluYW1pYyBjbGllbnQgd2l0aCBOb3Rpb24gTUNQIE9BdXRoIHNlcnZlclxyXG4gKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgc3RhcnRpbmcgdGhlIE9BdXRoIGZsb3dcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyRHluYW1pY0NsaWVudChyZWRpcmVjdFVyaTogc3RyaW5nKTogUHJvbWlzZTxEeW5hbWljQ2xpZW50Q3JlZGVudGlhbHM+IHtcclxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvblBheWxvYWQgPSB7XHJcbiAgICAgICAgY2xpZW50X25hbWU6IFwiQ2hyb21lIEFJIEV4dGVuc2lvbiAtIE5vdGlvbiBNQ1BcIixcclxuICAgICAgICByZWRpcmVjdF91cmlzOiBbcmVkaXJlY3RVcmldLFxyXG4gICAgICAgIGdyYW50X3R5cGVzOiBbXCJhdXRob3JpemF0aW9uX2NvZGVcIiwgXCJyZWZyZXNoX3Rva2VuXCJdLFxyXG4gICAgICAgIHJlc3BvbnNlX3R5cGVzOiBbXCJjb2RlXCJdLFxyXG4gICAgICAgIHNjb3BlOiBcInJlYWQgd3JpdGVcIixcclxuICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogXCJjbGllbnRfc2VjcmV0X2Jhc2ljXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc29sZS5sb2coJ1tPQXV0aF0gUmVnaXN0ZXJpbmcgZHluYW1pYyBjbGllbnQgd2l0aCBwYXlsb2FkOicsIHJlZ2lzdHJhdGlvblBheWxvYWQpO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTk9USU9OX0NPTkZJRy5PQVVUSF9SRUdJU1RFUl9VUkwsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlZ2lzdHJhdGlvblBheWxvYWQpXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgcmVnaXN0cmF0aW9uIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnW09BdXRoXSBDbGllbnQgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHk6Jywge1xyXG4gICAgICAgIGNsaWVudF9pZDogZGF0YS5jbGllbnRfaWQsXHJcbiAgICAgICAgcmVkaXJlY3RfdXJpczogZGF0YS5yZWRpcmVjdF91cmlzXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsaWVudF9pZDogZGF0YS5jbGllbnRfaWQsXHJcbiAgICAgICAgY2xpZW50X3NlY3JldDogZGF0YS5jbGllbnRfc2VjcmV0LFxyXG4gICAgICAgIHJlZGlyZWN0X3VyaXM6IGRhdGEucmVkaXJlY3RfdXJpcyxcclxuICAgICAgICBjbGllbnRfbmFtZTogZGF0YS5jbGllbnRfbmFtZSxcclxuICAgICAgICBncmFudF90eXBlczogZGF0YS5ncmFudF90eXBlcyxcclxuICAgICAgICByZXNwb25zZV90eXBlczogZGF0YS5yZXNwb25zZV90eXBlcyxcclxuICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogZGF0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCxcclxuICAgICAgICByZWdpc3RyYXRpb25fY2xpZW50X3VyaTogZGF0YS5yZWdpc3RyYXRpb25fY2xpZW50X3VyaSxcclxuICAgICAgICBjbGllbnRfaWRfaXNzdWVkX2F0OiBkYXRhLmNsaWVudF9pZF9pc3N1ZWRfYXQsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogRGF0ZS5ub3coKVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHN0cmluZyBmb3Igc3RhdGUgcGFyYW1ldGVyIChDU1JGIHByb3RlY3Rpb24pXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZyhsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCBieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgc3RhdGUgcGFyYW1ldGVyIGZvciBDU1JGIHByb3RlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU3RhdGUoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZVJhbmRvbVN0cmluZygxNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjb2RlIHZlcmlmaWVyIGZvciBQS0NFICg0My0xMjggY2hhcmFjdGVycywgYmFzZTY0dXJsKVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29kZVZlcmlmaWVyKCk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KDMyKTsgLy8gMzIgYnl0ZXMgPSA0MyBjaGFycyBpbiBiYXNlNjR1cmxcclxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xyXG4gICAgcmV0dXJuIGJhc2U2NFVybEVuY29kZShhcnJheSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjb2RlIGNoYWxsZW5nZSBmcm9tIGEgdmVyaWZpZXIgKFNIQS0yNTYgaGFzaCwgYmFzZTY0dXJsIGVuY29kZWQpXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVDb2RlQ2hhbGxlbmdlKHZlcmlmaWVyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gICAgY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZlcmlmaWVyKTtcclxuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGEpO1xyXG4gICAgcmV0dXJuIGJhc2U2NFVybEVuY29kZShuZXcgVWludDhBcnJheShoYXNoKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCYXNlNjRVUkwgZW5jb2RlICh3aXRob3V0IHBhZGRpbmcpXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlNjRVcmxFbmNvZGUoYnVmZmVyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGJhc2U2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5idWZmZXIpKTtcclxuICAgIHJldHVybiBiYXNlNjRcclxuICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcclxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcclxuICAgICAgICAucmVwbGFjZSgvPS9nLCAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBOb3Rpb24gTUNQIE9BdXRoIGF1dGhvcml6YXRpb24gVVJMIChzdGFuZGFyZCBPQXV0aCwgbm8gUEtDRSlcclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkQXV0aFVybChjbGllbnRJZDogc3RyaW5nLCByZWRpcmVjdFVyaTogc3RyaW5nLCBzdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcclxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxyXG4gICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXHJcbiAgICAgICAgb3duZXI6ICd1c2VyJyxcclxuICAgICAgICBzdGF0ZTogc3RhdGVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBgJHtOT1RJT05fQ09ORklHLk9BVVRIX0FVVEhfVVJMfT8ke3BhcmFtcy50b1N0cmluZygpfWA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGNoYW5nZSBhdXRob3JpemF0aW9uIGNvZGUgZm9yIHRva2VucyB1c2luZyBkeW5hbWljIGNsaWVudCBjcmVkZW50aWFsc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZXhjaGFuZ2VDb2RlRm9yVG9rZW5zKFxyXG4gICAgY29kZTogc3RyaW5nLFxyXG4gICAgY2xpZW50SWQ6IHN0cmluZyxcclxuICAgIGNsaWVudFNlY3JldDogc3RyaW5nLFxyXG4gICAgcmVkaXJlY3RVcmk6IHN0cmluZ1xyXG4pOiBQcm9taXNlPE5vdGlvbk9BdXRoVG9rZW5zPiB7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IEJ1ZmZlci5mcm9tKGAke2NsaWVudElkfToke2NsaWVudFNlY3JldH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdbT0F1dGhdIEV4Y2hhbmdlIGNvZGUgZm9yIHRva2VucyB3aXRoIGNsaWVudDonLCBjbGllbnRJZCk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSB4LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBmb3IgT0F1dGggdG9rZW4gZXhjaGFuZ2VcclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxyXG4gICAgICAgIGNvZGU6IGNvZGUsXHJcbiAgICAgICAgcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ1tPQXV0aF0gRXhjaGFuZ2UgY29kZSBmb3IgdG9rZW5zIGJvZHkgKHVybGVuY29kZWQpOicsIHBhcmFtcy50b1N0cmluZygpKTtcclxuICAgIGNvbnNvbGUubG9nKCdbT0F1dGhdIEV4Y2hhbmdlIGNvZGUgZm9yIHRva2VucyBVUkw6JywgTk9USU9OX0NPTkZJRy5PQVVUSF9UT0tFTl9VUkwpO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTk9USU9OX0NPTkZJRy5PQVVUSF9UT0tFTl9VUkwsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJhc2ljICR7Y3JlZGVudGlhbHN9YCxcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgICAgICAnTm90aW9uLVZlcnNpb24nOiAnMjAyMi0wNi0yOCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IHBhcmFtcy50b1N0cmluZygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbiBleGNoYW5nZSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGV4cGlyYXRpb24gdGltZXN0YW1wXHJcbiAgICBjb25zdCBleHBpcmVzSW4gPSBkYXRhLmV4cGlyZXNfaW4gfHwgMzYwMDsgLy8gRGVmYXVsdCAxIGhvdXIgaWYgbm90IHByb3ZpZGVkXHJcbiAgICBjb25zdCBleHBpcmVzQXQgPSBEYXRlLm5vdygpICsgKGV4cGlyZXNJbiAqIDEwMDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcclxuICAgICAgICByZWZyZXNoX3Rva2VuOiBkYXRhLnJlZnJlc2hfdG9rZW4sXHJcbiAgICAgICAgdG9rZW5fdHlwZTogZGF0YS50b2tlbl90eXBlIHx8ICdCZWFyZXInLFxyXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcclxuICAgICAgICB3b3Jrc3BhY2VfaWQ6IGRhdGEud29ya3NwYWNlX2lkLFxyXG4gICAgICAgIHdvcmtzcGFjZV9uYW1lOiBkYXRhLndvcmtzcGFjZV9uYW1lLFxyXG4gICAgICAgIHdvcmtzcGFjZV9pY29uOiBkYXRhLndvcmtzcGFjZV9pY29uLFxyXG4gICAgICAgIG93bmVyOiBkYXRhLm93bmVyLFxyXG4gICAgICAgIGJvdF9pZDogZGF0YS5ib3RfaWQsXHJcbiAgICAgICAgZHVwbGljYXRlZF90ZW1wbGF0ZV9pZDogZGF0YS5kdXBsaWNhdGVkX3RlbXBsYXRlX2lkLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IERhdGUubm93KClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWZyZXNoIGFjY2VzcyB0b2tlbiB1c2luZyByZWZyZXNoIHRva2VuIGFuZCBkeW5hbWljIGNsaWVudCBjcmVkZW50aWFsc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEFjY2Vzc1Rva2VuKFxyXG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmcsXHJcbiAgICBjbGllbnRJZDogc3RyaW5nLFxyXG4gICAgY2xpZW50U2VjcmV0OiBzdHJpbmdcclxuKTogUHJvbWlzZTxOb3Rpb25PQXV0aFRva2Vucz4ge1xyXG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBCdWZmZXIuZnJvbShgJHtjbGllbnRJZH06JHtjbGllbnRTZWNyZXR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXHJcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKE5PVElPTl9DT05GSUcuT0FVVEhfVE9LRU5fVVJMLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCYXNpYyAke2NyZWRlbnRpYWxzfWAsXHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcclxuICAgICAgICAgICAgJ05vdGlvbi1WZXJzaW9uJzogJzIwMjItMDYtMjgnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBwYXJhbXMudG9TdHJpbmcoKVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gcmVmcmVzaCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgY29uc3QgZXhwaXJlc0luID0gZGF0YS5leHBpcmVzX2luIHx8IDM2MDA7XHJcbiAgICBjb25zdCBleHBpcmVzQXQgPSBEYXRlLm5vdygpICsgKGV4cGlyZXNJbiAqIDEwMDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcclxuICAgICAgICByZWZyZXNoX3Rva2VuOiBkYXRhLnJlZnJlc2hfdG9rZW4gfHwgcmVmcmVzaFRva2VuLFxyXG4gICAgICAgIHRva2VuX3R5cGU6IGRhdGEudG9rZW5fdHlwZSB8fCAnQmVhcmVyJyxcclxuICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXHJcbiAgICAgICAgd29ya3NwYWNlX2lkOiBkYXRhLndvcmtzcGFjZV9pZCxcclxuICAgICAgICB3b3Jrc3BhY2VfbmFtZTogZGF0YS53b3Jrc3BhY2VfbmFtZSxcclxuICAgICAgICB3b3Jrc3BhY2VfaWNvbjogZGF0YS53b3Jrc3BhY2VfaWNvbixcclxuICAgICAgICBvd25lcjogZGF0YS5vd25lcixcclxuICAgICAgICBjcmVhdGVkX2F0OiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdG9rZW4gaXMgZXhwaXJlZCBvciBhYm91dCB0byBleHBpcmUgKHdpdGhpbiA1IG1pbnV0ZXMpXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Rva2VuRXhwaXJlZCh0b2tlbnM6IE5vdGlvbk9BdXRoVG9rZW5zKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgYnVmZmVyVGltZSA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlc1xyXG4gICAgcmV0dXJuIHRva2Vucy5leHBpcmVzX2F0IDw9IChub3cgKyBidWZmZXJUaW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0b3JlIHRva2VucyBpbiBjaHJvbWUuc3RvcmFnZS5sb2NhbFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3RvcmVUb2tlbnModG9rZW5zOiBOb3Rpb25PQXV0aFRva2Vucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtcclxuICAgICAgICBbYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LnRva2Vuc2BdOiB0b2tlbnNcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgdG9rZW5zIGZyb20gY2hyb21lLnN0b3JhZ2UubG9jYWxcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZFRva2VucygpOiBQcm9taXNlPE5vdGlvbk9BdXRoVG9rZW5zIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KGAke05PVElPTl9DT05GSUcuU1RPUkFHRV9LRVlfUFJFRklYfS50b2tlbnNgKTtcclxuICAgIHJldHVybiByZXN1bHRbYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LnRva2Vuc2BdIHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhciBzdG9yZWQgdG9rZW5zXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjbGVhclRva2VucygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnJlbW92ZShgJHtOT1RJT05fQ09ORklHLlNUT1JBR0VfS0VZX1BSRUZJWH0udG9rZW5zYCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBkeW5hbWljIGNsaWVudCBjcmVkZW50aWFscyBpbiBjaHJvbWUuc3RvcmFnZS5sb2NhbFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3RvcmVDbGllbnRDcmVkZW50aWFscyhjcmVkZW50aWFsczogRHluYW1pY0NsaWVudENyZWRlbnRpYWxzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xyXG4gICAgICAgIFtgJHtOT1RJT05fQ09ORklHLlNUT1JBR0VfS0VZX1BSRUZJWH0uY2xpZW50YF06IGNyZWRlbnRpYWxzXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlIGR5bmFtaWMgY2xpZW50IGNyZWRlbnRpYWxzIGZyb20gY2hyb21lLnN0b3JhZ2UubG9jYWxcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZENsaWVudENyZWRlbnRpYWxzKCk6IFByb21pc2U8RHluYW1pY0NsaWVudENyZWRlbnRpYWxzIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KGAke05PVElPTl9DT05GSUcuU1RPUkFHRV9LRVlfUFJFRklYfS5jbGllbnRgKTtcclxuICAgIHJldHVybiByZXN1bHRbYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LmNsaWVudGBdIHx8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhciBzdG9yZWQgY2xpZW50IGNyZWRlbnRpYWxzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjbGVhckNsaWVudENyZWRlbnRpYWxzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGAke05PVElPTl9DT05GSUcuU1RPUkFHRV9LRVlfUFJFRklYfS5jbGllbnRgKTtcclxufVxyXG5cclxuZXhwb3J0IHtcclxuICAgIHJlZ2lzdGVyRHluYW1pY0NsaWVudCxcclxuICAgIGdlbmVyYXRlU3RhdGUsXHJcbiAgICBjcmVhdGVDb2RlVmVyaWZpZXIsXHJcbiAgICBjcmVhdGVDb2RlQ2hhbGxlbmdlLFxyXG4gICAgYnVpbGRBdXRoVXJsLFxyXG4gICAgZXhjaGFuZ2VDb2RlRm9yVG9rZW5zLFxyXG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuLFxyXG4gICAgaXNUb2tlbkV4cGlyZWQsXHJcbiAgICBzdG9yZVRva2VucyxcclxuICAgIGdldFN0b3JlZFRva2VucyxcclxuICAgIGNsZWFyVG9rZW5zLFxyXG4gICAgc3RvcmVDbGllbnRDcmVkZW50aWFscyxcclxuICAgIGdldFN0b3JlZENsaWVudENyZWRlbnRpYWxzLFxyXG4gICAgY2xlYXJDbGllbnRDcmVkZW50aWFscyxcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIHsgRHluYW1pY0NsaWVudENyZWRlbnRpYWxzIH07XHJcbiIsInZhciBFcj1PYmplY3QuY3JlYXRlO3ZhciBOPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgZHI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgZ3I9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIG1yPU9iamVjdC5nZXRQcm90b3R5cGVPZixJcj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciAkPShpLHIpPT4oKT0+KHJ8fGkoKHI9e2V4cG9ydHM6e319KS5leHBvcnRzLHIpLHIuZXhwb3J0cyksRnI9KGkscik9Pntmb3IodmFyIHQgaW4gcilOKGksdCx7Z2V0OnJbdF0sZW51bWVyYWJsZTohMH0pfSxMPShpLHIsdCxuKT0+e2lmKHImJnR5cGVvZiByPT1cIm9iamVjdFwifHx0eXBlb2Ygcj09XCJmdW5jdGlvblwiKWZvcihsZXQgZSBvZiBncihyKSkhSXIuY2FsbChpLGUpJiZlIT09dCYmTihpLGUse2dldDooKT0+cltlXSxlbnVtZXJhYmxlOiEobj1kcihyLGUpKXx8bi5lbnVtZXJhYmxlfSk7cmV0dXJuIGl9LFM9KGkscix0KT0+KEwoaSxyLFwiZGVmYXVsdFwiKSx0JiZMKHQscixcImRlZmF1bHRcIikpLEo9KGkscix0KT0+KHQ9aSE9bnVsbD9FcihtcihpKSk6e30sTChyfHwhaXx8IWkuX19lc01vZHVsZT9OKHQsXCJkZWZhdWx0XCIse3ZhbHVlOmksZW51bWVyYWJsZTohMH0pOnQsaSkpLEFyPWk9PkwoTih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxpKTt2YXIgUT0kKE09PntcInVzZSBzdHJpY3RcIjtNLmJ5dGVMZW5ndGg9UnI7TS50b0J5dGVBcnJheT1DcjtNLmZyb21CeXRlQXJyYXk9THI7dmFyIEI9W10sdz1bXSxVcj10eXBlb2YgVWludDhBcnJheTxcInVcIj9VaW50OEFycmF5OkFycmF5LFA9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Zm9yKG09MCxLPVAubGVuZ3RoO208SzsrK20pQlttXT1QW21dLHdbUC5jaGFyQ29kZUF0KG0pXT1tO3ZhciBtLEs7d1tcIi1cIi5jaGFyQ29kZUF0KDApXT02Mjt3W1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2Z1bmN0aW9uIFooaSl7dmFyIHI9aS5sZW5ndGg7aWYociU0PjApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTt2YXIgdD1pLmluZGV4T2YoXCI9XCIpO3Q9PT0tMSYmKHQ9cik7dmFyIG49dD09PXI/MDo0LXQlNDtyZXR1cm5bdCxuXX1mdW5jdGlvbiBScihpKXt2YXIgcj1aKGkpLHQ9clswXSxuPXJbMV07cmV0dXJuKHQrbikqMy80LW59ZnVuY3Rpb24gVHIoaSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIENyKGkpe3ZhciByLHQ9WihpKSxuPXRbMF0sZT10WzFdLG89bmV3IFVyKFRyKGksbixlKSksdT0wLGY9ZT4wP24tNDpuLGM7Zm9yKGM9MDtjPGY7Yys9NClyPXdbaS5jaGFyQ29kZUF0KGMpXTw8MTh8d1tpLmNoYXJDb2RlQXQoYysxKV08PDEyfHdbaS5jaGFyQ29kZUF0KGMrMildPDw2fHdbaS5jaGFyQ29kZUF0KGMrMyldLG9bdSsrXT1yPj4xNiYyNTUsb1t1KytdPXI+PjgmMjU1LG9bdSsrXT1yJjI1NTtyZXR1cm4gZT09PTImJihyPXdbaS5jaGFyQ29kZUF0KGMpXTw8Mnx3W2kuY2hhckNvZGVBdChjKzEpXT4+NCxvW3UrK109ciYyNTUpLGU9PT0xJiYocj13W2kuY2hhckNvZGVBdChjKV08PDEwfHdbaS5jaGFyQ29kZUF0KGMrMSldPDw0fHdbaS5jaGFyQ29kZUF0KGMrMildPj4yLG9bdSsrXT1yPj44JjI1NSxvW3UrK109ciYyNTUpLG99ZnVuY3Rpb24gU3IoaSl7cmV0dXJuIEJbaT4+MTgmNjNdK0JbaT4+MTImNjNdK0JbaT4+NiY2M10rQltpJjYzXX1mdW5jdGlvbiBfcihpLHIsdCl7Zm9yKHZhciBuLGU9W10sbz1yO288dDtvKz0zKW49KGlbb108PDE2JjE2NzExNjgwKSsoaVtvKzFdPDw4JjY1MjgwKSsoaVtvKzJdJjI1NSksZS5wdXNoKFNyKG4pKTtyZXR1cm4gZS5qb2luKFwiXCIpfWZ1bmN0aW9uIExyKGkpe2Zvcih2YXIgcix0PWkubGVuZ3RoLG49dCUzLGU9W10sbz0xNjM4Myx1PTAsZj10LW47dTxmO3UrPW8pZS5wdXNoKF9yKGksdSx1K28+Zj9mOnUrbykpO3JldHVybiBuPT09MT8ocj1pW3QtMV0sZS5wdXNoKEJbcj4+Ml0rQltyPDw0JjYzXStcIj09XCIpKTpuPT09MiYmKHI9KGlbdC0yXTw8OCkraVt0LTFdLGUucHVzaChCW3I+PjEwXStCW3I+PjQmNjNdK0Jbcjw8MiY2M10rXCI9XCIpKSxlLmpvaW4oXCJcIil9fSk7dmFyIHY9JChPPT57Ty5yZWFkPWZ1bmN0aW9uKGkscix0LG4sZSl7dmFyIG8sdSxmPWUqOC1uLTEsYz0oMTw8ZiktMSxsPWM+PjEscz0tNyxwPXQ/ZS0xOjAsRj10Py0xOjEseD1pW3IrcF07Zm9yKHArPUYsbz14JigxPDwtcyktMSx4Pj49LXMscys9ZjtzPjA7bz1vKjI1NitpW3IrcF0scCs9RixzLT04KTtmb3IodT1vJigxPDwtcyktMSxvPj49LXMscys9bjtzPjA7dT11KjI1NitpW3IrcF0scCs9RixzLT04KTtpZihvPT09MClvPTEtbDtlbHNle2lmKG89PT1jKXJldHVybiB1P05hTjooeD8tMToxKSooMS8wKTt1PXUrTWF0aC5wb3coMixuKSxvPW8tbH1yZXR1cm4oeD8tMToxKSp1Kk1hdGgucG93KDIsby1uKX07Ty53cml0ZT1mdW5jdGlvbihpLHIsdCxuLGUsbyl7dmFyIHUsZixjLGw9byo4LWUtMSxzPSgxPDxsKS0xLHA9cz4+MSxGPWU9PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAseD1uPzA6by0xLGI9bj8xOi0xLEJyPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtmb3Iocj1NYXRoLmFicyhyKSxpc05hTihyKXx8cj09PTEvMD8oZj1pc05hTihyKT8xOjAsdT1zKToodT1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKSxyKihjPU1hdGgucG93KDIsLXUpKTwxJiYodS0tLGMqPTIpLHUrcD49MT9yKz1GL2M6cis9RipNYXRoLnBvdygyLDEtcCkscipjPj0yJiYodSsrLGMvPTIpLHUrcD49cz8oZj0wLHU9cyk6dStwPj0xPyhmPShyKmMtMSkqTWF0aC5wb3coMixlKSx1PXUrcCk6KGY9cipNYXRoLnBvdygyLHAtMSkqTWF0aC5wb3coMixlKSx1PTApKTtlPj04O2lbdCt4XT1mJjI1NSx4Kz1iLGYvPTI1NixlLT04KTtmb3IodT11PDxlfGYsbCs9ZTtsPjA7aVt0K3hdPXUmMjU1LHgrPWIsdS89MjU2LGwtPTgpO2lbdCt4LWJdfD1CcioxMjh9fSk7dmFyIHo9JChUPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEc9USgpLFU9digpLHJyPXR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5mb3I9PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtULkJ1ZmZlcj1oO1QuU2xvd0J1ZmZlcj0kcjtULklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBrPTIxNDc0ODM2NDc7VC5rTWF4TGVuZ3RoPWs7aC5UWVBFRF9BUlJBWV9TVVBQT1JUPU5yKCk7IWguVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGU8XCJ1XCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT1cImZ1bmN0aW9uXCImJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIik7ZnVuY3Rpb24gTnIoKXt0cnl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkoMSkscj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoaSxyKSxpLmZvbygpPT09NDJ9Y2F0Y2goaSl7cmV0dXJuITF9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2lmKGguaXNCdWZmZXIodGhpcykpcmV0dXJuIHRoaXMuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2lmKGguaXNCdWZmZXIodGhpcykpcmV0dXJuIHRoaXMuYnl0ZU9mZnNldH19KTtmdW5jdGlvbiBkKGkpe2lmKGk+ayl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytpKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtsZXQgcj1uZXcgVWludDhBcnJheShpKTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsaC5wcm90b3R5cGUpLHJ9ZnVuY3Rpb24gaChpLHIsdCl7aWYodHlwZW9mIGk9PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7cmV0dXJuIGooaSl9cmV0dXJuIGVyKGkscix0KX1oLnBvb2xTaXplPTgxOTI7ZnVuY3Rpb24gZXIoaSxyLHQpe2lmKHR5cGVvZiBpPT1cInN0cmluZ1wiKXJldHVybiBrcihpLHIpO2lmKEFycmF5QnVmZmVyLmlzVmlldyhpKSlyZXR1cm4gRHIoaSk7aWYoaT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGkpO2lmKEUoaSxBcnJheUJ1ZmZlcil8fGkmJkUoaS5idWZmZXIsQXJyYXlCdWZmZXIpfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJihFKGksU2hhcmVkQXJyYXlCdWZmZXIpfHxpJiZFKGkuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpcmV0dXJuIHEoaSxyLHQpO2lmKHR5cGVvZiBpPT1cIm51bWJlclwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7bGV0IG49aS52YWx1ZU9mJiZpLnZhbHVlT2YoKTtpZihuIT1udWxsJiZuIT09aSlyZXR1cm4gaC5mcm9tKG4scix0KTtsZXQgZT1icihpKTtpZihlKXJldHVybiBlO2lmKHR5cGVvZiBTeW1ib2w8XCJ1XCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIGlbU3ltYm9sLnRvUHJpbWl0aXZlXT09XCJmdW5jdGlvblwiKXJldHVybiBoLmZyb20oaVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCk7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBpKX1oLmZyb209ZnVuY3Rpb24oaSxyLHQpe3JldHVybiBlcihpLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihoLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGgsVWludDhBcnJheSk7ZnVuY3Rpb24gb3IoaSl7aWYodHlwZW9mIGkhPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpO2lmKGk8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytpKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX1mdW5jdGlvbiBNcihpLHIsdCl7cmV0dXJuIG9yKGkpLGk8PTA/ZChpKTpyIT09dm9pZCAwP3R5cGVvZiB0PT1cInN0cmluZ1wiP2QoaSkuZmlsbChyLHQpOmQoaSkuZmlsbChyKTpkKGkpfWguYWxsb2M9ZnVuY3Rpb24oaSxyLHQpe3JldHVybiBNcihpLHIsdCl9O2Z1bmN0aW9uIGooaSl7cmV0dXJuIG9yKGkpLGQoaTwwPzA6SChpKXwwKX1oLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGkpe3JldHVybiBqKGkpfTtoLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihpKXtyZXR1cm4gaihpKX07ZnVuY3Rpb24ga3IoaSxyKXtpZigodHlwZW9mIHIhPVwic3RyaW5nXCJ8fHI9PT1cIlwiKSYmKHI9XCJ1dGY4XCIpLCFoLmlzRW5jb2RpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpO2xldCB0PXVyKGkscil8MCxuPWQodCksZT1uLndyaXRlKGkscik7cmV0dXJuIGUhPT10JiYobj1uLnNsaWNlKDAsZSkpLG59ZnVuY3Rpb24gWShpKXtsZXQgcj1pLmxlbmd0aDwwPzA6SChpLmxlbmd0aCl8MCx0PWQocik7Zm9yKGxldCBuPTA7bjxyO24rPTEpdFtuXT1pW25dJjI1NTtyZXR1cm4gdH1mdW5jdGlvbiBEcihpKXtpZihFKGksVWludDhBcnJheSkpe2xldCByPW5ldyBVaW50OEFycmF5KGkpO3JldHVybiBxKHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpfXJldHVybiBZKGkpfWZ1bmN0aW9uIHEoaSxyLHQpe2lmKHI8MHx8aS5ieXRlTGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7aWYoaS5ieXRlTGVuZ3RoPHIrKHR8fDApKXRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpO2xldCBuO3JldHVybiByPT09dm9pZCAwJiZ0PT09dm9pZCAwP249bmV3IFVpbnQ4QXJyYXkoaSk6dD09PXZvaWQgMD9uPW5ldyBVaW50OEFycmF5KGkscik6bj1uZXcgVWludDhBcnJheShpLHIsdCksT2JqZWN0LnNldFByb3RvdHlwZU9mKG4saC5wcm90b3R5cGUpLG59ZnVuY3Rpb24gYnIoaSl7aWYoaC5pc0J1ZmZlcihpKSl7bGV0IHI9SChpLmxlbmd0aCl8MCx0PWQocik7cmV0dXJuIHQubGVuZ3RoPT09MHx8aS5jb3B5KHQsMCwwLHIpLHR9aWYoaS5sZW5ndGghPT12b2lkIDApcmV0dXJuIHR5cGVvZiBpLmxlbmd0aCE9XCJudW1iZXJcInx8WChpLmxlbmd0aCk/ZCgwKTpZKGkpO2lmKGkudHlwZT09PVwiQnVmZmVyXCImJkFycmF5LmlzQXJyYXkoaS5kYXRhKSlyZXR1cm4gWShpLmRhdGEpfWZ1bmN0aW9uIEgoaSl7aWYoaT49ayl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIitrLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gaXwwfWZ1bmN0aW9uICRyKGkpe3JldHVybitpIT1pJiYoaT0wKSxoLmFsbG9jKCtpKX1oLmlzQnVmZmVyPWZ1bmN0aW9uKHIpe3JldHVybiByIT1udWxsJiZyLl9pc0J1ZmZlcj09PSEwJiZyIT09aC5wcm90b3R5cGV9O2guY29tcGFyZT1mdW5jdGlvbihyLHQpe2lmKEUocixVaW50OEFycmF5KSYmKHI9aC5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKSksRSh0LFVpbnQ4QXJyYXkpJiYodD1oLmZyb20odCx0Lm9mZnNldCx0LmJ5dGVMZW5ndGgpKSwhaC5pc0J1ZmZlcihyKXx8IWguaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpO2lmKHI9PT10KXJldHVybiAwO2xldCBuPXIubGVuZ3RoLGU9dC5sZW5ndGg7Zm9yKGxldCBvPTAsdT1NYXRoLm1pbihuLGUpO288dTsrK28paWYocltvXSE9PXRbb10pe249cltvXSxlPXRbb107YnJlYWt9cmV0dXJuIG48ZT8tMTplPG4/MTowfTtoLmlzRW5jb2Rpbmc9ZnVuY3Rpb24ocil7c3dpdGNoKFN0cmluZyhyKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fTtoLmNvbmNhdD1mdW5jdGlvbihyLHQpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKHIubGVuZ3RoPT09MClyZXR1cm4gaC5hbGxvYygwKTtsZXQgbjtpZih0PT09dm9pZCAwKWZvcih0PTAsbj0wO248ci5sZW5ndGg7KytuKXQrPXJbbl0ubGVuZ3RoO2xldCBlPWguYWxsb2NVbnNhZmUodCksbz0wO2ZvcihuPTA7bjxyLmxlbmd0aDsrK24pe2xldCB1PXJbbl07aWYoRSh1LFVpbnQ4QXJyYXkpKW8rdS5sZW5ndGg+ZS5sZW5ndGg/KGguaXNCdWZmZXIodSl8fCh1PWguZnJvbSh1KSksdS5jb3B5KGUsbykpOlVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdSxvKTtlbHNlIGlmKGguaXNCdWZmZXIodSkpdS5jb3B5KGUsbyk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtvKz11Lmxlbmd0aH1yZXR1cm4gZX07ZnVuY3Rpb24gdXIoaSxyKXtpZihoLmlzQnVmZmVyKGkpKXJldHVybiBpLmxlbmd0aDtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoaSl8fEUoaSxBcnJheUJ1ZmZlcikpcmV0dXJuIGkuYnl0ZUxlbmd0aDtpZih0eXBlb2YgaSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBpKTtsZXQgdD1pLmxlbmd0aCxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09ITA7aWYoIW4mJnQ9PT0wKXJldHVybiAwO2xldCBlPSExO2Zvcig7Oylzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gVyhpKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHQqMjtjYXNlXCJoZXhcIjpyZXR1cm4gdD4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIHdyKGkpLmxlbmd0aDtkZWZhdWx0OmlmKGUpcmV0dXJuIG4/LTE6VyhpKS5sZW5ndGg7cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpLGU9ITB9fWguYnl0ZUxlbmd0aD11cjtmdW5jdGlvbiBQcihpLHIsdCl7bGV0IG49ITE7aWYoKHI9PT12b2lkIDB8fHI8MCkmJihyPTApLHI+dGhpcy5sZW5ndGh8fCgodD09PXZvaWQgMHx8dD50aGlzLmxlbmd0aCkmJih0PXRoaXMubGVuZ3RoKSx0PD0wKXx8KHQ+Pj49MCxyPj4+PTAsdDw9cikpcmV0dXJuXCJcIjtmb3IoaXx8KGk9XCJ1dGY4XCIpOzspc3dpdGNoKGkpe2Nhc2VcImhleFwiOnJldHVybiB6cih0aGlzLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIGZyKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBWcih0aGlzLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIFhyKHRoaXMscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4ganIodGhpcyxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBKcih0aGlzLHIsdCk7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitpKTtpPShpK1wiXCIpLnRvTG93ZXJDYXNlKCksbj0hMH19aC5wcm90b3R5cGUuX2lzQnVmZmVyPSEwO2Z1bmN0aW9uIEkoaSxyLHQpe2xldCBuPWlbcl07aVtyXT1pW3RdLGlbdF09bn1oLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24oKXtsZXQgcj10aGlzLmxlbmd0aDtpZihyJTIhPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7Zm9yKGxldCB0PTA7dDxyO3QrPTIpSSh0aGlzLHQsdCsxKTtyZXR1cm4gdGhpc307aC5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7bGV0IHI9dGhpcy5sZW5ndGg7aWYociU0IT09MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2ZvcihsZXQgdD0wO3Q8cjt0Kz00KUkodGhpcyx0LHQrMyksSSh0aGlzLHQrMSx0KzIpO3JldHVybiB0aGlzfTtoLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXtsZXQgcj10aGlzLmxlbmd0aDtpZihyJTghPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIik7Zm9yKGxldCB0PTA7dDxyO3QrPTgpSSh0aGlzLHQsdCs3KSxJKHRoaXMsdCsxLHQrNiksSSh0aGlzLHQrMix0KzUpLEkodGhpcyx0KzMsdCs0KTtyZXR1cm4gdGhpc307aC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtsZXQgcj10aGlzLmxlbmd0aDtyZXR1cm4gcj09PTA/XCJcIjphcmd1bWVudHMubGVuZ3RoPT09MD9mcih0aGlzLDAscik6UHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtoLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1oLnByb3RvdHlwZS50b1N0cmluZztoLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24ocil7aWYoIWguaXNCdWZmZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT1yPyEwOmguY29tcGFyZSh0aGlzLHIpPT09MH07aC5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe2xldCByPVwiXCIsdD1ULklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiByPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKSx0aGlzLmxlbmd0aD50JiYocis9XCIgLi4uIFwiKSxcIjxCdWZmZXIgXCIrcitcIj5cIn07cnImJihoLnByb3RvdHlwZVtycl09aC5wcm90b3R5cGUuaW5zcGVjdCk7aC5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihyLHQsbixlLG8pe2lmKEUocixVaW50OEFycmF5KSYmKHI9aC5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKSksIWguaXNCdWZmZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiByKTtpZih0PT09dm9pZCAwJiYodD0wKSxuPT09dm9pZCAwJiYobj1yP3IubGVuZ3RoOjApLGU9PT12b2lkIDAmJihlPTApLG89PT12b2lkIDAmJihvPXRoaXMubGVuZ3RoKSx0PDB8fG4+ci5sZW5ndGh8fGU8MHx8bz50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihlPj1vJiZ0Pj1uKXJldHVybiAwO2lmKGU+PW8pcmV0dXJuLTE7aWYodD49bilyZXR1cm4gMTtpZih0Pj4+PTAsbj4+Pj0wLGU+Pj49MCxvPj4+PTAsdGhpcz09PXIpcmV0dXJuIDA7bGV0IHU9by1lLGY9bi10LGM9TWF0aC5taW4odSxmKSxsPXRoaXMuc2xpY2UoZSxvKSxzPXIuc2xpY2UodCxuKTtmb3IobGV0IHA9MDtwPGM7KytwKWlmKGxbcF0hPT1zW3BdKXt1PWxbcF0sZj1zW3BdO2JyZWFrfXJldHVybiB1PGY/LTE6Zjx1PzE6MH07ZnVuY3Rpb24gaHIoaSxyLHQsbixlKXtpZihpLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCI/KG49dCx0PTApOnQ+MjE0NzQ4MzY0Nz90PTIxNDc0ODM2NDc6dDwtMjE0NzQ4MzY0OCYmKHQ9LTIxNDc0ODM2NDgpLHQ9K3QsWCh0KSYmKHQ9ZT8wOmkubGVuZ3RoLTEpLHQ8MCYmKHQ9aS5sZW5ndGgrdCksdD49aS5sZW5ndGgpe2lmKGUpcmV0dXJuLTE7dD1pLmxlbmd0aC0xfWVsc2UgaWYodDwwKWlmKGUpdD0wO2Vsc2UgcmV0dXJuLTE7aWYodHlwZW9mIHI9PVwic3RyaW5nXCImJihyPWguZnJvbShyLG4pKSxoLmlzQnVmZmVyKHIpKXJldHVybiByLmxlbmd0aD09PTA/LTE6dHIoaSxyLHQsbixlKTtpZih0eXBlb2Ygcj09XCJudW1iZXJcIilyZXR1cm4gcj1yJjI1NSx0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09XCJmdW5jdGlvblwiP2U/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGkscix0KTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGkscix0KTp0cihpLFtyXSx0LG4sZSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiB0cihpLHIsdCxuLGUpe2xldCBvPTEsdT1pLmxlbmd0aCxmPXIubGVuZ3RoO2lmKG4hPT12b2lkIDAmJihuPVN0cmluZyhuKS50b0xvd2VyQ2FzZSgpLG49PT1cInVjczJcInx8bj09PVwidWNzLTJcInx8bj09PVwidXRmMTZsZVwifHxuPT09XCJ1dGYtMTZsZVwiKSl7aWYoaS5sZW5ndGg8Mnx8ci5sZW5ndGg8MilyZXR1cm4tMTtvPTIsdS89MixmLz0yLHQvPTJ9ZnVuY3Rpb24gYyhzLHApe3JldHVybiBvPT09MT9zW3BdOnMucmVhZFVJbnQxNkJFKHAqbyl9bGV0IGw7aWYoZSl7bGV0IHM9LTE7Zm9yKGw9dDtsPHU7bCsrKWlmKGMoaSxsKT09PWMocixzPT09LTE/MDpsLXMpKXtpZihzPT09LTEmJihzPWwpLGwtcysxPT09ZilyZXR1cm4gcypvfWVsc2UgcyE9PS0xJiYobC09bC1zKSxzPS0xfWVsc2UgZm9yKHQrZj51JiYodD11LWYpLGw9dDtsPj0wO2wtLSl7bGV0IHM9ITA7Zm9yKGxldCBwPTA7cDxmO3ArKylpZihjKGksbCtwKSE9PWMocixwKSl7cz0hMTticmVha31pZihzKXJldHVybiBsfXJldHVybi0xfWgucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdGhpcy5pbmRleE9mKHIsdCxuKSE9PS0xfTtoLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gaHIodGhpcyxyLHQsbiwhMCl9O2gucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gaHIodGhpcyxyLHQsbiwhMSl9O2Z1bmN0aW9uIE9yKGkscix0LG4pe3Q9TnVtYmVyKHQpfHwwO2xldCBlPWkubGVuZ3RoLXQ7bj8obj1OdW1iZXIobiksbj5lJiYobj1lKSk6bj1lO2xldCBvPXIubGVuZ3RoO24+by8yJiYobj1vLzIpO2xldCB1O2Zvcih1PTA7dTxuOysrdSl7bGV0IGY9cGFyc2VJbnQoci5zdWJzdHIodSoyLDIpLDE2KTtpZihYKGYpKXJldHVybiB1O2lbdCt1XT1mfXJldHVybiB1fWZ1bmN0aW9uIEdyKGkscix0LG4pe3JldHVybiBEKFcocixpLmxlbmd0aC10KSxpLHQsbil9ZnVuY3Rpb24gWXIoaSxyLHQsbil7cmV0dXJuIEQodnIociksaSx0LG4pfWZ1bmN0aW9uIHFyKGkscix0LG4pe3JldHVybiBEKHdyKHIpLGksdCxuKX1mdW5jdGlvbiBXcihpLHIsdCxuKXtyZXR1cm4gRChydChyLGkubGVuZ3RoLXQpLGksdCxuKX1oLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihyLHQsbixlKXtpZih0PT09dm9pZCAwKWU9XCJ1dGY4XCIsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZihuPT09dm9pZCAwJiZ0eXBlb2YgdD09XCJzdHJpbmdcIillPXQsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZihpc0Zpbml0ZSh0KSl0PXQ+Pj4wLGlzRmluaXRlKG4pPyhuPW4+Pj4wLGU9PT12b2lkIDAmJihlPVwidXRmOFwiKSk6KGU9bixuPXZvaWQgMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtsZXQgbz10aGlzLmxlbmd0aC10O2lmKChuPT09dm9pZCAwfHxuPm8pJiYobj1vKSxyLmxlbmd0aD4wJiYobjwwfHx0PDApfHx0PnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7ZXx8KGU9XCJ1dGY4XCIpO2xldCB1PSExO2Zvcig7Oylzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIE9yKHRoaXMscix0LG4pO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBHcih0aGlzLHIsdCxuKTtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBZcih0aGlzLHIsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gcXIodGhpcyxyLHQsbik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIFdyKHRoaXMscix0LG4pO2RlZmF1bHQ6aWYodSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpLHU9ITB9fTtoLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24ganIoaSxyLHQpe3JldHVybiByPT09MCYmdD09PWkubGVuZ3RoP0cuZnJvbUJ5dGVBcnJheShpKTpHLmZyb21CeXRlQXJyYXkoaS5zbGljZShyLHQpKX1mdW5jdGlvbiBmcihpLHIsdCl7dD1NYXRoLm1pbihpLmxlbmd0aCx0KTtsZXQgbj1bXSxlPXI7Zm9yKDtlPHQ7KXtsZXQgbz1pW2VdLHU9bnVsbCxmPW8+MjM5PzQ6bz4yMjM/MzpvPjE5MT8yOjE7aWYoZStmPD10KXtsZXQgYyxsLHMscDtzd2l0Y2goZil7Y2FzZSAxOm88MTI4JiYodT1vKTticmVhaztjYXNlIDI6Yz1pW2UrMV0sKGMmMTkyKT09PTEyOCYmKHA9KG8mMzEpPDw2fGMmNjMscD4xMjcmJih1PXApKTticmVhaztjYXNlIDM6Yz1pW2UrMV0sbD1pW2UrMl0sKGMmMTkyKT09PTEyOCYmKGwmMTkyKT09PTEyOCYmKHA9KG8mMTUpPDwxMnwoYyY2Myk8PDZ8bCY2MyxwPjIwNDcmJihwPDU1Mjk2fHxwPjU3MzQzKSYmKHU9cCkpO2JyZWFrO2Nhc2UgNDpjPWlbZSsxXSxsPWlbZSsyXSxzPWlbZSszXSwoYyYxOTIpPT09MTI4JiYobCYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYocD0obyYxNSk8PDE4fChjJjYzKTw8MTJ8KGwmNjMpPDw2fHMmNjMscD42NTUzNSYmcDwxMTE0MTEyJiYodT1wKSl9fXU9PT1udWxsPyh1PTY1NTMzLGY9MSk6dT42NTUzNSYmKHUtPTY1NTM2LG4ucHVzaCh1Pj4+MTAmMTAyM3w1NTI5NiksdT01NjMyMHx1JjEwMjMpLG4ucHVzaCh1KSxlKz1mfXJldHVybiBIcihuKX12YXIgaXI9NDA5NjtmdW5jdGlvbiBIcihpKXtsZXQgcj1pLmxlbmd0aDtpZihyPD1pcilyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaSk7bGV0IHQ9XCJcIixuPTA7Zm9yKDtuPHI7KXQrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkuc2xpY2UobixuKz1pcikpO3JldHVybiB0fWZ1bmN0aW9uIFZyKGkscix0KXtsZXQgbj1cIlwiO3Q9TWF0aC5taW4oaS5sZW5ndGgsdCk7Zm9yKGxldCBlPXI7ZTx0OysrZSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGlbZV0mMTI3KTtyZXR1cm4gbn1mdW5jdGlvbiBYcihpLHIsdCl7bGV0IG49XCJcIjt0PU1hdGgubWluKGkubGVuZ3RoLHQpO2ZvcihsZXQgZT1yO2U8dDsrK2Upbis9U3RyaW5nLmZyb21DaGFyQ29kZShpW2VdKTtyZXR1cm4gbn1mdW5jdGlvbiB6cihpLHIsdCl7bGV0IG49aS5sZW5ndGg7KCFyfHxyPDApJiYocj0wKSwoIXR8fHQ8MHx8dD5uKSYmKHQ9bik7bGV0IGU9XCJcIjtmb3IobGV0IG89cjtvPHQ7KytvKWUrPXR0W2lbb11dO3JldHVybiBlfWZ1bmN0aW9uIEpyKGkscix0KXtsZXQgbj1pLnNsaWNlKHIsdCksZT1cIlwiO2ZvcihsZXQgbz0wO288bi5sZW5ndGgtMTtvKz0yKWUrPVN0cmluZy5mcm9tQ2hhckNvZGUobltvXStuW28rMV0qMjU2KTtyZXR1cm4gZX1oLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihyLHQpe2xldCBuPXRoaXMubGVuZ3RoO3I9fn5yLHQ9dD09PXZvaWQgMD9uOn5+dCxyPDA/KHIrPW4scjwwJiYocj0wKSk6cj5uJiYocj1uKSx0PDA/KHQrPW4sdDwwJiYodD0wKSk6dD5uJiYodD1uKSx0PHImJih0PXIpO2xldCBlPXRoaXMuc3ViYXJyYXkocix0KTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsaC5wcm90b3R5cGUpLGV9O2Z1bmN0aW9uIGEoaSxyLHQpe2lmKGklMSE9PTB8fGk8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihpK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9aC5wcm90b3R5cGUucmVhZFVpbnRMRT1oLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKHIsdCxuKXtyPXI+Pj4wLHQ9dD4+PjAsbnx8YShyLHQsdGhpcy5sZW5ndGgpO2xldCBlPXRoaXNbcl0sbz0xLHU9MDtmb3IoOysrdTx0JiYobyo9MjU2KTspZSs9dGhpc1tyK3VdKm87cmV0dXJuIGV9O2gucHJvdG90eXBlLnJlYWRVaW50QkU9aC5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbihyLHQsbil7cj1yPj4+MCx0PXQ+Pj4wLG58fGEocix0LHRoaXMubGVuZ3RoKTtsZXQgZT10aGlzW3IrLS10XSxvPTE7Zm9yKDt0PjAmJihvKj0yNTYpOyllKz10aGlzW3IrLS10XSpvO3JldHVybiBlfTtoLnByb3RvdHlwZS5yZWFkVWludDg9aC5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDEsdGhpcy5sZW5ndGgpLHRoaXNbcl19O2gucHJvdG90eXBlLnJlYWRVaW50MTZMRT1oLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsMix0aGlzLmxlbmd0aCksdGhpc1tyXXx0aGlzW3IrMV08PDh9O2gucHJvdG90eXBlLnJlYWRVaW50MTZCRT1oLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsMix0aGlzLmxlbmd0aCksdGhpc1tyXTw8OHx0aGlzW3IrMV19O2gucHJvdG90eXBlLnJlYWRVaW50MzJMRT1oLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsNCx0aGlzLmxlbmd0aCksKHRoaXNbcl18dGhpc1tyKzFdPDw4fHRoaXNbcisyXTw8MTYpK3RoaXNbciszXSoxNjc3NzIxNn07aC5wcm90b3R5cGUucmVhZFVpbnQzMkJFPWgucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSx0aGlzW3JdKjE2Nzc3MjE2Kyh0aGlzW3IrMV08PDE2fHRoaXNbcisyXTw8OHx0aGlzW3IrM10pfTtoLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEU9ZyhmdW5jdGlvbihyKXtyPXI+Pj4wLFIocixcIm9mZnNldFwiKTtsZXQgdD10aGlzW3JdLG49dGhpc1tyKzddOyh0PT09dm9pZCAwfHxuPT09dm9pZCAwKSYmXyhyLHRoaXMubGVuZ3RoLTgpO2xldCBlPXQrdGhpc1srK3JdKjIqKjgrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKioyNCxvPXRoaXNbKytyXSt0aGlzWysrcl0qMioqOCt0aGlzWysrcl0qMioqMTYrbioyKioyNDtyZXR1cm4gQmlnSW50KGUpKyhCaWdJbnQobyk8PEJpZ0ludCgzMikpfSk7aC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFPWcoZnVuY3Rpb24ocil7cj1yPj4+MCxSKHIsXCJvZmZzZXRcIik7bGV0IHQ9dGhpc1tyXSxuPXRoaXNbcis3XTsodD09PXZvaWQgMHx8bj09PXZvaWQgMCkmJl8ocix0aGlzLmxlbmd0aC04KTtsZXQgZT10KjIqKjI0K3RoaXNbKytyXSoyKioxNit0aGlzWysrcl0qMioqOCt0aGlzWysrcl0sbz10aGlzWysrcl0qMioqMjQrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKio4K247cmV0dXJuKEJpZ0ludChlKTw8QmlnSW50KDMyKSkrQmlnSW50KG8pfSk7aC5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHIsdCxuKXtyPXI+Pj4wLHQ9dD4+PjAsbnx8YShyLHQsdGhpcy5sZW5ndGgpO2xldCBlPXRoaXNbcl0sbz0xLHU9MDtmb3IoOysrdTx0JiYobyo9MjU2KTspZSs9dGhpc1tyK3VdKm87cmV0dXJuIG8qPTEyOCxlPj1vJiYoZS09TWF0aC5wb3coMiw4KnQpKSxlfTtoLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24ocix0LG4pe3I9cj4+PjAsdD10Pj4+MCxufHxhKHIsdCx0aGlzLmxlbmd0aCk7bGV0IGU9dCxvPTEsdT10aGlzW3IrLS1lXTtmb3IoO2U+MCYmKG8qPTI1Nik7KXUrPXRoaXNbcistLWVdKm87cmV0dXJuIG8qPTEyOCx1Pj1vJiYodS09TWF0aC5wb3coMiw4KnQpKSx1fTtoLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociwxLHRoaXMubGVuZ3RoKSx0aGlzW3JdJjEyOD8oMjU1LXRoaXNbcl0rMSkqLTE6dGhpc1tyXX07aC5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24ocix0KXtyPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKTtsZXQgbj10aGlzW3JdfHRoaXNbcisxXTw8ODtyZXR1cm4gbiYzMjc2OD9ufDQyOTQ5MDE3NjA6bn07aC5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24ocix0KXtyPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKTtsZXQgbj10aGlzW3IrMV18dGhpc1tyXTw8ODtyZXR1cm4gbiYzMjc2OD9ufDQyOTQ5MDE3NjA6bn07aC5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsNCx0aGlzLmxlbmd0aCksdGhpc1tyXXx0aGlzW3IrMV08PDh8dGhpc1tyKzJdPDwxNnx0aGlzW3IrM108PDI0fTtoLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSx0aGlzW3JdPDwyNHx0aGlzW3IrMV08PDE2fHRoaXNbcisyXTw8OHx0aGlzW3IrM119O2gucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFPWcoZnVuY3Rpb24ocil7cj1yPj4+MCxSKHIsXCJvZmZzZXRcIik7bGV0IHQ9dGhpc1tyXSxuPXRoaXNbcis3XTsodD09PXZvaWQgMHx8bj09PXZvaWQgMCkmJl8ocix0aGlzLmxlbmd0aC04KTtsZXQgZT10aGlzW3IrNF0rdGhpc1tyKzVdKjIqKjgrdGhpc1tyKzZdKjIqKjE2KyhuPDwyNCk7cmV0dXJuKEJpZ0ludChlKTw8QmlnSW50KDMyKSkrQmlnSW50KHQrdGhpc1srK3JdKjIqKjgrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKioyNCl9KTtoLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRT1nKGZ1bmN0aW9uKHIpe3I9cj4+PjAsUihyLFwib2Zmc2V0XCIpO2xldCB0PXRoaXNbcl0sbj10aGlzW3IrN107KHQ9PT12b2lkIDB8fG49PT12b2lkIDApJiZfKHIsdGhpcy5sZW5ndGgtOCk7bGV0IGU9KHQ8PDI0KSt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjgrdGhpc1srK3JdO3JldHVybihCaWdJbnQoZSk8PEJpZ0ludCgzMikpK0JpZ0ludCh0aGlzWysrcl0qMioqMjQrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKio4K24pfSk7aC5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsNCx0aGlzLmxlbmd0aCksVS5yZWFkKHRoaXMsciwhMCwyMyw0KX07aC5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsNCx0aGlzLmxlbmd0aCksVS5yZWFkKHRoaXMsciwhMSwyMyw0KX07aC5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDgsdGhpcy5sZW5ndGgpLFUucmVhZCh0aGlzLHIsITAsNTIsOCl9O2gucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw4LHRoaXMubGVuZ3RoKSxVLnJlYWQodGhpcyxyLCExLDUyLDgpfTtmdW5jdGlvbiB5KGkscix0LG4sZSxvKXtpZighaC5pc0J1ZmZlcihpKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPmV8fHI8byl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K24+aS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9aC5wcm90b3R5cGUud3JpdGVVaW50TEU9aC5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24ocix0LG4sZSl7aWYocj0rcix0PXQ+Pj4wLG49bj4+PjAsIWUpe2xldCBmPU1hdGgucG93KDIsOCpuKS0xO3kodGhpcyxyLHQsbixmLDApfWxldCBvPTEsdT0wO2Zvcih0aGlzW3RdPXImMjU1OysrdTxuJiYobyo9MjU2KTspdGhpc1t0K3VdPXIvbyYyNTU7cmV0dXJuIHQrbn07aC5wcm90b3R5cGUud3JpdGVVaW50QkU9aC5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24ocix0LG4sZSl7aWYocj0rcix0PXQ+Pj4wLG49bj4+PjAsIWUpe2xldCBmPU1hdGgucG93KDIsOCpuKS0xO3kodGhpcyxyLHQsbixmLDApfWxldCBvPW4tMSx1PTE7Zm9yKHRoaXNbdCtvXT1yJjI1NTstLW8+PTAmJih1Kj0yNTYpOyl0aGlzW3Qrb109ci91JjI1NTtyZXR1cm4gdCtufTtoLnByb3RvdHlwZS53cml0ZVVpbnQ4PWgucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwxLDI1NSwwKSx0aGlzW3RdPXImMjU1LHQrMX07aC5wcm90b3R5cGUud3JpdGVVaW50MTZMRT1oLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsMiw2NTUzNSwwKSx0aGlzW3RdPXImMjU1LHRoaXNbdCsxXT1yPj4+OCx0KzJ9O2gucHJvdG90eXBlLndyaXRlVWludDE2QkU9aC5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDIsNjU1MzUsMCksdGhpc1t0XT1yPj4+OCx0aGlzW3QrMV09ciYyNTUsdCsyfTtoLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFPWgucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCw0LDQyOTQ5NjcyOTUsMCksdGhpc1t0KzNdPXI+Pj4yNCx0aGlzW3QrMl09cj4+PjE2LHRoaXNbdCsxXT1yPj4+OCx0aGlzW3RdPXImMjU1LHQrNH07aC5wcm90b3R5cGUud3JpdGVVaW50MzJCRT1oLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbdF09cj4+PjI0LHRoaXNbdCsxXT1yPj4+MTYsdGhpc1t0KzJdPXI+Pj44LHRoaXNbdCszXT1yJjI1NSx0KzR9O2Z1bmN0aW9uIGNyKGkscix0LG4sZSl7eXIocixuLGUsaSx0LDcpO2xldCBvPU51bWJlcihyJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7aVt0KytdPW8sbz1vPj44LGlbdCsrXT1vLG89bz4+OCxpW3QrK109byxvPW8+PjgsaVt0KytdPW87bGV0IHU9TnVtYmVyKHI+PkJpZ0ludCgzMikmQmlnSW50KDQyOTQ5NjcyOTUpKTtyZXR1cm4gaVt0KytdPXUsdT11Pj44LGlbdCsrXT11LHU9dT4+OCxpW3QrK109dSx1PXU+PjgsaVt0KytdPXUsdH1mdW5jdGlvbiBwcihpLHIsdCxuLGUpe3lyKHIsbixlLGksdCw3KTtsZXQgbz1OdW1iZXIociZCaWdJbnQoNDI5NDk2NzI5NSkpO2lbdCs3XT1vLG89bz4+OCxpW3QrNl09byxvPW8+PjgsaVt0KzVdPW8sbz1vPj44LGlbdCs0XT1vO2xldCB1PU51bWJlcihyPj5CaWdJbnQoMzIpJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7cmV0dXJuIGlbdCszXT11LHU9dT4+OCxpW3QrMl09dSx1PXU+PjgsaVt0KzFdPXUsdT11Pj44LGlbdF09dSx0Kzh9aC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRT1nKGZ1bmN0aW9uKHIsdD0wKXtyZXR1cm4gY3IodGhpcyxyLHQsQmlnSW50KDApLEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKSl9KTtoLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFPWcoZnVuY3Rpb24ocix0PTApe3JldHVybiBwcih0aGlzLHIsdCxCaWdJbnQoMCksQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2gucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24ocix0LG4sZSl7aWYocj0rcix0PXQ+Pj4wLCFlKXtsZXQgYz1NYXRoLnBvdygyLDgqbi0xKTt5KHRoaXMscix0LG4sYy0xLC1jKX1sZXQgbz0wLHU9MSxmPTA7Zm9yKHRoaXNbdF09ciYyNTU7KytvPG4mJih1Kj0yNTYpOylyPDAmJmY9PT0wJiZ0aGlzW3Qrby0xXSE9PTAmJihmPTEpLHRoaXNbdCtvXT0oci91Pj4wKS1mJjI1NTtyZXR1cm4gdCtufTtoLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHIsdCxuLGUpe2lmKHI9K3IsdD10Pj4+MCwhZSl7bGV0IGM9TWF0aC5wb3coMiw4Km4tMSk7eSh0aGlzLHIsdCxuLGMtMSwtYyl9bGV0IG89bi0xLHU9MSxmPTA7Zm9yKHRoaXNbdCtvXT1yJjI1NTstLW8+PTAmJih1Kj0yNTYpOylyPDAmJmY9PT0wJiZ0aGlzW3QrbysxXSE9PTAmJihmPTEpLHRoaXNbdCtvXT0oci91Pj4wKS1mJjI1NTtyZXR1cm4gdCtufTtoLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwxLDEyNywtMTI4KSxyPDAmJihyPTI1NStyKzEpLHRoaXNbdF09ciYyNTUsdCsxfTtoLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwyLDMyNzY3LC0zMjc2OCksdGhpc1t0XT1yJjI1NSx0aGlzW3QrMV09cj4+PjgsdCsyfTtoLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwyLDMyNzY3LC0zMjc2OCksdGhpc1t0XT1yPj4+OCx0aGlzW3QrMV09ciYyNTUsdCsyfTtoLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLHRoaXNbdF09ciYyNTUsdGhpc1t0KzFdPXI+Pj44LHRoaXNbdCsyXT1yPj4+MTYsdGhpc1t0KzNdPXI+Pj4yNCx0KzR9O2gucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCkscjwwJiYocj00Mjk0OTY3Mjk1K3IrMSksdGhpc1t0XT1yPj4+MjQsdGhpc1t0KzFdPXI+Pj4xNix0aGlzW3QrMl09cj4+PjgsdGhpc1t0KzNdPXImMjU1LHQrNH07aC5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFPWcoZnVuY3Rpb24ocix0PTApe3JldHVybiBjcih0aGlzLHIsdCwtQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwXCIpLEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKSl9KTtoLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkU9ZyhmdW5jdGlvbihyLHQ9MCl7cmV0dXJuIHByKHRoaXMscix0LC1CaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDBcIiksQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2Z1bmN0aW9uIHNyKGkscix0LG4sZSxvKXtpZih0K24+aS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIGxyKGkscix0LG4sZSl7cmV0dXJuIHI9K3IsdD10Pj4+MCxlfHxzcihpLHIsdCw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMiksVS53cml0ZShpLHIsdCxuLDIzLDQpLHQrNH1oLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBscih0aGlzLHIsdCwhMCxuKX07aC5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gbHIodGhpcyxyLHQsITEsbil9O2Z1bmN0aW9uIGFyKGkscix0LG4sZSl7cmV0dXJuIHI9K3IsdD10Pj4+MCxlfHxzcihpLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKSxVLndyaXRlKGkscix0LG4sNTIsOCksdCs4fWgucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBhcih0aGlzLHIsdCwhMCxuKX07aC5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIGFyKHRoaXMscix0LCExLG4pfTtoLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKHIsdCxuLGUpe2lmKCFoLmlzQnVmZmVyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYobnx8KG49MCksIWUmJmUhPT0wJiYoZT10aGlzLmxlbmd0aCksdD49ci5sZW5ndGgmJih0PXIubGVuZ3RoKSx0fHwodD0wKSxlPjAmJmU8biYmKGU9biksZT09PW58fHIubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtlPnRoaXMubGVuZ3RoJiYoZT10aGlzLmxlbmd0aCksci5sZW5ndGgtdDxlLW4mJihlPXIubGVuZ3RoLXQrbik7bGV0IG89ZS1uO3JldHVybiB0aGlzPT09ciYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PVwiZnVuY3Rpb25cIj90aGlzLmNvcHlXaXRoaW4odCxuLGUpOlVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHIsdGhpcy5zdWJhcnJheShuLGUpLHQpLG99O2gucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24ocix0LG4sZSl7aWYodHlwZW9mIHI9PVwic3RyaW5nXCIpe2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiPyhlPXQsdD0wLG49dGhpcy5sZW5ndGgpOnR5cGVvZiBuPT1cInN0cmluZ1wiJiYoZT1uLG49dGhpcy5sZW5ndGgpLGUhPT12b2lkIDAmJnR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiJiYhaC5pc0VuY29kaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtpZihyLmxlbmd0aD09PTEpe2xldCB1PXIuY2hhckNvZGVBdCgwKTsoZT09PVwidXRmOFwiJiZ1PDEyOHx8ZT09PVwibGF0aW4xXCIpJiYocj11KX19ZWxzZSB0eXBlb2Ygcj09XCJudW1iZXJcIj9yPXImMjU1OnR5cGVvZiByPT1cImJvb2xlYW5cIiYmKHI9TnVtYmVyKHIpKTtpZih0PDB8fHRoaXMubGVuZ3RoPHR8fHRoaXMubGVuZ3RoPG4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYobjw9dClyZXR1cm4gdGhpczt0PXQ+Pj4wLG49bj09PXZvaWQgMD90aGlzLmxlbmd0aDpuPj4+MCxyfHwocj0wKTtsZXQgbztpZih0eXBlb2Ygcj09XCJudW1iZXJcIilmb3Iobz10O288bjsrK28pdGhpc1tvXT1yO2Vsc2V7bGV0IHU9aC5pc0J1ZmZlcihyKT9yOmguZnJvbShyLGUpLGY9dS5sZW5ndGg7aWYoZj09PTApdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytyKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKTtmb3Iobz0wO288bi10Oysrbyl0aGlzW28rdF09dVtvJWZdfXJldHVybiB0aGlzfTt2YXIgQT17fTtmdW5jdGlvbiBWKGkscix0KXtBW2ldPWNsYXNzIGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJtZXNzYWdlXCIse3ZhbHVlOnIuYXBwbHkodGhpcyxhcmd1bWVudHMpLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHRoaXMubmFtZT1cIlwiLmNvbmNhdCh0aGlzLm5hbWUsXCIgW1wiKS5jb25jYXQoaSxcIl1cIiksdGhpcy5zdGFjayxkZWxldGUgdGhpcy5uYW1lfWdldCBjb2RlKCl7cmV0dXJuIGl9c2V0IGNvZGUoZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJjb2RlXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOmUsd3JpdGFibGU6ITB9KX10b1N0cmluZygpe3JldHVyblwiXCIuY29uY2F0KHRoaXMubmFtZSxcIiBbXCIpLmNvbmNhdChpLFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpfX19VihcIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EU1wiLGZ1bmN0aW9uKGkpe3JldHVybiBpP1wiXCIuY29uY2F0KGksXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzXCIpOlwiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kc1wifSxSYW5nZUVycm9yKTtWKFwiRVJSX0lOVkFMSURfQVJHX1RZUEVcIixmdW5jdGlvbihpLHIpe3JldHVybidUaGUgXCInLmNvbmNhdChpLCdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICcpLmNvbmNhdCh0eXBlb2Ygcil9LFR5cGVFcnJvcik7VihcIkVSUl9PVVRfT0ZfUkFOR0VcIixmdW5jdGlvbihpLHIsdCl7bGV0IG49J1RoZSB2YWx1ZSBvZiBcIicuY29uY2F0KGksJ1wiIGlzIG91dCBvZiByYW5nZS4nKSxlPXQ7cmV0dXJuIE51bWJlci5pc0ludGVnZXIodCkmJk1hdGguYWJzKHQpPjIqKjMyP2U9bnIoU3RyaW5nKHQpKTp0eXBlb2YgdD09XCJiaWdpbnRcIiYmKGU9U3RyaW5nKHQpLCh0PkJpZ0ludCgyKSoqQmlnSW50KDMyKXx8dDwtKEJpZ0ludCgyKSoqQmlnSW50KDMyKSkpJiYoZT1ucihlKSksZSs9XCJuXCIpLG4rPVwiIEl0IG11c3QgYmUgXCIuY29uY2F0KHIsXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoZSksbn0sUmFuZ2VFcnJvcik7ZnVuY3Rpb24gbnIoaSl7bGV0IHI9XCJcIix0PWkubGVuZ3RoLG49aVswXT09PVwiLVwiPzE6MDtmb3IoO3Q+PW4rNDt0LT0zKXI9XCJfXCIuY29uY2F0KGkuc2xpY2UodC0zLHQpKS5jb25jYXQocik7cmV0dXJuXCJcIi5jb25jYXQoaS5zbGljZSgwLHQpKS5jb25jYXQocil9ZnVuY3Rpb24gS3IoaSxyLHQpe1IocixcIm9mZnNldFwiKSwoaVtyXT09PXZvaWQgMHx8aVtyK3RdPT09dm9pZCAwKSYmXyhyLGkubGVuZ3RoLSh0KzEpKX1mdW5jdGlvbiB5cihpLHIsdCxuLGUsbyl7aWYoaT50fHxpPHIpe2xldCB1PXR5cGVvZiByPT1cImJpZ2ludFwiP1wiblwiOlwiXCIsZjt0aHJvdyBvPjM/cj09PTB8fHI9PT1CaWdJbnQoMCk/Zj1cIj49IDBcIi5jb25jYXQodSxcIiBhbmQgPCAyXCIpLmNvbmNhdCh1LFwiICoqIFwiKS5jb25jYXQoKG8rMSkqOCkuY29uY2F0KHUpOmY9XCI+PSAtKDJcIi5jb25jYXQodSxcIiAqKiBcIikuY29uY2F0KChvKzEpKjgtMSkuY29uY2F0KHUsXCIpIGFuZCA8IDIgKiogXCIpK1wiXCIuY29uY2F0KChvKzEpKjgtMSkuY29uY2F0KHUpOmY9XCI+PSBcIi5jb25jYXQocikuY29uY2F0KHUsXCIgYW5kIDw9IFwiKS5jb25jYXQodCkuY29uY2F0KHUpLG5ldyBBLkVSUl9PVVRfT0ZfUkFOR0UoXCJ2YWx1ZVwiLGYsaSl9S3IobixlLG8pfWZ1bmN0aW9uIFIoaSxyKXtpZih0eXBlb2YgaSE9XCJudW1iZXJcIil0aHJvdyBuZXcgQS5FUlJfSU5WQUxJRF9BUkdfVFlQRShyLFwibnVtYmVyXCIsaSl9ZnVuY3Rpb24gXyhpLHIsdCl7dGhyb3cgTWF0aC5mbG9vcihpKSE9PWk/KFIoaSx0KSxuZXcgQS5FUlJfT1VUX09GX1JBTkdFKHR8fFwib2Zmc2V0XCIsXCJhbiBpbnRlZ2VyXCIsaSkpOnI8MD9uZXcgQS5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFM6bmV3IEEuRVJSX09VVF9PRl9SQU5HRSh0fHxcIm9mZnNldFwiLFwiPj0gXCIuY29uY2F0KHQ/MTowLFwiIGFuZCA8PSBcIikuY29uY2F0KHIpLGkpfXZhciBacj0vW14rLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIFFyKGkpe2lmKGk9aS5zcGxpdChcIj1cIilbMF0saT1pLnRyaW0oKS5yZXBsYWNlKFpyLFwiXCIpLGkubGVuZ3RoPDIpcmV0dXJuXCJcIjtmb3IoO2kubGVuZ3RoJTQhPT0wOylpPWkrXCI9XCI7cmV0dXJuIGl9ZnVuY3Rpb24gVyhpLHIpe3I9cnx8MS8wO2xldCB0LG49aS5sZW5ndGgsZT1udWxsLG89W107Zm9yKGxldCB1PTA7dTxuOysrdSl7aWYodD1pLmNoYXJDb2RlQXQodSksdD41NTI5NSYmdDw1NzM0NCl7aWYoIWUpe2lmKHQ+NTYzMTkpeyhyLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKHUrMT09PW4peyhyLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lPXQ7Y29udGludWV9aWYodDw1NjMyMCl7KHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpLGU9dDtjb250aW51ZX10PShlLTU1Mjk2PDwxMHx0LTU2MzIwKSs2NTUzNn1lbHNlIGUmJihyLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtpZihlPW51bGwsdDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO28ucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7by5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO28ucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztvLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9cmV0dXJuIG99ZnVuY3Rpb24gdnIoaSl7bGV0IHI9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3Qpci5wdXNoKGkuY2hhckNvZGVBdCh0KSYyNTUpO3JldHVybiByfWZ1bmN0aW9uIHJ0KGkscil7bGV0IHQsbixlLG89W107Zm9yKGxldCB1PTA7dTxpLmxlbmd0aCYmISgoci09Mik8MCk7Kyt1KXQ9aS5jaGFyQ29kZUF0KHUpLG49dD4+OCxlPXQlMjU2LG8ucHVzaChlKSxvLnB1c2gobik7cmV0dXJuIG99ZnVuY3Rpb24gd3IoaSl7cmV0dXJuIEcudG9CeXRlQXJyYXkoUXIoaSkpfWZ1bmN0aW9uIEQoaSxyLHQsbil7bGV0IGU7Zm9yKGU9MDtlPG4mJiEoZSt0Pj1yLmxlbmd0aHx8ZT49aS5sZW5ndGgpOysrZSlyW2UrdF09aVtlXTtyZXR1cm4gZX1mdW5jdGlvbiBFKGkscil7cmV0dXJuIGkgaW5zdGFuY2VvZiByfHxpIT1udWxsJiZpLmNvbnN0cnVjdG9yIT1udWxsJiZpLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJmkuY29uc3RydWN0b3IubmFtZT09PXIubmFtZX1mdW5jdGlvbiBYKGkpe3JldHVybiBpIT09aX12YXIgdHQ9ZnVuY3Rpb24oKXtsZXQgaT1cIjAxMjM0NTY3ODlhYmNkZWZcIixyPW5ldyBBcnJheSgyNTYpO2ZvcihsZXQgdD0wO3Q8MTY7Kyt0KXtsZXQgbj10KjE2O2ZvcihsZXQgZT0wO2U8MTY7KytlKXJbbitlXT1pW3RdK2lbZV19cmV0dXJuIHJ9KCk7ZnVuY3Rpb24gZyhpKXtyZXR1cm4gdHlwZW9mIEJpZ0ludD5cInVcIj9pdDppfWZ1bmN0aW9uIGl0KCl7dGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IG5vdCBzdXBwb3J0ZWRcIil9fSk7dmFyIEM9e307RnIoQyx7ZGVmYXVsdDooKT0+bnR9KTttb2R1bGUuZXhwb3J0cz1BcihDKTt2YXIgeHI9Sih6KCkpO1MoQyxKKHooKSksbW9kdWxlLmV4cG9ydHMpO3ZhciBudD14ci5kZWZhdWx0O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuaWVlZTc1NC9pbmRleC5qczpcbiAgKCohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKilcblxuYnVmZmVyL2luZGV4LmpzOlxuICAoKiFcbiAgICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gICAqXG4gICAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gICAqIEBsaWNlbnNlICBNSVRcbiAgICopXG4qL1xuIl0sIm5hbWVzIjpbIlNDSEVNRVMiLCJ1dWlkIiwic2NoZW1lIiwidXJuIiwibWFpbHRvIiwid3NzIiwid3MiLCJodHRwcyIsImh0dHAiLCJ1cm5Db21wb25lbnRzIiwibnNzIiwidXVpZENvbXBvbmVudHMiLCJ0b0xvd2VyQ2FzZSIsIm9wdGlvbnMiLCJlcnJvciIsInRvbGVyYW50IiwibWF0Y2giLCJVVUlEIiwidW5kZWZpbmVkIiwiaGFuZGxlciIsInVyaUNvbXBvbmVudHMiLCJwYXRoIiwibmlkIiwic2NoZW1lSGFuZGxlciIsInNlcmlhbGl6ZSIsInVyblNjaGVtZSIsInBhcnNlIiwibWF0Y2hlcyIsImNvbXBvbmVudHMiLCJVUk5fUEFSU0UiLCJxdWVyeSIsImZpZWxkcyIsImpvaW4iLCJsZW5ndGgiLCJwdXNoIiwibmFtZSIsInJlcGxhY2UiLCJQQ1RfRU5DT0RFRCIsImRlY29kZVVucmVzZXJ2ZWQiLCJ0b1VwcGVyQ2FzZSIsIk5PVF9IRk5BTUUiLCJwY3RFbmNDaGFyIiwiaGVhZGVycyIsIk5PVF9IRlZBTFVFIiwiTyIsIm1haWx0b0NvbXBvbmVudHMiLCJib2R5Iiwic3ViamVjdCIsInRvIiwieCIsImxvY2FsUGFydCIsImRvbWFpbiIsImlyaSIsImUiLCJwdW55Y29kZSIsInRvQVNDSUkiLCJ1bmVzY2FwZUNvbXBvbmVudCIsInRvVW5pY29kZSIsInRvQWRkciIsInNsaWNlIiwiYXRJZHgiLCJOT1RfTE9DQUxfUEFSVCIsImxhc3RJbmRleE9mIiwiU3RyaW5nIiwieGwiLCJ0b0FycmF5IiwiYWRkciIsInVuaWNvZGVTdXBwb3J0Iiwic3BsaXQiLCJ1bmtub3duSGVhZGVycyIsImhmaWVsZCIsInRvQWRkcnMiLCJoZmllbGRzIiwiZGVjU3RyIiwiVU5SRVNFUlZFRCIsInN0ciIsInBjdERlY0NoYXJzIiwiUmVnRXhwIiwibWVyZ2UiLCJVTlJFU0VSVkVEJCQiLCJTT01FX0RFTElNUyQkIiwiQVRFWFQkJCIsIlZDSEFSJCQiLCJQQ1RfRU5DT0RFRCQiLCJRVEVYVCQkIiwic3ViZXhwIiwiSEVYRElHJCQiLCJpc0lSSSIsImRvbWFpbkhvc3QiLCJ3c0NvbXBvbmVudHMiLCJmcmFnbWVudCIsInJlc291cmNlTmFtZSIsInNlY3VyZSIsInBvcnQiLCJpc1NlY3VyZSIsImhvc3QiLCJ0b1N0cmluZyIsIlVSSV9QUk9UT0NPTCIsIklSSV9QUk9UT0NPTCIsIkVTQ0FQRSIsImVzY2FwZUNvbXBvbmVudCIsInVyaUEiLCJ1cmlCIiwidHlwZU9mIiwiZXF1YWwiLCJ1cmkiLCJub3JtYWxpemUiLCJyZXNvbHZlQ29tcG9uZW50cyIsImJhc2VVUkkiLCJzY2hlbWVsZXNzT3B0aW9ucyIsInJlbGF0aXZlVVJJIiwiYXNzaWduIiwicmVzb2x2ZSIsInRhcmdldCIsInJlbGF0aXZlIiwiYmFzZSIsInVzZXJpbmZvIiwicmVtb3ZlRG90U2VnbWVudHMiLCJjaGFyQXQiLCJza2lwTm9ybWFsaXphdGlvbiIsInVyaVRva2VucyIsInMiLCJhdXRob3JpdHkiLCJhYnNvbHV0ZVBhdGgiLCJyZWZlcmVuY2UiLCJfcmVjb21wb3NlQXV0aG9yaXR5IiwicHJvdG9jb2wiLCJJUFY2QUREUkVTUyIsInRlc3QiLCJvdXRwdXQiLCJFcnJvciIsImlucHV0IiwiaW0iLCJSRFM1IiwicG9wIiwiUkRTMyIsIlJEUzIiLCJSRFMxIiwiJDEiLCIkMiIsIl9ub3JtYWxpemVJUHY2IiwiX25vcm1hbGl6ZUlQdjQiLCJfIiwidXJpU3RyaW5nIiwiaXNOYU4iLCJpbmRleE9mIiwicGFyc2VJbnQiLCJOT19NQVRDSF9JU19VTkRFRklORUQiLCJVUklfUEFSU0UiLCJuZXdIb3N0Iiwiem9uZSIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsImxvbmdlc3RaZXJvRmllbGRzIiwiaW5kZXgiLCJiIiwiYSIsImFsbFplcm9GaWVsZHMiLCJzb3J0IiwiYWNjIiwibGFzdExvbmdlc3QiLCJmaWVsZCIsInJlZHVjZSIsImZpZWxkQ291bnQiLCJpc0xhc3RGaWVsZElQdjRBZGRyZXNzIiwiZmlyc3RGaWVsZHMiLCJsYXN0RmllbGRzIiwibGFzdEZpZWxkc1N0YXJ0IiwiQXJyYXkiLCJJUFY0QUREUkVTUyIsImxhc3QiLCJtYXAiLCJfc3RyaXBMZWFkaW5nWmVyb3MiLCJmaXJzdCIsImFkZHJlc3MiLCJyZXZlcnNlIiwiTk9UX0ZSQUdNRU5UIiwiTk9UX1FVRVJZIiwiTk9UX1BBVEgiLCJOT1RfUEFUSF9OT1NDSEVNRSIsIk5PVF9IT1NUIiwiTk9UX1VTRVJJTkZPIiwiTk9UX1NDSEVNRSIsIl9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyIsIm5ld1N0ciIsInN1YnN0ciIsImkiLCJmcm9tQ2hhckNvZGUiLCJjIiwiYzIiLCJjMyIsImlsIiwiY2hyIiwiY2hhckNvZGVBdCIsImVuY29kZSIsImRlY29kZSIsInVjczJlbmNvZGUiLCJ1Y3MyZGVjb2RlIiwicmVnZXhOb25BU0NJSSIsInN0cmluZyIsIm1hcERvbWFpbiIsInJlZ2V4UHVueWNvZGUiLCJuIiwiZGVsdGEiLCJoYW5kbGVkQ1BDb3VudCIsImFkYXB0IiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwiYmFzaWNMZW5ndGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJkaWdpdFRvQmFzaWMiLCJxIiwiZmxvb3IiLCJxTWludXNUIiwiYmFzZU1pbnVzVCIsInQiLCJrIiwiYmlhcyIsInRNaW4iLCJ0TWF4IiwiY3VycmVudFZhbHVlIiwibWF4SW50IiwibSIsImlucHV0TGVuZ3RoIiwiZGVsaW1pdGVyIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImZyb21Db2RlUG9pbnQiLCJzcGxpY2UiLCJvdXQiLCJvbGRpIiwidyIsImRpZ2l0IiwiYmFzaWNUb0RpZ2l0IiwiYmFzaWMiLCJqIiwiYmFzZU1pbnVzVE1pbiIsInNrZXciLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJkYW1wIiwiZmxhZyIsImNvZGVQb2ludCIsImFycmF5IiwidmFsdWUiLCJleHRyYSIsImNvdW50ZXIiLCJyZXN1bHQiLCJlbmNvZGVkIiwibGFiZWxzIiwiZm4iLCJyZWdleFNlcGFyYXRvcnMiLCJwYXJ0cyIsIlJhbmdlRXJyb3IiLCJlcnJvcnMiLCJ0eXBlIiwiTWF0aCIsImJ1aWxkRXhwcyIsIklQVjZBRERSRVNTJCIsIlpPTkVJRCQiLCJJUFY0QUREUkVTUyQiLCJSRVNFUlZFRCQkIiwiU1VCX0RFTElNUyQkIiwiSVBSSVZBVEUkJCIsIkFMUEhBJCQiLCJESUdJVCQkIiwiQVVUSE9SSVRZX1JFRiQiLCJVU0VSSU5GTyQiLCJIT1NUJCIsIlBPUlQkIiwiU0FNRURPQ19SRUYkIiwiRlJBR01FTlQkIiwiQUJTT0xVVEVfUkVGJCIsIlNDSEVNRSQiLCJQQVRIX0FCRU1QVFkkIiwiUEFUSF9BQlNPTFVURSQiLCJQQVRIX1JPT1RMRVNTJCIsIlBBVEhfRU1QVFkkIiwiUVVFUlkkIiwiUkVMQVRJVkVfUkVGJCIsIlBBVEhfTk9TQ0hFTUUkIiwiR0VORVJJQ19SRUYkIiwiQUJTT0xVVEVfVVJJJCIsIkhJRVJfUEFSVCQiLCJVUklfUkVGRVJFTkNFJCIsIlVSSSQiLCJSRUxBVElWRSQiLCJSRUxBVElWRV9QQVJUJCIsIkFVVEhPUklUWSQiLCJQQ0hBUiQiLCJQQVRIJCIsIlNFR01FTlRfTlokIiwiU0VHTUVOVF9OWl9OQyQiLCJTRUdNRU5UJCIsIklQX0xJVEVSQUwkIiwiUkVHX05BTUUkIiwiSVBWNkFERFJaX1JFTEFYRUQkIiwiSVBWRlVUVVJFJCIsIklQVjZBRERSRVNTMSQiLCJJUFY2QUREUkVTUzIkIiwiSVBWNkFERFJFU1MzJCIsIklQVjZBRERSRVNTNCQiLCJJUFY2QUREUkVTUzUkIiwiSVBWNkFERFJFU1M2JCIsIklQVjZBRERSRVNTNyQiLCJJUFY2QUREUkVTUzgkIiwiSVBWNkFERFJFU1M5JCIsIkgxNiQiLCJMUzMyJCIsIkRFQ19PQ1RFVF9SRUxBWEVEJCIsIkRFQ19PQ1RFVCQiLCJVQ1NDSEFSJCQiLCJHRU5fREVMSU1TJCQiLCJTUCQkIiwiRFFVT1RFJCQiLCJDUiQiLCJvYmoiLCJrZXkiLCJzb3VyY2UiLCJzZXRJbnRlcnZhbCIsImNhbGwiLCJwcm90b3R5cGUiLCJvIiwiT2JqZWN0Iiwic2hpZnQiLCJzZXRzIiwiX2EiXSwidmVyc2lvbiI6MywiZmlsZSI6ImluZGV4LmpzLm1hcCJ9
 globalThis.define=__define;  })(globalThis.define);