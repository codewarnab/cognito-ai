(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"cbTDl":[function(require,module,exports) {
var u = globalThis.process?.argv || [];
var h = ()=>globalThis.process?.env || {};
var B = new Set(u), _ = (e)=>B.has(e), G = u.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var U = _("--dry-run"), g = ()=>_("--verbose") || h().VERBOSE === "true", N = g();
var m = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var y = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), v = (...e)=>m("\uD83D\uDD35 INFO", ...e), f = (...e)=>m("\uD83D\uDFE0 WARN", ...e), M = 0, i = (...e)=>g() && m(`\u{1F7E1} ${M++}`, ...e);
var b = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime, t = ()=>setInterval(e.getPlatformInfo, 24e3);
    e.onStartup.addListener(t), t();
};
var n = {
    "isContentScript": false,
    "isBackground": true,
    "isReact": false,
    "runtimes": [
        "background-service-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "C:\\Users\\HP\\Downloads\\CHROME\\chrome-ai-1\\.plasmo\\static\\background\\index.ts",
    "bundleId": "c338908e704c91f1",
    "envHash": "d99a5ffa57acd638",
    "verbose": "false",
    "secure": false,
    "serverPort": 1012
};
module.bundle.HMR_BUNDLE_ID = n.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: n.verbose
    }
};
var D = module.bundle.Module;
function H(e) {
    D.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = H;
module.bundle.hotData = {};
var c = globalThis.browser || globalThis.chrome || null;
function R() {
    return !n.host || n.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : n.host;
}
function x() {
    return !n.host || n.host === "0.0.0.0" ? "localhost" : n.host;
}
function d() {
    return n.port || location.port;
}
var P = "__plasmo_runtime_page_", S = "__plasmo_runtime_script_";
var O = `${n.secure ? "https" : "http"}://${R()}:${d()}/`;
async function k(e = 1470) {
    for(;;)try {
        await fetch(O);
        break;
    } catch  {
        await new Promise((o)=>setTimeout(o, e));
    }
}
if (c.runtime.getManifest().manifest_version === 3) {
    let e = c.runtime.getURL("/__plasmo_hmr_proxy__?url=");
    globalThis.addEventListener("fetch", function(t) {
        let o = t.request.url;
        if (o.startsWith(e)) {
            let s = new URL(decodeURIComponent(o.slice(e.length)));
            s.hostname === n.host && s.port === `${n.port}` ? (s.searchParams.set("t", Date.now().toString()), t.respondWith(fetch(s).then((r)=>new Response(r.body, {
                    headers: {
                        "Content-Type": r.headers.get("Content-Type") ?? "text/javascript"
                    }
                })))) : t.respondWith(new Response("Plasmo HMR", {
                status: 200,
                statusText: "Testing"
            }));
        }
    });
}
function E(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function C(e = d()) {
    let t = x();
    return `${n.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function L(e) {
    typeof e.message == "string" && y("[plasmo/parcel-runtime]: " + e.message);
}
function T(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C(Number(d()) + 1));
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        await e(s);
    }), t.addEventListener("error", L), t;
}
function A(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C());
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        if (s.type === "update" && await e(s.assets), s.type === "error") for (let r of s.diagnostics.ansi){
            let l = r.codeframe || r.stack;
            f("[plasmo/parcel-runtime]: " + r.message + `
` + l + `

` + r.hints.join(`
`));
        }
    }), t.addEventListener("error", L), t.addEventListener("open", ()=>{
        v(`[plasmo/parcel-runtime]: Connected to HMR server for ${n.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        f(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${n.entryFilePath}`);
    }), t;
}
var w = module.bundle.parent, a = {
    buildReady: !1,
    bgChanged: !1,
    csChanged: !1,
    pageChanged: !1,
    scriptPorts: new Set,
    pagePorts: new Set
};
async function p(e = !1) {
    if (e || a.buildReady && a.pageChanged) {
        i("BGSW Runtime - reloading Page");
        for (let t of a.pagePorts)t.postMessage(null);
    }
    if (e || a.buildReady && (a.bgChanged || a.csChanged)) {
        i("BGSW Runtime - reloading CS");
        let t = await c?.tabs.query({
            active: !0
        });
        for (let o of a.scriptPorts){
            let s = t.some((r)=>r.id === o.sender.tab?.id);
            o.postMessage({
                __plasmo_cs_active_tab__: s
            });
        }
        c.runtime.reload();
    }
}
if (!w || !w.isParcelRequire) {
    b();
    let e = A(async (t)=>{
        i("BGSW Runtime - On HMR Update"), a.bgChanged ||= t.filter((s)=>s.envHash === n.envHash).some((s)=>E(module.bundle, s.id));
        let o = t.find((s)=>s.type === "json");
        if (o) {
            let s = new Set(t.map((l)=>l.id)), r = Object.values(o.depsByBundle).map((l)=>Object.values(l)).flat();
            a.bgChanged ||= r.every((l)=>s.has(l));
        }
        p();
    });
    e.addEventListener("open", ()=>{
        let t = setInterval(()=>e.send("ping"), 24e3);
        e.addEventListener("close", ()=>clearInterval(t));
    }), e.addEventListener("close", async ()=>{
        await k(), p(!0);
    });
}
T(async (e)=>{
    switch(i("BGSW Runtime - On Build Repackaged"), e.type){
        case "build_ready":
            a.buildReady ||= !0, p();
            break;
        case "cs_changed":
            a.csChanged ||= !0, p();
            break;
    }
});
c.runtime.onConnect.addListener(function(e) {
    let t = e.name.startsWith(P), o = e.name.startsWith(S);
    if (t || o) {
        let s = t ? a.pagePorts : a.scriptPorts;
        s.add(e), e.onDisconnect.addListener(()=>{
            s.delete(e);
        }), e.onMessage.addListener(function(r) {
            i("BGSW Runtime - On source changed", r), r.__plasmo_cs_changed__ && (a.csChanged ||= !0), r.__plasmo_page_changed__ && (a.pageChanged ||= !0), p();
        });
    }
});
c.runtime.onMessage.addListener(function(t) {
    return t.__plasmo_full_reload__ && (i("BGSW Runtime - On top-level code changed"), p()), !0;
});

},{}],"8oeFb":[function(require,module,exports) {
var _background = require("../../../src/background");

},{"../../../src/background":"kimL1"}],"kimL1":[function(require,module,exports) {
/**
 * MV3 Background Service Worker - Main Entry Point
 * 
 * Handles:
 * - Side panel initialization
 * - Extension lifecycle events
 * - Notion MCP OAuth and SSE connection
 */ var _indexJs = require("@modelcontextprotocol/sdk/client/index.js");
var _sseJs = require("@modelcontextprotocol/sdk/client/sse.js");
var _notionClient = require("./mcp/notionClient");
var _oauth = require("./mcp/oauth");
var _constants = require("./constants");
// ============================================================================
// Notion MCP State
// ============================================================================
let notionMcpClient = null;
let notionTokens = null;
let notionClientCredentials = null;
let oauthState = null;
let notionStatus = {
    state: "disconnected"
};
let isEnabled = false;
/**
 * Start OAuth flow for Notion MCP with dynamic client registration
 */ async function startNotionAuth() {
    try {
        console.log("[Background] Starting Notion OAuth flow with dynamic client registration");
        // Step 1: Register a dynamic client
        console.log("[Background] Registering dynamic client...");
        notionStatus = {
            state: "registering"
        };
        broadcastStatusUpdate();
        const clientCredentials = await (0, _oauth.registerDynamicClient)((0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI);
        // Store client credentials
        notionClientCredentials = clientCredentials;
        await (0, _oauth.storeClientCredentials)(clientCredentials);
        console.log("[Background] Dynamic client registered:", clientCredentials.client_id);
        // Step 2: Generate state for CSRF protection
        const state = (0, _oauth.generateState)();
        // Store state in memory for the callback
        oauthState = {
            state,
            codeVerifier: "",
            created_at: Date.now()
        };
        // Step 3: Build authorization URL using the dynamic client ID
        const authUrl = (0, _oauth.buildAuthUrl)(clientCredentials.client_id, (0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI, state);
        console.log("[Background] Launching OAuth with URL:", authUrl);
        // Update status
        notionStatus = {
            state: "authorizing"
        };
        broadcastStatusUpdate();
        // Step 4: Launch OAuth flow using Chrome Identity API
        const redirectUrl = await chrome.identity.launchWebAuthFlow({
            url: authUrl,
            interactive: true
        });
        if (!redirectUrl) throw new Error("OAuth flow cancelled");
        console.log("[Background] OAuth redirect URL:", redirectUrl);
        // Step 5: Extract code and state from redirect URL
        const url = new URL(redirectUrl);
        const code = url.searchParams.get("code");
        const returnedState = url.searchParams.get("state");
        if (!code) throw new Error("No authorization code received");
        // Verify state
        if (!oauthState || returnedState !== oauthState.state) throw new Error("State mismatch - possible CSRF attack");
        console.log("[Background] Exchanging code for tokens");
        // Step 6: Exchange code for tokens using dynamic client credentials
        const tokens = await (0, _oauth.exchangeCodeForTokens)(code, clientCredentials.client_id, clientCredentials.client_secret, (0, _constants.NOTION_CONFIG).OAUTH_REDIRECT_URI);
        // Store tokens
        notionTokens = tokens;
        await (0, _oauth.storeTokens)(tokens);
        console.log("[Background] Tokens stored successfully");
        // Update status
        notionStatus = {
            state: "authenticated"
        };
        broadcastStatusUpdate();
        console.log("[Background] Notion MCP OAuth successful");
        return {
            success: true,
            data: {
                state: "authenticated"
            }
        };
    } catch (error) {
        console.error("[Background] Notion MCP OAuth error:", error);
        notionStatus = {
            state: "error",
            error: error instanceof Error ? error.message : "Authentication failed"
        };
        broadcastStatusUpdate();
        return {
            success: false,
            error: error instanceof Error ? error.message : "Authentication failed"
        };
    } finally{
        oauthState = null;
    }
}
/**
 * Refresh Notion access token
 */ async function refreshNotionToken() {
    if (!notionTokens?.refresh_token) {
        console.error("[Background] No refresh token available");
        notionStatus = {
            state: "needs-auth",
            error: "No refresh token"
        };
        broadcastStatusUpdate();
        return false;
    }
    // Load client credentials if not in memory
    if (!notionClientCredentials) notionClientCredentials = await (0, _oauth.getStoredClientCredentials)();
    if (!notionClientCredentials) {
        console.error("[Background] No client credentials available for token refresh");
        notionStatus = {
            state: "needs-auth",
            error: "No client credentials"
        };
        broadcastStatusUpdate();
        return false;
    }
    try {
        console.log("[Background] Refreshing Notion token");
        notionStatus = {
            state: "token-refresh"
        };
        broadcastStatusUpdate();
        const newTokens = await (0, _oauth.refreshAccessToken)(notionTokens.refresh_token, notionClientCredentials.client_id, notionClientCredentials.client_secret);
        notionTokens = newTokens;
        await (0, _oauth.storeTokens)(newTokens);
        notionStatus = {
            state: "authenticated"
        };
        broadcastStatusUpdate();
        console.log("[Background] Token refreshed successfully");
        return true;
    } catch (error) {
        console.error("[Background] Token refresh failed:", error);
        // Clear invalid tokens
        await (0, _oauth.clearTokens)();
        notionTokens = null;
        notionStatus = {
            state: "needs-auth",
            error: "Token refresh failed. Please re-authenticate."
        };
        broadcastStatusUpdate();
        return false;
    }
}
/**
 * Ensure we have a valid access token
 */ async function ensureValidToken() {
    if (!notionTokens) // Try to load from storage
    notionTokens = await (0, _oauth.getStoredTokens)();
    if (!notionTokens) return null;
    (0, _oauth.isTokenExpired)(notionTokens);
    return notionTokens.access_token;
}
// ============================================================================
// Notion MCP Connection Functions
// ============================================================================
/**
 * Connect to Notion MCP server
 */ async function connectNotionMcp() {
    try {
        console.log("[Background] Connecting to Notion MCP");
        const accessToken = await ensureValidToken();
        if (!accessToken) return {
            success: false,
            error: "Authentication required"
        };
        // Create SSE client
        notionMcpClient = new (0, _notionClient.McpSSEClient)((0, _constants.NOTION_CONFIG).MCP_SSE_URL, accessToken, {
            onStatusChange: (status)=>{
                notionStatus = status;
                broadcastStatusUpdate();
                // Handle token expiry (but not format errors)
                if (status.state === "needs-auth") ;
                else status.state;
            },
            onMessage: (message)=>{
                console.log("[Background] MCP message:", message);
            }
        });
        // Connect
        await notionMcpClient.connect();
        // Initialize MCP protocol
        await notionMcpClient.initialize();
        return {
            success: true,
            data: notionMcpClient.getStatus()
        };
    } catch (error) {
        console.error("[Background] Notion MCP connection error:", error);
        return {
            success: false,
            error: error instanceof Error ? error.message : "Connection failed"
        };
    }
}
/**
 * Disconnect from Notion MCP server
 */ function disconnectNotionMcp() {
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    notionStatus = {
        state: "authenticated"
    };
    broadcastStatusUpdate();
}
/**
 * Handle token expiry - attempt refresh and reconnect
 */ async function handleTokenExpiry() {
    console.log("[Background] Handling token expiry");
    // Disconnect current client
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    // Try to refresh
    const refreshed = await refreshNotionToken();
    // If enabled and refresh succeeded, reconnect
    if (refreshed && isEnabled) await connectNotionMcp();
}
/**
 * Handle invalid token format - clear tokens and require re-auth
 */ async function handleInvalidToken() {
    console.log("[Background] Handling invalid token format");
    // Disconnect current client
    if (notionMcpClient) {
        notionMcpClient.disconnect();
        notionMcpClient = null;
    }
    // Clear invalid tokens and client credentials - don't try to refresh
    await (0, _oauth.clearTokens)();
    await (0, _oauth.clearClientCredentials)();
    notionTokens = null;
    notionClientCredentials = null;
    notionStatus = {
        state: "invalid-token",
        error: "Invalid token format - please re-authenticate"
    };
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    broadcastStatusUpdate();
}
/**
 * Enable Notion MCP (connect if authenticated)
 */ async function enableNotionMcp() {
    isEnabled = true;
    // Store enabled state
    await chrome.storage.local.set({
        "mcp.notion.enabled": true
    });
    // If already connected, perform health check
    if (notionMcpClient && notionStatus.state === "connected") {
        console.log("[Background] Already connected, performing health check");
        const healthCheck = await performHealthCheck();
        if (healthCheck.success) return {
            success: true,
            data: notionStatus
        };
        else {
            console.warn("[Background] Health check failed, reconnecting...", healthCheck.error);
            // Health check failed, try to reconnect
            disconnectNotionMcp();
        }
    }
    // If authenticated, connect
    if (notionTokens || await (0, _oauth.getStoredTokens)()) {
        const connectResult = await connectNotionMcp();
        // If connection successful, perform health check
        if (connectResult.success && notionMcpClient) {
            console.log("[Background] Connection successful, performing health check");
            const healthCheck = await performHealthCheck();
            if (!healthCheck.success) {
                console.warn("[Background] Health check failed after connection:", healthCheck.error);
                notionStatus = {
                    ...notionStatus,
                    error: `Connected but health check failed: ${healthCheck.error}`
                };
                broadcastStatusUpdate();
            } else console.log("[Background] Health check passed:", healthCheck.data);
        }
        return connectResult;
    }
    // Otherwise, need auth
    return {
        success: false,
        error: "Authentication required. Please connect first."
    };
}
/**
 * Disable Notion MCP (disconnect)
 */ async function disableNotionMcp() {
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    disconnectNotionMcp();
    return {
        success: true
    };
}
/**
 * Disconnect and clear authentication
 */ async function disconnectNotionAuth() {
    disconnectNotionMcp();
    await (0, _oauth.clearTokens)();
    await (0, _oauth.clearClientCredentials)();
    notionTokens = null;
    notionClientCredentials = null;
    notionStatus = {
        state: "disconnected"
    };
    isEnabled = false;
    await chrome.storage.local.set({
        "mcp.notion.enabled": false
    });
    broadcastStatusUpdate();
    return {
        success: true
    };
}
/**
 * Get current Notion MCP status
 */ function getNotionStatus() {
    return notionStatus;
}
/**
 * Perform health check on Notion MCP connection using official MCP SDK
 * Validates connection and retrieves available tools
 * Similar to: https://modelcontextprotocol.io/docs/tools/clients
 */ async function performHealthCheck() {
    let client = undefined;
    try {
        console.log("[Background] Performing Notion MCP health check with SDK");
        // Get access token
        const accessToken = await ensureValidToken();
        if (!accessToken) return {
            success: false,
            error: "No valid access token available"
        };
        const url = new URL((0, _constants.NOTION_CONFIG).MCP_SSE_URL);
        try {
            // Create MCP client
            client = new (0, _indexJs.Client)({
                name: "chrome-ai-health-check",
                version: "1.0.0"
            }, {
                capabilities: {
                    roots: {
                        listChanged: true
                    }
                }
            });
            console.log("[Background] Connecting to MCP server with SSE transport...");
            // Create SSE transport with authorization
            // Use requestInit to add Authorization header to POST requests
            const transport = new (0, _sseJs.SSEClientTransport)(url, {
                requestInit: {
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Accept": "application/json, text/event-stream"
                    }
                },
                // Use custom fetch to add Authorization header to SSE connection
                fetch: async (input, init)=>{
                    const headers = new Headers(init?.headers);
                    headers.set("Authorization", `Bearer ${accessToken}`);
                    headers.set("Accept", "text/event-stream, application/json");
                    return fetch(input, {
                        ...init,
                        headers
                    });
                }
            });
            // Connect to the server
            await client.connect(transport);
            console.log("[Background] Connected using SSE transport");
            // Get tools from the connected client
            const toolsResponse = await client.listTools();
            console.log("[Background] Tools response:", toolsResponse);
            // Disconnect after getting tools
            await client.close();
            if (toolsResponse && toolsResponse.tools) {
                const toolCount = toolsResponse.tools.length;
                console.log("[Background] Health check passed. Tools available:", toolCount);
                return {
                    success: true,
                    data: {
                        state: "connected",
                        tools: toolsResponse.tools.map((tool)=>({
                                name: tool.name,
                                description: tool.description,
                                inputSchema: tool.inputSchema
                            })),
                        toolCount: toolCount
                    }
                };
            } else return {
                success: false,
                error: "No tools available from server"
            };
        } catch (transportError) {
            console.error("[Background] Health check failed:", transportError);
            // Clean up client if exists
            if (client) try {
                await client.close();
            } catch (closeError) {
                console.error("[Background] Error closing client:", closeError);
            }
            return {
                success: false,
                error: transportError instanceof Error ? transportError.message : "Connection failed"
            };
        }
    } catch (error) {
        console.error("[Background] Health check error:", error);
        // Clean up client if exists
        if (client) try {
            await client.close();
        } catch (closeError) {
            console.error("[Background] Error closing client:", closeError);
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : "Health check failed"
        };
    }
}
/**
 * Call a Notion MCP tool
 */ async function callNotionTool(name, args) {
    if (!notionMcpClient) return {
        success: false,
        error: "Not connected"
    };
    try {
        const result = await notionMcpClient.callTool(name, args);
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error("[Background] Tool call error:", error);
        return {
            success: false,
            error: error instanceof Error ? error.message : "Tool call failed"
        };
    }
}
/**
 * Broadcast status update to all listeners
 */ function broadcastStatusUpdate() {
    chrome.runtime.sendMessage({
        type: "mcp/notion/status/update",
        payload: notionStatus
    }).catch(()=>{
    // Ignore errors if no listeners
    });
}
// ============================================================================
// Message Handler
// ============================================================================
chrome.runtime.onMessage.addListener((message, sender, sendResponse)=>{
    // Handle Notion MCP messages
    if (message.type?.startsWith("mcp/notion/")) {
        (async ()=>{
            let response;
            switch(message.type){
                case "mcp/notion/auth/start":
                    response = await startNotionAuth();
                    break;
                case "mcp/notion/enable":
                    response = await enableNotionMcp();
                    break;
                case "mcp/notion/disable":
                    response = await disableNotionMcp();
                    break;
                case "mcp/notion/disconnect":
                    response = await disconnectNotionAuth();
                    break;
                case "mcp/notion/status/get":
                    response = {
                        success: true,
                        data: getNotionStatus()
                    };
                    break;
                case "mcp/notion/tool/call":
                    response = await callNotionTool(message.payload?.name, message.payload?.arguments);
                    break;
                case "mcp/notion/health/check":
                    response = await performHealthCheck();
                    break;
                default:
                    response = {
                        success: false,
                        error: "Unknown message type"
                    };
            }
            sendResponse(response);
        })();
        return true; // Will respond asynchronously
    }
});
// ============================================================================
// Runtime Listeners
// ============================================================================
// Global notification click handler for reminders
chrome.notifications.onClicked.addListener(async (notificationId)=>{
    try {
        if (!notificationId.startsWith("reminder:")) return;
        const id = notificationId.split(":")[1];
        const { reminders = {} } = await chrome.storage.local.get("reminders");
        const reminder = reminders[id];
        if (reminder?.url) await chrome.tabs.create({
            url: reminder.url
        });
        // Cleanup: remove reminder and clear notification
        if (reminders[id]) {
            delete reminders[id];
            await chrome.storage.local.set({
                reminders
            });
        }
        chrome.notifications.clear(notificationId);
    } catch (error) {
        console.error("[Background] Error handling notification click:", error);
    }
});
/**
 * Extension install/update handler
 */ chrome.runtime.onInstalled.addListener(async (details)=>{
    console.log("[Background] onInstalled:", details.reason);
    try {
        // Enable side panel on all existing tabs
        if (chrome.sidePanel) chrome.sidePanel.setPanelBehavior({
            openPanelOnActionClick: true
        }).catch(console.error);
        // Load saved state
        const stored = await chrome.storage.local.get([
            "mcp.notion.enabled"
        ]);
        isEnabled = stored["mcp.notion.enabled"] || false;
        // If enabled, try to restore connection
        if (isEnabled) {
            const tokens = await (0, _oauth.getStoredTokens)();
            const credentials = await (0, _oauth.getStoredClientCredentials)();
            if (tokens && credentials) {
                notionTokens = tokens;
                notionClientCredentials = credentials;
                await connectNotionMcp();
            }
        }
        console.log("[Background] Side panel configured");
    } catch (error) {
        console.error("[Background] onInstalled error:", error);
    }
});
/**
 * Extension startup handler
 */ chrome.runtime.onStartup.addListener(async ()=>{
    console.log("[Background] onStartup - Extension ready");
    // Load saved state
    const stored = await chrome.storage.local.get([
        "mcp.notion.enabled"
    ]);
    isEnabled = stored["mcp.notion.enabled"] || false;
    // If enabled, try to restore connection
    if (isEnabled) {
        const tokens = await (0, _oauth.getStoredTokens)();
        const credentials = await (0, _oauth.getStoredClientCredentials)();
        if (tokens && credentials) {
            notionTokens = tokens;
            notionClientCredentials = credentials;
            await connectNotionMcp();
        }
    }
});
/**
 * Action click handler - open side panel
 */ if (chrome.action) chrome.action.onClicked.addListener(async (tab)=>{
    if (chrome.sidePanel && tab.id) try {
        await chrome.sidePanel.open({
            tabId: tab.id
        });
    } catch (error) {
        console.error("[Background] Error opening side panel:", error);
    }
});
// Create cleanup alarm (runs every hour)
chrome.alarms.create("cleanup-expired-sessions", {
    periodInMinutes: 60
});
/**
 * Handle reminder alarms - show notification when reminder fires
 */ chrome.alarms.onAlarm.addListener(async (alarm)=>{
    // Only handle reminder alarms
    if (!alarm.name.startsWith("reminder:")) return;
    const id = alarm.name.split(":")[1];
    console.log("[Background] Reminder alarm fired:", id);
    try {
        // Get the reminder from storage
        const { reminders = {} } = await chrome.storage.local.get("reminders");
        const reminder = reminders[id];
        if (!reminder) {
            console.warn("[Background] Reminder not found:", id);
            return;
        }
        // Create notification with AI-generated content or fallback to original title
        const simpleIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==";
        const notificationTitle = reminder.generatedTitle || "\u23f0 Reminder";
        const notificationMessage = reminder.generatedDescription || reminder.title;
        // Use a namespaced notification ID to distinguish reminders
        chrome.notifications.create(`reminder:${id}`, {
            type: "basic",
            iconUrl: simpleIcon,
            title: notificationTitle,
            message: notificationMessage,
            priority: 2,
            requireInteraction: false
        });
        console.log("[Background] Reminder notification created:", {
            title: notificationTitle,
            message: notificationMessage
        });
    // Do not remove the reminder here; it will be removed by the global
    // notification click handler to avoid race conditions and ensure the
    // click handler has access to the stored reminder data.
    } catch (error) {
        console.error("[Background] Error handling reminder alarm:", error);
    }
});
// ============================================================================
// Initialization
// ============================================================================
console.log("[Background] Service worker loaded - CopilotKit powered extension ready");
console.log("[Background] Browser actions event listeners initialized");
// ============================================================================
// Offscreen Document: Summarizer Broker
// ============================================================================
// Ensure a single offscreen document exists
async function ensureOffscreenDocument() {
    try {
        // Chrome 116+ has chrome.offscreen.hasDocument
        // Fallback: try creating and ignore if already exists
        const hasDoc = typeof chrome.offscreen?.hasDocument === "function" ? await chrome.offscreen.hasDocument() : false;
        if (!hasDoc) {
            await chrome.offscreen.createDocument({
                url: "offscreen.html",
                // Using IFRAME_SCRIPTING is appropriate for running DOM APIs & scripts
                reasons: [
                    chrome.offscreen.Reason.IFRAME_SCRIPTING
                ],
                justification: "Run Chrome Summarizer API in an isolated offscreen document"
            });
            console.log("[Background] Offscreen document created");
        }
    } catch (error) {
        // Some Chrome versions throw if a document already exists
        console.warn("[Background] ensureOffscreenDocument warning:", error);
    }
}
// Wire summarize messages coming from UI to the offscreen document
chrome.runtime.onMessage.addListener((message, _sender, sendResponse)=>{
    if (message?.type === "summarize:availability") {
        (async ()=>{
            await ensureOffscreenDocument();
            try {
                const res = await chrome.runtime.sendMessage({
                    type: "offscreen/summarize/availability"
                });
                sendResponse(res);
            } catch (error) {
                sendResponse({
                    ok: false,
                    code: "error",
                    message: error instanceof Error ? error.message : "unknown"
                });
            }
        })();
        return true;
    }
    if (message?.type === "summarize:request") {
        (async ()=>{
            const msg = message;
            await ensureOffscreenDocument();
            try {
                const res = await chrome.runtime.sendMessage({
                    type: "offscreen/summarize/request",
                    payload: msg.payload
                });
                sendResponse(res);
            } catch (error) {
                sendResponse({
                    ok: false,
                    code: "error",
                    message: error instanceof Error ? error.message : "unknown"
                });
            }
        })();
        return true;
    }
});

},{"@modelcontextprotocol/sdk/client/index.js":"em2GV","@modelcontextprotocol/sdk/client/sse.js":"630Jy","./mcp/notionClient":"apA8I","./mcp/oauth":"bEC4Y","./constants":"aZX5f"}],"em2GV":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Client = void 0;
const protocol_js_1 = require("31457f837fb41349");
const types_js_1 = require("42936a4e62889fac");
const ajv_1 = __importDefault(require("88c9732a6748db7e"));
/**
 * An MCP client on top of a pluggable transport.
 *
 * The client will automatically begin the initialization flow with the server when connect() is called.
 *
 * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
 *
 * ```typescript
 * // Custom schemas
 * const CustomRequestSchema = RequestSchema.extend({...})
 * const CustomNotificationSchema = NotificationSchema.extend({...})
 * const CustomResultSchema = ResultSchema.extend({...})
 *
 * // Type aliases
 * type CustomRequest = z.infer<typeof CustomRequestSchema>
 * type CustomNotification = z.infer<typeof CustomNotificationSchema>
 * type CustomResult = z.infer<typeof CustomResultSchema>
 *
 * // Create typed client
 * const client = new Client<CustomRequest, CustomNotification, CustomResult>({
 *   name: "CustomClient",
 *   version: "1.0.0"
 * })
 * ```
 */ class Client extends protocol_js_1.Protocol {
    /**
     * Initializes this client with the given name and version information.
     */ constructor(_clientInfo, options){
        var _a;
        super(options);
        this._clientInfo = _clientInfo;
        this._cachedToolOutputValidators = new Map();
        this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
        this._ajv = new ajv_1.default();
    }
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */ registerCapabilities(capabilities) {
        if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
        this._capabilities = (0, protocol_js_1.mergeCapabilities)(this._capabilities, capabilities);
    }
    assertCapability(capability, method) {
        var _a;
        if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
    async connect(transport, options) {
        await super.connect(transport);
        // When transport sessionId is already set this means we are trying to reconnect.
        // In this case we don't need to initialize again.
        if (transport.sessionId !== undefined) return;
        try {
            const result = await this.request({
                method: "initialize",
                params: {
                    protocolVersion: types_js_1.LATEST_PROTOCOL_VERSION,
                    capabilities: this._capabilities,
                    clientInfo: this._clientInfo
                }
            }, types_js_1.InitializeResultSchema, options);
            if (result === undefined) throw new Error(`Server sent invalid initialize result: ${result}`);
            if (!types_js_1.SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
            this._serverCapabilities = result.capabilities;
            this._serverVersion = result.serverInfo;
            // HTTP transports must set the protocol version in each header after initialization.
            if (transport.setProtocolVersion) transport.setProtocolVersion(result.protocolVersion);
            this._instructions = result.instructions;
            await this.notification({
                method: "notifications/initialized"
            });
        } catch (error) {
            this.close();
            throw error;
        }
    }
    /**
     * After initialization has completed, this will be populated with the server's reported capabilities.
     */ getServerCapabilities() {
        return this._serverCapabilities;
    }
    /**
     * After initialization has completed, this will be populated with information about the server's name and version.
     */ getServerVersion() {
        return this._serverVersion;
    }
    /**
     * After initialization has completed, this may be populated with information about the server's instructions.
     */ getInstructions() {
        return this._instructions;
    }
    assertCapabilityForMethod(method) {
        var _a, _b, _c, _d, _e;
        switch(method){
            case "logging/setLevel":
                if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) throw new Error(`Server does not support logging (required for ${method})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) throw new Error(`Server does not support prompts (required for ${method})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
            case "resources/subscribe":
            case "resources/unsubscribe":
                if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) throw new Error(`Server does not support resources (required for ${method})`);
                if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) throw new Error(`Server does not support resource subscriptions (required for ${method})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) throw new Error(`Server does not support tools (required for ${method})`);
                break;
            case "completion/complete":
                if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) throw new Error(`Server does not support completions (required for ${method})`);
                break;
            case "initialize":
                break;
            case "ping":
                break;
        }
    }
    assertNotificationCapability(method) {
        var _a;
        switch(method){
            case "notifications/roots/list_changed":
                if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
                break;
            case "notifications/initialized":
                break;
            case "notifications/cancelled":
                break;
            case "notifications/progress":
                break;
        }
    }
    assertRequestHandlerCapability(method) {
        switch(method){
            case "sampling/createMessage":
                if (!this._capabilities.sampling) throw new Error(`Client does not support sampling capability (required for ${method})`);
                break;
            case "elicitation/create":
                if (!this._capabilities.elicitation) throw new Error(`Client does not support elicitation capability (required for ${method})`);
                break;
            case "roots/list":
                if (!this._capabilities.roots) throw new Error(`Client does not support roots capability (required for ${method})`);
                break;
            case "ping":
                break;
        }
    }
    async ping(options) {
        return this.request({
            method: "ping"
        }, types_js_1.EmptyResultSchema, options);
    }
    async complete(params, options) {
        return this.request({
            method: "completion/complete",
            params
        }, types_js_1.CompleteResultSchema, options);
    }
    async setLoggingLevel(level, options) {
        return this.request({
            method: "logging/setLevel",
            params: {
                level
            }
        }, types_js_1.EmptyResultSchema, options);
    }
    async getPrompt(params, options) {
        return this.request({
            method: "prompts/get",
            params
        }, types_js_1.GetPromptResultSchema, options);
    }
    async listPrompts(params, options) {
        return this.request({
            method: "prompts/list",
            params
        }, types_js_1.ListPromptsResultSchema, options);
    }
    async listResources(params, options) {
        return this.request({
            method: "resources/list",
            params
        }, types_js_1.ListResourcesResultSchema, options);
    }
    async listResourceTemplates(params, options) {
        return this.request({
            method: "resources/templates/list",
            params
        }, types_js_1.ListResourceTemplatesResultSchema, options);
    }
    async readResource(params, options) {
        return this.request({
            method: "resources/read",
            params
        }, types_js_1.ReadResourceResultSchema, options);
    }
    async subscribeResource(params, options) {
        return this.request({
            method: "resources/subscribe",
            params
        }, types_js_1.EmptyResultSchema, options);
    }
    async unsubscribeResource(params, options) {
        return this.request({
            method: "resources/unsubscribe",
            params
        }, types_js_1.EmptyResultSchema, options);
    }
    async callTool(params, resultSchema = types_js_1.CallToolResultSchema, options) {
        const result = await this.request({
            method: "tools/call",
            params
        }, resultSchema, options);
        // Check if the tool has an outputSchema
        const validator = this.getToolOutputValidator(params.name);
        if (validator) {
            // If tool has outputSchema, it MUST return structuredContent (unless it's an error)
            if (!result.structuredContent && !result.isError) throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
            // Only validate structured content if present (not when there's an error)
            if (result.structuredContent) try {
                // Validate the structured content (which is already an object) against the schema
                const isValid = validator(result.structuredContent);
                if (!isValid) throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`);
            } catch (error) {
                if (error instanceof types_js_1.McpError) throw error;
                throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        return result;
    }
    cacheToolOutputSchemas(tools) {
        this._cachedToolOutputValidators.clear();
        for (const tool of tools){
            // If the tool has an outputSchema, create and cache the Ajv validator
            if (tool.outputSchema) try {
                const validator = this._ajv.compile(tool.outputSchema);
                this._cachedToolOutputValidators.set(tool.name, validator);
            } catch (_a) {
            // Ignore schema compilation errors
            }
        }
    }
    getToolOutputValidator(toolName) {
        return this._cachedToolOutputValidators.get(toolName);
    }
    async listTools(params, options) {
        const result = await this.request({
            method: "tools/list",
            params
        }, types_js_1.ListToolsResultSchema, options);
        // Cache the tools and their output schemas for future validation
        this.cacheToolOutputSchemas(result.tools);
        return result;
    }
    async sendRootsListChanged() {
        return this.notification({
            method: "notifications/roots/list_changed"
        });
    }
}
exports.Client = Client;

},{"31457f837fb41349":"c36uq","42936a4e62889fac":"cqTxf","88c9732a6748db7e":"fIIXC"}],"c36uq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Protocol = exports.DEFAULT_REQUEST_TIMEOUT_MSEC = void 0;
exports.mergeCapabilities = mergeCapabilities;
const types_js_1 = require("d2c272aeee3e37dc");
/**
 * The default request timeout, in miliseconds.
 */ exports.DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
/**
 * Implements MCP protocol framing on top of a pluggable transport, including
 * features like request/response linking, notifications, and progress.
 */ class Protocol {
    constructor(_options){
        this._options = _options;
        this._requestMessageId = 0;
        this._requestHandlers = new Map();
        this._requestHandlerAbortControllers = new Map();
        this._notificationHandlers = new Map();
        this._responseHandlers = new Map();
        this._progressHandlers = new Map();
        this._timeoutInfo = new Map();
        this._pendingDebouncedNotifications = new Set();
        this.setNotificationHandler(types_js_1.CancelledNotificationSchema, (notification)=>{
            const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
            controller === null || controller === void 0 || controller.abort(notification.params.reason);
        });
        this.setNotificationHandler(types_js_1.ProgressNotificationSchema, (notification)=>{
            this._onprogress(notification);
        });
        this.setRequestHandler(types_js_1.PingRequestSchema, // Automatic pong by default.
        (_request)=>({}));
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
        this._timeoutInfo.set(messageId, {
            timeoutId: setTimeout(onTimeout, timeout),
            startTime: Date.now(),
            timeout,
            maxTotalTimeout,
            resetTimeoutOnProgress,
            onTimeout
        });
    }
    _resetTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (!info) return false;
        const totalElapsed = Date.now() - info.startTime;
        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
            this._timeoutInfo.delete(messageId);
            throw new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
                maxTotalTimeout: info.maxTotalTimeout,
                totalElapsed
            });
        }
        clearTimeout(info.timeoutId);
        info.timeoutId = setTimeout(info.onTimeout, info.timeout);
        return true;
    }
    _cleanupTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (info) {
            clearTimeout(info.timeoutId);
            this._timeoutInfo.delete(messageId);
        }
    }
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */ async connect(transport) {
        var _a, _b, _c;
        this._transport = transport;
        const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
        this._transport.onclose = ()=>{
            _onclose === null || _onclose === void 0 || _onclose();
            this._onclose();
        };
        const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
        this._transport.onerror = (error)=>{
            _onerror === null || _onerror === void 0 || _onerror(error);
            this._onerror(error);
        };
        const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
        this._transport.onmessage = (message, extra)=>{
            _onmessage === null || _onmessage === void 0 || _onmessage(message, extra);
            if ((0, types_js_1.isJSONRPCResponse)(message) || (0, types_js_1.isJSONRPCError)(message)) this._onresponse(message);
            else if ((0, types_js_1.isJSONRPCRequest)(message)) this._onrequest(message, extra);
            else if ((0, types_js_1.isJSONRPCNotification)(message)) this._onnotification(message);
            else this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
        };
        await this._transport.start();
    }
    _onclose() {
        var _a;
        const responseHandlers = this._responseHandlers;
        this._responseHandlers = new Map();
        this._progressHandlers.clear();
        this._pendingDebouncedNotifications.clear();
        this._transport = undefined;
        (_a = this.onclose) === null || _a === void 0 || _a.call(this);
        const error = new types_js_1.McpError(types_js_1.ErrorCode.ConnectionClosed, "Connection closed");
        for (const handler of responseHandlers.values())handler(error);
    }
    _onerror(error) {
        var _a;
        (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
    }
    _onnotification(notification) {
        var _a;
        const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
        // Ignore notifications not being subscribed to.
        if (handler === undefined) return;
        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.
        Promise.resolve().then(()=>handler(notification)).catch((error)=>this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
        var _a, _b;
        const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
        // Capture the current transport at request time to ensure responses go to the correct client
        const capturedTransport = this._transport;
        if (handler === undefined) {
            capturedTransport === null || capturedTransport === void 0 || capturedTransport.send({
                jsonrpc: "2.0",
                id: request.id,
                error: {
                    code: types_js_1.ErrorCode.MethodNotFound,
                    message: "Method not found"
                }
            }).catch((error)=>this._onerror(new Error(`Failed to send an error response: ${error}`)));
            return;
        }
        const abortController = new AbortController();
        this._requestHandlerAbortControllers.set(request.id, abortController);
        const fullExtra = {
            signal: abortController.signal,
            sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
            _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
            sendNotification: (notification)=>this.notification(notification, {
                    relatedRequestId: request.id
                }),
            sendRequest: (r, resultSchema, options)=>this.request(r, resultSchema, {
                    ...options,
                    relatedRequestId: request.id
                }),
            authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
            requestId: request.id,
            requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
        };
        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.
        Promise.resolve().then(()=>handler(request, fullExtra)).then((result)=>{
            if (abortController.signal.aborted) return;
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                result,
                jsonrpc: "2.0",
                id: request.id
            });
        }, (error)=>{
            var _a;
            if (abortController.signal.aborted) return;
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                jsonrpc: "2.0",
                id: request.id,
                error: {
                    code: Number.isSafeInteger(error["code"]) ? error["code"] : types_js_1.ErrorCode.InternalError,
                    message: (_a = error.message) !== null && _a !== void 0 ? _a : "Internal error"
                }
            });
        }).catch((error)=>this._onerror(new Error(`Failed to send response: ${error}`))).finally(()=>{
            this._requestHandlerAbortControllers.delete(request.id);
        });
    }
    _onprogress(notification) {
        const { progressToken, ...params } = notification.params;
        const messageId = Number(progressToken);
        const handler = this._progressHandlers.get(messageId);
        if (!handler) {
            this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
            return;
        }
        const responseHandler = this._responseHandlers.get(messageId);
        const timeoutInfo = this._timeoutInfo.get(messageId);
        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) try {
            this._resetTimeout(messageId);
        } catch (error) {
            responseHandler(error);
            return;
        }
        handler(params);
    }
    _onresponse(response) {
        const messageId = Number(response.id);
        const handler = this._responseHandlers.get(messageId);
        if (handler === undefined) {
            this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
            return;
        }
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        if ((0, types_js_1.isJSONRPCResponse)(response)) handler(response);
        else {
            const error = new types_js_1.McpError(response.error.code, response.error.message, response.error.data);
            handler(error);
        }
    }
    get transport() {
        return this._transport;
    }
    /**
     * Closes the connection.
     */ async close() {
        var _a;
        await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
    }
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */ request(request, resultSchema, options) {
        const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
        return new Promise((resolve, reject)=>{
            var _a, _b, _c, _d, _e, _f;
            if (!this._transport) {
                reject(new Error("Not connected"));
                return;
            }
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) this.assertCapabilityForMethod(request.method);
            (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 || _b.throwIfAborted();
            const messageId = this._requestMessageId++;
            const jsonrpcRequest = {
                ...request,
                jsonrpc: "2.0",
                id: messageId
            };
            if (options === null || options === void 0 ? void 0 : options.onprogress) {
                this._progressHandlers.set(messageId, options.onprogress);
                jsonrpcRequest.params = {
                    ...request.params,
                    _meta: {
                        ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
                        progressToken: messageId
                    }
                };
            }
            const cancel = (reason)=>{
                var _a;
                this._responseHandlers.delete(messageId);
                this._progressHandlers.delete(messageId);
                this._cleanupTimeout(messageId);
                (_a = this._transport) === null || _a === void 0 || _a.send({
                    jsonrpc: "2.0",
                    method: "notifications/cancelled",
                    params: {
                        requestId: messageId,
                        reason: String(reason)
                    }
                }, {
                    relatedRequestId,
                    resumptionToken,
                    onresumptiontoken
                }).catch((error)=>this._onerror(new Error(`Failed to send cancellation: ${error}`)));
                reject(reason);
            };
            this._responseHandlers.set(messageId, (response)=>{
                var _a;
                if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) return;
                if (response instanceof Error) return reject(response);
                try {
                    const result = resultSchema.parse(response.result);
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            });
            (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 || _d.addEventListener("abort", ()=>{
                var _a;
                cancel((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.reason);
            });
            const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : exports.DEFAULT_REQUEST_TIMEOUT_MSEC;
            const timeoutHandler = ()=>cancel(new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Request timed out", {
                    timeout
                }));
            this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
            this._transport.send(jsonrpcRequest, {
                relatedRequestId,
                resumptionToken,
                onresumptiontoken
            }).catch((error)=>{
                this._cleanupTimeout(messageId);
                reject(error);
            });
        });
    }
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */ async notification(notification, options) {
        var _a, _b;
        if (!this._transport) throw new Error("Not connected");
        this.assertNotificationCapability(notification.method);
        const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
        // A notification can only be debounced if it's in the list AND it's "simple"
        // (i.e., has no parameters and no related request ID that could be lost).
        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
        if (canDebounce) {
            // If a notification of this type is already scheduled, do nothing.
            if (this._pendingDebouncedNotifications.has(notification.method)) return;
            // Mark this notification type as pending.
            this._pendingDebouncedNotifications.add(notification.method);
            // Schedule the actual send to happen in the next microtask.
            // This allows all synchronous calls in the current event loop tick to be coalesced.
            Promise.resolve().then(()=>{
                var _a;
                // Un-mark the notification so the next one can be scheduled.
                this._pendingDebouncedNotifications.delete(notification.method);
                // SAFETY CHECK: If the connection was closed while this was pending, abort.
                if (!this._transport) return;
                const jsonrpcNotification = {
                    ...notification,
                    jsonrpc: "2.0"
                };
                // Send the notification, but don't await it here to avoid blocking.
                // Handle potential errors with a .catch().
                (_a = this._transport) === null || _a === void 0 || _a.send(jsonrpcNotification, options).catch((error)=>this._onerror(error));
            });
            // Return immediately.
            return;
        }
        const jsonrpcNotification = {
            ...notification,
            jsonrpc: "2.0"
        };
        await this._transport.send(jsonrpcNotification, options);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */ setRequestHandler(requestSchema, handler) {
        const method = requestSchema.shape.method.value;
        this.assertRequestHandlerCapability(method);
        this._requestHandlers.set(method, (request, extra)=>{
            return Promise.resolve(handler(requestSchema.parse(request), extra));
        });
    }
    /**
     * Removes the request handler for the given method.
     */ removeRequestHandler(method) {
        this._requestHandlers.delete(method);
    }
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */ assertCanSetRequestHandler(method) {
        if (this._requestHandlers.has(method)) throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */ setNotificationHandler(notificationSchema, handler) {
        this._notificationHandlers.set(notificationSchema.shape.method.value, (notification)=>Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    /**
     * Removes the notification handler for the given method.
     */ removeNotificationHandler(method) {
        this._notificationHandlers.delete(method);
    }
}
exports.Protocol = Protocol;
function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value])=>{
        if (value && typeof value === "object") acc[key] = acc[key] ? {
            ...acc[key],
            ...value
        } : value;
        else acc[key] = value;
        return acc;
    }, {
        ...base
    });
}

},{"d2c272aeee3e37dc":"cqTxf"}],"cqTxf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceListChangedNotificationSchema = exports.ReadResourceResultSchema = exports.ReadResourceRequestSchema = exports.ListResourceTemplatesResultSchema = exports.ListResourceTemplatesRequestSchema = exports.ListResourcesResultSchema = exports.ListResourcesRequestSchema = exports.ResourceTemplateSchema = exports.ResourceSchema = exports.BlobResourceContentsSchema = exports.TextResourceContentsSchema = exports.ResourceContentsSchema = exports.PaginatedResultSchema = exports.PaginatedRequestSchema = exports.ProgressNotificationSchema = exports.ProgressSchema = exports.PingRequestSchema = exports.isInitializedNotification = exports.InitializedNotificationSchema = exports.InitializeResultSchema = exports.ServerCapabilitiesSchema = exports.isInitializeRequest = exports.InitializeRequestSchema = exports.ClientCapabilitiesSchema = exports.ImplementationSchema = exports.BaseMetadataSchema = exports.IconsSchema = exports.IconSchema = exports.CancelledNotificationSchema = exports.EmptyResultSchema = exports.JSONRPCMessageSchema = exports.isJSONRPCError = exports.JSONRPCErrorSchema = exports.ErrorCode = exports.isJSONRPCResponse = exports.JSONRPCResponseSchema = exports.isJSONRPCNotification = exports.JSONRPCNotificationSchema = exports.isJSONRPCRequest = exports.JSONRPCRequestSchema = exports.RequestIdSchema = exports.ResultSchema = exports.NotificationSchema = exports.RequestSchema = exports.CursorSchema = exports.ProgressTokenSchema = exports.JSONRPC_VERSION = exports.SUPPORTED_PROTOCOL_VERSIONS = exports.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = exports.LATEST_PROTOCOL_VERSION = void 0;
exports.ClientRequestSchema = exports.RootsListChangedNotificationSchema = exports.ListRootsResultSchema = exports.ListRootsRequestSchema = exports.RootSchema = exports.CompleteResultSchema = exports.CompleteRequestSchema = exports.PromptReferenceSchema = exports.ResourceReferenceSchema = exports.ResourceTemplateReferenceSchema = exports.ElicitResultSchema = exports.ElicitRequestSchema = exports.PrimitiveSchemaDefinitionSchema = exports.EnumSchemaSchema = exports.NumberSchemaSchema = exports.StringSchemaSchema = exports.BooleanSchemaSchema = exports.CreateMessageResultSchema = exports.CreateMessageRequestSchema = exports.SamplingMessageSchema = exports.ModelPreferencesSchema = exports.ModelHintSchema = exports.LoggingMessageNotificationSchema = exports.SetLevelRequestSchema = exports.LoggingLevelSchema = exports.ToolListChangedNotificationSchema = exports.CallToolRequestSchema = exports.CompatibilityCallToolResultSchema = exports.CallToolResultSchema = exports.ListToolsResultSchema = exports.ListToolsRequestSchema = exports.ToolSchema = exports.ToolAnnotationsSchema = exports.PromptListChangedNotificationSchema = exports.GetPromptResultSchema = exports.PromptMessageSchema = exports.ContentBlockSchema = exports.ResourceLinkSchema = exports.EmbeddedResourceSchema = exports.AudioContentSchema = exports.ImageContentSchema = exports.TextContentSchema = exports.GetPromptRequestSchema = exports.ListPromptsResultSchema = exports.ListPromptsRequestSchema = exports.PromptSchema = exports.PromptArgumentSchema = exports.ResourceUpdatedNotificationSchema = exports.UnsubscribeRequestSchema = exports.SubscribeRequestSchema = void 0;
exports.McpError = exports.ServerResultSchema = exports.ServerNotificationSchema = exports.ServerRequestSchema = exports.ClientResultSchema = exports.ClientNotificationSchema = void 0;
const zod_1 = require("10ab419ef9be205a");
exports.LATEST_PROTOCOL_VERSION = "2025-06-18";
exports.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
exports.SUPPORTED_PROTOCOL_VERSIONS = [
    exports.LATEST_PROTOCOL_VERSION,
    "2025-03-26",
    "2024-11-05",
    "2024-10-07"
];
/* JSON-RPC types */ exports.JSONRPC_VERSION = "2.0";
/**
 * A progress token, used to associate progress notifications with the original request.
 */ exports.ProgressTokenSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number().int()
]);
/**
 * An opaque token used to represent a cursor for pagination.
 */ exports.CursorSchema = zod_1.z.string();
const RequestMetaSchema = zod_1.z.object({
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */ progressToken: zod_1.z.optional(exports.ProgressTokenSchema)
}).passthrough();
const BaseRequestParamsSchema = zod_1.z.object({
    _meta: zod_1.z.optional(RequestMetaSchema)
}).passthrough();
exports.RequestSchema = zod_1.z.object({
    method: zod_1.z.string(),
    params: zod_1.z.optional(BaseRequestParamsSchema)
});
const BaseNotificationParamsSchema = zod_1.z.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
exports.NotificationSchema = zod_1.z.object({
    method: zod_1.z.string(),
    params: zod_1.z.optional(BaseNotificationParamsSchema)
});
exports.ResultSchema = zod_1.z.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * A uniquely identifying ID for a request in JSON-RPC.
 */ exports.RequestIdSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number().int()
]);
/**
 * A request that expects a response.
 */ exports.JSONRPCRequestSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema
}).merge(exports.RequestSchema).strict();
const isJSONRPCRequest = (value)=>exports.JSONRPCRequestSchema.safeParse(value).success;
exports.isJSONRPCRequest = isJSONRPCRequest;
/**
 * A notification which does not expect a response.
 */ exports.JSONRPCNotificationSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION)
}).merge(exports.NotificationSchema).strict();
const isJSONRPCNotification = (value)=>exports.JSONRPCNotificationSchema.safeParse(value).success;
exports.isJSONRPCNotification = isJSONRPCNotification;
/**
 * A successful (non-error) response to a request.
 */ exports.JSONRPCResponseSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema,
    result: exports.ResultSchema
}).strict();
const isJSONRPCResponse = (value)=>exports.JSONRPCResponseSchema.safeParse(value).success;
exports.isJSONRPCResponse = isJSONRPCResponse;
/**
 * Error codes defined by the JSON-RPC specification.
 */ var ErrorCode;
(function(ErrorCode) {
    // SDK error codes
    ErrorCode[ErrorCode["ConnectionClosed"] = -32000] = "ConnectionClosed";
    ErrorCode[ErrorCode["RequestTimeout"] = -32001] = "RequestTimeout";
    // Standard JSON-RPC error codes
    ErrorCode[ErrorCode["ParseError"] = -32700] = "ParseError";
    ErrorCode[ErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode[ErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode[ErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode[ErrorCode["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));
/**
 * A response to a request that indicates an error occurred.
 */ exports.JSONRPCErrorSchema = zod_1.z.object({
    jsonrpc: zod_1.z.literal(exports.JSONRPC_VERSION),
    id: exports.RequestIdSchema,
    error: zod_1.z.object({
        /**
         * The error type that occurred.
         */ code: zod_1.z.number().int(),
        /**
         * A short description of the error. The message SHOULD be limited to a concise single sentence.
         */ message: zod_1.z.string(),
        /**
         * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
         */ data: zod_1.z.optional(zod_1.z.unknown())
    })
}).strict();
const isJSONRPCError = (value)=>exports.JSONRPCErrorSchema.safeParse(value).success;
exports.isJSONRPCError = isJSONRPCError;
exports.JSONRPCMessageSchema = zod_1.z.union([
    exports.JSONRPCRequestSchema,
    exports.JSONRPCNotificationSchema,
    exports.JSONRPCResponseSchema,
    exports.JSONRPCErrorSchema
]);
/* Empty result */ /**
 * A response that indicates success but carries no data.
 */ exports.EmptyResultSchema = exports.ResultSchema.strict();
/* Cancellation */ /**
 * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
 *
 * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
 *
 * This notification indicates that the result will be unused, so any associated processing SHOULD cease.
 *
 * A client MUST NOT attempt to cancel its `initialize` request.
 */ exports.CancelledNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */ requestId: exports.RequestIdSchema,
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */ reason: zod_1.z.string().optional()
    })
});
/* Base Metadata */ /**
 * Icon schema for use in tools, prompts, resources, and implementations.
 */ exports.IconSchema = zod_1.z.object({
    /**
     * URL or data URI for the icon.
     */ src: zod_1.z.string(),
    /**
     * Optional MIME type for the icon.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * Optional array of strings that specify sizes at which the icon can be used.
     * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
     *
     * If not provided, the client should assume that the icon can be used at any size.
     */ sizes: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
}).passthrough();
/**
 * Base schema to add `icons` property.
 *
 */ exports.IconsSchema = zod_1.z.object({
    /**
     * Optional set of sized icons that the client can display in a user interface.
     *
     * Clients that support rendering icons MUST support at least the following MIME types:
     * - `image/png` - PNG images (safe, universal compatibility)
     * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
     *
     * Clients that support rendering icons SHOULD also support:
     * - `image/svg+xml` - SVG images (scalable but requires security precautions)
     * - `image/webp` - WebP images (modern, efficient format)
     */ icons: zod_1.z.array(exports.IconSchema).optional()
}).passthrough();
/**
 * Base metadata interface for common properties across resources, tools, prompts, and implementations.
 */ exports.BaseMetadataSchema = zod_1.z.object({
    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */ name: zod_1.z.string(),
    /**
     * Intended for UI and end-user contexts \u2014 optimized to be human-readable and easily understood,
     * even by those unfamiliar with domain-specific terminology.
     *
     * If not provided, the name should be used for display (except for Tool,
     * where `annotations.title` should be given precedence over using `name`,
     * if present).
     */ title: zod_1.z.optional(zod_1.z.string())
}).passthrough();
/* Initialization */ /**
 * Describes the name and version of an MCP implementation.
 */ exports.ImplementationSchema = exports.BaseMetadataSchema.extend({
    version: zod_1.z.string(),
    /**
     * An optional URL of the website for this implementation.
     */ websiteUrl: zod_1.z.optional(zod_1.z.string())
}).merge(exports.IconsSchema);
/**
 * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
 */ exports.ClientCapabilitiesSchema = zod_1.z.object({
    /**
     * Experimental, non-standard capabilities that the client supports.
     */ experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports sampling from an LLM.
     */ sampling: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports eliciting user input.
     */ elicitation: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the client supports listing roots.
     */ roots: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough())
}).passthrough();
/**
 * This request is sent from the client to the server when it first connects, asking it to begin initialization.
 */ exports.InitializeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
         */ protocolVersion: zod_1.z.string(),
        capabilities: exports.ClientCapabilitiesSchema,
        clientInfo: exports.ImplementationSchema
    })
});
const isInitializeRequest = (value)=>exports.InitializeRequestSchema.safeParse(value).success;
exports.isInitializeRequest = isInitializeRequest;
/**
 * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
 */ exports.ServerCapabilitiesSchema = zod_1.z.object({
    /**
     * Experimental, non-standard capabilities that the server supports.
     */ experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server supports sending log messages to the client.
     */ logging: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server supports sending completions to the client.
     */ completions: zod_1.z.optional(zod_1.z.object({}).passthrough()),
    /**
     * Present if the server offers any prompt templates.
     */ prompts: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any resources to read.
     */ resources: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports clients subscribing to resource updates.
         */ subscribe: zod_1.z.optional(zod_1.z.boolean()),
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any tools to call.
     */ tools: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */ listChanged: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough())
}).passthrough();
/**
 * After receiving an initialize request from the client, the server sends this response.
 */ exports.InitializeResultSchema = exports.ResultSchema.extend({
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */ protocolVersion: zod_1.z.string(),
    capabilities: exports.ServerCapabilitiesSchema,
    serverInfo: exports.ImplementationSchema,
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */ instructions: zod_1.z.optional(zod_1.z.string())
});
/**
 * This notification is sent from the client to the server after initialization has finished.
 */ exports.InitializedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/initialized")
});
const isInitializedNotification = (value)=>exports.InitializedNotificationSchema.safeParse(value).success;
exports.isInitializedNotification = isInitializedNotification;
/* Ping */ /**
 * A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
 */ exports.PingRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("ping")
});
/* Progress notifications */ exports.ProgressSchema = zod_1.z.object({
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */ progress: zod_1.z.number(),
    /**
     * Total number of items to process (or total progress required), if known.
     */ total: zod_1.z.optional(zod_1.z.number()),
    /**
     * An optional message describing the current progress.
     */ message: zod_1.z.optional(zod_1.z.string())
}).passthrough();
/**
 * An out-of-band notification used to inform the receiver of a progress update for a long-running request.
 */ exports.ProgressNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(exports.ProgressSchema).extend({
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */ progressToken: exports.ProgressTokenSchema
    })
});
/* Pagination */ exports.PaginatedRequestSchema = exports.RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
        /**
         * An opaque token representing the current pagination position.
         * If provided, the server should return results starting after this cursor.
         */ cursor: zod_1.z.optional(exports.CursorSchema)
    }).optional()
});
exports.PaginatedResultSchema = exports.ResultSchema.extend({
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */ nextCursor: zod_1.z.optional(exports.CursorSchema)
});
/* Resources */ /**
 * The contents of a specific resource or sub-resource.
 */ exports.ResourceContentsSchema = zod_1.z.object({
    /**
     * The URI of this resource.
     */ uri: zod_1.z.string(),
    /**
     * The MIME type of this resource, if known.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
exports.TextResourceContentsSchema = exports.ResourceContentsSchema.extend({
    /**
     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
     */ text: zod_1.z.string()
});
/**
 * A Zod schema for validating Base64 strings that is more performant and
 * robust for very large inputs than the default regex-based check. It avoids
 * stack overflows by using the native `atob` function for validation.
 */ const Base64Schema = zod_1.z.string().refine((val)=>{
    try {
        // atob throws a DOMException if the string contains characters
        // that are not part of the Base64 character set.
        atob(val);
        return true;
    } catch (_a) {
        return false;
    }
}, {
    message: "Invalid Base64 string"
});
exports.BlobResourceContentsSchema = exports.ResourceContentsSchema.extend({
    /**
     * A base64-encoded string representing the binary data of the item.
     */ blob: Base64Schema
});
/**
 * A known resource that the server is capable of reading.
 */ exports.ResourceSchema = exports.BaseMetadataSchema.extend({
    /**
     * The URI of this resource.
     */ uri: zod_1.z.string(),
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * The MIME type of this resource, if known.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * A template description for resources available on the server.
 */ exports.ResourceTemplateSchema = exports.BaseMetadataSchema.extend({
    /**
     * A URI template (according to RFC 6570) that can be used to construct resource URIs.
     */ uriTemplate: zod_1.z.string(),
    /**
     * A description of what this template is for.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
     */ mimeType: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of resources the server has.
 */ exports.ListResourcesRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("resources/list")
});
/**
 * The server's response to a resources/list request from the client.
 */ exports.ListResourcesResultSchema = exports.PaginatedResultSchema.extend({
    resources: zod_1.z.array(exports.ResourceSchema)
});
/**
 * Sent from the client to request a list of resource templates the server has.
 */ exports.ListResourceTemplatesRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("resources/templates/list")
});
/**
 * The server's response to a resources/templates/list request from the client.
 */ exports.ListResourceTemplatesResultSchema = exports.PaginatedResultSchema.extend({
    resourceTemplates: zod_1.z.array(exports.ResourceTemplateSchema)
});
/**
 * Sent from the client to the server, to read a specific resource URI.
 */ exports.ReadResourceRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
         */ uri: zod_1.z.string()
    })
});
/**
 * The server's response to a resources/read request from the client.
 */ exports.ReadResourceResultSchema = exports.ResultSchema.extend({
    contents: zod_1.z.array(zod_1.z.union([
        exports.TextResourceContentsSchema,
        exports.BlobResourceContentsSchema
    ]))
});
/**
 * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.ResourceListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/resources/list_changed")
});
/**
 * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
 */ exports.SubscribeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
         */ uri: zod_1.z.string()
    })
});
/**
 * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
 */ exports.UnsubscribeRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to unsubscribe from.
         */ uri: zod_1.z.string()
    })
});
/**
 * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
 */ exports.ResourceUpdatedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */ uri: zod_1.z.string()
    })
});
/* Prompts */ /**
 * Describes an argument that a prompt can accept.
 */ exports.PromptArgumentSchema = zod_1.z.object({
    /**
     * The name of the argument.
     */ name: zod_1.z.string(),
    /**
     * A human-readable description of the argument.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * Whether this argument must be provided.
     */ required: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * A prompt or prompt template that the server offers.
 */ exports.PromptSchema = exports.BaseMetadataSchema.extend({
    /**
     * An optional description of what this prompt provides
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * A list of arguments to use for templating the prompt.
     */ arguments: zod_1.z.optional(zod_1.z.array(exports.PromptArgumentSchema)),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of prompts and prompt templates the server has.
 */ exports.ListPromptsRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("prompts/list")
});
/**
 * The server's response to a prompts/list request from the client.
 */ exports.ListPromptsResultSchema = exports.PaginatedResultSchema.extend({
    prompts: zod_1.z.array(exports.PromptSchema)
});
/**
 * Used by the client to get a prompt provided by the server.
 */ exports.GetPromptRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The name of the prompt or prompt template.
         */ name: zod_1.z.string(),
        /**
         * Arguments to use for templating the prompt.
         */ arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
    })
});
/**
 * Text provided to or from an LLM.
 */ exports.TextContentSchema = zod_1.z.object({
    type: zod_1.z.literal("text"),
    /**
     * The text content of the message.
     */ text: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * An image provided to or from an LLM.
 */ exports.ImageContentSchema = zod_1.z.object({
    type: zod_1.z.literal("image"),
    /**
     * The base64-encoded image data.
     */ data: Base64Schema,
    /**
     * The MIME type of the image. Different providers may support different image types.
     */ mimeType: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * An Audio provided to or from an LLM.
 */ exports.AudioContentSchema = zod_1.z.object({
    type: zod_1.z.literal("audio"),
    /**
     * The base64-encoded audio data.
     */ data: Base64Schema,
    /**
     * The MIME type of the audio. Different providers may support different audio types.
     */ mimeType: zod_1.z.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * The contents of a resource, embedded into a prompt or tool call result.
 */ exports.EmbeddedResourceSchema = zod_1.z.object({
    type: zod_1.z.literal("resource"),
    resource: zod_1.z.union([
        exports.TextResourceContentsSchema,
        exports.BlobResourceContentsSchema
    ]),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * A resource that the server is capable of reading, included in a prompt or tool call result.
 *
 * Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
 */ exports.ResourceLinkSchema = exports.ResourceSchema.extend({
    type: zod_1.z.literal("resource_link")
});
/**
 * A content block that can be used in prompts and tool results.
 */ exports.ContentBlockSchema = zod_1.z.union([
    exports.TextContentSchema,
    exports.ImageContentSchema,
    exports.AudioContentSchema,
    exports.ResourceLinkSchema,
    exports.EmbeddedResourceSchema
]);
/**
 * Describes a message returned as part of a prompt.
 */ exports.PromptMessageSchema = zod_1.z.object({
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: exports.ContentBlockSchema
}).passthrough();
/**
 * The server's response to a prompts/get request from the client.
 */ exports.GetPromptResultSchema = exports.ResultSchema.extend({
    /**
     * An optional description for the prompt.
     */ description: zod_1.z.optional(zod_1.z.string()),
    messages: zod_1.z.array(exports.PromptMessageSchema)
});
/**
 * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.PromptListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/prompts/list_changed")
});
/* Tools */ /**
 * Additional properties describing a Tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */ exports.ToolAnnotationsSchema = zod_1.z.object({
    /**
     * A human-readable title for the tool.
     */ title: zod_1.z.optional(zod_1.z.string()),
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */ readOnlyHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: true
     */ destructiveHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on the its environment.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: false
     */ idempotentHint: zod_1.z.optional(zod_1.z.boolean()),
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */ openWorldHint: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * Definition for a tool the client can call.
 */ exports.ToolSchema = exports.BaseMetadataSchema.extend({
    /**
     * A human-readable description of the tool.
     */ description: zod_1.z.optional(zod_1.z.string()),
    /**
     * A JSON Schema object defining the expected parameters for the tool.
     */ inputSchema: zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough(),
    /**
     * An optional JSON Schema object defining the structure of the tool's output returned in
     * the structuredContent field of a CallToolResult.
     */ outputSchema: zod_1.z.optional(zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough()),
    /**
     * Optional additional tool information.
     */ annotations: zod_1.z.optional(exports.ToolAnnotationsSchema),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).merge(exports.IconsSchema);
/**
 * Sent from the client to request a list of tools the server has.
 */ exports.ListToolsRequestSchema = exports.PaginatedRequestSchema.extend({
    method: zod_1.z.literal("tools/list")
});
/**
 * The server's response to a tools/list request from the client.
 */ exports.ListToolsResultSchema = exports.PaginatedResultSchema.extend({
    tools: zod_1.z.array(exports.ToolSchema)
});
/**
 * The server's response to a tool call.
 */ exports.CallToolResultSchema = exports.ResultSchema.extend({
    /**
     * A list of content objects that represent the result of the tool call.
     *
     * If the Tool does not define an outputSchema, this field MUST be present in the result.
     * For backwards compatibility, this field is always present, but it may be empty.
     */ content: zod_1.z.array(exports.ContentBlockSchema).default([]),
    /**
     * An object containing structured tool output.
     *
     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
     */ structuredContent: zod_1.z.object({}).passthrough().optional(),
    /**
     * Whether the tool call ended in an error.
     *
     * If not set, this is assumed to be false (the call was successful).
     *
     * Any errors that originate from the tool SHOULD be reported inside the result
     * object, with `isError` set to true, _not_ as an MCP protocol-level error
     * response. Otherwise, the LLM would not be able to see that an error occurred
     * and self-correct.
     *
     * However, any errors in _finding_ the tool, an error indicating that the
     * server does not support tool calls, or any other exceptional conditions,
     * should be reported as an MCP error response.
     */ isError: zod_1.z.optional(zod_1.z.boolean())
});
/**
 * CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.
 */ exports.CompatibilityCallToolResultSchema = exports.CallToolResultSchema.or(exports.ResultSchema.extend({
    toolResult: zod_1.z.unknown()
}));
/**
 * Used by the client to invoke a tool provided by the server.
 */ exports.CallToolRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
        name: zod_1.z.string(),
        arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.unknown()))
    })
});
/**
 * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
 */ exports.ToolListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/tools/list_changed")
});
/* Logging */ /**
 * The severity of a log message.
 */ exports.LoggingLevelSchema = zod_1.z.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
]);
/**
 * A request from the client to the server, to enable or adjust logging.
 */ exports.SetLevelRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
         */ level: exports.LoggingLevelSchema
    })
});
/**
 * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
 */ exports.LoggingMessageNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
        /**
         * The severity of this log message.
         */ level: exports.LoggingLevelSchema,
        /**
         * An optional name of the logger issuing this message.
         */ logger: zod_1.z.optional(zod_1.z.string()),
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */ data: zod_1.z.unknown()
    })
});
/* Sampling */ /**
 * Hints to use for model selection.
 */ exports.ModelHintSchema = zod_1.z.object({
    /**
     * A hint for a model name.
     */ name: zod_1.z.string().optional()
}).passthrough();
/**
 * The server's preferences for model selection, requested of the client during sampling.
 */ exports.ModelPreferencesSchema = zod_1.z.object({
    /**
     * Optional hints to use for model selection.
     */ hints: zod_1.z.optional(zod_1.z.array(exports.ModelHintSchema)),
    /**
     * How much to prioritize cost when selecting a model.
     */ costPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
    /**
     * How much to prioritize sampling speed (latency) when selecting a model.
     */ speedPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
    /**
     * How much to prioritize intelligence and capabilities when selecting a model.
     */ intelligencePriority: zod_1.z.optional(zod_1.z.number().min(0).max(1))
}).passthrough();
/**
 * Describes a message issued to or received from an LLM API.
 */ exports.SamplingMessageSchema = zod_1.z.object({
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: zod_1.z.union([
        exports.TextContentSchema,
        exports.ImageContentSchema,
        exports.AudioContentSchema
    ])
}).passthrough();
/**
 * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
 */ exports.CreateMessageRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
        messages: zod_1.z.array(exports.SamplingMessageSchema),
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */ systemPrompt: zod_1.z.optional(zod_1.z.string()),
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */ includeContext: zod_1.z.optional(zod_1.z.enum([
            "none",
            "thisServer",
            "allServers"
        ])),
        temperature: zod_1.z.optional(zod_1.z.number()),
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */ maxTokens: zod_1.z.number().int(),
        stopSequences: zod_1.z.optional(zod_1.z.array(zod_1.z.string())),
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */ metadata: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        /**
         * The server's preferences for which model to select.
         */ modelPreferences: zod_1.z.optional(exports.ModelPreferencesSchema)
    })
});
/**
 * The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.
 */ exports.CreateMessageResultSchema = exports.ResultSchema.extend({
    /**
     * The name of the model that generated the message.
     */ model: zod_1.z.string(),
    /**
     * The reason why sampling stopped.
     */ stopReason: zod_1.z.optional(zod_1.z.enum([
        "endTurn",
        "stopSequence",
        "maxTokens"
    ]).or(zod_1.z.string())),
    role: zod_1.z.enum([
        "user",
        "assistant"
    ]),
    content: zod_1.z.discriminatedUnion("type", [
        exports.TextContentSchema,
        exports.ImageContentSchema,
        exports.AudioContentSchema
    ])
});
/* Elicitation */ /**
 * Primitive schema definition for boolean fields.
 */ exports.BooleanSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("boolean"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    default: zod_1.z.optional(zod_1.z.boolean())
}).passthrough();
/**
 * Primitive schema definition for string fields.
 */ exports.StringSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("string"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    minLength: zod_1.z.optional(zod_1.z.number()),
    maxLength: zod_1.z.optional(zod_1.z.number()),
    format: zod_1.z.optional(zod_1.z.enum([
        "email",
        "uri",
        "date",
        "date-time"
    ]))
}).passthrough();
/**
 * Primitive schema definition for number fields.
 */ exports.NumberSchemaSchema = zod_1.z.object({
    type: zod_1.z.enum([
        "number",
        "integer"
    ]),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    minimum: zod_1.z.optional(zod_1.z.number()),
    maximum: zod_1.z.optional(zod_1.z.number())
}).passthrough();
/**
 * Primitive schema definition for enum fields.
 */ exports.EnumSchemaSchema = zod_1.z.object({
    type: zod_1.z.literal("string"),
    title: zod_1.z.optional(zod_1.z.string()),
    description: zod_1.z.optional(zod_1.z.string()),
    enum: zod_1.z.array(zod_1.z.string()),
    enumNames: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
}).passthrough();
/**
 * Union of all primitive schema definitions.
 */ exports.PrimitiveSchemaDefinitionSchema = zod_1.z.union([
    exports.BooleanSchemaSchema,
    exports.StringSchemaSchema,
    exports.NumberSchemaSchema,
    exports.EnumSchemaSchema
]);
/**
 * A request from the server to elicit user input via the client.
 * The client should present the message and form fields to the user.
 */ exports.ElicitRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("elicitation/create"),
    params: BaseRequestParamsSchema.extend({
        /**
         * The message to present to the user.
         */ message: zod_1.z.string(),
        /**
         * The schema for the requested user input.
         */ requestedSchema: zod_1.z.object({
            type: zod_1.z.literal("object"),
            properties: zod_1.z.record(zod_1.z.string(), exports.PrimitiveSchemaDefinitionSchema),
            required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
        }).passthrough()
    })
});
/**
 * The client's response to an elicitation/create request from the server.
 */ exports.ElicitResultSchema = exports.ResultSchema.extend({
    /**
     * The user's response action.
     */ action: zod_1.z.enum([
        "accept",
        "decline",
        "cancel"
    ]),
    /**
     * The collected user input content (only present if action is "accept").
     */ content: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()))
});
/* Autocomplete */ /**
 * A reference to a resource or resource template definition.
 */ exports.ResourceTemplateReferenceSchema = zod_1.z.object({
    type: zod_1.z.literal("ref/resource"),
    /**
     * The URI or URI template of the resource.
     */ uri: zod_1.z.string()
}).passthrough();
/**
 * @deprecated Use ResourceTemplateReferenceSchema instead
 */ exports.ResourceReferenceSchema = exports.ResourceTemplateReferenceSchema;
/**
 * Identifies a prompt.
 */ exports.PromptReferenceSchema = zod_1.z.object({
    type: zod_1.z.literal("ref/prompt"),
    /**
     * The name of the prompt or prompt template
     */ name: zod_1.z.string()
}).passthrough();
/**
 * A request from the client to the server, to ask for completion options.
 */ exports.CompleteRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
        ref: zod_1.z.union([
            exports.PromptReferenceSchema,
            exports.ResourceTemplateReferenceSchema
        ]),
        /**
         * The argument's information
         */ argument: zod_1.z.object({
            /**
             * The name of the argument
             */ name: zod_1.z.string(),
            /**
             * The value of the argument to use for completion matching.
             */ value: zod_1.z.string()
        }).passthrough(),
        context: zod_1.z.optional(zod_1.z.object({
            /**
             * Previously-resolved variables in a URI template or prompt.
             */ arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.string()))
        }))
    })
});
/**
 * The server's response to a completion/complete request
 */ exports.CompleteResultSchema = exports.ResultSchema.extend({
    completion: zod_1.z.object({
        /**
         * An array of completion values. Must not exceed 100 items.
         */ values: zod_1.z.array(zod_1.z.string()).max(100),
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */ total: zod_1.z.optional(zod_1.z.number().int()),
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */ hasMore: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough()
});
/* Roots */ /**
 * Represents a root directory or file that the server can operate on.
 */ exports.RootSchema = zod_1.z.object({
    /**
     * The URI identifying the root. This *must* start with file:// for now.
     */ uri: zod_1.z.string().startsWith("file://"),
    /**
     * An optional name for the root.
     */ name: zod_1.z.optional(zod_1.z.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */ _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
}).passthrough();
/**
 * Sent from the server to request a list of root URIs from the client.
 */ exports.ListRootsRequestSchema = exports.RequestSchema.extend({
    method: zod_1.z.literal("roots/list")
});
/**
 * The client's response to a roots/list request from the server.
 */ exports.ListRootsResultSchema = exports.ResultSchema.extend({
    roots: zod_1.z.array(exports.RootSchema)
});
/**
 * A notification from the client to the server, informing it that the list of roots has changed.
 */ exports.RootsListChangedNotificationSchema = exports.NotificationSchema.extend({
    method: zod_1.z.literal("notifications/roots/list_changed")
});
/* Client messages */ exports.ClientRequestSchema = zod_1.z.union([
    exports.PingRequestSchema,
    exports.InitializeRequestSchema,
    exports.CompleteRequestSchema,
    exports.SetLevelRequestSchema,
    exports.GetPromptRequestSchema,
    exports.ListPromptsRequestSchema,
    exports.ListResourcesRequestSchema,
    exports.ListResourceTemplatesRequestSchema,
    exports.ReadResourceRequestSchema,
    exports.SubscribeRequestSchema,
    exports.UnsubscribeRequestSchema,
    exports.CallToolRequestSchema,
    exports.ListToolsRequestSchema
]);
exports.ClientNotificationSchema = zod_1.z.union([
    exports.CancelledNotificationSchema,
    exports.ProgressNotificationSchema,
    exports.InitializedNotificationSchema,
    exports.RootsListChangedNotificationSchema
]);
exports.ClientResultSchema = zod_1.z.union([
    exports.EmptyResultSchema,
    exports.CreateMessageResultSchema,
    exports.ElicitResultSchema,
    exports.ListRootsResultSchema
]);
/* Server messages */ exports.ServerRequestSchema = zod_1.z.union([
    exports.PingRequestSchema,
    exports.CreateMessageRequestSchema,
    exports.ElicitRequestSchema,
    exports.ListRootsRequestSchema
]);
exports.ServerNotificationSchema = zod_1.z.union([
    exports.CancelledNotificationSchema,
    exports.ProgressNotificationSchema,
    exports.LoggingMessageNotificationSchema,
    exports.ResourceUpdatedNotificationSchema,
    exports.ResourceListChangedNotificationSchema,
    exports.ToolListChangedNotificationSchema,
    exports.PromptListChangedNotificationSchema
]);
exports.ServerResultSchema = zod_1.z.union([
    exports.EmptyResultSchema,
    exports.InitializeResultSchema,
    exports.CompleteResultSchema,
    exports.GetPromptResultSchema,
    exports.ListPromptsResultSchema,
    exports.ListResourcesResultSchema,
    exports.ListResourceTemplatesResultSchema,
    exports.ReadResourceResultSchema,
    exports.CallToolResultSchema,
    exports.ListToolsResultSchema
]);
class McpError extends Error {
    constructor(code, message, data){
        super(`MCP error ${code}: ${message}`);
        this.code = code;
        this.data = data;
        this.name = "McpError";
    }
}
exports.McpError = McpError;

},{"10ab419ef9be205a":"hP52C"}],"hP52C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "z", ()=>_externalJs);
var _externalJs = require("./v3/external.js");
parcelHelpers.exportAll(_externalJs, exports);
exports.default = _externalJs;

},{"./v3/external.js":"bNeQ6","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bNeQ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("./errors.js");
parcelHelpers.exportAll(_errorsJs, exports);
var _parseUtilJs = require("./helpers/parseUtil.js");
parcelHelpers.exportAll(_parseUtilJs, exports);
var _typeAliasesJs = require("./helpers/typeAliases.js");
parcelHelpers.exportAll(_typeAliasesJs, exports);
var _utilJs = require("./helpers/util.js");
parcelHelpers.exportAll(_utilJs, exports);
var _typesJs = require("./types.js");
parcelHelpers.exportAll(_typesJs, exports);
var _zodErrorJs = require("./ZodError.js");
parcelHelpers.exportAll(_zodErrorJs, exports);

},{"./errors.js":"9JtgG","./helpers/parseUtil.js":"dRtcR","./helpers/typeAliases.js":"gdiUn","./helpers/util.js":"eVgjV","./types.js":"1sKQ4","./ZodError.js":"bChKR","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"9JtgG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultErrorMap", ()=>(0, _enJsDefault.default));
parcelHelpers.export(exports, "setErrorMap", ()=>setErrorMap);
parcelHelpers.export(exports, "getErrorMap", ()=>getErrorMap);
var _enJs = require("./locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
let overrideErrorMap = (0, _enJsDefault.default);
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

},{"./locales/en.js":"5ZU2p","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"5ZU2p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _zodErrorJs = require("../ZodError.js");
var _utilJs = require("../helpers/util.js");
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case (0, _zodErrorJs.ZodIssueCode).invalid_type:
            if (issue.received === (0, _utilJs.ZodParsedType).undefined) message = "Required";
            else message = `Expected ${issue.expected}, received ${issue.received}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, (0, _utilJs.util).jsonStringifyReplacer)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).unrecognized_keys:
            message = `Unrecognized key(s) in object: ${(0, _utilJs.util).joinValues(issue.keys, ", ")}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${(0, _utilJs.util).joinValues(issue.options)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_enum_value:
            message = `Invalid enum value. Expected ${(0, _utilJs.util).joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_return_type:
            message = `Invalid function return type`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_date:
            message = `Invalid date`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                else (0, _utilJs.util).assertNever(issue.validation);
            } else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
            else message = "Invalid";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "bigint") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).custom:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            (0, _utilJs.util).assertNever(issue);
    }
    return {
        message
    };
};
exports.default = errorMap;

},{"../ZodError.js":"bChKR","../helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bChKR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodIssueCode", ()=>ZodIssueCode);
parcelHelpers.export(exports, "quotelessJson", ()=>quotelessJson);
parcelHelpers.export(exports, "ZodError", ()=>ZodError);
var _utilJs = require("./helpers/util.js");
const ZodIssueCode = (0, _utilJs.util).arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
const quotelessJson = (obj)=>{
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        this.issues = [];
        this.addIssue = (sub)=>{
            this.issues = [
                ...this.issues,
                sub
            ];
        };
        this.addIssues = (subs = [])=>{
            this.issues = [
                ...this.issues,
                ...subs
            ];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) // eslint-disable-next-line ban/ban
        Object.setPrototypeOf(this, actualProto);
        else this.__proto__ = actualProto;
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") issue.unionErrors.map(processError);
                else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
                else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
                else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) curr[el] = curr[el] || {
                            _errors: []
                        };
                        else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, (0, _utilJs.util).jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues)if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
        } else formErrors.push(mapper(sub));
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues)=>{
    const error = new ZodError(issues);
    return error;
};

},{"./helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"eVgjV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "util", ()=>util);
parcelHelpers.export(exports, "objectUtil", ()=>objectUtil);
parcelHelpers.export(exports, "ZodParsedType", ()=>ZodParsedType);
parcelHelpers.export(exports, "getParsedType", ()=>getParsedType);
var util;
(function(util) {
    util.assertEqual = (_)=>{};
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items)obj[item] = item;
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys)filtered[k] = obj[k];
        return util.objectValues(filtered);
    };
    util.objectValues = (obj)=>{
        return util.objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban
     : (object)=>{
        const keys = [];
        for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban
     : (val)=>typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value)=>{
        if (typeof value === "bigint") return value.toString();
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) return ZodParsedType.array;
            if (data === null) return ZodParsedType.null;
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
            if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
            if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
            if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"5G9Z5":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"dRtcR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeIssue", ()=>makeIssue);
parcelHelpers.export(exports, "EMPTY_PATH", ()=>EMPTY_PATH);
parcelHelpers.export(exports, "addIssueToContext", ()=>addIssueToContext);
parcelHelpers.export(exports, "ParseStatus", ()=>ParseStatus);
parcelHelpers.export(exports, "INVALID", ()=>INVALID);
parcelHelpers.export(exports, "DIRTY", ()=>DIRTY);
parcelHelpers.export(exports, "OK", ()=>OK);
parcelHelpers.export(exports, "isAborted", ()=>isAborted);
parcelHelpers.export(exports, "isDirty", ()=>isDirty);
parcelHelpers.export(exports, "isValid", ()=>isValid);
parcelHelpers.export(exports, "isAsync", ()=>isAsync);
var _errorsJs = require("../errors.js");
var _enJs = require("../locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    if (issueData.message !== undefined) return {
        ...issueData,
        path: fullPath,
        message: issueData.message
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps)errorMessage = map(fullIssue, {
        data,
        defaultError: errorMessage
    }).message;
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = (0, _errorsJs.getErrorMap)();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === (0, _enJsDefault.default) ? undefined : (0, _enJsDefault.default)
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value } = pair;
            if (key.status === "aborted") return INVALID;
            if (value.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
const INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value)=>({
        status: "dirty",
        value
    });
const OK = (value)=>({
        status: "valid",
        value
    });
const isAborted = (x)=>x.status === "aborted";
const isDirty = (x)=>x.status === "dirty";
const isValid = (x)=>x.status === "valid";
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;

},{"../errors.js":"9JtgG","../locales/en.js":"5ZU2p","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"gdiUn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"1sKQ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodType", ()=>ZodType);
// Adapted from https://stackoverflow.com/a/3143231
parcelHelpers.export(exports, "datetimeRegex", ()=>datetimeRegex);
parcelHelpers.export(exports, "ZodString", ()=>ZodString);
parcelHelpers.export(exports, "ZodNumber", ()=>ZodNumber);
parcelHelpers.export(exports, "ZodBigInt", ()=>ZodBigInt);
parcelHelpers.export(exports, "ZodBoolean", ()=>ZodBoolean);
parcelHelpers.export(exports, "ZodDate", ()=>ZodDate);
parcelHelpers.export(exports, "ZodSymbol", ()=>ZodSymbol);
parcelHelpers.export(exports, "ZodUndefined", ()=>ZodUndefined);
parcelHelpers.export(exports, "ZodNull", ()=>ZodNull);
parcelHelpers.export(exports, "ZodAny", ()=>ZodAny);
parcelHelpers.export(exports, "ZodUnknown", ()=>ZodUnknown);
parcelHelpers.export(exports, "ZodNever", ()=>ZodNever);
parcelHelpers.export(exports, "ZodVoid", ()=>ZodVoid);
parcelHelpers.export(exports, "ZodArray", ()=>ZodArray);
parcelHelpers.export(exports, "ZodObject", ()=>ZodObject);
parcelHelpers.export(exports, "ZodUnion", ()=>ZodUnion);
parcelHelpers.export(exports, "ZodDiscriminatedUnion", ()=>ZodDiscriminatedUnion);
parcelHelpers.export(exports, "ZodIntersection", ()=>ZodIntersection);
// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
parcelHelpers.export(exports, "ZodTuple", ()=>ZodTuple);
parcelHelpers.export(exports, "ZodRecord", ()=>ZodRecord);
parcelHelpers.export(exports, "ZodMap", ()=>ZodMap);
parcelHelpers.export(exports, "ZodSet", ()=>ZodSet);
parcelHelpers.export(exports, "ZodFunction", ()=>ZodFunction);
parcelHelpers.export(exports, "ZodLazy", ()=>ZodLazy);
parcelHelpers.export(exports, "ZodLiteral", ()=>ZodLiteral);
parcelHelpers.export(exports, "ZodEnum", ()=>ZodEnum);
parcelHelpers.export(exports, "ZodNativeEnum", ()=>ZodNativeEnum);
parcelHelpers.export(exports, "ZodPromise", ()=>ZodPromise);
parcelHelpers.export(exports, "ZodEffects", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodTransformer", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodOptional", ()=>ZodOptional);
parcelHelpers.export(exports, "ZodNullable", ()=>ZodNullable);
parcelHelpers.export(exports, "ZodDefault", ()=>ZodDefault);
parcelHelpers.export(exports, "ZodCatch", ()=>ZodCatch);
parcelHelpers.export(exports, "ZodNaN", ()=>ZodNaN);
parcelHelpers.export(exports, "BRAND", ()=>BRAND);
parcelHelpers.export(exports, "ZodBranded", ()=>ZodBranded);
parcelHelpers.export(exports, "ZodPipeline", ()=>ZodPipeline);
parcelHelpers.export(exports, "ZodReadonly", ()=>ZodReadonly);
parcelHelpers.export(exports, "custom", ()=>custom);
parcelHelpers.export(exports, "Schema", ()=>ZodType);
parcelHelpers.export(exports, "ZodSchema", ()=>ZodType);
parcelHelpers.export(exports, "late", ()=>late);
parcelHelpers.export(exports, "ZodFirstPartyTypeKind", ()=>ZodFirstPartyTypeKind);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "any", ()=>anyType);
parcelHelpers.export(exports, "array", ()=>arrayType);
parcelHelpers.export(exports, "bigint", ()=>bigIntType);
parcelHelpers.export(exports, "boolean", ()=>booleanType);
parcelHelpers.export(exports, "date", ()=>dateType);
parcelHelpers.export(exports, "discriminatedUnion", ()=>discriminatedUnionType);
parcelHelpers.export(exports, "effect", ()=>effectsType);
parcelHelpers.export(exports, "enum", ()=>enumType);
parcelHelpers.export(exports, "function", ()=>functionType);
parcelHelpers.export(exports, "instanceof", ()=>instanceOfType);
parcelHelpers.export(exports, "intersection", ()=>intersectionType);
parcelHelpers.export(exports, "lazy", ()=>lazyType);
parcelHelpers.export(exports, "literal", ()=>literalType);
parcelHelpers.export(exports, "map", ()=>mapType);
parcelHelpers.export(exports, "nan", ()=>nanType);
parcelHelpers.export(exports, "nativeEnum", ()=>nativeEnumType);
parcelHelpers.export(exports, "never", ()=>neverType);
parcelHelpers.export(exports, "null", ()=>nullType);
parcelHelpers.export(exports, "nullable", ()=>nullableType);
parcelHelpers.export(exports, "number", ()=>numberType);
parcelHelpers.export(exports, "object", ()=>objectType);
parcelHelpers.export(exports, "oboolean", ()=>oboolean);
parcelHelpers.export(exports, "onumber", ()=>onumber);
parcelHelpers.export(exports, "optional", ()=>optionalType);
parcelHelpers.export(exports, "ostring", ()=>ostring);
parcelHelpers.export(exports, "pipeline", ()=>pipelineType);
parcelHelpers.export(exports, "preprocess", ()=>preprocessType);
parcelHelpers.export(exports, "promise", ()=>promiseType);
parcelHelpers.export(exports, "record", ()=>recordType);
parcelHelpers.export(exports, "set", ()=>setType);
parcelHelpers.export(exports, "strictObject", ()=>strictObjectType);
parcelHelpers.export(exports, "string", ()=>stringType);
parcelHelpers.export(exports, "symbol", ()=>symbolType);
parcelHelpers.export(exports, "transformer", ()=>effectsType);
parcelHelpers.export(exports, "tuple", ()=>tupleType);
parcelHelpers.export(exports, "undefined", ()=>undefinedType);
parcelHelpers.export(exports, "union", ()=>unionType);
parcelHelpers.export(exports, "unknown", ()=>unknownType);
parcelHelpers.export(exports, "void", ()=>voidType);
parcelHelpers.export(exports, "NEVER", ()=>NEVER);
var _zodErrorJs = require("./ZodError.js");
var _errorsJs = require("./errors.js");
var _errorUtilJs = require("./helpers/errorUtil.js");
var _parseUtilJs = require("./helpers/parseUtil.js");
var _utilJs = require("./helpers/util.js");
class ParseInputLazyPath {
    constructor(parent, value, path, key){
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if ((0, _parseUtilJs.isValid)(result)) return {
        success: true,
        data: result.value
    };
    else {
        if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new (0, _zodErrorJs.ZodError)(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        const { message } = params;
        if (iss.code === "invalid_enum_value") return {
            message: message ?? ctx.defaultError
        };
        if (typeof ctx.data === "undefined") return {
            message: message ?? required_error ?? ctx.defaultError
        };
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        return {
            message: message ?? invalid_type_error ?? ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, _utilJs.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, _utilJs.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new (0, _parseUtilJs.ParseStatus)(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, _utilJs.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, _parseUtilJs.isAsync)(result)) throw new Error("Synchronous parse encountered promise.");
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        if (!this["~standard"].async) try {
            const result = this._parseSync({
                data,
                path: [],
                parent: ctx
            });
            return (0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            };
        } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
            ctx.common = {
                issues: [],
                async: true
            };
        }
        return this._parseAsync({
            data,
            path: [],
            parent: ctx
        }).then((result)=>(0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await ((0, _parseUtilJs.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val)=>{
            if (typeof message === "string" || typeof message === "undefined") return {
                message
            };
            else if (typeof message === "function") return message(val);
            else return message;
        };
        return this._refinement((val, ctx)=>{
            const result = check(val);
            const setError = ()=>ctx.addIssue({
                    code: (0, _zodErrorJs.ZodIssueCode).custom,
                    ...getIssueProperties(val)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data)=>{
                if (!data) {
                    setError();
                    return false;
                } else return true;
            });
            if (!result) {
                setError();
                return false;
            } else return true;
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx)=>{
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else return true;
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data)=>this["~validate"](data)
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) return true;
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt)) return false;
    try {
        const [header] = jwt.split(".");
        if (!header) return false;
        // Convert base64url to base64
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null) return false;
        if ("typ" in decoded && decoded?.typ !== "JWT") return false;
        if (!decoded.alg) return false;
        if (alg && decoded.alg !== alg) return false;
        return true;
    } catch  {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return true;
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = String(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).string) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).string,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    else if (tooSmall) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "email",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "nanoid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") try {
                new URL(input.data);
            } catch  {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    validation: "url",
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                    message: check.message
                });
                status.dirty();
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") input.data = input.data.trim();
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
            else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "duration",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "jwt",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cidr",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64url",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex(regex, validation, message) {
        return this.refinement((data)=>regex.test(data), {
            validation,
            code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    nanoid(message) {
        return this._addCheck({
            kind: "nanoid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64(message) {
        return this._addCheck({
            kind: "base64",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    jwt(options) {
        return this._addCheck({
            kind: "jwt",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    cidr(options) {
        return this._addCheck({
            kind: "cidr",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    datetime(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
        });
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    date(message) {
        return this._addCheck({
            kind: "date",
            message
        });
    }
    time(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "time",
            precision: null,
            message: options
        });
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    duration(message) {
        return this._addCheck({
            kind: "duration",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    /**
     * Equivalent to `.min(1)`
     */ nonempty(message) {
        return this.min(1, (0, _errorUtilJs.errorUtil).errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch)=>ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch)=>ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch)=>ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch)=>ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch)=>ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch)=>ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params)=>{
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) input.data = Number(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).number) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).number,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!(0, _utilJs.util).isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && (0, _utilJs.util).isInteger(ch.value));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
            else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params)=>{
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodBigInt extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) try {
            input.data = BigInt(input.data);
        } catch  {
            return this._getInvalidInput(input);
        }
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).bigint) return this._getInvalidInput(input);
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).bigint,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params)=>{
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = Boolean(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).boolean,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodBoolean.create = (params)=>{
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = new Date(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).date) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).date,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_date
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params)=>{
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).symbol,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodSymbol.create = (params)=>{
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).undefined,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUndefined.create = (params)=>{
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).null) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).null,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodNull.create = (params)=>{
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
    });
};
class ZodAny extends ZodType {
    constructor(){
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodAny.create = (params)=>{
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
    });
};
class ZodUnknown extends ZodType {
    constructor(){
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUnknown.create = (params)=>{
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).never,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
}
ZodNever.create = (params)=>{
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).void,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodVoid.create = (params)=>{
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: tooBig ? (0, _zodErrorJs.ZodIssueCode).too_big : (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) return Promise.all([
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
        });
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params)=>{
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
    });
    else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    else return schema;
}
class ZodObject extends ZodType {
    constructor(){
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */ this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */ this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = (0, _utilJs.util).objectKeys(shape);
        this._cached = {
            shape,
            keys
        };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).object) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") for (const key of extraKeys)pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: {
                    status: "valid",
                    value: ctx.data[key]
                }
            });
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") ;
            else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        } else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) return Promise.resolve().then(async ()=>{
            const syncPairs = [];
            for (const pair of pairs){
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                    key,
                    value,
                    alwaysSet: pair.alwaysSet
                });
            }
            return syncPairs;
        }).then((syncPairs)=>{
            return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, syncPairs);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        (0, _errorUtilJs.errorUtil).errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: (0, _errorUtilJs.errorUtil).errToObj(message).message ?? defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */ merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    /**
     * @deprecated
     */ deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape)){
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) newShape[key] = fieldSchema;
            else newShape[key] = fieldSchema.optional();
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
        else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while(newField instanceof ZodOptional)newField = newField._def.innerType;
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum((0, _utilJs.util).objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.strictCreate = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.lazycreate = (shape, params)=>{
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results){
                if (result.result.status === "valid") return result.result;
            }
            for (const result of results)if (result.result.status === "dirty") {
                // add issues from dirty option
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
            }
            // return invalid
            const unionErrors = results.map((result)=>new (0, _zodErrorJs.ZodError)(result.ctx.common.issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return Promise.all(options.map(async (option)=>{
            const childCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                }),
                ctx: childCtx
            };
        })).then(handleResults);
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") return result;
                else if (result.status === "dirty" && !dirty) dirty = {
                    result,
                    ctx: childCtx
                };
                if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new (0, _zodErrorJs.ZodError)(issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params)=>{
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) return getDiscriminator(type.schema);
    else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
    else if (type instanceof ZodLiteral) return [
        type.value
    ];
    else if (type instanceof ZodEnum) return type.options;
    else if (type instanceof ZodNativeEnum) // eslint-disable-next-line ban/ban
    return (0, _utilJs.util).objectValues(type.enum);
    else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
    else if (type instanceof ZodUndefined) return [
        undefined
    ];
    else if (type instanceof ZodNull) return [
        null
    ];
    else if (type instanceof ZodOptional) return [
        undefined,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodNullable) return [
        null,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
    else return [];
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
        else return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */ static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            for (const value of discriminatorValues){
                if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
function mergeValues(a, b) {
    const aType = (0, _utilJs.getParsedType)(a);
    const bType = (0, _utilJs.getParsedType)(b);
    if (a === b) return {
        valid: true,
        data: a
    };
    else if (aType === (0, _utilJs.ZodParsedType).object && bType === (0, _utilJs.ZodParsedType).object) {
        const bKeys = (0, _utilJs.util).objectKeys(b);
        const sharedKeys = (0, _utilJs.util).objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) return {
                valid: false
            };
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === (0, _utilJs.ZodParsedType).array && bType === (0, _utilJs.ZodParsedType).array) {
        if (a.length !== b.length) return {
            valid: false
        };
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) return {
                valid: false
            };
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === (0, _utilJs.ZodParsedType).date && bType === (0, _utilJs.ZodParsedType).date && +a === +b) return {
        valid: true,
        data: a
    };
    else return {
        valid: false
    };
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if ((0, _parseUtilJs.isAborted)(parsedLeft) || (0, _parseUtilJs.isAborted)(parsedRight)) return 0, _parseUtilJs.INVALID;
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types
                });
                return 0, _parseUtilJs.INVALID;
            }
            if ((0, _parseUtilJs.isDirty)(parsedLeft) || (0, _parseUtilJs.isDirty)(parsedRight)) status.dirty();
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) return Promise.all([
            this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }),
            this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            })
        ]).then(([left, right])=>handleParsed(left, right));
        else return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }));
    }
}
ZodIntersection.create = (left, right, params)=>{
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return 0, _parseUtilJs.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x); // filter nulls
        if (ctx.common.async) return Promise.all(items).then((results)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, results);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeArray(status, items);
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
}
ZodTuple.create = (schemas, params)=>{
    if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data)pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
        });
        if (ctx.common.async) return (0, _parseUtilJs.ParseStatus).mergeObjectAsync(status, pairs);
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
        });
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).map) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).map,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                    if (key.status === "dirty" || value.status === "dirty") status.dirty();
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (key.status === "dirty" || value.status === "dirty") status.dirty();
                finalMap.set(key.value, value.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
}
ZodMap.create = (keyType, valueType, params)=>{
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).set) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).set,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
        else return finalizeSet(elements);
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params)=>{
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
    });
};
class ZodFunction extends ZodType {
    constructor(){
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).function) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).function,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(async function(...args) {
                const error = new (0, _zodErrorJs.ZodError)([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(function(...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) throw new (0, _zodErrorJs.ZodError)([
                    makeArgsIssue(args, parsedArgs.error)
                ]);
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) throw new (0, _zodErrorJs.ZodError)([
                    makeReturnsIssue(result, parsedReturns.error)
                ]);
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
}
ZodLazy.create = (getter, params)=>{
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_literal,
                expected: this._def.value
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params)=>{
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
            ...this._def,
            ...newDef
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = (0, _utilJs.util).getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).string && ctx.parsedType !== (0, _utilJs.ZodParsedType).number) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set((0, _utilJs.util).getValidEnumValues(this._def.values));
        if (!this._cache.has(input.data)) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params)=>{
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).promise && ctx.common.async === false) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).promise,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const promisified = ctx.parsedType === (0, _utilJs.ZodParsedType).promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, _parseUtilJs.OK)(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
}
ZodPromise.create = (schema, params)=>{
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg)=>{
                (0, _parseUtilJs.addIssueToContext)(ctx, arg);
                if (arg.fatal) status.abort();
                else status.dirty();
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = await this._def.schema._parseAsync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            });
            else {
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) return Promise.resolve(result);
                if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((inner)=>{
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                return executeRefinement(inner.value).then(()=>{
                    return {
                        status: status.value,
                        value: inner.value
                    };
                });
            });
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                return {
                    status: status.value,
                    value: result
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((base)=>{
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                        status: status.value,
                        value: result
                    }));
            });
        }
        (0, _utilJs.util).assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params)=>{
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
    return new ZodEffects({
        schema,
        effect: {
            type: "preprocess",
            transform: preprocess
        },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).undefined) return (0, _parseUtilJs.OK)(undefined);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params)=>{
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).null) return (0, _parseUtilJs.OK)(null);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params)=>{
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === (0, _utilJs.ZodParsedType).undefined) data = this._def.defaultValue();
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params)=>{
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
        ...processCreateParams(params)
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if ((0, _parseUtilJs.isAsync)(result)) return result.then((result)=>{
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        });
        else return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
                get error () {
                    return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                },
                input: newCtx.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params)=>{
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
        ...processCreateParams(params)
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).nan,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
}
ZodNaN.create = (params)=>{
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, _parseUtilJs.DIRTY)(inResult.value);
                } else return this._def.out._parseAsync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data)=>{
            if ((0, _parseUtilJs.isValid)(data)) data.value = Object.freeze(data.value);
            return data;
        };
        return (0, _parseUtilJs.isAsync)(result) ? result.then((data)=>freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params)=>{
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
        message: params
    } : params;
    const p2 = typeof p === "string" ? {
        message: p
    } : p;
    return p2;
}
function custom(check, _params = {}, /**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */ fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx)=>{
        const r = check(data);
        if (r instanceof Promise) return r.then((r)=>{
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({
                    code: "custom",
                    ...params,
                    fatal: _fatal
                });
            }
        });
        if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({
                code: "custom",
                ...params,
                fatal: _fatal
            });
        }
        return;
    });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._){}
}
const instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`
})=>custom((data)=>data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = ()=>stringType().optional();
const onumber = ()=>numberType().optional();
const oboolean = ()=>booleanType().optional();
const coerce = {
    string: (arg)=>ZodString.create({
            ...arg,
            coerce: true
        }),
    number: (arg)=>ZodNumber.create({
            ...arg,
            coerce: true
        }),
    boolean: (arg)=>ZodBoolean.create({
            ...arg,
            coerce: true
        }),
    bigint: (arg)=>ZodBigInt.create({
            ...arg,
            coerce: true
        }),
    date: (arg)=>ZodDate.create({
            ...arg,
            coerce: true
        })
};
const NEVER = (0, _parseUtilJs.INVALID);

},{"./ZodError.js":"bChKR","./errors.js":"9JtgG","./helpers/errorUtil.js":"kove1","./helpers/parseUtil.js":"dRtcR","./helpers/util.js":"eVgjV","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"kove1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorUtil", ()=>errorUtil);
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message)=>typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"fIIXC":[function(require,module,exports) {
"use strict";
var compileSchema = require("f7dd346044c34c6"), resolve = require("7a9956f372715dcc"), Cache = require("5169c4eac89c863f"), SchemaObject = require("9f1d640a8f9c4afc"), stableStringify = require("4d82020015b3afe8"), formats = require("1432f29152da5daf"), rules = require("914f694b4009365d"), $dataMetaSchema = require("4687edf7dbe4b29d"), util = require("292cd9db142892b3");
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require("93a7b3072f6d309");
var customKeyword = require("fb2e4f3d81c5111a");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = require("b6ec3ec3248ee9fb");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
var META_IGNORE_OPTIONS = [
    "removeAdditional",
    "useDefaults",
    "coerceTypes",
    "strictDefaults"
];
var META_SUPPORT_DATA = [
    "/properties"
];
/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */ function Ajv(opts) {
    if (!(this instanceof Ajv)) return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache;
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
    if (opts.serialize === undefined) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
    if (opts.nullable) this.addKeyword("nullable", {
        metaSchema: {
            type: "boolean"
        }
    });
    addInitialSchemas(this);
}
/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */ function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true) this.errors = v.errors;
    return valid;
}
/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */ function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, undefined, _meta);
    return schemaObj.validate || this._compile(schemaObj);
}
/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */ function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
        for(var i = 0; i < schema.length; i++)this.addSchema(schema[i], undefined, _skipValidation, _meta);
        return this;
    }
    var id = this._getId(schema);
    if (id !== undefined && typeof id != "string") throw new Error("schema id must be string");
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
}
/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */ function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
}
/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */ function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== undefined && typeof $schema != "string") throw new Error("$schema must be a string");
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(message);
        else throw new Error(message);
    }
    return valid;
}
function defaultMeta(self) {
    var meta = self._opts.meta;
    self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
    return self._opts.defaultMeta;
}
/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */ function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch(typeof schemaObj){
        case "object":
            return schemaObj.validate || this._compile(schemaObj);
        case "string":
            return this.getSchema(schemaObj);
        case "undefined":
            return _getSchemaFragment(this, keyRef);
    }
}
function _getSchemaFragment(self, ref) {
    var res = resolve.schema.call(self, {
        schema: {}
    }, ref);
    if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, undefined, baseId);
        self._fragments[ref] = new SchemaObject({
            ref: ref,
            fragment: true,
            schema: schema,
            root: root,
            baseId: baseId,
            validate: v
        });
        return v;
    }
}
function _getSchemaObj(self, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */ function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
    }
    switch(typeof schemaKeyRef){
        case "undefined":
            _removeAllSchemas(this, this._schemas);
            _removeAllSchemas(this, this._refs);
            this._cache.clear();
            return this;
        case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            if (schemaObj) this._cache.del(schemaObj.cacheKey);
            delete this._schemas[schemaKeyRef];
            delete this._refs[schemaKeyRef];
            return this;
        case "object":
            var serialize = this._opts.serialize;
            var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            if (id) {
                id = resolve.normalizeId(id);
                delete this._schemas[id];
                delete this._refs[id];
            }
    }
    return this;
}
function _removeAllSchemas(self, schemas, regex) {
    for(var keyRef in schemas){
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
            self._cache.del(schemaObj.cacheKey);
            delete schemas[keyRef];
        }
    }
}
/* @this   Ajv */ function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean") throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached) return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema) checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
        id: id,
        schema: schema,
        localRefs: localRefs,
        cacheKey: cacheKey,
        meta: meta
    });
    if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
}
/* @this   Ajv */ function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true) callValidate.$async = true;
        return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
    }
    var v;
    try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
        delete schemaObj.validate;
        throw e;
    } finally{
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    /* @this   {*} - custom context, see passContext option */ function callValidate() {
        /* jshint validthis: true */ var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
    }
}
function chooseGetId(opts) {
    switch(opts.schemaId){
        case "auto":
            return _get$IdOrId;
        case "id":
            return _getId;
        default:
            return _get$Id;
    }
}
/* @this   Ajv */ function _getId(schema) {
    if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
}
/* @this   Ajv */ function _get$Id(schema) {
    if (schema.id) this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
}
function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id) throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
}
/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */ function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors) return "No errors";
    options = options || {};
    var separator = options.separator === undefined ? ", " : options.separator;
    var dataVar = options.dataVar === undefined ? "data" : options.dataVar;
    var text = "";
    for(var i = 0; i < errors.length; i++){
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
}
/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */ function addFormat(name, format) {
    if (typeof format == "string") format = new RegExp(format);
    this._formats[name] = format;
    return this;
}
function addDefaultMetaSchema(self) {
    var $dataSchema;
    if (self._opts.$data) {
        $dataSchema = require("9bfbe520330691f6");
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self._opts.meta === false) return;
    var metaSchema = require("5772ffc00882093d");
    if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
    var optsSchemas = self._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
    else for(var key in optsSchemas)self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
    for(var name in self._opts.formats){
        var format = self._opts.formats[name];
        self.addFormat(name, format);
    }
}
function addInitialKeywords(self) {
    for(var name in self._opts.keywords){
        var keyword = self._opts.keywords[name];
        self.addKeyword(name, keyword);
    }
}
function checkUnique(self, id) {
    if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self) {
    var metaOpts = util.copy(self._opts);
    for(var i = 0; i < META_IGNORE_OPTIONS.length; i++)delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
}
function setLogger(self) {
    var logger = self._opts.logger;
    if (logger === false) self.logger = {
        log: noop,
        warn: noop,
        error: noop
    };
    else {
        if (logger === undefined) logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error)) throw new Error("logger must implement log, warn and error methods");
        self.logger = logger;
    }
}
function noop() {}

},{"f7dd346044c34c6":"kyFAJ","7a9956f372715dcc":"4DPrg","5169c4eac89c863f":"6QdJ9","9f1d640a8f9c4afc":"bGI5K","4d82020015b3afe8":"l5BCD","1432f29152da5daf":"bJBRk","914f694b4009365d":"bZh8w","4687edf7dbe4b29d":"brIE5","292cd9db142892b3":"bXWQH","93a7b3072f6d309":"6gt4e","fb2e4f3d81c5111a":"bUesF","b6ec3ec3248ee9fb":"2CCBr","9bfbe520330691f6":"8zgol","5772ffc00882093d":"66Yv9"}],"kyFAJ":[function(require,module,exports) {
"use strict";
var resolve = require("b589f22f51e17623"), util = require("a05853e7143a65f5"), errorClasses = require("7d0b6873cca90c67"), stableStringify = require("d698a727cccd50d6");
var validateGenerator = require("1bb2bd76cac2de13");
/**
 * Functions below are used inside compiled validations function
 */ var ucs2length = util.ucs2length;
var equal = require("c3d7d0741df3ddff");
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */ function compile(schema, root, localRefs, baseId) {
    /* jshint validthis: true, evil: true */ /* eslint no-shadow: 0 */ var self = this, opts = this._opts, refVal = [
        undefined
    ], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root = root || {
        schema: schema,
        refVal: refVal,
        refs: refs
    };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling) return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
            cv.schema = v.schema;
            cv.errors = null;
            cv.refs = v.refs;
            cv.refVal = v.refVal;
            cv.root = v.root;
            cv.$async = v.$async;
            if (opts.sourceCode) cv.source = v.source;
        }
        return v;
    } finally{
        endCompiling.call(this, schema, root, baseId);
    }
    /* @this   {*} - custom context, see passContext option */ function callValidate() {
        /* jshint validthis: true */ var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
    }
    function localCompile(_schema, _root, localRefs, baseId) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
            isTop: true,
            schema: _schema,
            isRoot: isRoot,
            baseId: baseId,
            root: _root,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            MissingRefError: errorClasses.MissingRef,
            RULES: RULES,
            validate: validateGenerator,
            util: util,
            resolve: resolve,
            resolveRef: resolveRef,
            usePattern: usePattern,
            useDefault: useDefault,
            useCustomRule: useCustomRule,
            opts: opts,
            formats: formats,
            logger: self.logger,
            self: self
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
        var validate;
        try {
            var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
            validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
            refVal[0] = validate;
        } catch (e) {
            self.logger.error("Error compiling schema, function code:", sourceCode);
            throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) validate.source = {
            code: sourceCode,
            patterns: patterns,
            defaults: defaults
        };
        return validate;
    }
    function resolveRef(baseId, ref, isRoot) {
        ref = resolve.url(baseId, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== undefined) {
            _refVal = refVal[refIndex];
            refCode = "refVal[" + refIndex + "]";
            return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
            var rootRefId = root.refs[ref];
            if (rootRefId !== undefined) {
                _refVal = root.refVal[rootRefId];
                refCode = addLocalRef(ref, _refVal);
                return resolvedRef(_refVal, refCode);
            }
        }
        refCode = addLocalRef(ref);
        var v = resolve.call(self, localCompile, root, ref);
        if (v === undefined) {
            var localSchema = localRefs && localRefs[ref];
            if (localSchema) v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId);
        }
        if (v === undefined) removeLocalRef(ref);
        else {
            replaceLocalRef(ref, v);
            return resolvedRef(v, refCode);
        }
    }
    function addLocalRef(ref, v) {
        var refId = refVal.length;
        refVal[refId] = v;
        refs[ref] = refId;
        return "refVal" + refId;
    }
    function removeLocalRef(ref) {
        delete refs[ref];
    }
    function replaceLocalRef(ref, v) {
        var refId = refs[ref];
        refVal[refId] = v;
    }
    function resolvedRef(refVal, code) {
        return typeof refVal == "object" || typeof refVal == "boolean" ? {
            code: code,
            schema: refVal,
            inline: true
        } : {
            code: code,
            $async: refVal && !!refVal.$async
        };
    }
    function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === undefined) {
            index = patternsHash[regexStr] = patterns.length;
            patterns[index] = regexStr;
        }
        return "pattern" + index;
    }
    function useDefault(value) {
        switch(typeof value){
            case "boolean":
            case "number":
                return "" + value;
            case "string":
                return util.toQuotedString(value);
            case "object":
                if (value === null) return "null";
                var valueStr = stableStringify(value);
                var index = defaultsHash[valueStr];
                if (index === undefined) {
                    index = defaultsHash[valueStr] = defaults.length;
                    defaults[index] = value;
                }
                return "default" + index;
        }
    }
    function useCustomRule(rule, schema, parentSchema, it) {
        if (self._opts.validateSchema !== false) {
            var deps = rule.definition.dependencies;
            if (deps && !deps.every(function(keyword) {
                return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
            })) throw new Error("parent schema must have all required keywords: " + deps.join(","));
            var validateSchema = rule.definition.validateSchema;
            if (validateSchema) {
                var valid = validateSchema(schema);
                if (!valid) {
                    var message = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
                    if (self._opts.validateSchema == "log") self.logger.error(message);
                    else throw new Error(message);
                }
            }
        }
        var compile = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile) validate = compile.call(self, schema, parentSchema, it);
        else if (macro) {
            validate = macro.call(self, schema, parentSchema, it);
            if (opts.validateSchema !== false) self.validateSchema(validate, true);
        } else if (inline) validate = inline.call(self, it, rule.keyword, schema, parentSchema);
        else {
            validate = rule.definition.validate;
            if (!validate) return;
        }
        if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
            code: "customRule" + index,
            validate: validate
        };
    }
}
/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */ function checkCompiling(schema, root, baseId) {
    /* jshint validthis: true */ var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0) return {
        index: index,
        compiling: true
    };
    index = this._compilations.length;
    this._compilations[index] = {
        schema: schema,
        root: root,
        baseId: baseId
    };
    return {
        index: index,
        compiling: false
    };
}
/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */ function endCompiling(schema, root, baseId) {
    /* jshint validthis: true */ var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0) this._compilations.splice(i, 1);
}
/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */ function compIndex(schema, root, baseId) {
    /* jshint validthis: true */ for(var i = 0; i < this._compilations.length; i++){
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
    }
    return -1;
}
function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
}
function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
}
function refValCode(i, refVal) {
    return refVal[i] === undefined ? "" : "var refVal" + i + " = refVal[" + i + "];";
}
function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
}
function vars(arr, statement) {
    if (!arr.length) return "";
    var code = "";
    for(var i = 0; i < arr.length; i++)code += statement(i, arr);
    return code;
}

},{"b589f22f51e17623":"4DPrg","a05853e7143a65f5":"bXWQH","7d0b6873cca90c67":"2CCBr","d698a727cccd50d6":"l5BCD","1bb2bd76cac2de13":"9i9eI","c3d7d0741df3ddff":"jtux3"}],"4DPrg":[function(require,module,exports) {
"use strict";
var URI = require("9cd31ea3887257c9"), equal = require("db717c6b6196b116"), util = require("2c84dcea76bf50ab"), SchemaObject = require("e62d6335d482eb3f"), traverse = require("16cd7b7b84452e6c");
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */ function resolve(compile, root, ref) {
    /* jshint validthis: true */ var refVal = this._refs[ref];
    if (typeof refVal == "string") {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    var res = resolveSchema.call(this, root, ref);
    var schema, v, baseId;
    if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
    else if (schema !== undefined) v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
    return v;
}
/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */ function resolveSchema(root, ref) {
    /* jshint validthis: true */ var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") return resolveRecursive.call(this, root, refVal, p);
        else if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            root = refVal;
        } else {
            refVal = this._schemas[id];
            if (refVal instanceof SchemaObject) {
                if (!refVal.validate) this._compile(refVal);
                if (id == normalizeId(ref)) return {
                    schema: refVal,
                    root: root,
                    baseId: baseId
                };
                root = refVal;
            } else return;
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */ function resolveRecursive(root, ref, parsedRef) {
    /* jshint validthis: true */ var res = resolveSchema.call(this, root, ref);
    if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
}
var PREVENT_SCOPE_CHANGE = util.toHash([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
]);
/* @this Ajv */ function getJsonPointer(parsedRef, baseId, schema, root) {
    /* jshint validthis: true */ parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/") return;
    var parts = parsedRef.fragment.split("/");
    for(var i = 1; i < parts.length; i++){
        var part = parts[i];
        if (part) {
            part = util.unescapeFragment(part);
            schema = schema[part];
            if (schema === undefined) break;
            var id;
            if (!PREVENT_SCOPE_CHANGE[part]) {
                id = this._getId(schema);
                if (id) baseId = resolveUrl(baseId, id);
                if (schema.$ref) {
                    var $ref = resolveUrl(baseId, schema.$ref);
                    var res = resolveSchema.call(this, root, $ref);
                    if (res) {
                        schema = res.schema;
                        root = res.root;
                        baseId = res.baseId;
                    }
                }
            }
        }
    }
    if (schema !== undefined && schema !== root.schema) return {
        schema: schema,
        root: root,
        baseId: baseId
    };
}
var SIMPLE_INLINED = util.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
]);
function inlineRef(schema, limit) {
    if (limit === false) return false;
    if (limit === undefined || limit === true) return checkNoRef(schema);
    else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) for(var i = 0; i < schema.length; i++){
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item)) return false;
    }
    else for(var key in schema){
        if (key == "$ref") return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item)) return false;
    }
    return true;
}
function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) for(var i = 0; i < schema.length; i++){
        item = schema[i];
        if (typeof item == "object") count += countKeys(item);
        if (count == Infinity) return Infinity;
    }
    else for(var key in schema){
        if (key == "$ref") return Infinity;
        if (SIMPLE_INLINED[key]) count++;
        else {
            item = schema[key];
            if (typeof item == "object") count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
        }
    }
    return count;
}
function getFullPath(id, normalize) {
    if (normalize !== false) id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
}
function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
}
/* @this Ajv */ function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = {
        "": schemaId
    };
    var fullPaths = {
        "": getFullPath(schemaId, false)
    };
    var localRefs = {};
    var self = this;
    traverse(schema, {
        allKeys: true
    }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "") return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== undefined) fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
            id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
            var refVal = self._refs[id];
            if (typeof refVal == "string") refVal = self._refs[refVal];
            if (refVal && refVal.schema) {
                if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
            } else if (id != normalizeId(fullPath)) {
                if (id[0] == "#") {
                    if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
                    localRefs[id] = sch;
                } else self._refs[id] = fullPath;
            }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
}

},{"9cd31ea3887257c9":"vmPB9","db717c6b6196b116":"jtux3","2c84dcea76bf50ab":"bXWQH","e62d6335d482eb3f":"bGI5K","16cd7b7b84452e6c":"dOV7I"}],"vmPB9":[function(require,module,exports) {
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {
    factory(exports);
})(this, function(exports1) {
    "use strict";
    function merge() {
        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++)sets[_key] = arguments[_key];
        if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for(var x = 1; x < xl; ++x)sets[x] = sets[x].slice(1, -1);
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
        } else return sets[0];
    }
    function subexp(str) {
        return "(?:" + str + ")";
    }
    function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
        return str.toUpperCase();
    }
    function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [
            obj
        ] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
        var obj = target;
        if (source) for(var key in source)obj[key] = source[key];
        return obj;
    }
    function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), //case-insensitive
        LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), //expanded
        GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", //subset, excludes bidi control characters
        IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", //subset
        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), //relaxed parsing rules
        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), //                           6( h16 ":" ) ls32
        IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), //                      "::" 5( h16 ":" ) ls32
        IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), //[               h16 ] "::" 4( h16 ":" ) ls32
        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), //[ *4( h16 ":" ) h16 ] "::"              ls32
        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), //[ *5( h16 ":" ) h16 ] "::"              h16
        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), //[ *6( h16 ":" ) h16 ] "::"
        IPV6ADDRESS$ = subexp([
            IPV6ADDRESS1$,
            IPV6ADDRESS2$,
            IPV6ADDRESS3$,
            IPV6ADDRESS4$,
            IPV6ADDRESS5$,
            IPV6ADDRESS6$,
            IPV6ADDRESS7$,
            IPV6ADDRESS8$,
            IPV6ADDRESS9$
        ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), //RFC 6874
        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), //RFC 6874
        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), //RFC 6874, with relaxed parsing rules
        IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), //RFC 6874
        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), //simplified
        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified
        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified
        PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;
            try {
                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr;
            else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
            else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
            return arr2;
        } else return Array.from(arr);
    };
    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
    /** Bootstring parameters */ var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = "-"; // '\x2D'
    /** Regular expressions */ var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
    /** Error messages */ var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
    };
    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    /*--------------------------------------------------------------------------*/ /**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */ function error$1(type) {
        throw new RangeError(errors[type]);
    }
    /**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */ function map(array, fn) {
        var result = [];
        var length = array.length;
        while(length--)result[length] = fn(array[length]);
        return result;
    }
    /**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */ function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + "@";
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
    }
    /**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */ function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while(counter < length){
            var value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // It's a high surrogate, and there is a next character.
                var extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) // Low surrogate.
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                else {
                    // It's an unmatched surrogate; only append this code unit, in case the
                    // next code unit is the high surrogate of a surrogate pair.
                    output.push(value);
                    counter--;
                }
            } else output.push(value);
        }
        return output;
    }
    /**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */ var ucs2encode = function ucs2encode(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    /**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */ var basicToDigit = function basicToDigit(codePoint) {
        if (codePoint - 0x30 < 0x0A) return codePoint - 0x16;
        if (codePoint - 0x41 < 0x1A) return codePoint - 0x41;
        if (codePoint - 0x61 < 0x1A) return codePoint - 0x61;
        return base;
    };
    /**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */ var digitToBasic = function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    /**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */ var adapt = function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    /**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */ var decode = function decode(input) {
        // Don't use UCS-2.
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) basic = 0;
        for(var j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) error$1("not-basic");
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i;
            for(var w = 1, k = base;; k += base){
                if (index >= inputLength) error$1("invalid-input");
                var digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) error$1("overflow");
                i += digit * w;
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) break;
                var baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) error$1("overflow");
                w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) error$1("overflow");
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
    };
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */ var encode = function encode(input) {
        var output = [];
        // Convert the input in UCS-2 to an array of Unicode code points.
        input = ucs2decode(input);
        // Cache the length.
        var inputLength = input.length;
        // Initialize the state.
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        // Handle the basic code points.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _currentValue2 = _step.value;
                if (_currentValue2 < 0x80) output.push(stringFromCharCode(_currentValue2));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
            } finally{
                if (_didIteratorError) throw _iteratorError;
            }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string with a delimiter unless it's empty.
        if (basicLength) output.push(delimiter);
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;
            try {
                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                    var currentValue = _step2.value;
                    if (currentValue >= n && currentValue < m) m = currentValue;
                }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow.
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
                } finally{
                    if (_didIteratorError2) throw _iteratorError2;
                }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error$1("overflow");
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;
            try {
                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                    var _currentValue = _step3.value;
                    if (_currentValue < n && ++delta > maxInt) error$1("overflow");
                    if (_currentValue == n) {
                        // Represent delta as a generalized variable-length integer.
                        var q = delta;
                        for(var k = base;; k += base){
                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) break;
                            var qMinusT = q - t;
                            var baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) _iterator3.return();
                } finally{
                    if (_didIteratorError3) throw _iteratorError3;
                }
            }
            ++delta;
            ++n;
        }
        return output.join("");
    };
    /**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */ var toUnicode = function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    };
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */ var toASCII = function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
    };
    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {
        /**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */ "version": "2.1.0",
        /**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */ "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
    };
    /**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */ /**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */ var SCHEMES = {};
    function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
    }
    function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while(i < il){
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
                newStr += String.fromCharCode(c);
                i += 3;
            } else if (c >= 194 && c < 224) {
                if (il - i >= 6) {
                    var c2 = parseInt(str.substr(i + 4, 2), 16);
                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
                } else newStr += str.substr(i, 6);
                i += 6;
            } else if (c >= 224) {
                if (il - i >= 9) {
                    var _c = parseInt(str.substr(i + 4, 2), 16);
                    var c3 = parseInt(str.substr(i + 7, 2), 16);
                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
                } else newStr += str.substr(i, 9);
                i += 9;
            } else {
                newStr += str.substr(i, 3);
                i += 3;
            }
        }
        return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
    }
    function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) return address.split(".").map(_stripLeadingZeros).join(".");
        else return host;
    }
    function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for(var x = 0; x < fieldCount; ++x)fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
            if (isLastFieldIPv4Address) fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            var allZeroFields = fields.reduce(function(acc, field, index) {
                if (!field || field === "0") {
                    var lastLongest = acc[acc.length - 1];
                    if (lastLongest && lastLongest.index + lastLongest.length === index) lastLongest.length++;
                    else acc.push({
                        index: index,
                        length: 1
                    });
                }
                return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
                return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
                var newFirst = fields.slice(0, longestZeroFields.index);
                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else newHost = fields.join(":");
            if (zone) newHost += "%" + zone;
            return newHost;
        } else return host;
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
    function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
                //store each component
                components.scheme = matches[1];
                components.userinfo = matches[3];
                components.host = matches[4];
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = matches[7];
                components.fragment = matches[8];
                //fix port number
                if (isNaN(components.port)) components.port = matches[5];
            } else {
                //IE FIX for improper RegExp matching
                //store each component
                components.scheme = matches[1] || undefined;
                components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
                components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
                components.port = parseInt(matches[5], 10);
                components.path = matches[6] || "";
                components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
                components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
                //fix port number
                if (isNaN(components.port)) components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
            if (components.host) //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            //determine reference type
            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) components.reference = "same-document";
            else if (components.scheme === undefined) components.reference = "relative";
            else if (components.fragment === undefined) components.reference = "absolute";
            else components.reference = "uri";
            //check for reference errors
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) components.error = components.error || "URI is not a " + options.reference + " reference.";
            //find scheme handler
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            //check if scheme can't handle IRIs
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                //if host component is a domain name
                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
                //convert IRI -> URI
                _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else //normalize encodings
            _normalizeComponentEncoding(components, protocol);
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) schemeHandler.parse(components, options);
        } else components.error = components.error || "URI can not be parsed.";
        return components;
    }
    function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
        }
        if (components.host !== undefined) //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
        if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
        var output = [];
        while(input.length){
            if (input.match(RDS1)) input = input.replace(RDS1, "");
            else if (input.match(RDS2)) input = input.replace(RDS2, "/");
            else if (input.match(RDS3)) {
                input = input.replace(RDS3, "/");
                output.pop();
            } else if (input === "." || input === "..") input = "";
            else {
                var im = input.match(RDS5);
                if (im) {
                    var s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else throw new Error("Unexpected dot segment condition");
            }
        }
        return output.join("");
    }
    function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) ;
            else if (options.domainHost || schemeHandler && schemeHandler.domainHost) //convert IDN via punycode
            try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
            if (options.reference !== "suffix") uriTokens.push("//");
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") uriTokens.push("/");
        }
        if (components.path !== undefined) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
            if (authority === undefined) s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
            uriTokens.push(s);
        }
        if (components.query !== undefined) {
            uriTokens.push("?");
            uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
    }
    function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
            base = parse(serialize(base, options), options); //normalize base components
            relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
                //target.authority = relative.authority;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || "");
                target.query = relative.query;
            } else {
                if (!relative.path) {
                    target.path = base.path;
                    if (relative.query !== undefined) target.query = relative.query;
                    else target.query = base.query;
                } else {
                    if (relative.path.charAt(0) === "/") target.path = removeDotSegments(relative.path);
                    else {
                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) target.path = "/" + relative.path;
                        else if (!base.path) target.path = relative.path;
                        else target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                        target.path = removeDotSegments(target.path);
                    }
                    target.query = relative.query;
                }
                //target.authority = base.authority;
                target.userinfo = base.userinfo;
                target.host = base.host;
                target.port = base.port;
            }
            target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
    }
    function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({
            scheme: "null"
        }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
        if (typeof uri === "string") uri = serialize(parse(uri, options), options);
        else if (typeOf(uri) === "object") uri = parse(serialize(uri, options), options);
        return uri;
    }
    function equal(uriA, uriB, options) {
        if (typeof uriA === "string") uriA = serialize(parse(uriA, options), options);
        else if (typeOf(uriA) === "object") uriA = serialize(uriA, options);
        if (typeof uriB === "string") uriB = serialize(parse(uriB, options), options);
        else if (typeOf(uriB) === "object") uriB = serialize(uriB, options);
        return uriA === uriB;
    }
    function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
            //report missing host
            if (!components.host) components.error = components.error || "HTTP URIs must have a host.";
            return components;
        },
        serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            //normalize the default port
            if (components.port === (secure ? 443 : 80) || components.port === "") components.port = undefined;
            //normalize the empty path
            if (!components.path) components.path = "/";
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components;
        }
    };
    var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
    };
    function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    //RFC 6455
    var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse(components, options) {
            var wsComponents = components;
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents);
            //construct resouce name
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = undefined;
            wsComponents.query = undefined;
            return wsComponents;
        },
        serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") wsComponents.port = undefined;
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === "boolean") {
                wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
                wsComponents.secure = undefined;
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
                var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                wsComponents.path = path && path !== "/" ? path : undefined;
                wsComponents.query = query;
                wsComponents.resourceName = undefined;
            }
            //forbid fragment component
            wsComponents.fragment = undefined;
            return wsComponents;
        }
    };
    var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
    };
    var O = {};
    var isIRI = true;
    //RFC 3986
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
    //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
    //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
    //const VCHAR$$ = "[\\x21-\\x7E]";
    //const WSP$$ = "[\\x20\\x09]";
    //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
    //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
    //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
    //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = undefined;
            if (mailtoComponents.query) {
                var unknownHeaders = false;
                var headers = {};
                var hfields = mailtoComponents.query.split("&");
                for(var x = 0, xl = hfields.length; x < xl; ++x){
                    var hfield = hfields[x].split("=");
                    switch(hfield[0]){
                        case "to":
                            var toAddrs = hfield[1].split(",");
                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x)to.push(toAddrs[_x]);
                            break;
                        case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;
                        case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;
                        default:
                            unknownHeaders = true;
                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            break;
                    }
                }
                if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = undefined;
            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){
                var addr = to[_x2].split("@");
                addr[0] = unescapeComponent(addr[0]);
                if (!options.unicodeSupport) //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
                else addr[1] = unescapeComponent(addr[1], options).toLowerCase();
                to[_x2] = addr.join("@");
            }
            return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
                for(var x = 0, xl = to.length; x < xl; ++x){
                    var toAddr = String(to[x]);
                    var atIdx = toAddr.lastIndexOf("@");
                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                    var domain = toAddr.slice(atIdx + 1);
                    //convert IDN via punycode
                    try {
                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                    } catch (e) {
                        components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                    }
                    to[x] = localPart + "@" + domain;
                }
                components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for(var name in headers)if (headers[name] !== O[name]) fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            if (fields.length) components.query = fields.join("&");
            return components;
        }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    //RFC 2141
    var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
                var scheme = options.scheme || urnComponents.scheme || "urn";
                var nid = matches[1].toLowerCase();
                var nss = matches[2];
                var urnScheme = scheme + ":" + (options.nid || nid);
                var schemeHandler = SCHEMES[urnScheme];
                urnComponents.nid = nid;
                urnComponents.nss = nss;
                urnComponents.path = undefined;
                if (schemeHandler) urnComponents = schemeHandler.parse(urnComponents, options);
            } else urnComponents.error = urnComponents.error || "URN can not be parsed.";
            return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) urnComponents = schemeHandler.serialize(urnComponents, options);
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
        }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    //RFC 4122
    var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = undefined;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents;
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
        }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports1.SCHEMES = SCHEMES;
    exports1.pctEncChar = pctEncChar;
    exports1.pctDecChars = pctDecChars;
    exports1.parse = parse;
    exports1.removeDotSegments = removeDotSegments;
    exports1.serialize = serialize;
    exports1.resolveComponents = resolveComponents;
    exports1.resolve = resolve;
    exports1.normalize = normalize;
    exports1.equal = equal;
    exports1.escapeComponent = escapeComponent;
    exports1.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});

},{}],"jtux3":[function(require,module,exports) {
"use strict";
// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};

},{}],"bXWQH":[function(require,module,exports) {
"use strict";
module.exports = {
    copy: copy,
    checkDataType: checkDataType,
    checkDataTypes: checkDataTypes,
    coerceToTypes: coerceToTypes,
    toHash: toHash,
    getProperty: getProperty,
    escapeQuotes: escapeQuotes,
    equal: require("6e2c918aa5d5ba8a"),
    ucs2length: require("6ee8393837aee5ca"),
    varOccurences: varOccurences,
    varReplace: varReplace,
    schemaHasRules: schemaHasRules,
    schemaHasRulesExcept: schemaHasRulesExcept,
    schemaUnknownRules: schemaUnknownRules,
    toQuotedString: toQuotedString,
    getPathExpr: getPathExpr,
    getPath: getPath,
    getData: getData,
    unescapeFragment: unescapeFragment,
    unescapeJsonPointer: unescapeJsonPointer,
    escapeFragment: escapeFragment,
    escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
    to = to || {};
    for(var key in o)to[key] = o[key];
    return to;
}
function checkDataType(dataType, data, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch(dataType){
        case "null":
            return data + EQUAL + "null";
        case "array":
            return OK + "Array.isArray(" + data + ")";
        case "object":
            return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
            return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
            return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
            return "typeof " + data + EQUAL + '"' + dataType + '"';
    }
}
function checkDataTypes(dataTypes, data, strictNumbers) {
    switch(dataTypes.length){
        case 1:
            return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
            var code = "";
            var types = toHash(dataTypes);
            if (types.array && types.object) {
                code = types.null ? "(" : "(!" + data + " || ";
                code += "typeof " + data + ' !== "object")';
                delete types.null;
                delete types.array;
                delete types.object;
            }
            if (types.number) delete types.integer;
            for(var t in types)code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
            return code;
    }
}
var COERCE_TO_TYPES = toHash([
    "string",
    "number",
    "integer",
    "boolean",
    "null"
]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
        var types = [];
        for(var i = 0; i < dataTypes.length; i++){
            var t = dataTypes[i];
            if (COERCE_TO_TYPES[t]) types[types.length] = t;
            else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
        }
        if (types.length) return types;
    } else if (COERCE_TO_TYPES[dataTypes]) return [
        dataTypes
    ];
    else if (optionCoerceTypes === "array" && dataTypes === "array") return [
        "array"
    ];
}
function toHash(arr) {
    var hash = {};
    for(var i = 0; i < arr.length; i++)hash[arr[i]] = true;
    return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
}
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean") return !schema;
    for(var key in schema)if (rules[key]) return true;
}
function schemaHasRulesExcept(schema, rules, exceptKeyword) {
    if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
    for(var key in schema)if (key != exceptKeyword && rules[key]) return true;
}
function schemaUnknownRules(schema, rules) {
    if (typeof schema == "boolean") return;
    for(var key in schema)if (!rules[key]) return key;
}
function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers // false by default
     ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers // false by default
     ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
}
var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === "") return "rootData";
    if ($data[0] == "/") {
        if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
    } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
            if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
            return paths[lvl - up];
        }
        if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer) return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for(var i = 0; i < segments.length; i++){
        var segment = segments[i];
        if (segment) {
            data += getProperty(unescapeJsonPointer(segment));
            expr += " && " + data;
        }
    }
    return expr;
}
function joinPaths(a, b) {
    if (a == '""') return b;
    return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
}
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}

},{"6e2c918aa5d5ba8a":"jtux3","6ee8393837aee5ca":"f0Moj"}],"f0Moj":[function(require,module,exports) {
"use strict";
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
    var length = 0, len = str.length, pos = 0, value;
    while(pos < len){
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
        }
    }
    return length;
};

},{}],"bGI5K":[function(require,module,exports) {
"use strict";
var util = require("864288866c3cff07");
module.exports = SchemaObject;
function SchemaObject(obj) {
    util.copy(obj, this);
}

},{"864288866c3cff07":"bXWQH"}],"dOV7I":[function(require,module,exports) {
"use strict";
var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == "function") {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == "object") for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}

},{}],"2CCBr":[function(require,module,exports) {
"use strict";
var resolve = require("91e7fc61203c0143");
module.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
}
MissingRefError.message = function(baseId, ref) {
    return "can't resolve reference " + ref + " from id " + baseId;
};
function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
}

},{"91e7fc61203c0143":"4DPrg"}],"l5BCD":[function(require,module,exports) {
"use strict";
module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") node = node.toJSON();
        if (node === undefined) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = "[";
            for(i = 0; i < node.length; i++){
                if (i) out += ",";
                out += stringify(node[i]) || "null";
            }
            return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
    }(data);
};

},{}],"9i9eI":[function(require,module,exports) {
"use strict";
module.exports = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
            var $keywordsMsg = "unknown keyword: " + $unknownKwd;
            if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
            else throw new Error($keywordsMsg);
        }
    }
    if (it.isTop) {
        out += " var validate = ";
        if ($async) {
            it.async = true;
            out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) out += " " + ("/*# sourceURL=" + $id + " */") + " ";
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
            if (it.isTop) $breakOnError = true;
            else out += " var " + $valid + " = false; ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ""; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
                if (it.opts.messages !== false) out += " , message: 'boolean schema is false' ";
                if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                else out += " validate.errors = [" + __err + "]; return false; ";
            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        } else if (it.isTop) {
            if ($async) out += " return data; ";
            else out += " validate.errors = null; return true; ";
        } else out += " var " + $valid + " = true; ";
        if (it.isTop) out += " }; return validate; ";
        return out;
    }
    if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [
            ""
        ];
        if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
            var $defaultMsg = "default is ignored in the schema root";
            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
            else throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
    } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
            if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
            $typeSchema = [
                $typeSchema,
                "null"
            ];
            $typeIsArray = true;
        }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        else if (it.opts.extendRefs !== true) {
            $refKeywords = false;
            it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
    }
    if (it.schema.$comment && it.opts.$comment) out += " " + it.RULES.all.$comment.code(it, "$comment");
    if ($typeSchema) {
        if (it.opts.coerceTypes) var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
            out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
            if ($coerceToTypes) {
                var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
                out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
                if (it.opts.coerceTypes == "array") out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
                out += " if (" + $coerced + " !== undefined) ; ";
                var arr1 = $coerceToTypes;
                if (arr1) {
                    var $type, $i = -1, l1 = arr1.length - 1;
                    while($i < l1){
                        $type = arr1[$i += 1];
                        if ($type == "string") out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                        else if ($type == "number" || $type == "integer") {
                            out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                            if ($type == "integer") out += " && !(" + $data + " % 1)";
                            out += ")) " + $coerced + " = +" + $data + "; ";
                        } else if ($type == "boolean") out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                        else if ($type == "null") out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                        else if (it.opts.coerceTypes == "array" && $type == "array") out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                    }
                }
                out += " else {   ";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                    else out += "" + $typeSchema;
                    out += "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) out += "" + $typeSchema.join(",");
                        else out += "" + $typeSchema;
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } if (" + $coerced + " !== undefined) {  ";
                var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
                out += " " + $data + " = " + $coerced + "; ";
                if (!$dataLvl) out += "if (" + $parentData + " !== undefined)";
                out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
            } else {
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                    else out += "" + $typeSchema;
                    out += "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) out += "" + $typeSchema.join(",");
                        else out += "" + $typeSchema;
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
        }
    }
    if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
            out += " } if (errors === ";
            if ($top) out += "0";
            else out += "errs_" + $lvl;
            out += ") { ";
            $closingBraces2 += "}";
        }
    } else {
        var arr2 = it.RULES;
        if (arr2) {
            var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
            while(i2 < l2){
                $rulesGroup = arr2[i2 += 1];
                if ($shouldUseGroup($rulesGroup)) {
                    if ($rulesGroup.type) out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
                    if (it.opts.useDefaults) {
                        if ($rulesGroup.type == "object" && it.schema.properties) {
                            var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                            var arr3 = $schemaKeys;
                            if (arr3) {
                                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                                while(i3 < l3){
                                    $propertyKey = arr3[i3 += 1];
                                    var $sch = $schema[$propertyKey];
                                    if ($sch.default !== undefined) {
                                        var $passData = $data + it.util.getProperty($propertyKey);
                                        if (it.compositeRule) {
                                            if (it.opts.strictDefaults) {
                                                var $defaultMsg = "default is ignored for: " + $passData;
                                                if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                                                else throw new Error($defaultMsg);
                                            }
                                        } else {
                                            out += " if (" + $passData + " === undefined ";
                                            if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
                                            out += " ) " + $passData + " = ";
                                            if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
                                            else out += " " + JSON.stringify($sch.default) + " ";
                                            out += "; ";
                                        }
                                    }
                                }
                            }
                        } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                            var arr4 = it.schema.items;
                            if (arr4) {
                                var $sch, $i = -1, l4 = arr4.length - 1;
                                while($i < l4){
                                    $sch = arr4[$i += 1];
                                    if ($sch.default !== undefined) {
                                        var $passData = $data + "[" + $i + "]";
                                        if (it.compositeRule) {
                                            if (it.opts.strictDefaults) {
                                                var $defaultMsg = "default is ignored for: " + $passData;
                                                if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                                                else throw new Error($defaultMsg);
                                            }
                                        } else {
                                            out += " if (" + $passData + " === undefined ";
                                            if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
                                            out += " ) " + $passData + " = ";
                                            if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
                                            else out += " " + JSON.stringify($sch.default) + " ";
                                            out += "; ";
                                        }
                                    }
                                }
                            }
                        }
                    }
                    var arr5 = $rulesGroup.rules;
                    if (arr5) {
                        var $rule, i5 = -1, l5 = arr5.length - 1;
                        while(i5 < l5){
                            $rule = arr5[i5 += 1];
                            if ($shouldUseRule($rule)) {
                                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                                if ($code) {
                                    out += " " + $code + " ";
                                    if ($breakOnError) $closingBraces1 += "}";
                                }
                            }
                        }
                    }
                    if ($breakOnError) {
                        out += " " + $closingBraces1 + " ";
                        $closingBraces1 = "";
                    }
                    if ($rulesGroup.type) {
                        out += " } ";
                        if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                            out += " else { ";
                            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ""; /* istanbul ignore else */ 
                            if (it.createErrors !== false) {
                                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                                if ($typeIsArray) out += "" + $typeSchema.join(",");
                                else out += "" + $typeSchema;
                                out += "' } ";
                                if (it.opts.messages !== false) {
                                    out += " , message: 'should be ";
                                    if ($typeIsArray) out += "" + $typeSchema.join(",");
                                    else out += "" + $typeSchema;
                                    out += "' ";
                                }
                                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                                out += " } ";
                            } else out += " {} ";
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                                else out += " validate.errors = [" + __err + "]; return false; ";
                            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                            out += " } ";
                        }
                    }
                    if ($breakOnError) {
                        out += " if (errors === ";
                        if ($top) out += "0";
                        else out += "errs_" + $lvl;
                        out += ") { ";
                        $closingBraces2 += "}";
                    }
                }
            }
        }
    }
    if ($breakOnError) out += " " + $closingBraces2 + " ";
    if ($top) {
        if ($async) {
            out += " if (errors === 0) return data;           ";
            out += " else throw new ValidationError(vErrors); ";
        } else {
            out += " validate.errors = vErrors; ";
            out += " return errors === 0;       ";
        }
        out += " }; return validate;";
    } else out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    function $shouldUseGroup($rulesGroup) {
        var rules = $rulesGroup.rules;
        for(var i = 0; i < rules.length; i++)if ($shouldUseRule(rules[i])) return true;
    }
    function $shouldUseRule($rule) {
        return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
    }
    function $ruleImplementsSomeKeyword($rule) {
        var impl = $rule.implements;
        for(var i = 0; i < impl.length; i++)if (it.schema[impl[i]] !== undefined) return true;
    }
    return out;
};

},{}],"6QdJ9":[function(require,module,exports) {
"use strict";
var Cache = module.exports = function Cache() {
    this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
};

},{}],"bJBRk":[function(require,module,exports) {
"use strict";
var util = require("a2faed526b64ac6");
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [
    0,
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util.copy(formats[mode]);
}
formats.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: UUID,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": RELATIVE_JSON_POINTER
};
formats.full = {
    date: date,
    time: time,
    "date-time": date_time,
    uri: uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
        new RegExp(str);
        return true;
    } catch (e) {
        return false;
    }
}

},{"a2faed526b64ac6":"bXWQH"}],"bZh8w":[function(require,module,exports) {
"use strict";
var ruleModules = require("320fad79ae8493c7"), toHash = require("8ce0e99024dd72ae").toHash;
module.exports = function rules() {
    var RULES = [
        {
            type: "number",
            rules: [
                {
                    "maximum": [
                        "exclusiveMaximum"
                    ]
                },
                {
                    "minimum": [
                        "exclusiveMinimum"
                    ]
                },
                "multipleOf",
                "format"
            ]
        },
        {
            type: "string",
            rules: [
                "maxLength",
                "minLength",
                "pattern",
                "format"
            ]
        },
        {
            type: "array",
            rules: [
                "maxItems",
                "minItems",
                "items",
                "contains",
                "uniqueItems"
            ]
        },
        {
            type: "object",
            rules: [
                "maxProperties",
                "minProperties",
                "required",
                "dependencies",
                "propertyNames",
                {
                    "properties": [
                        "additionalProperties",
                        "patternProperties"
                    ]
                }
            ]
        },
        {
            rules: [
                "$ref",
                "const",
                "enum",
                "not",
                "anyOf",
                "oneOf",
                "allOf",
                "if"
            ]
        }
    ];
    var ALL = [
        "type",
        "$comment"
    ];
    var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
    ];
    var TYPES = [
        "number",
        "integer",
        "string",
        "array",
        "object",
        "boolean",
        "null"
    ];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
            var implKeywords;
            if (typeof keyword == "object") {
                var key = Object.keys(keyword)[0];
                implKeywords = keyword[key];
                keyword = key;
                implKeywords.forEach(function(k) {
                    ALL.push(k);
                    RULES.all[k] = true;
                });
            }
            ALL.push(keyword);
            var rule = RULES.all[keyword] = {
                keyword: keyword,
                code: ruleModules[keyword],
                implements: implKeywords
            };
            return rule;
        });
        RULES.all.$comment = {
            keyword: "$comment",
            code: ruleModules.$comment
        };
        if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
};

},{"320fad79ae8493c7":"hNsm7","8ce0e99024dd72ae":"bXWQH"}],"hNsm7":[function(require,module,exports) {
"use strict";
//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
    "$ref": require("b78d457e7afd64bb"),
    allOf: require("48b34d085e3ec99e"),
    anyOf: require("391b436b4af2f7be"),
    "$comment": require("cf4e7ee5e0296fb8"),
    const: require("4d4c491d625674ab"),
    contains: require("88a4b137152f067d"),
    dependencies: require("74b02ee6cab2c47e"),
    "enum": require("be60ff2180bfa23"),
    format: require("8c9714d616d1ed0a"),
    "if": require("5adbc4b502609522"),
    items: require("c7646594fda72068"),
    maximum: require("38a39307400a1be1"),
    minimum: require("38a39307400a1be1"),
    maxItems: require("bc10152125d4a5ad"),
    minItems: require("bc10152125d4a5ad"),
    maxLength: require("7c37752877e496f4"),
    minLength: require("7c37752877e496f4"),
    maxProperties: require("b93ee89a9995ea2e"),
    minProperties: require("b93ee89a9995ea2e"),
    multipleOf: require("22b153b53f98c24a"),
    not: require("7b5c836b893a7a0d"),
    oneOf: require("753ea2f532bfe6f9"),
    pattern: require("339cd9d78fdcc133"),
    properties: require("5528eda3a7169306"),
    propertyNames: require("9b21f26c2748ece9"),
    required: require("6d833c3f730abbb0"),
    uniqueItems: require("db1334fb636c8b52"),
    validate: require("75546f50e533d308")
};

},{"b78d457e7afd64bb":"9UHvA","48b34d085e3ec99e":"2HcQW","391b436b4af2f7be":"81lnt","cf4e7ee5e0296fb8":"95g0Y","4d4c491d625674ab":"2uSzM","88a4b137152f067d":"3YULK","74b02ee6cab2c47e":"XM7QB","be60ff2180bfa23":"feBdm","8c9714d616d1ed0a":"jBKEp","5adbc4b502609522":"ibGkV","c7646594fda72068":"eM8X9","38a39307400a1be1":"g43aN","bc10152125d4a5ad":"23KTc","7c37752877e496f4":"8mb3k","b93ee89a9995ea2e":"e7j0q","22b153b53f98c24a":"4UMFT","7b5c836b893a7a0d":"2tc1f","753ea2f532bfe6f9":"E1aup","339cd9d78fdcc133":"3ISsR","5528eda3a7169306":"jkeTR","9b21f26c2748ece9":"6jF0e","6d833c3f730abbb0":"bbInV","db1334fb636c8b52":"1fSfs","75546f50e533d308":"9i9eI"}],"9UHvA":[function(require,module,exports) {
"use strict";
module.exports = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
            $async = it.async;
            $refCode = "validate";
        } else {
            $async = it.root.schema.$async === true;
            $refCode = "root.refVal[0]";
        }
    } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === undefined) {
            var $message = it.MissingRefError.message(it.baseId, $schema);
            if (it.opts.missingRefs == "fail") {
                it.logger.error($message);
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
                    if (it.opts.messages !== false) out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
                    if (it.opts.verbose) out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                if ($breakOnError) out += " if (false) { ";
            } else if (it.opts.missingRefs == "ignore") {
                it.logger.warn($message);
                if ($breakOnError) out += " if (true) { ";
            } else throw new it.MissingRefError(it.baseId, $schema, $message);
        } else if ($refVal.inline) {
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            $it.schema = $refVal.schema;
            $it.schemaPath = "";
            $it.errSchemaPath = $schema;
            var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
            out += " " + $code + " ";
            if ($breakOnError) out += " if (" + $nextValid + ") { ";
        } else {
            $async = $refVal.$async === true || it.async && $refVal.$async !== false;
            $refCode = $refVal.code;
        }
    }
    if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) out += " " + $refCode + ".call(this, ";
        else out += " " + $refCode + "( ";
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') out += " + " + it.errorPath;
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
            if (!it.async) throw new Error("async schema referenced by sync schema");
            if ($breakOnError) out += " var " + $valid + "; ";
            out += " try { await " + __callValidate + "; ";
            if ($breakOnError) out += " " + $valid + " = true; ";
            out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
            if ($breakOnError) out += " " + $valid + " = false; ";
            out += " } ";
            if ($breakOnError) out += " if (" + $valid + ") { ";
        } else {
            out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
            if ($breakOnError) out += " else { ";
        }
    }
    return out;
};

},{}],"2HcQW":[function(require,module,exports) {
"use strict";
module.exports = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while($i < l1){
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $allSchemasEmpty = false;
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                }
            }
        }
    }
    if ($breakOnError) {
        if ($allSchemasEmpty) out += " if (true) { ";
        else out += " " + $closingBraces.slice(0, -1) + " ";
    }
    return out;
};

},{}],"81lnt":[function(require,module,exports) {
"use strict";
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema.every(function($sch) {
        return it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all);
    });
    if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while($i < l1){
                $sch = arr1[$i += 1];
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
                out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
                $closingBraces += "}";
            }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should match some schema in anyOf' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) out += " } ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"95g0Y":[function(require,module,exports) {
"use strict";
module.exports = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema);
    if (it.opts.$comment === true) out += " console.log(" + $comment + ");";
    else if (typeof it.opts.$comment == "function") out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    return out;
};

},{}],"2uSzM":[function(require,module,exports) {
"use strict";
module.exports = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!$isData) out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) out += " , message: 'should be equal to constant' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " }";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"3YULK":[function(require,module,exports) {
"use strict";
module.exports = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else out += " if (" + $data + ".length == 0) {";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) out += " , message: 'should contain a valid item' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } else { ";
    if ($nonEmptySchema) out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) out += " } ";
    return out;
};

},{}],"XM7QB":[function(require,module,exports) {
"use strict";
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for($property in $schema){
        if ($property == "__proto__") continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for(var $property in $propertyDeps){
        $deps = $propertyDeps[$property];
        if ($deps.length) {
            out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            if ($breakOnError) {
                out += " && ( ";
                var arr1 = $deps;
                if (arr1) {
                    var $propertyKey, $i = -1, l1 = arr1.length - 1;
                    while($i < l1){
                        $propertyKey = arr1[$i += 1];
                        if ($i) out += " || ";
                        var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                        out += " ( ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                    }
                }
                out += ")) {  ";
                var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: 'should have ";
                        if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
                        else out += "properties " + it.util.escapeQuotes($deps.join(", "));
                        out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            } else {
                out += " ) { ";
                var arr2 = $deps;
                if (arr2) {
                    var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                    while(i2 < l2){
                        $propertyKey = arr2[i2 += 1];
                        var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                        if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                        out += " if ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") {  var err =   "; /* istanbul ignore else */ 
                        if (it.createErrors !== false) {
                            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                            if (it.opts.messages !== false) {
                                out += " , message: 'should have ";
                                if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
                                else out += "properties " + it.util.escapeQuotes($deps.join(", "));
                                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                            }
                            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                            out += " } ";
                        } else out += " {} ";
                        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                    }
                }
            }
            out += " }   ";
            if ($breakOnError) {
                $closingBraces += "}";
                out += " else { ";
            }
        }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for(var $property in $schemaDeps){
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            out += ") { ";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + it.util.getProperty($property);
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " }  ";
            if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
            }
        }
    }
    if ($breakOnError) out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"feBdm":[function(require,module,exports) {
"use strict";
module.exports = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    out += "var " + $valid + ";";
    if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) out += "  }  ";
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) out += " , message: 'should be equal to one of the allowed values' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " }";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"jBKEp":[function(require,module,exports) {
"use strict";
module.exports = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
        if ($breakOnError) out += " if (true) { ";
        return out;
    }
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) out += " var async" + $lvl + " = " + $format + ".async; ";
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        out += " (";
        if ($unknownFormats != "ignore") {
            out += " (" + $schemaValue + " && !" + $format + " ";
            if ($allowUnknown) out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
            out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        else out += " " + $format + "(" + $data + ") ";
        out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
        var $format = it.formats[$schema];
        if (!$format) {
            if ($unknownFormats == "ignore") {
                it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
                if ($breakOnError) out += " if (true) { ";
                return out;
            } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
                if ($breakOnError) out += " if (true) { ";
                return out;
            } else throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
            var $async = $format.async === true;
            $format = $format.validate;
        }
        if ($formatType != $ruleType) {
            if ($breakOnError) out += " if (true) { ";
            return out;
        }
        if ($async) {
            if (!it.async) throw new Error("async format in sync schema");
            var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
            out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
            out += " if (! ";
            var $formatRef = "formats" + it.util.getProperty($schema);
            if ($isObject) $formatRef += ".validate";
            if (typeof $format == "function") out += " " + $formatRef + "(" + $data + ") ";
            else out += " " + $formatRef + ".test(" + $data + ") ";
            out += ") { ";
        }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) out += "" + $schemaValue;
        else out += "" + it.util.toQuotedString($schema);
        out += "  } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should match format \"";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + it.util.escapeQuotes($schema);
            out += "\"' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + it.util.toQuotedString($schema);
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"ibGkV":[function(require,module,exports) {
"use strict";
module.exports = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
            out += " if (" + $nextValid + ") {  ";
            $it.schema = it.schema["then"];
            $it.schemaPath = it.schemaPath + ".then";
            $it.errSchemaPath = it.errSchemaPath + "/then";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
                $ifClause = "ifClause" + $lvl;
                out += " var " + $ifClause + " = 'then'; ";
            } else $ifClause = "'then'";
            out += " } ";
            if ($elsePresent) out += " else { ";
        } else out += " if (!" + $nextValid + ") { ";
        if ($elsePresent) {
            $it.schema = it.schema["else"];
            $it.schemaPath = it.schemaPath + ".else";
            $it.errSchemaPath = it.errSchemaPath + "/else";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
                $ifClause = "ifClause" + $lvl;
                out += " var " + $ifClause + " = 'else'; ";
            } else $ifClause = "'else'";
            out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
            if (it.opts.messages !== false) out += " , message: 'should match \"' + " + $ifClause + " + '\" schema' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        out += " }   ";
        if ($breakOnError) out += " else { ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"eM8X9":[function(require,module,exports) {
"use strict";
module.exports = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
            out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ""; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
                if (it.opts.messages !== false) out += " , message: 'should NOT have more than " + $schema.length + " items' ";
                if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                else out += " validate.errors = [" + __err + "]; return false; ";
            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            out += " } ";
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
                $closingBraces += "}";
                out += " else { ";
            }
        }
        var arr1 = $schema;
        if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while($i < l1){
                $sch = arr1[$i += 1];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
                    var $passData = $data + "[" + $i + "]";
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + "[" + $i + "]";
                    $it.errSchemaPath = $errSchemaPath + "/" + $i;
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                    $it.dataPathArr[$dataNxt] = $i;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    out += " }  ";
                    if ($breakOnError) {
                        out += " if (" + $nextValid + ") { ";
                        $closingBraces += "}";
                    }
                }
            }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
            $it.schema = $additionalItems;
            $it.schemaPath = it.schemaPath + ".additionalItems";
            $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
            var $passData = $data + "[" + $idx + "]";
            $it.dataPathArr[$dataNxt] = $idx;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
            out += " } }  ";
            if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
            }
        }
    } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
        out += " }";
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"g43aN":[function(require,module,exports) {
"use strict";
module.exports = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = undefined;
    if (!($isData || typeof $schema == "number" || $schema === undefined)) throw new Error($keyword + " must be number");
    if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) throw new Error($exclusiveKeyword + " must be number or boolean");
    if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } else if ( ";
        if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === undefined) {
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaValueExcl;
            $isData = $isDataExcl;
        }
    } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
            if ($exclIsNumber && $schema === undefined) {
                $exclusive = true;
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                $schemaValue = $schemaExcl;
                $notOp += "=";
            } else {
                if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
                if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                    $exclusive = true;
                    $errorKeyword = $exclusiveKeyword;
                    $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                    $notOp += "=";
                } else {
                    $exclusive = false;
                    $opStr += "=";
                }
            }
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should be " + $opStr + " ";
            if ($isData) out += "' + " + $schemaValue;
            else out += "" + $schemaValue + "'";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += " } ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"23KTc":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxItems") out += "more";
            else out += "fewer";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " items' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"8mb3k":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    if (it.opts.unicode === false) out += " " + $data + ".length ";
    else out += " ucs2length(" + $data + ") ";
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT be ";
            if ($keyword == "maxLength") out += "longer";
            else out += "shorter";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " characters' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"e7j0q":[function(require,module,exports) {
"use strict";
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxProperties") out += "more";
            else out += "fewer";
            out += " than ";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + $schema;
            out += " properties' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"4UMFT":[function(require,module,exports) {
"use strict";
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
    out += "var division" + $lvl + ";if (";
    if ($isData) out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    else out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    out += " ) ";
    if ($isData) out += "  )  ";
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should be multiple of ";
            if ($isData) out += "' + " + $schemaValue;
            else out += "" + $schemaValue + "'";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + $schema;
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"2tc1f":[function(require,module,exports) {
"use strict";
module.exports = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
            $allErrorsOption = $it.opts.allErrors;
            $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) out += " } ";
    } else {
        out += "  var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) out += " if (false) { ";
    }
    return out;
};

},{}],"E1aup":[function(require,module,exports) {
"use strict";
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while($i < l1){
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                out += "  " + it.validate($it) + " ";
                $it.baseId = $currentBaseId;
            } else out += " var " + $nextValid + " = true; ";
            if ($i) {
                out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
                $closingBraces += "}";
            }
            out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   "; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) out += " , message: 'should match exactly one schema in oneOf' ";
        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        out += " } ";
    } else out += " {} ";
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
        else out += " validate.errors = vErrors; return false; ";
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) out += " } ";
    return out;
};

},{}],"3ISsR":[function(require,module,exports) {
"use strict";
module.exports = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
    out += "if ( ";
    if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ""; /* istanbul ignore else */ 
    if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) out += "" + $schemaValue;
        else out += "" + it.util.toQuotedString($schema);
        out += "  } ";
        if (it.opts.messages !== false) {
            out += " , message: 'should match pattern \"";
            if ($isData) out += "' + " + $schemaValue + " + '";
            else out += "" + it.util.escapeQuotes($schema);
            out += "\"' ";
        }
        if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) out += "validate.schema" + $schemaPath;
            else out += "" + it.util.toQuotedString($schema);
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
    } else out += " {} ";
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
        else out += " validate.errors = [" + __err + "]; return false; ";
    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    out += "} ";
    if ($breakOnError) out += " else { ";
    return out;
};

},{}],"jkeTR":[function(require,module,exports) {
"use strict";
module.exports = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
    function notProto(p) {
        return p !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) out += " var " + $dataProperties + " = undefined;";
    if ($checkAdditional) {
        if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        else out += " for (var " + $key + " in " + $data + ") { ";
        if ($someProperties) {
            out += " var isAdditional" + $lvl + " = !(false ";
            if ($schemaKeys.length) {
                if ($schemaKeys.length > 8) out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
                else {
                    var arr1 = $schemaKeys;
                    if (arr1) {
                        var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                        while(i1 < l1){
                            $propertyKey = arr1[i1 += 1];
                            out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                        }
                    }
                }
            }
            if ($pPropertyKeys.length) {
                var arr2 = $pPropertyKeys;
                if (arr2) {
                    var $pProperty, $i = -1, l2 = arr2.length - 1;
                    while($i < l2){
                        $pProperty = arr2[$i += 1];
                        out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
                    }
                }
            }
            out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") out += " delete " + $data + "[" + $key + "]; ";
        else {
            var $currentErrorPath = it.errorPath;
            var $additionalProperty = "' + " + $key + " + '";
            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            if ($noAdditional) {
                if ($removeAdditional) out += " delete " + $data + "[" + $key + "]; ";
                else {
                    out += " " + $nextValid + " = false; ";
                    var $currErrSchemaPath = $errSchemaPath;
                    $errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ""; /* istanbul ignore else */ 
                    if (it.createErrors !== false) {
                        out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                        if (it.opts.messages !== false) {
                            out += " , message: '";
                            if (it.opts._errorDataPathProperty) out += "is an invalid additional property";
                            else out += "should NOT have additional properties";
                            out += "' ";
                        }
                        if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                        out += " } ";
                    } else out += " {} ";
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                        /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                        else out += " validate.errors = [" + __err + "]; return false; ";
                    } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    $errSchemaPath = $currErrSchemaPath;
                    if ($breakOnError) out += " break; ";
                }
            } else if ($additionalIsSchema) {
                if ($removeAdditional == "failing") {
                    out += " var " + $errs + " = errors;  ";
                    var $wasComposite = it.compositeRule;
                    it.compositeRule = $it.compositeRule = true;
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
                    it.compositeRule = $it.compositeRule = $wasComposite;
                } else {
                    $it.schema = $aProperties;
                    $it.schemaPath = it.schemaPath + ".additionalProperties";
                    $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                    $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
                }
            }
            it.errorPath = $currentErrorPath;
        }
        if ($someProperties) out += " } ";
        out += " }  ";
        if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
        }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while(i3 < l3){
                $propertyKey = arr3[i3 += 1];
                var $sch = $schema[$propertyKey];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== undefined;
                    $it.schema = $sch;
                    $it.schemaPath = $schemaPath + $prop;
                    $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
                    $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                    $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) {
                        $code = it.util.varReplace($code, $nextData, $passData);
                        var $useData = $passData;
                    } else {
                        var $useData = $nextData;
                        out += " var " + $nextData + " = " + $passData + "; ";
                    }
                    if ($hasDefault) out += " " + $code + " ";
                    else {
                        if ($requiredHash && $requiredHash[$propertyKey]) {
                            out += " if ( " + $useData + " === undefined ";
                            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += ") { " + $nextValid + " = false; ";
                            var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                            $errSchemaPath = it.errSchemaPath + "/required";
                            var $$outStack = $$outStack || [];
                            $$outStack.push(out);
                            out = ""; /* istanbul ignore else */ 
                            if (it.createErrors !== false) {
                                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                                if (it.opts.messages !== false) {
                                    out += " , message: '";
                                    if (it.opts._errorDataPathProperty) out += "is a required property";
                                    else out += "should have required property \\'" + $missingProperty + "\\'";
                                    out += "' ";
                                }
                                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                                out += " } ";
                            } else out += " {} ";
                            var __err = out;
                            out = $$outStack.pop();
                            if (!it.compositeRule && $breakOnError) {
                                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                                else out += " validate.errors = [" + __err + "]; return false; ";
                            } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                            $errSchemaPath = $currErrSchemaPath;
                            it.errorPath = $currentErrorPath;
                            out += " } else { ";
                        } else if ($breakOnError) {
                            out += " if ( " + $useData + " === undefined ";
                            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += ") { " + $nextValid + " = true; } else { ";
                        } else {
                            out += " if (" + $useData + " !== undefined ";
                            if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                            out += " ) { ";
                        }
                        out += " " + $code + " } ";
                    }
                }
                if ($breakOnError) {
                    out += " if (" + $nextValid + ") { ";
                    $closingBraces += "}";
                }
            }
        }
    }
    if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
            var $pProperty, i4 = -1, l4 = arr4.length - 1;
            while(i4 < l4){
                $pProperty = arr4[i4 += 1];
                var $sch = $pProperties[$pProperty];
                if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                    $it.schema = $sch;
                    $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
                    $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
                    if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
                    else out += " for (var " + $key + " in " + $data + ") { ";
                    out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
                    $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                    var $passData = $data + "[" + $key + "]";
                    $it.dataPathArr[$dataNxt] = $key;
                    var $code = it.validate($it);
                    $it.baseId = $currentBaseId;
                    if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                    else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                    if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
                    out += " } ";
                    if ($breakOnError) out += " else " + $nextValid + " = true; ";
                    out += " }  ";
                    if ($breakOnError) {
                        out += " if (" + $nextValid + ") { ";
                        $closingBraces += "}";
                    }
                }
            }
        }
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"6jF0e":[function(require,module,exports) {
"use strict";
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) out += " var " + $dataProperties + " = undefined; ";
        if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        else out += " for (var " + $key + " in " + $data + ") { ";
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   "; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
            if (it.opts.messages !== false) out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
            else out += " validate.errors = vErrors; return false; ";
        }
        if ($breakOnError) out += " break; ";
        out += " } }";
    }
    if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    return out;
};

},{}],"bbInV":[function(require,module,exports) {
"use strict";
module.exports = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
            var $required = [];
            var arr1 = $schema;
            if (arr1) {
                var $property, i1 = -1, l1 = arr1.length - 1;
                while(i1 < l1){
                    $property = arr1[i1 += 1];
                    var $propertySch = it.schema.properties[$property];
                    if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) $required[$required.length] = $property;
                }
            }
        } else var $required = $schema;
    }
    if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
            out += " var missing" + $lvl + "; ";
            if ($loopRequired) {
                if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
                var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                out += " var " + $valid + " = true; ";
                if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
                out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
                if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
                out += "; if (!" + $valid + ") break; } ";
                if ($isData) out += "  }  ";
                out += "  if (!" + $valid + ") {   ";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } else { ";
            } else {
                out += " if ( ";
                var arr2 = $required;
                if (arr2) {
                    var $propertyKey, $i = -1, l2 = arr2.length - 1;
                    while($i < l2){
                        $propertyKey = arr2[$i += 1];
                        if ($i) out += " || ";
                        var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                        out += " ( ( " + $useData + " === undefined ";
                        if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                        out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                    }
                }
                out += ") {  ";
                var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
                if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ""; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
                    else out += " validate.errors = [" + __err + "]; return false; ";
                } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                out += " } else { ";
            }
        } else if ($loopRequired) {
            if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            if ($isData) {
                out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   "; /* istanbul ignore else */ 
                if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) out += "is a required property";
                        else out += "should have required property \\'" + $missingProperty + "\\'";
                        out += "' ";
                    }
                    if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    out += " } ";
                } else out += " {} ";
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            out += ") {  var err =   "; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) out += "is a required property";
                    else out += "should have required property \\'" + $missingProperty + "\\'";
                    out += "' ";
                }
                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) out += "  }  ";
        } else {
            var arr3 = $required;
            if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while(i3 < l3){
                    $propertyKey = arr3[i3 += 1];
                    var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                    if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    out += ") {  var err =   "; /* istanbul ignore else */ 
                    if (it.createErrors !== false) {
                        out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                        if (it.opts.messages !== false) {
                            out += " , message: '";
                            if (it.opts._errorDataPathProperty) out += "is a required property";
                            else out += "should have required property \\'" + $missingProperty + "\\'";
                            out += "' ";
                        }
                        if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                        out += " } ";
                    } else out += " {} ";
                    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
            }
        }
        it.errorPath = $currentErrorPath;
    } else if ($breakOnError) out += " if (true) {";
    return out;
};

},{}],"1fSfs":[function(require,module,exports) {
"use strict";
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        else {
            out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
            var $method = "checkDataType" + ($typeIsArray ? "s" : "");
            out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
            if ($typeIsArray) out += " if (typeof item == 'string') item = '\"' + item; ";
            out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) out += "  }  ";
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
            if (it.opts.messages !== false) out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
            if (it.opts.verbose) {
                out += " , schema:  ";
                if ($isData) out += "validate.schema" + $schemaPath;
                else out += "" + $schema;
                out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        out += " } ";
        if ($breakOnError) out += " else { ";
    } else if ($breakOnError) out += " if (true) { ";
    return out;
};

},{}],"brIE5":[function(require,module,exports) {
"use strict";
var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
];
module.exports = function(metaSchema, keywordsJsonPointers) {
    for(var i = 0; i < keywordsJsonPointers.length; i++){
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for(j = 1; j < segments.length; j++)keywords = keywords[segments[j]];
        for(j = 0; j < KEYWORDS.length; j++){
            var key = KEYWORDS[j];
            var schema = keywords[key];
            if (schema) keywords[key] = {
                anyOf: [
                    schema,
                    {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }
                ]
            };
        }
    }
    return metaSchema;
};

},{}],"6gt4e":[function(require,module,exports) {
"use strict";
var MissingRefError = require("a18ea71e70251293").MissingRef;
module.exports = compileAsync;
/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */ function compileAsync(schema, meta, callback) {
    /* eslint no-shadow: 0 */ /* global Promise */ /* jshint validthis: true */ var self = this;
    if (typeof this._opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
        callback = meta;
        meta = undefined;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self._addSchema(schema, undefined, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) p.then(function(v) {
        callback(null, v);
    }, callback);
    return p;
    function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema) ? compileAsync.call(self, {
            $ref: $schema
        }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
        try {
            return self._compile(schemaObj);
        } catch (e) {
            if (e instanceof MissingRefError) return loadMissingSchema(e);
            throw e;
        }
        function loadMissingSchema(e) {
            var ref = e.missingSchema;
            if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
            var schemaPromise = self._loadingSchemas[ref];
            if (!schemaPromise) {
                schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
                schemaPromise.then(removePromise, removePromise);
            }
            return schemaPromise.then(function(sch) {
                if (!added(ref)) return loadMetaSchemaOf(sch).then(function() {
                    if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
                });
            }).then(function() {
                return _compileAsync(schemaObj);
            });
            function removePromise() {
                delete self._loadingSchemas[ref];
            }
            function added(ref) {
                return self._refs[ref] || self._schemas[ref];
            }
        }
    }
}

},{"a18ea71e70251293":"2CCBr"}],"bUesF":[function(require,module,exports) {
"use strict";
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require("2eb02720cefc34c7");
var definitionSchema = require("3e1481dcb7c8ff2f");
module.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
};
/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */ function addKeyword(keyword, definition) {
    /* jshint validthis: true */ /* eslint no-shadow: 0 */ var RULES = this.RULES;
    if (RULES.keywords[keyword]) throw new Error("Keyword " + keyword + " is already defined");
    if (!IDENTIFIER.test(keyword)) throw new Error("Keyword " + keyword + " is not a valid identifier");
    if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) for(var i = 0; i < dataType.length; i++)_addRule(keyword, dataType[i], definition);
        else _addRule(keyword, dataType, definition);
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
            if (definition.$data && this._opts.$data) metaSchema = {
                anyOf: [
                    metaSchema,
                    {
                        "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }
                ]
            };
            definition.validateSchema = this.compile(metaSchema, true);
        }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword, dataType, definition) {
        var ruleGroup;
        for(var i = 0; i < RULES.length; i++){
            var rg = RULES[i];
            if (rg.type == dataType) {
                ruleGroup = rg;
                break;
            }
        }
        if (!ruleGroup) {
            ruleGroup = {
                type: dataType,
                rules: []
            };
            RULES.push(ruleGroup);
        }
        var rule = {
            keyword: keyword,
            definition: definition,
            custom: true,
            code: customRuleCode,
            implements: definition.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword] = rule;
    }
    return this;
}
/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */ function getKeyword(keyword) {
    /* jshint validthis: true */ var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */ function removeKeyword(keyword) {
    /* jshint validthis: true */ var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for(var i = 0; i < RULES.length; i++){
        var rules = RULES[i].rules;
        for(var j = 0; j < rules.length; j++)if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
        }
    }
    return this;
}
/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */ function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition)) return true;
    validateKeyword.errors = v.errors;
    if (throwError) throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else return false;
}

},{"2eb02720cefc34c7":"bEt8E","3e1481dcb7c8ff2f":"7qT17"}],"bEt8E":[function(require,module,exports) {
"use strict";
module.exports = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
    } else $schemaValue = $schema;
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) out += "" + $ruleErrs + " = null;";
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
            $closingBraces += "}";
            out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
    }
    if ($inline) {
        if ($rDef.statements) out += " " + $ruleValidate.validate + " ";
        else out += " " + $valid + " = " + $ruleValidate.validate + "; ";
    } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
    } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) out += "this";
        else out += "self";
        if ($compile || $rDef.schema === false) out += " , " + $data + " ";
        else out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        out += " , (dataPath || '')";
        if (it.errorPath != '""') out += " + " + it.errorPath;
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
            out += " " + $valid + " = ";
            if ($asyncKeyword) out += "await ";
            out += "" + def_callRuleValidate + "; ";
        } else if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
    }
    if ($rDef.modifying) out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    out += "" + $closingBraces;
    if ($rDef.valid) {
        if ($breakOnError) out += " if (true) { ";
    } else {
        out += " if ( ";
        if ($rDef.valid === undefined) {
            out += " !";
            if ($macro) out += "" + $nextValid;
            else out += "" + $valid;
        } else out += " " + !$rDef.valid + " ";
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ""; /* istanbul ignore else */ 
        if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
            if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            out += " } ";
        } else out += " {} ";
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */ if (it.async) out += " throw new ValidationError([" + __err + "]); ";
            else out += " validate.errors = [" + __err + "]; return false; ";
        } else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
            if ($rDef.errors) {
                if ($rDef.errors != "full") {
                    out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                    if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                    out += " } ";
                }
            } else if ($rDef.errors === false) out += " " + def_customError + " ";
            else {
                out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                out += " } } ";
            }
        } else if ($macro) {
            out += "   var err =   "; /* istanbul ignore else */ 
            if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
                if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
                if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                out += " } ";
            } else out += " {} ";
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */ if (it.async) out += " throw new ValidationError(vErrors); ";
                else out += " validate.errors = vErrors; return false; ";
            }
        } else if ($rDef.errors === false) out += " " + def_customError + " ";
        else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            out += " } } else { " + def_customError + " } ";
        }
        out += " } ";
        if ($breakOnError) out += " else { ";
    }
    return out;
};

},{}],"7qT17":[function(require,module,exports) {
"use strict";
var metaSchema = require("56b1049aa06f7c21");
module.exports = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
        schema: [
            "validate"
        ],
        $data: [
            "validate"
        ],
        statements: [
            "inline"
        ],
        valid: {
            not: {
                required: [
                    "macro"
                ]
            }
        }
    },
    properties: {
        type: metaSchema.properties.type,
        schema: {
            type: "boolean"
        },
        statements: {
            type: "boolean"
        },
        dependencies: {
            type: "array",
            items: {
                type: "string"
            }
        },
        metaSchema: {
            type: "object"
        },
        modifying: {
            type: "boolean"
        },
        valid: {
            type: "boolean"
        },
        $data: {
            type: "boolean"
        },
        async: {
            type: "boolean"
        },
        errors: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    const: "full"
                }
            ]
        }
    }
};

},{"56b1049aa06f7c21":"66Yv9"}],"66Yv9":[function(require,module,exports) {
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

},{}],"8zgol":[function(require,module,exports) {
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

},{}],"630Jy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SSEClientTransport = exports.SseError = void 0;
const eventsource_1 = require("a061df00f9f5f87");
const types_js_1 = require("ead8e3b10b8466e6");
const auth_js_1 = require("64b720d250a30bca");
class SseError extends Error {
    constructor(code, message, event){
        super(`SSE error: ${message}`);
        this.code = code;
        this.event = event;
    }
}
exports.SseError = SseError;
/**
 * Client transport for SSE: this will connect to a server using Server-Sent Events for receiving
 * messages and make separate POST requests for sending messages.
 */ class SSEClientTransport {
    constructor(url, opts){
        this._url = url;
        this._resourceMetadataUrl = undefined;
        this._eventSourceInit = opts === null || opts === void 0 ? void 0 : opts.eventSourceInit;
        this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
        this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
        this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
    }
    async _authThenStart() {
        var _a;
        if (!this._authProvider) throw new auth_js_1.UnauthorizedError("No auth provider");
        let result;
        try {
            result = await (0, auth_js_1.auth)(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch
            });
        } catch (error) {
            (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
            throw error;
        }
        if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError();
        return await this._startOrAuth();
    }
    async _commonHeaders() {
        var _a;
        const headers = {};
        if (this._authProvider) {
            const tokens = await this._authProvider.tokens();
            if (tokens) headers["Authorization"] = `Bearer ${tokens.access_token}`;
        }
        if (this._protocolVersion) headers["mcp-protocol-version"] = this._protocolVersion;
        return new Headers({
            ...headers,
            ...(_a = this._requestInit) === null || _a === void 0 ? void 0 : _a.headers
        });
    }
    _startOrAuth() {
        var _a, _b, _c;
        const fetchImpl = (_c = (_b = (_a = this === null || this === void 0 ? void 0 : this._eventSourceInit) === null || _a === void 0 ? void 0 : _a.fetch) !== null && _b !== void 0 ? _b : this._fetch) !== null && _c !== void 0 ? _c : fetch;
        return new Promise((resolve, reject)=>{
            this._eventSource = new eventsource_1.EventSource(this._url.href, {
                ...this._eventSourceInit,
                fetch: async (url, init)=>{
                    const headers = await this._commonHeaders();
                    headers.set("Accept", "text/event-stream");
                    const response = await fetchImpl(url, {
                        ...init,
                        headers
                    });
                    if (response.status === 401 && response.headers.has("www-authenticate")) this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
                    return response;
                }
            });
            this._abortController = new AbortController();
            this._eventSource.onerror = (event)=>{
                var _a;
                if (event.code === 401 && this._authProvider) {
                    this._authThenStart().then(resolve, reject);
                    return;
                }
                const error = new SseError(event.code, event.message, event);
                reject(error);
                (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
            };
            this._eventSource.onopen = ()=>{
            // The connection is open, but we need to wait for the endpoint to be received.
            };
            this._eventSource.addEventListener("endpoint", (event)=>{
                var _a;
                const messageEvent = event;
                try {
                    this._endpoint = new URL(messageEvent.data, this._url);
                    if (this._endpoint.origin !== this._url.origin) throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
                } catch (error) {
                    reject(error);
                    (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
                    this.close();
                    return;
                }
                resolve();
            });
            this._eventSource.onmessage = (event)=>{
                var _a, _b;
                const messageEvent = event;
                let message;
                try {
                    message = types_js_1.JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
                } catch (error) {
                    (_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
                    return;
                }
                (_b = this.onmessage) === null || _b === void 0 || _b.call(this, message);
            };
        });
    }
    async start() {
        if (this._eventSource) throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        return await this._startOrAuth();
    }
    /**
     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
     */ async finishAuth(authorizationCode) {
        if (!this._authProvider) throw new auth_js_1.UnauthorizedError("No auth provider");
        const result = await (0, auth_js_1.auth)(this._authProvider, {
            serverUrl: this._url,
            authorizationCode,
            resourceMetadataUrl: this._resourceMetadataUrl,
            fetchFn: this._fetch
        });
        if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError("Failed to authorize");
    }
    async close() {
        var _a, _b, _c;
        (_a = this._abortController) === null || _a === void 0 || _a.abort();
        (_b = this._eventSource) === null || _b === void 0 || _b.close();
        (_c = this.onclose) === null || _c === void 0 || _c.call(this);
    }
    async send(message) {
        var _a, _b, _c;
        if (!this._endpoint) throw new Error("Not connected");
        try {
            const headers = await this._commonHeaders();
            headers.set("content-type", "application/json");
            const init = {
                ...this._requestInit,
                method: "POST",
                headers,
                body: JSON.stringify(message),
                signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
            };
            const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._endpoint, init);
            if (!response.ok) {
                if (response.status === 401 && this._authProvider) {
                    this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
                    const result = await (0, auth_js_1.auth)(this._authProvider, {
                        serverUrl: this._url,
                        resourceMetadataUrl: this._resourceMetadataUrl,
                        fetchFn: this._fetch
                    });
                    if (result !== "AUTHORIZED") throw new auth_js_1.UnauthorizedError();
                    // Purposely _not_ awaited, so we don't call onerror twice
                    return this.send(message);
                }
                const text = await response.text().catch(()=>null);
                throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
            }
        } catch (error) {
            (_c = this.onerror) === null || _c === void 0 || _c.call(this, error);
            throw error;
        }
    }
    setProtocolVersion(version) {
        this._protocolVersion = version;
    }
}
exports.SSEClientTransport = SSEClientTransport;

},{"a061df00f9f5f87":"9furR","ead8e3b10b8466e6":"cqTxf","64b720d250a30bca":"3sJTi"}],"9furR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ErrorEvent", ()=>ErrorEvent);
parcelHelpers.export(exports, "EventSource", ()=>EventSource);
var _eventsourceParser = require("eventsource-parser");
class ErrorEvent extends Event {
    /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */ constructor(type, errorEventInitDict){
        var _a, _b;
        super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
    }
    /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */ [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        return inspect(inspectableError(this), options);
    }
    /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */ [Symbol.for("Deno.customInspect")](inspect, options) {
        return inspect(inspectableError(this), options);
    }
}
function syntaxError(message) {
    const DomException = globalThis.DOMException;
    return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
    return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
    return {
        type: err.type,
        message: err.message,
        code: err.code,
        defaultPrevented: err.defaultPrevented,
        cancelable: err.cancelable,
        timeStamp: err.timeStamp
    };
}
var __typeError = (msg)=>{
    throw TypeError(msg);
}, __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
class EventSource extends EventTarget {
    constructor(url, eventSourceInitDict){
        var _a, _b;
        super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response)=>{
            var _a2;
            __privateGet(this, _parser).reset();
            const { body, redirected, status, headers } = response;
            if (status === 204) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
                return;
            }
            if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
                return;
            }
            if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
                return;
            }
            if (__privateGet(this, _readyState) === this.CLOSED) return;
            __privateSet(this, _readyState, this.OPEN);
            const openEvent = new Event("open");
            if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
                return;
            }
            const decoder = new TextDecoder(), reader = body.getReader();
            let open = !0;
            do {
                const { done, value } = await reader.read();
                value && __privateGet(this, _parser).feed(decoder.decode(value, {
                    stream: !done
                })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
            }while (open);
        }), __privateAdd(this, _onFetchError, (err)=>{
            __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
        }), __privateAdd(this, _onEvent, (event)=>{
            typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
            const messageEvent = new MessageEvent(event.event || "message", {
                data: event.data,
                origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
                lastEventId: event.id || ""
            });
            __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
        }), __privateAdd(this, _onRetryChange, (value)=>{
            __privateSet(this, _reconnectInterval, value);
        }), __privateAdd(this, _reconnect, ()=>{
            __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
        });
        try {
            if (url instanceof URL) __privateSet(this, _url, url);
            else if (typeof url == "string") __privateSet(this, _url, new URL(url, getBaseURL()));
            else throw new Error("Invalid URL");
        } catch  {
            throw syntaxError("An invalid or illegal string was specified");
        }
        __privateSet(this, _parser, (0, _eventsourceParser.createParser)({
            onEvent: __privateGet(this, _onEvent),
            onRetry: __privateGet(this, _onRetryChange)
        })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */ get readyState() {
        return __privateGet(this, _readyState);
    }
    /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */ get url() {
        return __privateGet(this, _url).href;
    }
    /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */ get withCredentials() {
        return __privateGet(this, _withCredentials);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */ get onerror() {
        return __privateGet(this, _onError);
    }
    set onerror(value) {
        __privateSet(this, _onError, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */ get onmessage() {
        return __privateGet(this, _onMessage);
    }
    set onmessage(value) {
        __privateSet(this, _onMessage, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */ get onopen() {
        return __privateGet(this, _onOpen);
    }
    set onopen(value) {
        __privateSet(this, _onOpen, value);
    }
    addEventListener(type, listener, options) {
        const listen = listener;
        super.addEventListener(type, listen, options);
    }
    removeEventListener(type, listener, options) {
        const listen = listener;
        super.removeEventListener(type, listen, options);
    }
    /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */ close() {
        __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
    }
}
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/ connect_fn = function() {
    __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/ getRequestOptions_fn = function() {
    var _a;
    const init = {
        // [spec] Let `corsAttributeState` be `Anonymous`\u2026
        // [spec] \u2026will have their mode set to "cors"\u2026
        mode: "cors",
        redirect: "follow",
        headers: {
            Accept: "text/event-stream",
            ...__privateGet(this, _lastEventId) ? {
                "Last-Event-ID": __privateGet(this, _lastEventId)
            } : void 0
        },
        cache: "no-store",
        signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal
    };
    return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ failConnection_fn = function(message, code) {
    var _a;
    __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ scheduleReconnect_fn = function(message, code) {
    var _a;
    if (__privateGet(this, _readyState) === this.CLOSED) return;
    __privateSet(this, _readyState, this.CONNECTING);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/ EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/ EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/ EventSource.CLOSED = 2;
function getBaseURL() {
    const doc = "document" in globalThis ? globalThis.document : void 0;
    return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}

},{"eventsource-parser":"4FXrw","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"4FXrw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ParseError", ()=>ParseError);
parcelHelpers.export(exports, "createParser", ()=>createParser);
class ParseError extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
}
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = !1;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\x00") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"3sJTi":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnauthorizedError = void 0;
exports.parseErrorResponse = parseErrorResponse;
exports.auth = auth;
exports.selectResourceURL = selectResourceURL;
exports.extractResourceMetadataUrl = extractResourceMetadataUrl;
exports.discoverOAuthProtectedResourceMetadata = discoverOAuthProtectedResourceMetadata;
exports.discoverOAuthMetadata = discoverOAuthMetadata;
exports.buildDiscoveryUrls = buildDiscoveryUrls;
exports.discoverAuthorizationServerMetadata = discoverAuthorizationServerMetadata;
exports.startAuthorization = startAuthorization;
exports.exchangeAuthorization = exchangeAuthorization;
exports.refreshAuthorization = refreshAuthorization;
exports.registerClient = registerClient;
const pkce_challenge_1 = __importDefault(require("577f380df1a9847c"));
const types_js_1 = require("d1137141d2c4e193");
const auth_js_1 = require("e7f1ee2964d2231b");
const auth_js_2 = require("e7f1ee2964d2231b");
const auth_utils_js_1 = require("aebeafd3a3b920d0");
const errors_js_1 = require("404492e758091926");
class UnauthorizedError extends Error {
    constructor(message){
        super(message !== null && message !== void 0 ? message : "Unauthorized");
    }
}
exports.UnauthorizedError = UnauthorizedError;
const AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
const AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
/**
 * Determines the best client authentication method to use based on server support and client configuration.
 *
 * Priority order (highest to lowest):
 * 1. client_secret_basic (if client secret is available)
 * 2. client_secret_post (if client secret is available)
 * 3. none (for public clients)
 *
 * @param clientInformation - OAuth client information containing credentials
 * @param supportedMethods - Authentication methods supported by the authorization server
 * @returns The selected authentication method
 */ function selectClientAuthMethod(clientInformation, supportedMethods) {
    const hasClientSecret = clientInformation.client_secret !== undefined;
    // If server doesn't specify supported methods, use RFC 6749 defaults
    if (supportedMethods.length === 0) return hasClientSecret ? "client_secret_post" : "none";
    // Try methods in priority order (most secure first)
    if (hasClientSecret && supportedMethods.includes("client_secret_basic")) return "client_secret_basic";
    if (hasClientSecret && supportedMethods.includes("client_secret_post")) return "client_secret_post";
    if (supportedMethods.includes("none")) return "none";
    // Fallback: use what we have
    return hasClientSecret ? "client_secret_post" : "none";
}
/**
 * Applies client authentication to the request based on the specified method.
 *
 * Implements OAuth 2.1 client authentication methods:
 * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)
 * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)
 * - none: Public client authentication (RFC 6749 Section 2.1)
 *
 * @param method - The authentication method to use
 * @param clientInformation - OAuth client information containing credentials
 * @param headers - HTTP headers object to modify
 * @param params - URL search parameters to modify
 * @throws {Error} When required credentials are missing
 */ function applyClientAuthentication(method, clientInformation, headers, params) {
    const { client_id, client_secret } = clientInformation;
    switch(method){
        case "client_secret_basic":
            applyBasicAuth(client_id, client_secret, headers);
            return;
        case "client_secret_post":
            applyPostAuth(client_id, client_secret, params);
            return;
        case "none":
            applyPublicAuth(client_id, params);
            return;
        default:
            throw new Error(`Unsupported client authentication method: ${method}`);
    }
}
/**
 * Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)
 */ function applyBasicAuth(clientId, clientSecret, headers) {
    if (!clientSecret) throw new Error("client_secret_basic authentication requires a client_secret");
    const credentials = btoa(`${clientId}:${clientSecret}`);
    headers.set("Authorization", `Basic ${credentials}`);
}
/**
 * Applies POST body authentication (RFC 6749 Section 2.3.1)
 */ function applyPostAuth(clientId, clientSecret, params) {
    params.set("client_id", clientId);
    if (clientSecret) params.set("client_secret", clientSecret);
}
/**
 * Applies public client authentication (RFC 6749 Section 2.1)
 */ function applyPublicAuth(clientId, params) {
    params.set("client_id", clientId);
}
/**
 * Parses an OAuth error response from a string or Response object.
 *
 * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec
 * and an instance of the appropriate OAuthError subclass will be returned.
 * If parsing fails, it falls back to a generic ServerError that includes
 * the response status (if available) and original content.
 *
 * @param input - A Response object or string containing the error response
 * @returns A Promise that resolves to an OAuthError instance
 */ async function parseErrorResponse(input) {
    const statusCode = input instanceof Response ? input.status : undefined;
    const body = input instanceof Response ? await input.text() : input;
    try {
        const result = auth_js_1.OAuthErrorResponseSchema.parse(JSON.parse(body));
        const { error, error_description, error_uri } = result;
        const errorClass = errors_js_1.OAUTH_ERRORS[error] || errors_js_1.ServerError;
        return new errorClass(error_description || "", error_uri);
    } catch (error) {
        // Not a valid OAuth error response, but try to inform the user of the raw data anyway
        const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
        return new errors_js_1.ServerError(errorMessage);
    }
}
/**
 * Orchestrates the full auth flow with a server.
 *
 * This can be used as a single entry point for all authorization functionality,
 * instead of linking together the other lower-level functions in this module.
 */ async function auth(provider, options) {
    var _a, _b;
    try {
        return await authInternal(provider, options);
    } catch (error) {
        // Handle recoverable error types by invalidating credentials and retrying
        if (error instanceof errors_js_1.InvalidClientError || error instanceof errors_js_1.UnauthorizedClientError) {
            await ((_a = provider.invalidateCredentials) === null || _a === void 0 ? void 0 : _a.call(provider, "all"));
            return await authInternal(provider, options);
        } else if (error instanceof errors_js_1.InvalidGrantError) {
            await ((_b = provider.invalidateCredentials) === null || _b === void 0 ? void 0 : _b.call(provider, "tokens"));
            return await authInternal(provider, options);
        }
        // Throw otherwise
        throw error;
    }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
    let resourceMetadata;
    let authorizationServerUrl;
    try {
        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, {
            resourceMetadataUrl
        }, fetchFn);
        if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) authorizationServerUrl = resourceMetadata.authorization_servers[0];
    } catch (_a) {
    // Ignore errors and fall back to /.well-known/oauth-authorization-server
    }
    /**
     * If we don't get a valid authorization server metadata from protected resource metadata,
     * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server acts as the Authorization server.
     */ if (!authorizationServerUrl) authorizationServerUrl = serverUrl;
    const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
    const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
        fetchFn
    });
    // Handle client registration if needed
    let clientInformation = await Promise.resolve(provider.clientInformation());
    if (!clientInformation) {
        if (authorizationCode !== undefined) throw new Error("Existing OAuth client information is required when exchanging an authorization code");
        if (!provider.saveClientInformation) throw new Error("OAuth client information must be saveable for dynamic registration");
        const fullInformation = await registerClient(authorizationServerUrl, {
            metadata,
            clientMetadata: provider.clientMetadata,
            fetchFn
        });
        await provider.saveClientInformation(fullInformation);
        clientInformation = fullInformation;
    }
    // Exchange authorization code for tokens
    if (authorizationCode !== undefined) {
        const codeVerifier = await provider.codeVerifier();
        const tokens = await exchangeAuthorization(authorizationServerUrl, {
            metadata,
            clientInformation,
            authorizationCode,
            codeVerifier,
            redirectUri: provider.redirectUrl,
            resource,
            addClientAuthentication: provider.addClientAuthentication,
            fetchFn: fetchFn
        });
        await provider.saveTokens(tokens);
        return "AUTHORIZED";
    }
    const tokens = await provider.tokens();
    // Handle token refresh or new authorization
    if (tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token) try {
        // Attempt to refresh the token
        const newTokens = await refreshAuthorization(authorizationServerUrl, {
            metadata,
            clientInformation,
            refreshToken: tokens.refresh_token,
            resource,
            addClientAuthentication: provider.addClientAuthentication,
            fetchFn
        });
        await provider.saveTokens(newTokens);
        return "AUTHORIZED";
    } catch (error) {
        // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.
        if (!(error instanceof errors_js_1.OAuthError) || error instanceof errors_js_1.ServerError) ;
        else // Refresh failed for another reason, re-throw
        throw error;
    }
    const state = provider.state ? await provider.state() : undefined;
    // Start new authorization flow
    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        state,
        redirectUrl: provider.redirectUrl,
        scope: scope || provider.clientMetadata.scope,
        resource
    });
    await provider.saveCodeVerifier(codeVerifier);
    await provider.redirectToAuthorization(authorizationUrl);
    return "REDIRECT";
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
    const defaultResource = (0, auth_utils_js_1.resourceUrlFromServerUrl)(serverUrl);
    // If provider has custom validation, delegate to it
    if (provider.validateResourceURL) return await provider.validateResourceURL(defaultResource, resourceMetadata === null || resourceMetadata === void 0 ? void 0 : resourceMetadata.resource);
    // Only include resource parameter when Protected Resource Metadata is present
    if (!resourceMetadata) return undefined;
    // Validate that the metadata's resource is compatible with our request
    if (!(0, auth_utils_js_1.checkResourceAllowed)({
        requestedResource: defaultResource,
        configuredResource: resourceMetadata.resource
    })) throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
    // Prefer the resource from metadata since it's what the server is telling us to request
    return new URL(resourceMetadata.resource);
}
/**
 * Extract resource_metadata from response header.
 */ function extractResourceMetadataUrl(res) {
    const authenticateHeader = res.headers.get("WWW-Authenticate");
    if (!authenticateHeader) return undefined;
    const [type, scheme] = authenticateHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !scheme) return undefined;
    const regex = /resource_metadata="([^"]*)"/;
    const match = regex.exec(authenticateHeader);
    if (!match) return undefined;
    try {
        return new URL(match[1]);
    } catch (_a) {
        return undefined;
    }
}
/**
 * Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.
 *
 * If the server returns a 404 for the well-known endpoint, this function will
 * return `undefined`. Any other errors will be thrown as exceptions.
 */ async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
    const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
        protocolVersion: opts === null || opts === void 0 ? void 0 : opts.protocolVersion,
        metadataUrl: opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl
    });
    if (!response || response.status === 404) throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
    if (!response.ok) throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
    return auth_js_2.OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
/**
 * Helper function to handle fetch with CORS retry logic
 */ async function fetchWithCorsRetry(url, headers, fetchFn = fetch) {
    try {
        return await fetchFn(url, {
            headers
        });
    } catch (error) {
        if (error instanceof TypeError) {
            if (headers) // CORS errors come back as TypeError, retry without headers
            return fetchWithCorsRetry(url, undefined, fetchFn);
            else // We're getting CORS errors on retry too, return undefined
            return undefined;
        }
        throw error;
    }
}
/**
 * Constructs the well-known path for auth-related metadata discovery
 */ function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
    // Strip trailing slash from pathname to avoid double slashes
    if (pathname.endsWith("/")) pathname = pathname.slice(0, -1);
    return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
/**
 * Tries to discover OAuth metadata at a specific URL
 */ async function tryMetadataDiscovery(url, protocolVersion, fetchFn = fetch) {
    const headers = {
        "MCP-Protocol-Version": protocolVersion
    };
    return await fetchWithCorsRetry(url, headers, fetchFn);
}
/**
 * Determines if fallback to root discovery should be attempted
 */ function shouldAttemptFallback(response, pathname) {
    return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
/**
 * Generic function for discovering OAuth metadata with fallback support
 */ async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
    var _a, _b;
    const issuer = new URL(serverUrl);
    const protocolVersion = (_a = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a !== void 0 ? _a : types_js_1.LATEST_PROTOCOL_VERSION;
    let url;
    if (opts === null || opts === void 0 ? void 0 : opts.metadataUrl) url = new URL(opts.metadataUrl);
    else {
        // Try path-aware discovery first
        const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
        url = new URL(wellKnownPath, (_b = opts === null || opts === void 0 ? void 0 : opts.metadataServerUrl) !== null && _b !== void 0 ? _b : issuer);
        url.search = issuer.search;
    }
    let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);
    // If path-aware discovery fails with 404 and we're not already at root, try fallback to root discovery
    if (!(opts === null || opts === void 0 ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {
        const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
        response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
    }
    return response;
}
/**
 * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.
 *
 * If the server returns a 404 for the well-known endpoint, this function will
 * return `undefined`. Any other errors will be thrown as exceptions.
 *
 * @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.
 */ async function discoverOAuthMetadata(issuer, { authorizationServerUrl, protocolVersion } = {}, fetchFn = fetch) {
    if (typeof issuer === "string") issuer = new URL(issuer);
    if (!authorizationServerUrl) authorizationServerUrl = issuer;
    if (typeof authorizationServerUrl === "string") authorizationServerUrl = new URL(authorizationServerUrl);
    protocolVersion !== null && protocolVersion !== void 0 ? protocolVersion : protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION;
    const response = await discoverMetadataWithFallback(authorizationServerUrl, "oauth-authorization-server", fetchFn, {
        protocolVersion,
        metadataServerUrl: authorizationServerUrl
    });
    if (!response || response.status === 404) return undefined;
    if (!response.ok) throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
    return auth_js_2.OAuthMetadataSchema.parse(await response.json());
}
/**
 * Builds a list of discovery URLs to try for authorization server metadata.
 * URLs are returned in priority order:
 * 1. OAuth metadata at the given URL
 * 2. OAuth metadata at root (if URL has path)
 * 3. OIDC metadata endpoints
 */ function buildDiscoveryUrls(authorizationServerUrl) {
    const url = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
    const hasPath = url.pathname !== "/";
    const urlsToTry = [];
    if (!hasPath) {
        // Root path: https://example.com/.well-known/oauth-authorization-server
        urlsToTry.push({
            url: new URL("/.well-known/oauth-authorization-server", url.origin),
            type: "oauth"
        });
        // OIDC: https://example.com/.well-known/openid-configuration
        urlsToTry.push({
            url: new URL(`/.well-known/openid-configuration`, url.origin),
            type: "oidc"
        });
        return urlsToTry;
    }
    // Strip trailing slash from pathname to avoid double slashes
    let pathname = url.pathname;
    if (pathname.endsWith("/")) pathname = pathname.slice(0, -1);
    // 1. OAuth metadata at the given URL
    // Insert well-known before the path: https://example.com/.well-known/oauth-authorization-server/tenant1
    urlsToTry.push({
        url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),
        type: "oauth"
    });
    // Root path: https://example.com/.well-known/oauth-authorization-server
    urlsToTry.push({
        url: new URL("/.well-known/oauth-authorization-server", url.origin),
        type: "oauth"
    });
    // 3. OIDC metadata endpoints
    // RFC 8414 style: Insert /.well-known/openid-configuration before the path
    urlsToTry.push({
        url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),
        type: "oidc"
    });
    // OIDC Discovery 1.0 style: Append /.well-known/openid-configuration after the path
    urlsToTry.push({
        url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),
        type: "oidc"
    });
    return urlsToTry;
}
/**
 * Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata
 * and OpenID Connect Discovery 1.0 specifications.
 *
 * This function implements a fallback strategy for authorization server discovery:
 * 1. Attempts RFC 8414 OAuth metadata discovery first
 * 2. If OAuth discovery fails, falls back to OpenID Connect Discovery
 *
 * @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's
 *                                 protected resource metadata, or the MCP server's URL if the
 *                                 metadata was not found.
 * @param options - Configuration options
 * @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch
 * @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION
 * @returns Promise resolving to authorization server metadata, or undefined if discovery fails
 */ async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION } = {}) {
    const headers = {
        "MCP-Protocol-Version": protocolVersion
    };
    // Get the list of URLs to try
    const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
    // Try each URL in order
    for (const { url: endpointUrl, type } of urlsToTry){
        const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
        if (!response) continue;
        if (!response.ok) {
            // Continue looking for any 4xx response code.
            if (response.status >= 400 && response.status < 500) continue; // Try next URL
            throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
        }
        // Parse and validate based on type
        if (type === "oauth") return auth_js_2.OAuthMetadataSchema.parse(await response.json());
        else return auth_js_1.OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
    return undefined;
}
/**
 * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.
 */ async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
    let authorizationUrl;
    if (metadata) {
        authorizationUrl = new URL(metadata.authorization_endpoint);
        if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
        if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    } else authorizationUrl = new URL("/authorize", authorizationServerUrl);
    // Generate PKCE challenge
    const challenge = await (0, pkce_challenge_1.default)();
    const codeVerifier = challenge.code_verifier;
    const codeChallenge = challenge.code_challenge;
    authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
    authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
    authorizationUrl.searchParams.set("code_challenge", codeChallenge);
    authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
    authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
    if (state) authorizationUrl.searchParams.set("state", state);
    if (scope) authorizationUrl.searchParams.set("scope", scope);
    if (scope === null || scope === void 0 ? void 0 : scope.includes("offline_access")) // if the request includes the OIDC-only "offline_access" scope,
    // we need to set the prompt to "consent" to ensure the user is prompted to grant offline access
    // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess
    authorizationUrl.searchParams.append("prompt", "consent");
    if (resource) authorizationUrl.searchParams.set("resource", resource.href);
    return {
        authorizationUrl,
        codeVerifier
    };
}
/**
 * Exchanges an authorization code for an access token with the given server.
 *
 * Supports multiple client authentication methods as specified in OAuth 2.1:
 * - Automatically selects the best authentication method based on server support
 * - Falls back to appropriate defaults when server metadata is unavailable
 *
 * @param authorizationServerUrl - The authorization server's base URL
 * @param options - Configuration object containing client info, auth code, etc.
 * @returns Promise resolving to OAuth tokens
 * @throws {Error} When token exchange fails or authentication is invalid
 */ async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
    var _a;
    const grantType = "authorization_code";
    const tokenUrl = (metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
    if ((metadata === null || metadata === void 0 ? void 0 : metadata.grant_types_supported) && !metadata.grant_types_supported.includes(grantType)) throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
    // Exchange code for tokens
    const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded",
        Accept: "application/json"
    });
    const params = new URLSearchParams({
        grant_type: grantType,
        code: authorizationCode,
        code_verifier: codeVerifier,
        redirect_uri: String(redirectUri)
    });
    if (addClientAuthentication) addClientAuthentication(headers, params, authorizationServerUrl, metadata);
    else {
        // Determine and apply client authentication method
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
    }
    if (resource) params.set("resource", resource.href);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthTokensSchema.parse(await response.json());
}
/**
 * Exchange a refresh token for an updated access token.
 *
 * Supports multiple client authentication methods as specified in OAuth 2.1:
 * - Automatically selects the best authentication method based on server support
 * - Preserves the original refresh token if a new one is not returned
 *
 * @param authorizationServerUrl - The authorization server's base URL
 * @param options - Configuration object containing client info, refresh token, etc.
 * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)
 * @throws {Error} When token refresh fails or authentication is invalid
 */ async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
    var _a;
    const grantType = "refresh_token";
    let tokenUrl;
    if (metadata) {
        tokenUrl = new URL(metadata.token_endpoint);
        if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
    } else tokenUrl = new URL("/token", authorizationServerUrl);
    // Exchange refresh token
    const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded"
    });
    const params = new URLSearchParams({
        grant_type: grantType,
        refresh_token: refreshToken
    });
    if (addClientAuthentication) addClientAuthentication(headers, params, authorizationServerUrl, metadata);
    else {
        // Determine and apply client authentication method
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
    }
    if (resource) params.set("resource", resource.href);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthTokensSchema.parse({
        refresh_token: refreshToken,
        ...await response.json()
    });
}
/**
 * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.
 */ async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
    let registrationUrl;
    if (metadata) {
        if (!metadata.registration_endpoint) throw new Error("Incompatible auth server: does not support dynamic client registration");
        registrationUrl = new URL(metadata.registration_endpoint);
    } else registrationUrl = new URL("/register", authorizationServerUrl);
    const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(registrationUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(clientMetadata)
    });
    if (!response.ok) throw await parseErrorResponse(response);
    return auth_js_2.OAuthClientInformationFullSchema.parse(await response.json());
}

},{"577f380df1a9847c":"8hncT","d1137141d2c4e193":"cqTxf","e7f1ee2964d2231b":"a0kYt","aebeafd3a3b920d0":"wRvBb","404492e758091926":"3sNJj"}],"8hncT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Generate a PKCE code challenge from a code verifier
 * @param code_verifier
 * @returns The base64 url encoded code challenge
 */ parcelHelpers.export(exports, "generateChallenge", ()=>generateChallenge);
parcelHelpers.export(exports, "default", ()=>pkceChallenge);
/** Verify that a code_verifier produces the expected code challenge
 * @param code_verifier
 * @param expectedChallenge The code challenge to verify
 * @returns True if challenges are equal. False otherwise.
 */ parcelHelpers.export(exports, "verifyChallenge", ()=>verifyChallenge);
let crypto;
crypto = globalThis.crypto; // web browsers
/**
 * Creates an array of length `size` of random bytes
 * @param size
 * @returns Array of random ints (0 to 255)
 */ async function getRandomValues(size) {
    return (await crypto).getRandomValues(new Uint8Array(size));
}
/** Generate cryptographically strong random string
 * @param size The desired length of the string
 * @returns The random string
 */ async function random(size) {
    const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let result = "";
    const randomUints = await getRandomValues(size);
    for(let i = 0; i < size; i++){
        // cap the value of the randomIndex to mask.length - 1
        const randomIndex = randomUints[i] % mask.length;
        result += mask[randomIndex];
    }
    return result;
}
/** Generate a PKCE challenge verifier
 * @param length Length of the verifier
 * @returns A random verifier `length` characters long
 */ async function generateVerifier(length) {
    return await random(length);
}
async function generateChallenge(code_verifier) {
    const buffer = await (await crypto).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
    // Generate base64url string
    // btoa is deprecated in Node.js but is used here for web browser compatibility
    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)
    return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
    if (!length) length = 43;
    if (length < 43 || length > 128) throw `Expected a length between 43 and 128. Received ${length}.`;
    const verifier = await generateVerifier(length);
    const challenge = await generateChallenge(verifier);
    return {
        code_verifier: verifier,
        code_challenge: challenge
    };
}
async function verifyChallenge(code_verifier, expectedChallenge) {
    const actualChallenge = await generateChallenge(code_verifier);
    return actualChallenge === expectedChallenge;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"a0kYt":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthTokenRevocationRequestSchema = exports.OAuthClientRegistrationErrorSchema = exports.OAuthClientInformationFullSchema = exports.OAuthClientInformationSchema = exports.OAuthClientMetadataSchema = exports.OAuthErrorResponseSchema = exports.OAuthTokensSchema = exports.OpenIdProviderDiscoveryMetadataSchema = exports.OpenIdProviderMetadataSchema = exports.OAuthMetadataSchema = exports.OAuthProtectedResourceMetadataSchema = exports.SafeUrlSchema = void 0;
const zod_1 = require("cc196583bd0bcc1e");
/**
 * Reusable URL validation that disallows javascript: scheme
 */ exports.SafeUrlSchema = zod_1.z.string().url().superRefine((val, ctx)=>{
    if (!URL.canParse(val)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: "URL must be parseable",
            fatal: true
        });
        return zod_1.z.NEVER;
    }
}).refine((url)=>{
    const u = new URL(url);
    return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
}, {
    message: "URL cannot use javascript:, data:, or vbscript: scheme"
});
/**
 * RFC 9728 OAuth Protected Resource Metadata
 */ exports.OAuthProtectedResourceMetadataSchema = zod_1.z.object({
    resource: zod_1.z.string().url(),
    authorization_servers: zod_1.z.array(exports.SafeUrlSchema).optional(),
    jwks_uri: zod_1.z.string().url().optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    bearer_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    resource_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    resource_name: zod_1.z.string().optional(),
    resource_documentation: zod_1.z.string().optional(),
    resource_policy_uri: zod_1.z.string().url().optional(),
    resource_tos_uri: zod_1.z.string().url().optional(),
    tls_client_certificate_bound_access_tokens: zod_1.z.boolean().optional(),
    authorization_details_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    dpop_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    dpop_bound_access_tokens_required: zod_1.z.boolean().optional()
}).passthrough();
/**
 * RFC 8414 OAuth 2.0 Authorization Server Metadata
 */ exports.OAuthMetadataSchema = zod_1.z.object({
    issuer: zod_1.z.string(),
    authorization_endpoint: exports.SafeUrlSchema,
    token_endpoint: exports.SafeUrlSchema,
    registration_endpoint: exports.SafeUrlSchema.optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    service_documentation: exports.SafeUrlSchema.optional(),
    revocation_endpoint: exports.SafeUrlSchema.optional(),
    revocation_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    revocation_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    introspection_endpoint: zod_1.z.string().optional(),
    introspection_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    introspection_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    code_challenge_methods_supported: zod_1.z.array(zod_1.z.string()).optional()
}).passthrough();
/**
 * OpenID Connect Discovery 1.0 Provider Metadata
 * see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
 */ exports.OpenIdProviderMetadataSchema = zod_1.z.object({
    issuer: zod_1.z.string(),
    authorization_endpoint: exports.SafeUrlSchema,
    token_endpoint: exports.SafeUrlSchema,
    userinfo_endpoint: exports.SafeUrlSchema.optional(),
    jwks_uri: exports.SafeUrlSchema,
    registration_endpoint: exports.SafeUrlSchema.optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    acr_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    subject_types_supported: zod_1.z.array(zod_1.z.string()),
    id_token_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()),
    id_token_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    id_token_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    userinfo_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    display_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claim_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_supported: zod_1.z.array(zod_1.z.string()).optional(),
    service_documentation: zod_1.z.string().optional(),
    claims_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    ui_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_parameter_supported: zod_1.z.boolean().optional(),
    request_parameter_supported: zod_1.z.boolean().optional(),
    request_uri_parameter_supported: zod_1.z.boolean().optional(),
    require_request_uri_registration: zod_1.z.boolean().optional(),
    op_policy_uri: exports.SafeUrlSchema.optional(),
    op_tos_uri: exports.SafeUrlSchema.optional()
}).passthrough();
/**
 * OpenID Connect Discovery metadata that may include OAuth 2.0 fields
 * This schema represents the real-world scenario where OIDC providers
 * return a mix of OpenID Connect and OAuth 2.0 metadata fields
 */ exports.OpenIdProviderDiscoveryMetadataSchema = exports.OpenIdProviderMetadataSchema.merge(exports.OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
}));
/**
 * OAuth 2.1 token response
 */ exports.OAuthTokensSchema = zod_1.z.object({
    access_token: zod_1.z.string(),
    id_token: zod_1.z.string().optional(),
    token_type: zod_1.z.string(),
    expires_in: zod_1.z.number().optional(),
    scope: zod_1.z.string().optional(),
    refresh_token: zod_1.z.string().optional()
}).strip();
/**
 * OAuth 2.1 error response
 */ exports.OAuthErrorResponseSchema = zod_1.z.object({
    error: zod_1.z.string(),
    error_description: zod_1.z.string().optional(),
    error_uri: zod_1.z.string().optional()
});
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration metadata
 */ exports.OAuthClientMetadataSchema = zod_1.z.object({
    redirect_uris: zod_1.z.array(exports.SafeUrlSchema),
    token_endpoint_auth_method: zod_1.z.string().optional(),
    grant_types: zod_1.z.array(zod_1.z.string()).optional(),
    response_types: zod_1.z.array(zod_1.z.string()).optional(),
    client_name: zod_1.z.string().optional(),
    client_uri: exports.SafeUrlSchema.optional(),
    logo_uri: exports.SafeUrlSchema.optional(),
    scope: zod_1.z.string().optional(),
    contacts: zod_1.z.array(zod_1.z.string()).optional(),
    tos_uri: exports.SafeUrlSchema.optional(),
    policy_uri: zod_1.z.string().optional(),
    jwks_uri: exports.SafeUrlSchema.optional(),
    jwks: zod_1.z.any().optional(),
    software_id: zod_1.z.string().optional(),
    software_version: zod_1.z.string().optional(),
    software_statement: zod_1.z.string().optional()
}).strip();
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration client information
 */ exports.OAuthClientInformationSchema = zod_1.z.object({
    client_id: zod_1.z.string(),
    client_secret: zod_1.z.string().optional(),
    client_id_issued_at: zod_1.z.number().optional(),
    client_secret_expires_at: zod_1.z.number().optional()
}).strip();
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata)
 */ exports.OAuthClientInformationFullSchema = exports.OAuthClientMetadataSchema.merge(exports.OAuthClientInformationSchema);
/**
 * RFC 7591 OAuth 2.0 Dynamic Client Registration error response
 */ exports.OAuthClientRegistrationErrorSchema = zod_1.z.object({
    error: zod_1.z.string(),
    error_description: zod_1.z.string().optional()
}).strip();
/**
 * RFC 7009 OAuth 2.0 Token Revocation request
 */ exports.OAuthTokenRevocationRequestSchema = zod_1.z.object({
    token: zod_1.z.string(),
    token_type_hint: zod_1.z.string().optional()
}).strip();

},{"cc196583bd0bcc1e":"hP52C"}],"wRvBb":[function(require,module,exports) {
"use strict";
/**
 * Utilities for handling OAuth resource URIs.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resourceUrlFromServerUrl = resourceUrlFromServerUrl;
exports.checkResourceAllowed = checkResourceAllowed;
/**
 * Converts a server URL to a resource URL by removing the fragment.
 * RFC 8707 section 2 states that resource URIs "MUST NOT include a fragment component".
 * Keeps everything else unchanged (scheme, domain, port, path, query).
 */ function resourceUrlFromServerUrl(url) {
    const resourceURL = typeof url === "string" ? new URL(url) : new URL(url.href);
    resourceURL.hash = ""; // Remove fragment
    return resourceURL;
}
/**
 * Checks if a requested resource URL matches a configured resource URL.
 * A requested resource matches if it has the same scheme, domain, port,
 * and its path starts with the configured resource's path.
 *
 * @param requestedResource The resource URL being requested
 * @param configuredResource The resource URL that has been configured
 * @returns true if the requested resource matches the configured resource, false otherwise
 */ function checkResourceAllowed({ requestedResource, configuredResource }) {
    const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
    const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
    // Compare the origin (scheme, domain, and port)
    if (requested.origin !== configured.origin) return false;
    // Handle cases like requested=/foo and configured=/foo/
    if (requested.pathname.length < configured.pathname.length) return false;
    // Check if the requested path starts with the configured path
    // Ensure both paths end with / for proper comparison
    // This ensures that if we have paths like "/api" and "/api/users",
    // we properly detect that "/api/users" is a subpath of "/api"
    // By adding a trailing slash if missing, we avoid false positives
    // where paths like "/api123" would incorrectly match "/api"
    const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
    const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
    return requestedPath.startsWith(configuredPath);
}

},{}],"3sNJj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAUTH_ERRORS = exports.CustomOAuthError = exports.InsufficientScopeError = exports.InvalidClientMetadataError = exports.TooManyRequestsError = exports.MethodNotAllowedError = exports.InvalidTokenError = exports.UnsupportedTokenTypeError = exports.UnsupportedResponseTypeError = exports.TemporarilyUnavailableError = exports.ServerError = exports.AccessDeniedError = exports.InvalidScopeError = exports.UnsupportedGrantTypeError = exports.UnauthorizedClientError = exports.InvalidGrantError = exports.InvalidClientError = exports.InvalidRequestError = exports.OAuthError = void 0;
/**
 * Base class for all OAuth errors
 */ class OAuthError extends Error {
    constructor(message, errorUri){
        super(message);
        this.errorUri = errorUri;
        this.name = this.constructor.name;
    }
    /**
     * Converts the error to a standard OAuth error response object
     */ toResponseObject() {
        const response = {
            error: this.errorCode,
            error_description: this.message
        };
        if (this.errorUri) response.error_uri = this.errorUri;
        return response;
    }
    get errorCode() {
        return this.constructor.errorCode;
    }
}
exports.OAuthError = OAuthError;
/**
 * Invalid request error - The request is missing a required parameter,
 * includes an invalid parameter value, includes a parameter more than once,
 * or is otherwise malformed.
 */ class InvalidRequestError extends OAuthError {
}
exports.InvalidRequestError = InvalidRequestError;
InvalidRequestError.errorCode = "invalid_request";
/**
 * Invalid client error - Client authentication failed (e.g., unknown client, no client
 * authentication included, or unsupported authentication method).
 */ class InvalidClientError extends OAuthError {
}
exports.InvalidClientError = InvalidClientError;
InvalidClientError.errorCode = "invalid_client";
/**
 * Invalid grant error - The provided authorization grant or refresh token is
 * invalid, expired, revoked, does not match the redirection URI used in the
 * authorization request, or was issued to another client.
 */ class InvalidGrantError extends OAuthError {
}
exports.InvalidGrantError = InvalidGrantError;
InvalidGrantError.errorCode = "invalid_grant";
/**
 * Unauthorized client error - The authenticated client is not authorized to use
 * this authorization grant type.
 */ class UnauthorizedClientError extends OAuthError {
}
exports.UnauthorizedClientError = UnauthorizedClientError;
UnauthorizedClientError.errorCode = "unauthorized_client";
/**
 * Unsupported grant type error - The authorization grant type is not supported
 * by the authorization server.
 */ class UnsupportedGrantTypeError extends OAuthError {
}
exports.UnsupportedGrantTypeError = UnsupportedGrantTypeError;
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
/**
 * Invalid scope error - The requested scope is invalid, unknown, malformed, or
 * exceeds the scope granted by the resource owner.
 */ class InvalidScopeError extends OAuthError {
}
exports.InvalidScopeError = InvalidScopeError;
InvalidScopeError.errorCode = "invalid_scope";
/**
 * Access denied error - The resource owner or authorization server denied the request.
 */ class AccessDeniedError extends OAuthError {
}
exports.AccessDeniedError = AccessDeniedError;
AccessDeniedError.errorCode = "access_denied";
/**
 * Server error - The authorization server encountered an unexpected condition
 * that prevented it from fulfilling the request.
 */ class ServerError extends OAuthError {
}
exports.ServerError = ServerError;
ServerError.errorCode = "server_error";
/**
 * Temporarily unavailable error - The authorization server is currently unable to
 * handle the request due to a temporary overloading or maintenance of the server.
 */ class TemporarilyUnavailableError extends OAuthError {
}
exports.TemporarilyUnavailableError = TemporarilyUnavailableError;
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
/**
 * Unsupported response type error - The authorization server does not support
 * obtaining an authorization code using this method.
 */ class UnsupportedResponseTypeError extends OAuthError {
}
exports.UnsupportedResponseTypeError = UnsupportedResponseTypeError;
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
/**
 * Unsupported token type error - The authorization server does not support
 * the requested token type.
 */ class UnsupportedTokenTypeError extends OAuthError {
}
exports.UnsupportedTokenTypeError = UnsupportedTokenTypeError;
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
/**
 * Invalid token error - The access token provided is expired, revoked, malformed,
 * or invalid for other reasons.
 */ class InvalidTokenError extends OAuthError {
}
exports.InvalidTokenError = InvalidTokenError;
InvalidTokenError.errorCode = "invalid_token";
/**
 * Method not allowed error - The HTTP method used is not allowed for this endpoint.
 * (Custom, non-standard error)
 */ class MethodNotAllowedError extends OAuthError {
}
exports.MethodNotAllowedError = MethodNotAllowedError;
MethodNotAllowedError.errorCode = "method_not_allowed";
/**
 * Too many requests error - Rate limit exceeded.
 * (Custom, non-standard error based on RFC 6585)
 */ class TooManyRequestsError extends OAuthError {
}
exports.TooManyRequestsError = TooManyRequestsError;
TooManyRequestsError.errorCode = "too_many_requests";
/**
 * Invalid client metadata error - The client metadata is invalid.
 * (Custom error for dynamic client registration - RFC 7591)
 */ class InvalidClientMetadataError extends OAuthError {
}
exports.InvalidClientMetadataError = InvalidClientMetadataError;
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
/**
 * Insufficient scope error - The request requires higher privileges than provided by the access token.
 */ class InsufficientScopeError extends OAuthError {
}
exports.InsufficientScopeError = InsufficientScopeError;
InsufficientScopeError.errorCode = "insufficient_scope";
/**
 * A utility class for defining one-off error codes
 */ class CustomOAuthError extends OAuthError {
    constructor(customErrorCode, message, errorUri){
        super(message, errorUri);
        this.customErrorCode = customErrorCode;
    }
    get errorCode() {
        return this.customErrorCode;
    }
}
exports.CustomOAuthError = CustomOAuthError;
/**
 * A full list of all OAuthErrors, enabling parsing from error responses
 */ exports.OAUTH_ERRORS = {
    [InvalidRequestError.errorCode]: InvalidRequestError,
    [InvalidClientError.errorCode]: InvalidClientError,
    [InvalidGrantError.errorCode]: InvalidGrantError,
    [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
    [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
    [InvalidScopeError.errorCode]: InvalidScopeError,
    [AccessDeniedError.errorCode]: AccessDeniedError,
    [ServerError.errorCode]: ServerError,
    [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
    [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
    [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
    [InvalidTokenError.errorCode]: InvalidTokenError,
    [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
    [TooManyRequestsError.errorCode]: TooManyRequestsError,
    [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
    [InsufficientScopeError.errorCode]: InsufficientScopeError
};

},{}],"apA8I":[function(require,module,exports) {
/**
 * Notion MCP SSE Client
 * Handles Server-Sent Events connection to Notion's hosted MCP server
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "McpSSEClient", ()=>McpSSEClient);
var _constants = require("../constants");
/**
 * EventSource-like interface for SSE in extension context
 * Chrome extensions need special handling for SSE
 */ class McpSSEClient {
    constructor(sseUrl, accessToken, callbacks){
        this.sessionId = null // MCP session ID from initialization
        ;
        this.sseSessionId = null // SSE stream session ID for resumability
        ;
        this.messageEndpoint = null // POST endpoint from SSE 'endpoint' event
        ;
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.reconnectTimeout = null;
        this.messageId = 0;
        this.pendingRequests = new Map();
        this.currentStatus = {
            state: "disconnected"
        };
        this.sseUrl = sseUrl;
        this.accessToken = accessToken;
        this.onStatusChange = callbacks.onStatusChange;
        this.onMessage = callbacks.onMessage;
    }
    /**
     * Connect to the SSE endpoint
     */ async connect() {
        this.updateStatus("connecting");
        try {
            // For MV3 extensions, we need to use fetch with ReadableStream
            // instead of EventSource due to CSP restrictions
            await this.connectWithFetch();
        } catch (error) {
            console.error("[NotionMCP] Connection error:", error);
            this.updateStatus("error", error instanceof Error ? error.message : "Connection failed");
            this.scheduleReconnect();
        }
    }
    /**
     * Connect using fetch and ReadableStream (MV3 compatible)
     */ async connectWithFetch() {
        console.log("[NotionMCP] Connecting to SSE endpoint:", this.sseUrl);
        console.log("[NotionMCP] Using access token (first 20 chars):", this.accessToken.substring(0, 20) + "...");
        const response = await fetch(this.sseUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${this.accessToken}`,
                "Accept": "text/event-stream, application/json",
                "Cache-Control": "no-cache",
                "MCP-Protocol-Version": "2025-06-18"
            }
        });
        console.log("[NotionMCP] SSE response status:", response.status);
        console.log("[NotionMCP] SSE response headers:", Object.fromEntries(response.headers.entries()));
        if (!response.ok) {
            const errorText = await response.text();
            console.error("[NotionMCP] SSE connection failed:", response.status, errorText);
            if (response.status === 401) {
                // Parse error to distinguish between format and expiry issues
                let errorData;
                try {
                    errorData = JSON.parse(errorText);
                } catch  {
                    errorData = {
                        error: "unknown",
                        error_description: errorText
                    };
                }
                if (errorData.error === "invalid_token" && errorData.error_description?.includes("Invalid token format")) {
                    // Token format is wrong - don't try to refresh, need re-auth
                    this.updateStatus("invalid-token", "Invalid token format - please re-authenticate");
                    throw new Error(`Invalid token format: ${errorData.error_description}`);
                } else {
                    // Token expired or other auth issue - might be refreshable
                    this.updateStatus("needs-auth", "Token expired or invalid");
                    throw new Error(`Authentication required: ${errorText}`);
                }
            }
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        if (!response.body) throw new Error("Response body is null");
        this.reconnectAttempts = 0;
        this.updateStatus("connected");
        // Process the stream in the background (don't await)
        this.processStream(response.body);
    // Note: MCP session ID comes from initialization response headers,
    // not from the SSE stream. The SSE endpoint event provides a separate
    // session ID for stream resumability.
    }
    /**
     * Process the SSE stream in the background
     */ async processStream(body) {
        const reader = body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let currentEvent = null;
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    console.log("[NotionMCP] Stream ended");
                    break;
                }
                buffer += decoder.decode(value, {
                    stream: true
                });
                const lines = buffer.split("\n");
                buffer = lines.pop() || "";
                for (const line of lines){
                    if (line.startsWith("event: ")) {
                        // Handle SSE event types (e.g., "event: endpoint", "event: message")
                        currentEvent = line.slice(7).trim();
                        console.log("[NotionMCP] SSE event type:", currentEvent);
                        continue;
                    }
                    if (line.startsWith("data: ")) {
                        const data = line.slice(6).trim();
                        if (data === "[DONE]") continue;
                        // Handle endpoint event - extract message endpoint for POST requests
                        if (currentEvent === "endpoint") {
                            // Per MCP spec: server sends endpoint URI for client to use for POST requests
                            // data format: /sse/message?sessionId=... (relative URI)
                            this.messageEndpoint = data;
                            // Extract session ID if present
                            const match = data.match(/sessionId=([a-f0-9-]+)/);
                            if (match) this.sseSessionId = match[1];
                            console.log("[NotionMCP] Message endpoint received:", this.messageEndpoint);
                            console.log("[NotionMCP] SSE Session ID:", this.sseSessionId);
                            currentEvent = null;
                            continue;
                        }
                        // Skip empty data or non-JSON data
                        if (!data || !data.startsWith("{") && !data.startsWith("[")) {
                            console.log("[NotionMCP] Non-JSON SSE data:", data);
                            currentEvent = null;
                            continue;
                        }
                        try {
                            const message = JSON.parse(data);
                            this.handleMessage(message);
                        } catch (err) {
                            console.error("[NotionMCP] Failed to parse message:", err, "Data:", data);
                        }
                        currentEvent = null;
                    }
                }
            }
        } catch (error) {
            console.error("[NotionMCP] Stream error:", error);
        } finally{
            reader.releaseLock();
            // Connection closed, attempt reconnect
            this.scheduleReconnect();
        }
    }
    /**
     * Handle incoming SSE message
     */ handleMessage(message) {
        this.onMessage(message);
        // Handle responses to our requests
        if (message.id && this.pendingRequests.has(message.id)) {
            const pending = this.pendingRequests.get(message.id);
            this.pendingRequests.delete(message.id);
            if (message.error) pending.reject(new Error(message.error.message));
            else pending.resolve(message.result);
        }
    }
    /**
     * Get the full POST endpoint URL
     */ getPostUrl() {
        if (!this.messageEndpoint) throw new Error("Message endpoint not available. SSE connection may not be established.");
        // If endpoint is relative, construct full URL
        if (this.messageEndpoint.startsWith("/")) {
            const url = new URL(this.sseUrl);
            return `${url.origin}${this.messageEndpoint}`;
        }
        // If endpoint is already absolute, use it as-is
        return this.messageEndpoint;
    }
    /**
     * Send a notification (no response expected)
     */ async sendNotification(method, params) {
        const message = {
            jsonrpc: "2.0",
            method,
            params
        };
        // Build headers
        const headers = {
            "Authorization": `Bearer ${this.accessToken}`,
            "Content-Type": "application/json",
            "Accept": "application/json, text/event-stream",
            "MCP-Protocol-Version": "2025-06-18"
        };
        // Include session ID if available
        if (this.sessionId) headers["Mcp-Session-Id"] = this.sessionId;
        // Per MCP spec: use the endpoint from SSE 'endpoint' event for POST requests
        const postUrl = this.getPostUrl();
        console.log("[NotionMCP] Sending notification to:", postUrl);
        // Send notification - no response expected (should return 202 Accepted)
        const response = await fetch(postUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(message)
        });
        if (!response.ok) {
            const errorText = await response.text();
            console.error("[NotionMCP] Notification failed:", response.status, errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        console.log("[NotionMCP] Notification sent:", method);
    }
    /**
     * Send a request over SSE (via POST to endpoint from SSE 'endpoint' event)
     * Per MCP spec: SSE for receiving, POST to endpoint provided by server for sending
     */ async sendRequest(method, params, options) {
        const id = ++this.messageId;
        const message = {
            jsonrpc: "2.0",
            id,
            method,
            params
        };
        return new Promise((resolve, reject)=>{
            this.pendingRequests.set(id, {
                resolve,
                reject
            });
            // Build headers
            const headers = {
                "Authorization": `Bearer ${this.accessToken}`,
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream",
                "MCP-Protocol-Version": "2025-06-18"
            };
            // Include session ID if available
            const isInitialize = method === "initialize";
            if (!isInitialize && this.sessionId) headers["Mcp-Session-Id"] = this.sessionId;
            // Per MCP spec: use the endpoint from SSE 'endpoint' event for POST requests
            const postUrl = this.getPostUrl();
            console.log("[NotionMCP] Sending request to:", postUrl, "Method:", method);
            // Send via POST to the message endpoint (from SSE endpoint event)
            fetch(postUrl, {
                method: "POST",
                headers,
                body: JSON.stringify(message)
            }).then(async (response)=>{
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("[NotionMCP] Request failed:", response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                // Extract session ID from response headers if this is initialization
                if (isInitialize) {
                    const sessionIdHeader = response.headers.get("Mcp-Session-Id");
                    if (sessionIdHeader) {
                        this.sessionId = sessionIdHeader;
                        console.log("[NotionMCP] Session ID from init response:", this.sessionId);
                    }
                }
                // Check content type to determine how to parse
                const contentType = response.headers.get("content-type") || "";
                if (contentType.includes("text/event-stream")) {
                    // Response is SSE format - parse it
                    const text = await response.text();
                    const lines = text.split("\n");
                    for (const line of lines)if (line.startsWith("data: ")) {
                        const data = line.slice(6).trim();
                        if (data && (data.startsWith("{") || data.startsWith("["))) try {
                            const result = JSON.parse(data);
                            if (result.id === id) {
                                this.handleMessage(result);
                                return;
                            }
                        } catch (err) {
                            console.error("[NotionMCP] Failed to parse SSE data:", err);
                        }
                    }
                } else if (contentType.includes("application/json")) {
                    // Response is JSON - parse directly
                    const result = await response.json();
                    if (result.id === id) this.handleMessage(result);
                } else throw new Error(`Unexpected content type: ${contentType}`);
            }).catch((error)=>{
                this.pendingRequests.delete(id);
                reject(error);
            });
            // Timeout after 30 seconds
            setTimeout(()=>{
                if (this.pendingRequests.has(id)) {
                    this.pendingRequests.delete(id);
                    reject(new Error("Request timeout"));
                }
            }, 30000);
        });
    }
    /**
     * Wait for message endpoint to be available
     */ async waitForEndpoint(timeoutMs = 10000) {
        const startTime = Date.now();
        while(!this.messageEndpoint){
            if (Date.now() - startTime > timeoutMs) throw new Error("Timeout waiting for message endpoint from SSE");
            await new Promise((resolve)=>setTimeout(resolve, 100));
        }
    }
    /**
     * Initialize the MCP connection
     * Must be called AFTER SSE connection is established and endpoint event is received
     */ async initialize() {
        // Per MCP spec: Wait for SSE 'endpoint' event before sending requests
        console.log("[NotionMCP] Waiting for message endpoint from SSE...");
        await this.waitForEndpoint();
        console.log("[NotionMCP] Message endpoint ready, sending initialize request");
        const params = {
            protocolVersion: "2025-06-18",
            capabilities: {
                experimental: {},
                roots: {
                    listChanged: true
                }
            },
            clientInfo: {
                name: "chrome-ai-extension",
                version: "0.0.1"
            }
        };
        // Send initialize request
        // Session ID will be extracted from response headers
        const result = await this.sendRequest("initialize", params);
        console.log("[NotionMCP] Initialized:", result);
        // Verify session ID was received (if server uses sessions)
        if (this.sessionId) console.log("[NotionMCP] Session established:", this.sessionId);
        else console.log("[NotionMCP] Server does not use session management");
        // After initialization, send initialized notification (no response expected)
        await this.sendNotification("notifications/initialized");
        // Fetch available tools
        await this.fetchTools();
    }
    /**
     * Fetch available tools from MCP server
     */ async fetchTools() {
        try {
            const result = await this.sendRequest("tools/list");
            this.currentStatus.tools = result.tools;
            this.onStatusChange(this.currentStatus);
            console.log("[NotionMCP] Tools:", result.tools);
        } catch (error) {
            console.error("[NotionMCP] Failed to fetch tools:", error);
        }
    }
    /**
     * Call a tool
     */ async callTool(name, args) {
        return this.sendRequest("tools/call", {
            name,
            arguments: args
        });
    }
    /**
     * Update connection status
     */ updateStatus(state, error) {
        this.currentStatus = {
            ...this.currentStatus,
            state,
            error,
            lastConnected: state === "connected" ? Date.now() : this.currentStatus.lastConnected
        };
        this.onStatusChange(this.currentStatus);
    }
    /**
     * Schedule reconnection with exponential backoff
     */ scheduleReconnect() {
        if (this.reconnectTimeout) return;
        const delay = Math.min((0, _constants.NOTION_CONFIG).RECONNECT_MIN_DELAY * Math.pow((0, _constants.NOTION_CONFIG).RECONNECT_MULTIPLIER, this.reconnectAttempts), (0, _constants.NOTION_CONFIG).RECONNECT_MAX_DELAY);
        this.reconnectAttempts++;
        this.updateStatus("connecting", `Reconnecting in ${Math.round(delay / 1000)}s...`);
        this.reconnectTimeout = window.setTimeout(()=>{
            this.reconnectTimeout = null;
            this.connect();
        }, delay);
    }
    /**
     * Disconnect and cleanup
     */ disconnect() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        // Reject all pending requests
        for (const [id, pending] of this.pendingRequests)pending.reject(new Error("Disconnected"));
        this.pendingRequests.clear();
        this.updateStatus("disconnected");
    }
    /**
     * Get current status
     */ getStatus() {
        return this.currentStatus;
    }
}

},{"../constants":"aZX5f","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"aZX5f":[function(require,module,exports) {
/**
 * Configuration constants for the extension
 */ // Chrome Built-in AI (Gemini Nano) limits
// Based on Chrome AI documentation and community reports
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHROME_AI_LIMITS", ()=>CHROME_AI_LIMITS);
parcelHelpers.export(exports, "COPILOT_RUNTIME_URL", ()=>COPILOT_RUNTIME_URL);
parcelHelpers.export(exports, "COPILOT_RUNTIME_URL_DEFAULT", ()=>COPILOT_RUNTIME_URL_DEFAULT);
parcelHelpers.export(exports, "NOTION_CONFIG", ()=>NOTION_CONFIG);
const CHROME_AI_LIMITS = {
    /** Maximum tokens per single prompt to Gemini Nano (on-device model) */ MAX_TOKENS_PER_PROMPT: 1024,
    /** Maximum tokens for session retention (sliding window) */ MAX_TOKENS_PER_SESSION: 4096,
    /** Recommended chunk size for text processing to stay well under prompt limit */ RECOMMENDED_CHUNK_TOKENS: 800,
    /** Maximum output tokens per response */ MAX_OUTPUT_TOKENS: 1024
};
const COPILOT_RUNTIME_URL = " http://localhost:3000/api"; // TODO: Edit this URL
const COPILOT_RUNTIME_URL_DEFAULT = " http://localhost:3000/";
const NOTION_CONFIG = {
    /** OAuth redirect URI - Chrome extension identity redirect */ OAUTH_REDIRECT_URI: "https://finfnkhchelfofloocidpepacfbajmlh.chromiumapp.org/",
    /** OAuth dynamic client registration endpoint */ OAUTH_REGISTER_URL: "https://mcp.notion.com/register",
    /** OAuth authorization endpoint - Standard Notion OAuth */ OAUTH_AUTH_URL: "https://mcp.notion.com/authorize",
    /** OAuth token endpoint - Standard Notion OAuth */ OAUTH_TOKEN_URL: "https://mcp.notion.com/token",
    /** OAuth token introspection endpoint */ OAUTH_INTROSPECT_URL: "https://api.notion.com/v1/oauth/introspect",
    /** MCP resource identifier for OAuth scope */ MCP_RESOURCE: "https://mcp.notion.com/",
    /** Notion MCP SSE endpoint (for establishing SSE connection and receiving events) */ MCP_SSE_URL: "https://mcp.notion.com/sse",
    /** Token storage key prefix */ STORAGE_KEY_PREFIX: "oauth.notion.mcp",
    /** Reconnection settings */ RECONNECT_MIN_DELAY: 500,
    RECONNECT_MAX_DELAY: 30000,
    RECONNECT_MULTIPLIER: 2
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"bEC4Y":[function(require,module,exports) {
/**
 * OAuth utilities for Notion MCP authentication
 * Implements OAuth 2.0 PKCE (Proof Key for Code Exchange) flow
 * for Notion's hosted MCP server (no client secret)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerDynamicClient", ()=>registerDynamicClient);
parcelHelpers.export(exports, "generateState", ()=>generateState);
parcelHelpers.export(exports, "createCodeVerifier", ()=>createCodeVerifier);
parcelHelpers.export(exports, "createCodeChallenge", ()=>createCodeChallenge);
parcelHelpers.export(exports, "buildAuthUrl", ()=>buildAuthUrl);
parcelHelpers.export(exports, "exchangeCodeForTokens", ()=>exchangeCodeForTokens);
parcelHelpers.export(exports, "refreshAccessToken", ()=>refreshAccessToken);
parcelHelpers.export(exports, "isTokenExpired", ()=>isTokenExpired);
parcelHelpers.export(exports, "storeTokens", ()=>storeTokens);
parcelHelpers.export(exports, "getStoredTokens", ()=>getStoredTokens);
parcelHelpers.export(exports, "clearTokens", ()=>clearTokens);
parcelHelpers.export(exports, "storeClientCredentials", ()=>storeClientCredentials);
parcelHelpers.export(exports, "getStoredClientCredentials", ()=>getStoredClientCredentials);
parcelHelpers.export(exports, "clearClientCredentials", ()=>clearClientCredentials);
var _constants = require("../constants");
var Buffer = require("8593971f56fb0efb").Buffer;
/**
 * Register a dynamic client with Notion MCP OAuth server
 * This is called before starting the OAuth flow
 */ async function registerDynamicClient(redirectUri) {
    const registrationPayload = {
        client_name: "Chrome AI Extension - Notion MCP",
        redirect_uris: [
            redirectUri
        ],
        grant_types: [
            "authorization_code",
            "refresh_token"
        ],
        response_types: [
            "code"
        ],
        scope: "read write",
        token_endpoint_auth_method: "client_secret_basic"
    };
    console.log("[OAuth] Registering dynamic client with payload:", registrationPayload);
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_REGISTER_URL, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(registrationPayload)
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Client registration failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    console.log("[OAuth] Client registered successfully:", {
        client_id: data.client_id,
        redirect_uris: data.redirect_uris
    });
    return {
        client_id: data.client_id,
        client_secret: data.client_secret,
        redirect_uris: data.redirect_uris,
        client_name: data.client_name,
        grant_types: data.grant_types,
        response_types: data.response_types,
        token_endpoint_auth_method: data.token_endpoint_auth_method,
        registration_client_uri: data.registration_client_uri,
        client_id_issued_at: data.client_id_issued_at,
        created_at: Date.now()
    };
}
/**
 * Generate a random string for state parameter (CSRF protection)
 */ function generateRandomString(length) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, (byte)=>byte.toString(16).padStart(2, "0")).join("");
}
/**
 * Generate state parameter for CSRF protection
 */ function generateState() {
    return generateRandomString(16);
}
/**
 * Create a code verifier for PKCE (43-128 characters, base64url)
 */ function createCodeVerifier() {
    const array = new Uint8Array(32); // 32 bytes = 43 chars in base64url
    crypto.getRandomValues(array);
    return base64UrlEncode(array);
}
/**
 * Create a code challenge from a verifier (SHA-256 hash, base64url encoded)
 */ async function createCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return base64UrlEncode(new Uint8Array(hash));
}
/**
 * Base64URL encode (without padding)
 */ function base64UrlEncode(buffer) {
    const base64 = btoa(String.fromCharCode(...buffer));
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
/**
 * Build Notion MCP OAuth authorization URL (standard OAuth, no PKCE)
 */ function buildAuthUrl(clientId, redirectUri, state) {
    const params = new URLSearchParams({
        response_type: "code",
        client_id: clientId,
        redirect_uri: redirectUri,
        owner: "user",
        state: state
    });
    return `${(0, _constants.NOTION_CONFIG).OAUTH_AUTH_URL}?${params.toString()}`;
}
/**
 * Exchange authorization code for tokens using dynamic client credentials
 */ async function exchangeCodeForTokens(code, clientId, clientSecret, redirectUri) {
    const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
    console.log("[OAuth] Exchange code for tokens with client:", clientId);
    // Create x-www-form-urlencoded body for OAuth token exchange
    const params = new URLSearchParams({
        grant_type: "authorization_code",
        code: code,
        redirect_uri: redirectUri
    });
    console.log("[OAuth] Exchange code for tokens body (urlencoded):", params.toString());
    console.log("[OAuth] Exchange code for tokens URL:", (0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL);
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL, {
        method: "POST",
        headers: {
            "Authorization": `Basic ${credentials}`,
            "Content-Type": "application/x-www-form-urlencoded",
            "Notion-Version": "2022-06-28"
        },
        body: params.toString()
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Token exchange failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    // Calculate expiration timestamp
    const expiresIn = data.expires_in || 3600; // Default 1 hour if not provided
    const expiresAt = Date.now() + expiresIn * 1000;
    return {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "Bearer",
        expires_at: expiresAt,
        workspace_id: data.workspace_id,
        workspace_name: data.workspace_name,
        workspace_icon: data.workspace_icon,
        owner: data.owner,
        bot_id: data.bot_id,
        duplicated_template_id: data.duplicated_template_id,
        created_at: Date.now()
    };
}
/**
 * Refresh access token using refresh token and dynamic client credentials
 */ async function refreshAccessToken(refreshToken, clientId, clientSecret) {
    const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
    const params = new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken
    });
    const response = await fetch((0, _constants.NOTION_CONFIG).OAUTH_TOKEN_URL, {
        method: "POST",
        headers: {
            "Authorization": `Basic ${credentials}`,
            "Content-Type": "application/x-www-form-urlencoded",
            "Notion-Version": "2022-06-28"
        },
        body: params.toString()
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Token refresh failed: ${response.status} ${error}`);
    }
    const data = await response.json();
    const expiresIn = data.expires_in || 3600;
    const expiresAt = Date.now() + expiresIn * 1000;
    return {
        access_token: data.access_token,
        refresh_token: data.refresh_token || refreshToken,
        token_type: data.token_type || "Bearer",
        expires_at: expiresAt,
        workspace_id: data.workspace_id,
        workspace_name: data.workspace_name,
        workspace_icon: data.workspace_icon,
        owner: data.owner,
        created_at: Date.now()
    };
}
/**
 * Check if token is expired or about to expire (within 5 minutes)
 */ function isTokenExpired(tokens) {
    const now = Date.now();
    const bufferTime = 300000; // 5 minutes
    return tokens.expires_at <= now + bufferTime;
}
/**
 * Store tokens in chrome.storage.local
 */ async function storeTokens(tokens) {
    await chrome.storage.local.set({
        [`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`]: tokens
    });
}
/**
 * Retrieve tokens from chrome.storage.local
 */ async function getStoredTokens() {
    const result = await chrome.storage.local.get(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`);
    return result[`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`] || null;
}
/**
 * Clear stored tokens
 */ async function clearTokens() {
    await chrome.storage.local.remove(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.tokens`);
}
/**
 * Store dynamic client credentials in chrome.storage.local
 */ async function storeClientCredentials(credentials) {
    await chrome.storage.local.set({
        [`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`]: credentials
    });
}
/**
 * Retrieve dynamic client credentials from chrome.storage.local
 */ async function getStoredClientCredentials() {
    const result = await chrome.storage.local.get(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`);
    return result[`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`] || null;
}
/**
 * Clear stored client credentials
 */ async function clearClientCredentials() {
    await chrome.storage.local.remove(`${(0, _constants.NOTION_CONFIG).STORAGE_KEY_PREFIX}.client`);
}

},{"8593971f56fb0efb":"4qdzc","../constants":"aZX5f","@parcel/transformer-js/src/esmodule-helpers.js":"5G9Z5"}],"4qdzc":[function(require,module,exports) {
var Er = Object.create;
var N = Object.defineProperty;
var dr = Object.getOwnPropertyDescriptor;
var gr = Object.getOwnPropertyNames;
var mr = Object.getPrototypeOf, Ir = Object.prototype.hasOwnProperty;
var $ = (i, r)=>()=>(r || i((r = {
            exports: {}
        }).exports, r), r.exports), Fr = (i, r)=>{
    for(var t in r)N(i, t, {
        get: r[t],
        enumerable: !0
    });
}, L = (i, r, t, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of gr(r))!Ir.call(i, e) && e !== t && N(i, e, {
        get: ()=>r[e],
        enumerable: !(n = dr(r, e)) || n.enumerable
    });
    return i;
}, S = (i, r, t)=>(L(i, r, "default"), t && L(t, r, "default")), J = (i, r, t)=>(t = i != null ? Er(mr(i)) : {}, L(r || !i || !i.__esModule ? N(t, "default", {
        value: i,
        enumerable: !0
    }) : t, i)), Ar = (i)=>L(N({}, "__esModule", {
        value: !0
    }), i);
var Q = $((M)=>{
    "use strict";
    M.byteLength = Rr;
    M.toByteArray = Cr;
    M.fromByteArray = Lr;
    var B = [], w = [], Ur = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(m = 0, K = P.length; m < K; ++m)B[m] = P[m], w[P.charCodeAt(m)] = m;
    var m, K;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function Z(i) {
        var r = i.length;
        if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = i.indexOf("=");
        t === -1 && (t = r);
        var n = t === r ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    function Rr(i) {
        var r = Z(i), t = r[0], n = r[1];
        return (t + n) * 3 / 4 - n;
    }
    function Tr(i, r, t) {
        return (r + t) * 3 / 4 - t;
    }
    function Cr(i) {
        var r, t = Z(i), n = t[0], e = t[1], o = new Ur(Tr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
        for(c = 0; c < f; c += 4)r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
        return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Sr(i) {
        return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function _r(i, r, t) {
        for(var n, e = [], o = r; o < t; o += 3)n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Sr(n));
        return e.join("");
    }
    function Lr(i) {
        for(var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)e.push(_r(i, u, u + o > f ? f : u + o));
        return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
});
var v = $((O)=>{
    O.read = function(i, r, t, n, e) {
        var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
        for(p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8);
        for(u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8);
        if (o === 0) o = 1 - l;
        else {
            if (o === c) return u ? NaN : (x ? -1 : 1) * (1 / 0);
            u = u + Math.pow(2, n), o = o - l;
        }
        return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    O.write = function(i, r, t, n, e, o) {
        var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, b = n ? 1 : -1, Br = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for(r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += b, f /= 256, e -= 8);
        for(u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += b, u /= 256, l -= 8);
        i[t + x - b] |= Br * 128;
    };
});
var z = $((T)=>{
    "use strict";
    var G = Q(), U = v(), rr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    T.Buffer = h;
    T.SlowBuffer = $r;
    T.INSPECT_MAX_BYTES = 50;
    var k = 2147483647;
    T.kMaxLength = k;
    h.TYPED_ARRAY_SUPPORT = Nr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Nr() {
        try {
            let i = new Uint8Array(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
        } catch (i) {
            return !1;
        }
    }
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.buffer;
        }
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (h.isBuffer(this)) return this.byteOffset;
        }
    });
    function d(i) {
        if (i > k) throw new RangeError('The value "' + i + '" is invalid for option "size"');
        let r = new Uint8Array(i);
        return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
        if (typeof i == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return j(i);
        }
        return er(i, r, t);
    }
    h.poolSize = 8192;
    function er(i, r, t) {
        if (typeof i == "string") return kr(i, r);
        if (ArrayBuffer.isView(i)) return Dr(i);
        if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
        if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer))) return q(i, r, t);
        if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = i.valueOf && i.valueOf();
        if (n != null && n !== i) return h.from(n, r, t);
        let e = br(i);
        if (e) return e;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return h.from(i[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
        return er(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function or(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
        if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function Mr(i, r, t) {
        return or(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
        return Mr(i, r, t);
    };
    function j(i) {
        return or(i), d(i < 0 ? 0 : H(i) | 0);
    }
    h.allocUnsafe = function(i) {
        return j(i);
    };
    h.allocUnsafeSlow = function(i) {
        return j(i);
    };
    function kr(i, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        let t = ur(i, r) | 0, n = d(t), e = n.write(i, r);
        return e !== t && (n = n.slice(0, e)), n;
    }
    function Y(i) {
        let r = i.length < 0 ? 0 : H(i.length) | 0, t = d(r);
        for(let n = 0; n < r; n += 1)t[n] = i[n] & 255;
        return t;
    }
    function Dr(i) {
        if (E(i, Uint8Array)) {
            let r = new Uint8Array(i);
            return q(r.buffer, r.byteOffset, r.byteLength);
        }
        return Y(i);
    }
    function q(i, r, t) {
        if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function br(i) {
        if (h.isBuffer(i)) {
            let r = H(i.length) | 0, t = d(r);
            return t.length === 0 || i.copy(t, 0, 0, r), t;
        }
        if (i.length !== void 0) return typeof i.length != "number" || X(i.length) ? d(0) : Y(i);
        if (i.type === "Buffer" && Array.isArray(i.data)) return Y(i.data);
    }
    function H(i) {
        if (i >= k) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + k.toString(16) + " bytes");
        return i | 0;
    }
    function $r(i) {
        return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== h.prototype;
    };
    h.compare = function(r, t) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let n = r.length, e = t.length;
        for(let o = 0, u = Math.min(n, e); o < u; ++o)if (r[o] !== t[o]) {
            n = r[o], e = t[o];
            break;
        }
        return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    };
    h.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < r.length; ++n)t += r[n].length;
        let e = h.allocUnsafe(t), o = 0;
        for(n = 0; n < r.length; ++n){
            let u = r[n];
            if (E(u, Uint8Array)) o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
            else if (h.isBuffer(u)) u.copy(e, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += u.length;
        }
        return e;
    };
    function ur(i, r) {
        if (h.isBuffer(i)) return i.length;
        if (ArrayBuffer.isView(i) || E(i, ArrayBuffer)) return i.byteLength;
        if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
        let t = i.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return W(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return wr(i).length;
            default:
                if (e) return n ? -1 : W(i).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    h.byteLength = ur;
    function Pr(i, r, t) {
        let n = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(i || (i = "utf8");;)switch(i){
            case "hex":
                return zr(this, r, t);
            case "utf8":
            case "utf-8":
                return fr(this, r, t);
            case "ascii":
                return Vr(this, r, t);
            case "latin1":
            case "binary":
                return Xr(this, r, t);
            case "base64":
                return jr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Jr(this, r, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), n = !0;
        }
    }
    h.prototype._isBuffer = !0;
    function I(i, r, t) {
        let n = i[r];
        i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
        let r = this.length;
        if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)I(this, t, t + 1);
        return this;
    };
    h.prototype.swap32 = function() {
        let r = this.length;
        if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)I(this, t, t + 3), I(this, t + 1, t + 2);
        return this;
    };
    h.prototype.swap64 = function() {
        let r = this.length;
        if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
        return this;
    };
    h.prototype.toString = function() {
        let r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? fr(this, 0, r) : Pr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
        if (!h.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
        let r = "", t = T.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    rr && (h.prototype[rr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length) throw new RangeError("out of range index");
        if (e >= o && t >= n) return 0;
        if (e >= o) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r) return 0;
        let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
        for(let p = 0; p < c; ++p)if (l[p] !== s[p]) {
            u = l[p], f = s[p];
            break;
        }
        return u < f ? -1 : f < u ? 1 : 0;
    };
    function hr(i, r, t, n, e) {
        if (i.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
            if (e) return -1;
            t = i.length - 1;
        } else if (t < 0) {
            if (e) t = 0;
            else return -1;
        }
        if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r)) return r.length === 0 ? -1 : tr(i, r, t, n, e);
        if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : tr(i, [
            r
        ], t, n, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function tr(i, r, t, n, e) {
        let o = 1, u = i.length, f = r.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, u /= 2, f /= 2, t /= 2;
        }
        function c(s, p) {
            return o === 1 ? s[p] : s.readUInt16BE(p * o);
        }
        let l;
        if (e) {
            let s = -1;
            for(l = t; l < u; l++)if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
                if (s === -1 && (s = l), l - s + 1 === f) return s * o;
            } else s !== -1 && (l -= l - s), s = -1;
        } else for(t + f > u && (t = u - f), l = t; l >= 0; l--){
            let s = !0;
            for(let p = 0; p < f; p++)if (c(i, l + p) !== c(r, p)) {
                s = !1;
                break;
            }
            if (s) return l;
        }
        return -1;
    }
    h.prototype.includes = function(r, t, n) {
        return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
        return hr(this, r, t, n, !0);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
        return hr(this, r, t, n, !1);
    };
    function Or(i, r, t, n) {
        t = Number(t) || 0;
        let e = i.length - t;
        n ? (n = Number(n), n > e && (n = e)) : n = e;
        let o = r.length;
        n > o / 2 && (n = o / 2);
        let u;
        for(u = 0; u < n; ++u){
            let f = parseInt(r.substr(u * 2, 2), 16);
            if (X(f)) return u;
            i[t + u] = f;
        }
        return u;
    }
    function Gr(i, r, t, n) {
        return D(W(r, i.length - t), i, t, n);
    }
    function Yr(i, r, t, n) {
        return D(vr(r), i, t, n);
    }
    function qr(i, r, t, n) {
        return D(wr(r), i, t, n);
    }
    function Wr(i, r, t, n) {
        return D(rt(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
        if (t === void 0) e = "utf8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") e = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t;
        if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let u = !1;
        for(;;)switch(e){
            case "hex":
                return Or(this, r, t, n);
            case "utf8":
            case "utf-8":
                return Gr(this, r, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return Yr(this, r, t, n);
            case "base64":
                return qr(this, r, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Wr(this, r, t, n);
            default:
                if (u) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), u = !0;
        }
    };
    h.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function jr(i, r, t) {
        return r === 0 && t === i.length ? G.fromByteArray(i) : G.fromByteArray(i.slice(r, t));
    }
    function fr(i, r, t) {
        t = Math.min(i.length, t);
        let n = [], e = r;
        for(; e < t;){
            let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (e + f <= t) {
                let c, l, s, p;
                switch(f){
                    case 1:
                        o < 128 && (u = o);
                        break;
                    case 2:
                        c = i[e + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
                        break;
                    case 3:
                        c = i[e + 1], l = i[e + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
                        break;
                    case 4:
                        c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
                }
            }
            u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
        }
        return Hr(n);
    }
    var ir = 4096;
    function Hr(i) {
        let r = i.length;
        if (r <= ir) return String.fromCharCode.apply(String, i);
        let t = "", n = 0;
        for(; n < r;)t += String.fromCharCode.apply(String, i.slice(n, n += ir));
        return t;
    }
    function Vr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e] & 127);
        return n;
    }
    function Xr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e]);
        return n;
    }
    function zr(i, r, t) {
        let n = i.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
        let e = "";
        for(let o = r; o < t; ++o)e += tt[i[o]];
        return e;
    }
    function Jr(i, r, t) {
        let n = i.slice(r, t), e = "";
        for(let o = 0; o < n.length - 1; o += 2)e += String.fromCharCode(n[o] + n[o + 1] * 256);
        return e;
    }
    h.prototype.slice = function(r, t) {
        let n = this.length;
        r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
        let e = this.subarray(r, t);
        return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
        if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r + --t], o = 1;
        for(; t > 0 && (o *= 256);)e += this[r + --t] * o;
        return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 256 + this[++r] * 2 ** 16 + n * 2 ** 24;
        return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n;
        return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = t, o = 1, u = this[r + --e];
        for(; e > 0 && (o *= 256);)u += this[r + --e] * o;
        return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r] | this[r + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r + 1] | this[r] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = this[r + 4] + this[r + 5] * 256 + this[r + 6] * 2 ** 16 + (n << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 256 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
        r = r >>> 0, R(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && _(r, this.length - 8);
        let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 256 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 256 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !0, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, !1, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !0, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, !1, 52, 8);
    };
    function y(i, r, t, n, e, o) {
        if (!h.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < o) throw new RangeError('"value" argument is out of bounds');
        if (t + n > i.length) throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = 1, u = 0;
        for(this[t] = r & 255; ++u < n && (o *= 256);)this[t + u] = r / o & 255;
        return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = n - 1, u = 1;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)this[t + o] = r / u & 255;
        return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function cr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function pr(i, r, t, n, e) {
        yr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = 0, u = 1, f = 0;
        for(this[t] = r & 255; ++o < n && (u *= 256);)r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = n - 1, u = 1, f = 0;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
        return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
        return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function sr(i, r, t, n, e, o) {
        if (t + n > i.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function lr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 4, 34028234663852886e22, -340282346638528860000000000000000000000), U.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
        return lr(this, r, t, !0, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
        return lr(this, r, t, !1, n);
    };
    function ar(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || sr(i, r, t, 8, 17976931348623157e292, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), U.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
        return ar(this, r, t, !0, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
        return ar(this, r, t, !1, n);
    };
    h.prototype.copy = function(r, t, n, e) {
        if (!h.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
        let o = e - n;
        return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                let u = r.charCodeAt(0);
                (e === "utf8" && u < 128 || e === "latin1") && (r = u);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
        let o;
        if (typeof r == "number") for(o = t; o < n; ++o)this[o] = r;
        else {
            let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
            if (f === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(o = 0; o < n - t; ++o)this[o + t] = u[o % f];
        }
        return this;
    };
    var A = {};
    function V(i, r, t) {
        A[i] = class extends t {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = "".concat(this.name, " [").concat(i, "]"), this.stack, delete this.name;
            }
            get code() {
                return i;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return "".concat(this.name, " [").concat(i, "]: ").concat(this.message);
            }
        };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
        return i ? "".concat(i, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i, r) {
        return 'The "'.concat(i, '" argument must be of type number. Received type ').concat(typeof r);
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i, r, t) {
        let n = 'The value of "'.concat(i, '" is out of range.'), e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = nr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = nr(e)), e += "n"), n += " It must be ".concat(r, ". Received ").concat(e), n;
    }, RangeError);
    function nr(i) {
        let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)r = "_".concat(i.slice(t - 3, t)).concat(r);
        return "".concat(i.slice(0, t)).concat(r);
    }
    function Kr(i, r, t) {
        R(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && _(r, i.length - (t + 1));
    }
    function yr(i, r, t, n, e, o) {
        if (i > t || i < r) {
            let u = typeof r == "bigint" ? "n" : "", f;
            throw o > 3 ? r === 0 || r === BigInt(0) ? f = ">= 0".concat(u, " and < 2").concat(u, " ** ").concat((o + 1) * 8).concat(u) : f = ">= -(2".concat(u, " ** ").concat((o + 1) * 8 - 1).concat(u, ") and < 2 ** ") + "".concat((o + 1) * 8 - 1).concat(u) : f = ">= ".concat(r).concat(u, " and <= ").concat(t).concat(u), new A.ERR_OUT_OF_RANGE("value", f, i);
        }
        Kr(n, e, o);
    }
    function R(i, r) {
        if (typeof i != "number") throw new A.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function _(i, r, t) {
        throw Math.floor(i) !== i ? (R(i, t), new A.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS : new A.ERR_OUT_OF_RANGE(t || "offset", ">= ".concat(t ? 1 : 0, " and <= ").concat(r), i);
    }
    var Zr = /[^+/0-9A-Za-z-_]/g;
    function Qr(i) {
        if (i = i.split("=")[0], i = i.trim().replace(Zr, ""), i.length < 2) return "";
        for(; i.length % 4 !== 0;)i = i + "=";
        return i;
    }
    function W(i, r) {
        r = r || 1 / 0;
        let t, n = i.length, e = null, o = [];
        for(let u = 0; u < n; ++u){
            if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (u + 1 === n) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && o.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                o.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                o.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    function vr(i) {
        let r = [];
        for(let t = 0; t < i.length; ++t)r.push(i.charCodeAt(t) & 255);
        return r;
    }
    function rt(i, r) {
        let t, n, e, o = [];
        for(let u = 0; u < i.length && !((r -= 2) < 0); ++u)t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
        return o;
    }
    function wr(i) {
        return G.toByteArray(Qr(i));
    }
    function D(i, r, t, n) {
        let e;
        for(e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)r[e + t] = i[e];
        return e;
    }
    function E(i, r) {
        return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function X(i) {
        return i !== i;
    }
    var tt = function() {
        let i = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let e = 0; e < 16; ++e)r[n + e] = i[t] + i[e];
        }
        return r;
    }();
    function g(i) {
        return typeof BigInt > "u" ? it : i;
    }
    function it() {
        throw new Error("BigInt not supported");
    }
});
var C = {};
Fr(C, {
    default: ()=>nt
});
module.exports = Ar(C);
var xr = J(z());
S(C, J(z()), module.exports);
var nt = xr.default; /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/ 

},{}]},["cbTDl","8oeFb"], "8oeFb", "parcelRequirec096")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNO0lBRXpEO0lBRUE7O0tBRUcsR0FDSCwwQkFBMEIsTUFBYyxFQUF4QztRQUNJLElBQUksQ0FBQyxzQkFBc0IsT0FBTztJQUN0QztBQUNIO0FBeGdCRCxRQUFBLFdBQUE7QUEwZ0JBLFNBQWdCLGtCQUFxRSxJQUFPLEVBQUUsVUFBYTtJQUN2RyxPQUFPLE9BQU8sUUFBUSxZQUFZLE9BQzlCLENBQUMsS0FBSyxDQUFDLEtBQUssTUFBTTtRQUNkLElBQUksU0FBUyxPQUFPLFVBQVUsVUFDMUIsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHO1lBQUUsR0FBRyxHQUFHLENBQUMsSUFBSTtZQUFFLEdBQUcsS0FBSztRQUFBLElBQUs7YUFFbEQsR0FBRyxDQUFDLElBQUksR0FBRztRQUVmLE9BQU87SUFDWCxHQUNBO1FBQUUsR0FBRyxJQUFJO0lBQUE7QUFFakI7OztBO0EsTyxlLFMsYztJLE87QTtBLFEsd0MsUSwyQixRLDRCLFEsb0MsUSxxQyxRLDRCLFEsNkIsUSx5QixRLGlCLFEsNkIsUSw2QixRLHlCLFEsd0IsUSx5QixRLDZCLFEsaUIsUSxvQixRLDRCLFEsZ0MsUSx5QixRLDJCLFEsc0IsUSwwQixRLDJCLFEsdUIsUSxxQixRLGMsUSxhLFEsOEIsUSxvQixRLHVCLFEsaUIsUSxxQixRLFksUSxvQixRLHdCLFEsd0IsUSw0QixRLG1CLFEsdUIsUSxrQixRLGUsUSxxQixRLGdCLFEsZSxRLHNCLFEsa0IsUSw4QixRLHNDLFEsMEIsSztBLFEsc0IsUSxxQyxRLHdCLFEseUIsUSxhLFEsdUIsUSx3QixRLHdCLFEsMEIsUSxrQyxRLHFCLFEsc0IsUSxrQyxRLG1CLFEscUIsUSxxQixRLHNCLFEsNEIsUSw2QixRLHdCLFEseUIsUSxrQixRLG1DLFEsd0IsUSxxQixRLG9DLFEsd0IsUSxvQyxRLHVCLFEsd0IsUSx5QixRLGEsUSx3QixRLHNDLFEsd0IsUSxzQixRLHFCLFEscUIsUSx5QixRLHFCLFEscUIsUSxvQixRLHlCLFEsMEIsUSwyQixRLGUsUSx1QixRLG9DLFEsMkIsUSx5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LFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsU0FBUyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxVQUFVLFNBQVM7WUFDbkIsR0FBRyxDQUFBLEdBQUEsc0JBQVEsRUFBRSxTQUFTLFNBQVMsUUFBUTtRQUMzQztJQUNKO0lBQ0EsV0FBVyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsU0FBUyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsSUFBSSxTQUFTLEVBQUUsT0FBTyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsSUFBSSxTQUFTLEVBQUUsT0FBTyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0EsT0FBTyxHQUFHLEVBQUUsT0FBTyxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFVBQVU7WUFDbEIsTUFBTTtZQUNOLE9BQU87WUFDUCxHQUFHLENBQUEsR0FBQSxzQkFBUSxFQUFFLFNBQVMsUUFBUTtRQUNsQztJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTLE9BQU8sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFBLEdBQUEsc0JBQVEsRUFBRSxT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Y3NMLGVBQWU7WUFDeEQsbUJBQUEsSUFBSXhMLE9BQU9DLE1BQU0sZ0JBQWdCQyxjQUFjc0wsZUFBZTtZQUN0RSxXQUFBLElBQUl4TCxPQUFPQyxNQUFNLFVBQVVDLGNBQWNzTCxjQUFjLGtCQUFrQkMsYUFBYTtZQUNuRixjQUFBLElBQUl6TCxPQUFPQyxNQUFNLFVBQVVDLGNBQWNzTCxjQUFjLG1CQUFtQjtZQUNoRixRQUFBLElBQUl4TCxPQUFPQyxNQUFNLE9BQU9DLGNBQWNzTCxlQUFlO1lBQ2pELFlBQUEsSUFBSXhMLE9BQU9FLGNBQWM7WUFDeEIsYUFBQSxJQUFJRixPQUFPQyxNQUFNLFVBQVVDLGNBQWNxTCxhQUFhO1lBQ3RELGFBQUEsSUFBSXZMLE9BQU9NLGNBQWM7WUFDekIsYUFBQSxJQUFJTixPQUFPLE9BQU9zTCxlQUFlO1lBQ2pDLGFBQUEsSUFBSXRMLE9BQU8sV0FBV29MLGVBQWUsTUFBTTVLLE9BQU9BLE9BQU8saUJBQWlCQyxXQUFXLFVBQVUsTUFBTTRLLFVBQVUsT0FBTyxVQUF0SCxzQ0FBQTtRQWJmO0k7SUFpQkQsSUFBQSxlQUFlRixVQUFVO0lEckZ6QixJQUFBLGVBQWVBLFVBQVU7SSxJLGdCO1EsUyxjLEcsRSxDO1ksSSxPLEU7WSxJLEs7WSxJLEs7WSxJLEs7WSxJO2dCLEksSSxLLEcsQyxPLFMsSSxJLEMsQyxLLEEsQyxLLEcsTSxFLEksRyxLLEs7b0IsSyxLLEc7b0IsSSxLLEssVyxHO2dCO1ksRSxPLEs7Z0IsSztnQixLO1ksUztnQixJO29CLEksQyxNLEUsQyxTLEUsRSxDLFM7Z0IsUztvQixJLEksTTtnQjtZO1ksTztRO1EsTyxTLEcsRSxDO1ksSSxNLFEsTSxPO2lCLEksTyxZLE8sTSxPLGMsSztpQixNLEksVTtRO0k7SSxJLG9CLFMsRztRLEksTSxRLE07WSxJLEksSSxHLE8sTSxJLFMsSSxJLFEsSSxJLEMsRSxHLEcsQyxFO1ksTztRLE8sTyxNLEs7STtJRER6QiwrQ0FBQSxHQUNBLElBQU1wQyxTQUFTLFlBQWYsNEJBQUE7SSwwQixHQUdBLElBQU16RyxPQUFP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TSxPQUFPLENBQUMsRUFBRSxDQUFBLEdBQUEsd0JBQVksRUFBRSxtQkFBbUIsT0FBTyxDQUFDO0FBQ2xGOzs7QUMzU0EsSUFBSSxLQUFHLE9BQU87QUFBTyxJQUFJLElBQUUsT0FBTztBQUFlLElBQUksS0FBRyxPQUFPO0FBQXlCLElBQUksS0FBRyxPQUFPO0FBQW9CLElBQUksS0FBRyxPQUFPLGdCQUFlLEtBQUcsT0FBTyxVQUFVO0FBQWUsSUFBSSxJQUFFLENBQUMsR0FBRSxJQUFJLElBQUssQ0FBQSxLQUFHLEVBQUUsQUFBQyxDQUFBLElBQUU7WUFBQyxTQUFRLENBQUM7UUFBQyxDQUFBLEVBQUcsU0FBUSxJQUFHLEVBQUUsT0FBTSxHQUFHLEtBQUcsQ0FBQyxHQUFFO0lBQUssSUFBSSxJQUFJLEtBQUssRUFBRSxFQUFFLEdBQUUsR0FBRTtRQUFDLEtBQUksQ0FBQyxDQUFDLEVBQUU7UUFBQyxZQUFXLENBQUM7SUFBQztBQUFFLEdBQUUsSUFBRSxDQUFDLEdBQUUsR0FBRSxHQUFFO0lBQUssSUFBRyxLQUFHLE9BQU8sS0FBRyxZQUFVLE9BQU8sS0FBRyxZQUFXLEtBQUksSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFFLE1BQUksTUFBSSxLQUFHLEVBQUUsR0FBRSxHQUFFO1FBQUMsS0FBSSxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQUMsWUFBVyxDQUFFLENBQUEsSUFBRSxHQUFHLEdBQUUsRUFBQyxLQUFJLEVBQUU7SUFBVTtJQUFHLE9BQU87QUFBQyxHQUFFLElBQUUsQ0FBQyxHQUFFLEdBQUUsSUFBSyxDQUFBLEVBQUUsR0FBRSxHQUFFLFlBQVcsS0FBRyxFQUFFLEdBQUUsR0FBRSxVQUFTLEdBQUcsSUFBRSxDQUFDLEdBQUUsR0FBRSxJQUFLLENBQUEsSUFBRSxLQUFHLE9BQUssR0FBRyxHQUFHLE1BQUksQ0FBQyxHQUFFLEVBQUUsS0FBRyxDQUFDLEtBQUcsQ0FBQyxFQUFFLGFBQVcsRUFBRSxHQUFFLFdBQVU7UUFBQyxPQUFNO1FBQUUsWUFBVyxDQUFDO0lBQUMsS0FBRyxHQUFFLEVBQUMsR0FBRyxLQUFHLENBQUEsSUFBRyxFQUFFLEVBQUUsQ0FBQyxHQUFFLGNBQWE7UUFBQyxPQUFNLENBQUM7SUFBQyxJQUFHO0FBQUcsSUFBSSxJQUFFLEVBQUUsQ0FBQTtJQUFJO0lBQWEsRUFBRSxhQUFXO0lBQUcsRUFBRSxjQUFZO0lBQUcsRUFBRSxnQkFBYztJQUFHLElBQUksSUFBRSxFQUFFLEVBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxPQUFPLGFBQVcsTUFBSSxhQUFXLE9BQU0sSUFBRTtJQUFtRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxJQUFFLEdBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsR0FBQztJQUFFLElBQUksR0FBRTtJQUFFLENBQUMsQ0FBQyxJQUFJLFdBQVcsR0FBRyxHQUFDO0lBQUcsQ0FBQyxDQUFDLElBQUksV0FBVyxHQUFHLEdBQUM7SUFBRyxTQUFTLEVBQUUsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxJQUFFLElBQUUsR0FBRSxNQUFNLElBQUksTUFBTTtRQUFrRCxJQUFJLElBQUUsRUFBRSxRQUFRO1FBQUssTUFBSSxNQUFLLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLE1BQUksSUFBRSxJQUFFLElBQUUsSUFBRTtRQUFFLE9BQU07WUFBQztZQUFFO1NBQUU7SUFBQTtJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFFLEVBQUUsSUFBRyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU0sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsSUFBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLEdBQUUsSUFBRSxFQUFFLElBQUcsSUFBRSxDQUFDLENBQUMsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksR0FBRyxHQUFHLEdBQUUsR0FBRSxLQUFJLElBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUUsR0FBRTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsRUFBQyxDQUFDLENBQUMsSUFBSSxHQUFDLEtBQUcsS0FBRyxLQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUMsS0FBRyxJQUFFLEtBQUksQ0FBQyxDQUFDLElBQUksR0FBQyxJQUFFO1FBQUksT0FBTyxNQUFJLEtBQUksQ0FBQSxJQUFFLENBQUMsQ0FBQyxFQUFFLFdBQVcsR0FBRyxJQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsV0FBVyxJQUFFLEdBQUcsSUFBRSxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsSUFBRSxHQUFFLEdBQUcsTUFBSSxLQUFJLENBQUEsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEdBQUcsSUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBRSxHQUFHLElBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLElBQUUsR0FBRyxJQUFFLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxLQUFHLElBQUUsS0FBSSxDQUFDLENBQUMsSUFBSSxHQUFDLElBQUUsR0FBRSxHQUFHO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLElBQUUsR0FBRztJQUFBO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBSSxHQUFFLElBQUUsRUFBRSxFQUFDLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxFQUFFLElBQUUsS0FBRyxRQUFPLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLElBQUUsSUFBRSxLQUFJLElBQUksQ0FBQSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxHQUFHLEVBQUUsS0FBSyxHQUFHO1FBQUksT0FBTyxFQUFFLEtBQUs7SUFBRztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsSUFBSSxJQUFJLEdBQUUsSUFBRSxFQUFFLFFBQU8sSUFBRSxJQUFFLEdBQUUsSUFBRSxFQUFFLEVBQUMsSUFBRSxPQUFNLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsS0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBSSxPQUFPLE1BQUksSUFBRyxDQUFBLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsS0FBSSxJQUFHLE1BQUksS0FBSSxDQUFBLElBQUUsQUFBQyxDQUFBLENBQUMsQ0FBQyxJQUFFLEVBQUUsSUFBRSxDQUFBLElBQUcsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBRyxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsQ0FBQyxDQUFDLEtBQUcsSUFBRSxHQUFHLEdBQUMsSUFBRyxHQUFHLEVBQUUsS0FBSztJQUFHO0FBQUM7QUFBRyxJQUFJLElBQUUsRUFBRSxDQUFBO0lBQUksRUFBRSxPQUFLLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLEdBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUcsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFO1FBQUMsSUFBSSxLQUFHLEdBQUUsSUFBRSxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUMsQ0FBQSxJQUFHLEdBQUUsTUFBSSxDQUFDLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsTUFBSSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsS0FBRyxHQUFFLEtBQUc7UUFBRyxJQUFJLElBQUUsSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFDLENBQUEsSUFBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFFLE1BQUksQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEtBQUcsR0FBRSxLQUFHO1FBQUcsSUFBRyxNQUFJLEdBQUUsSUFBRSxJQUFFO2FBQU07WUFBQyxJQUFHLE1BQUksR0FBRSxPQUFPLElBQUUsTUFBSSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBSSxDQUFBLElBQUUsQ0FBQTtZQUFHLElBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsSUFBRTtRQUFDO1FBQUMsT0FBTSxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUU7SUFBRTtJQUFFLEVBQUUsUUFBTSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxNQUFJLEtBQUcsS0FBSyxJQUFJLEdBQUUsT0FBSyxLQUFLLElBQUksR0FBRSxPQUFLLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxJQUFFLElBQUcsS0FBRyxJQUFFLEtBQUcsTUFBSSxLQUFHLElBQUUsSUFBRSxJQUFFLElBQUU7UUFBRSxJQUFJLElBQUUsS0FBSyxJQUFJLElBQUcsTUFBTSxNQUFJLE1BQUksSUFBRSxJQUFHLENBQUEsSUFBRSxNQUFNLEtBQUcsSUFBRSxHQUFFLElBQUUsQ0FBQSxJQUFJLENBQUEsSUFBRSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUcsS0FBSyxNQUFLLElBQUcsQ0FBQSxJQUFFLEtBQUssSUFBSSxHQUFFLENBQUMsRUFBQyxJQUFHLEtBQUksQ0FBQSxLQUFJLEtBQUcsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFFLEtBQUcsSUFBRSxJQUFFLEtBQUcsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLElBQUcsSUFBRSxLQUFHLEtBQUksQ0FBQSxLQUFJLEtBQUcsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFHLENBQUEsSUFBRSxHQUFFLElBQUUsQ0FBQSxJQUFHLElBQUUsS0FBRyxJQUFHLENBQUEsSUFBRSxBQUFDLENBQUEsSUFBRSxJQUFFLENBQUEsSUFBRyxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsSUFBRSxDQUFBLElBQUksQ0FBQSxJQUFFLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxDQUFBLENBQUMsR0FBRyxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxHQUFDLElBQUUsS0FBSSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7UUFBRyxJQUFJLElBQUUsS0FBRyxJQUFFLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLEtBQUcsR0FBRSxLQUFHLEtBQUks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SUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7UUFBSSxPQUFPO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUcsRUFBRSxHQUFFLGFBQVk7WUFBQyxJQUFJLElBQUUsSUFBSSxXQUFXO1lBQUcsT0FBTyxFQUFFLEVBQUUsUUFBTyxFQUFFLFlBQVcsRUFBRTtRQUFXO1FBQUMsT0FBTyxFQUFFO0lBQUU7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLEtBQUcsRUFBRSxhQUFXLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBd0MsSUFBRyxFQUFFLGFBQVcsSUFBRyxDQUFBLEtBQUcsQ0FBQSxHQUFHLE1BQU0sSUFBSSxXQUFXO1FBQXdDLElBQUk7UUFBRSxPQUFPLE1BQUksS0FBSyxLQUFHLE1BQUksS0FBSyxJQUFFLElBQUUsSUFBSSxXQUFXLEtBQUcsTUFBSSxLQUFLLElBQUUsSUFBRSxJQUFJLFdBQVcsR0FBRSxLQUFHLElBQUUsSUFBSSxXQUFXLEdBQUUsR0FBRSxJQUFHLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFHLEVBQUUsU0FBUyxJQUFHO1lBQUMsSUFBSSxJQUFFLEVBQUUsRUFBRSxVQUFRLEdBQUUsSUFBRSxFQUFFO1lBQUcsT0FBTyxFQUFFLFdBQVMsS0FBRyxFQUFFLEtBQUssR0FBRSxHQUFFLEdBQUUsSUFBRztRQUFDO1FBQUMsSUFBRyxFQUFFLFdBQVMsS0FBSyxHQUFFLE9BQU8sT0FBTyxFQUFFLFVBQVEsWUFBVSxFQUFFLEVBQUUsVUFBUSxFQUFFLEtBQUcsRUFBRTtRQUFHLElBQUcsRUFBRSxTQUFPLFlBQVUsTUFBTSxRQUFRLEVBQUUsT0FBTSxPQUFPLEVBQUUsRUFBRTtJQUFLO0lBQUMsU0FBUyxFQUFFLENBQUM7UUFBRSxJQUFHLEtBQUcsR0FBRSxNQUFNLElBQUksV0FBVyw0REFBMEQsRUFBRSxTQUFTLE1BQUk7UUFBVSxPQUFPLElBQUU7SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDO1FBQUUsT0FBTSxDQUFDLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLEVBQUUsTUFBTSxDQUFDO0lBQUU7SUFBQyxFQUFFLFdBQVMsU0FBUyxDQUFDO1FBQUUsT0FBTyxLQUFHLFFBQU0sRUFBRSxjQUFZLENBQUMsS0FBRyxNQUFJLEVBQUU7SUFBUztJQUFFLEVBQUUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLEdBQUUsZUFBYyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBRSxRQUFPLEVBQUUsV0FBVSxHQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsTUFBSSxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQXlFLElBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxLQUFLLElBQUksR0FBRSxJQUFHLElBQUUsR0FBRSxFQUFFLEVBQUUsSUFBRyxDQUFDLENBQUMsRUFBRSxLQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7WUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxDQUFDLENBQUMsRUFBRTtZQUFDO1FBQUs7UUFBQyxPQUFPLElBQUUsSUFBRSxLQUFHLElBQUUsSUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLGFBQVcsU0FBUyxDQUFDO1FBQUUsT0FBTyxPQUFPLEdBQUc7WUFBZSxLQUFJO1lBQU0sS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVEsS0FBSTtZQUFTLEtBQUk7WUFBUyxLQUFJO1lBQVMsS0FBSTtZQUFPLEtBQUk7WUFBUSxLQUFJO1lBQVUsS0FBSTtnQkFBVyxPQUFNLENBQUM7WUFBRTtnQkFBUSxPQUFNLENBQUM7UUFBQztJQUFDO0lBQUUsRUFBRSxTQUFPLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLENBQUMsTUFBTSxRQUFRLElBQUcsTUFBTSxJQUFJLFVBQVU7UUFBK0MsSUFBRyxFQUFFLFdBQVMsR0FBRSxPQUFPLEVBQUUsTUFBTTtRQUFHLElBQUk7UUFBRSxJQUFHLE1BQUksS0FBSyxHQUFFLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUUsS0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQU8sSUFBSSxJQUFFLEVBQUUsWUFBWSxJQUFHLElBQUU7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsUUFBTyxFQUFFLEVBQUU7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7WUFBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLElBQUUsRUFBRSxTQUFPLEVBQUUsU0FBUSxDQUFBLEVBQUUsU0FBUyxNQUFLLENBQUEsSUFBRSxFQUFFLEtBQUssRUFBQyxHQUFHLEVBQUUsS0FBSyxHQUFFLEVBQUMsSUFBRyxXQUFXLFVBQVUsSUFBSSxLQUFLLEdBQUUsR0FBRTtpQkFBUSxJQUFHLEVBQUUsU0FBUyxJQUFHLEVBQUUsS0FBSyxHQUFFO2lCQUFRLE1BQU0sSUFBSSxVQUFVO1lBQStDLEtBQUcsRUFBRTtRQUFNO1FBQUMsT0FBTztJQUFDO0lBQUUsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxFQUFFLFNBQVMsSUFBRyxPQUFPLEVBQUU7UUFBTyxJQUFHLFlBQVksT0FBTyxNQUFJLEVBQUUsR0FBRSxjQUFhLE9BQU8sRUFBRTtRQUFXLElBQUcsT0FBTyxLQUFHLFVBQVMsTUFBTSxJQUFJLFVBQVUsNkZBQTJGLE9BQU87UUFBRyxJQUFJLElBQUUsRUFBRSxRQUFPLElBQUUsVUFBVSxTQUFPLEtBQUcsU0FBUyxDQUFDLEVBQUUsS0FBRyxDQUFDO1FBQUUsSUFBRyxDQUFDLEtBQUcsTUFBSSxHQUFFLE9BQU87UUFBRSxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPO1lBQUUsS0FBSTtZQUFPLEtBQUk7Z0JBQVEsT0FBTyxFQUFFLEdBQUc7WUFBTyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sSUFBRTtZQUFFLEtBQUk7Z0JBQU0sT0FBTyxNQUFJO1lBQUUsS0FBSTtnQkFBUyxPQUFPLEdBQUcsR0FBRztZQUFPO2dCQUFRLElBQUcsR0FBRSxPQUFPLElBQUUsS0FBRyxFQUFFLEdBQUc7Z0JBQU8sSUFBRSxBQUFDLENBQUEsS0FBRyxDQUFBLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxhQUFXO0lBQUcsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxJQUFFLElBQUksQ0FBQyxVQUFTLENBQUEsQUFBQyxDQUFBLE1BQUksS0FBSyxLQUFHLElBQUUsSUFBSSxDQUFDLE1BQUssS0FBSyxDQUFBLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxLQUFHLENBQUEsS0FBSyxDQUFBLE9BQUssR0FBRSxPQUFLLEdBQUUsS0FBRyxDQUFBLEdBQUcsT0FBTTtRQUFHLElBQUksS0FBSSxDQUFBLElBQUUsTUFBSyxJQUFLLE9BQU87WUFBRyxLQUFJO2dCQUFNLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7WUFBTyxLQUFJO2dCQUFRLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHLEtBQUk7Z0JBQVEsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtZQUFTLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFO1lBQUcsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRTtZQUFHO2dCQUFRLElBQUcsR0FBRSxNQUFNLElBQUksVUFBVSx1QkFBcUI7Z0JBQUcsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEVBQUcsZUFBYyxJQUFFLENBQUM7UUFBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFlBQVUsQ0FBQztJQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7UUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQztJQUFDO0lBQUMsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxJQUFHLElBQUUsTUFBSSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQTZDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEtBQUcsRUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFHLE9BQU8sSUFBSTtJQUFBO0lBQUUsRUFBRSxVQUFVLFNBQU87UUFBVyxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRyxJQUFFLE1BQUksR0FBRSxNQUFNLElBQUksV0FBVztRQUE2QyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxJQUFFLElBQUcsRUFBRSxJQUFJLEVBQUMsSUFBRSxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksRUFBQyxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsSUFBSSxFQUFDLElBQUUsR0FBRSxJQUFFO1FBQUcsT0FBTyxJQUFJO0lBQUE7SUFBRSxFQUFFLFVBQVUsV0FBUztRQUFXLElBQUksSUFBRSxJQUFJLENBQUM7UUFBTyxPQUFPLE1BQUksSUFBRSxLQUFHLFVBQVUsV0FBUyxJQUFFLEdBQUcsSUFBSSxFQUFDLEdBQUUsS0FBRyxHQUFHLE1BQU0sSUFBSSxFQUFDO0lBQVU7SUFBRSxFQUFFLFVBQVUsaUJBQWUsRUFBRSxVQUFVO0lBQVMsRUFBRSxVQUFVLFNBQU8sU0FBUyxDQUFDO1FBQUUsSUFBRyxDQUFDLEVBQUUsU0FBUyxJQUFHLE1BQU0sSUFBSSxVQUFVO1FBQTZCLE9BQU8sSUFBSSxLQUFHLElBQUUsQ0FBQyxJQUFFLEVBQUUsUUFBUSxJQUFJLEVBQUMsT0FBSztJQUFDO0lBQUUsRUFBRSxVQUFVLFVBQVE7UUFBVyxJQUFJLElBQUUsSUFBRyxJQUFFLEVBQUU7UUFBa0IsT0FBTyxJQUFFLElBQUksQ0FBQyxTQUFTLE9BQU0sR0FBRSxHQUFHLFFBQVEsV0FBVSxPQUFPLFFBQU8sSUFBSSxDQUFDLFNBQU8sS0FBSSxDQUFBLEtBQUcsT0FBTSxHQUFHLGFBQVcsSUFBRTtJQUFHO0lBQUUsTUFBSyxDQUFBLEVBQUUsU0FBUyxDQUFDLEdBQUcsR0FBQyxFQUFFLFVBQVUsT0FBTTtJQUFHLEVBQUUsVUFBVSxVQUFRLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLEVBQUUsR0FBRSxlQUFjLENBQUEsSUFBRSxFQUFFLEtBQUssR0FBRSxFQUFFLFFBQU8sRUFBRSxXQUFVLEdBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVSxtRkFBaUYsT0FBTztRQUFHLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLENBQUEsR0FBRyxNQUFJLEtBQUssS0FBSSxDQUFBLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLE1BQUksS0FBSyxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLElBQUksQ0FBQyxNQUFLLEdBQUcsSUFBRSxLQUFHLElBQUUsRUFBRSxVQUFRLElBQUUsS0FBRyxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsS0FBRyxLQUFHLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBRyxLQUFHLEdBQUUsT0FBTTtRQUFHLElBQUcsS0FBRyxHQUFFLE9BQU87UUFBRSxJQUFHLE9BQUssR0FBRSxPQUFLLEdBQUUsT0FBSyxHQUFFLE9BQUssR0FBRSxJQUFJLEtBQUcsR0FBRSxPQUFPO1FBQUUsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxJQUFFLEtBQUssSUFBSSxHQUFFLElBQUcsSUFBRSxJQUFJLENBQUMsTUFBTSxHQUFFLElBQUcsSUFBRSxFQUFFLE1BQU0sR0FBRTtRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxJQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztZQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxFQUFFO1lBQUM7UUFBSztRQUFDLE9BQU8sSUFBRSxJQUFFLEtBQUcsSUFBRSxJQUFFLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsRUFBRSxXQUFTLEdBQUUsT0FBTTtRQUFHLElBQUcsT0FBTyxLQUFHLFdBQVUsQ0FBQSxJQUFFLEdBQUUsSUFBRSxDQUFBLElBQUcsSUFBRSxhQUFXLElBQUUsYUFBVyxJQUFFLGVBQWMsQ0FBQSxJQUFFLFdBQVUsR0FBRyxJQUFFLENBQUMsR0FBRSxFQUFFLE1BQUssQ0FBQSxJQUFFLElBQUUsSUFBRSxFQUFFLFNBQU8sQ0FBQSxHQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsRUFBRSxTQUFPLENBQUEsR0FBRyxLQUFHLEVBQUUsUUFBTztZQUFDLElBQUcsR0FBRSxPQUFNO1lBQUcsSUFBRSxFQUFFLFNBQU87UUFBQyxPQUFNLElBQUcsSUFBRTtZQUFFLElBQUcsR0FBRSxJQUFFO2lCQUFPLE9BQU07O1FBQUcsSUFBRyxPQUFPLEtBQUcsWUFBVyxDQUFBLElBQUUsRUFBRSxLQUFLLEdBQUUsRUFBQyxHQUFHLEVBQUUsU0FBUyxJQUFHLE9BQU8sRUFBRSxXQUFTLElBQUUsS0FBRyxHQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFHLE9BQU8sS0FBRyxVQUFTLE9BQU8sSUFBRSxJQUFFLEtBQUksT0FBTyxXQUFXLFVBQVUsV0FBUyxhQUFXLElBQUUsV0FBVyxVQUFVLFFBQVEsS0FBSyxHQUFFLEdBQUUsS0FBRyxXQUFXLFVBQVUsWUFBWSxLQUFLLEdBQUUsR0FBRSxLQUFHLEdBQUcsR0FBRTtZQUFDO1NBQUUsRUFBQyxHQUFFLEdBQUU7UUFBRyxNQUFNLElBQUksVUFBVTtJQUF1QztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsRUFBRSxRQUFPLElBQUUsRUFBRTtRQUFPLElBQUcsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE9BQU8sR0FBRyxlQUFjLE1BQUksVUFBUSxNQUFJLFdBQVMsTUFBSSxhQUFXLE1BQUksVUFBUyxHQUFHO1lBQUMsSUFBRyxFQUFFLFNBQU8sS0FBRyxFQUFFLFNBQU8sR0FBRSxPQUFNO1lBQUcsSUFBRSxHQUFFLEtBQUcsR0FBRSxLQUFHLEdBQUUsS0FBRztRQUFDO1FBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO1lBQUUsT0FBTyxNQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLGFBQWEsSUFBRTtRQUFFO1FBQUMsSUFBSTtRQUFFLElBQUcsR0FBRTtZQUFDLElBQUksSUFBRTtZQUFHLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFJLElBQUcsRUFBRSxHQUFFLE9BQUssRUFBRSxHQUFFLE1BQUksS0FBRyxJQUFFLElBQUUsSUFBRztnQkFBQyxJQUFHLE1BQUksTUFBSyxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUUsSUFBRSxNQUFJLEdBQUUsT0FBTyxJQUFFO1lBQUMsT0FBTSxNQUFJLE1BQUssQ0FBQSxLQUFHLElBQUUsQ0FBQSxHQUFHLElBQUU7UUFBRSxPQUFNLElBQUksSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQSxHQUFHLElBQUUsR0FBRSxLQUFHLEdBQUUsSUFBSTtZQUFDLElBQUksSUFBRSxDQUFDO1lBQUUsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBSSxJQUFHLEVBQUUsR0FBRSxJQUFFLE9BQUssRUFBRSxHQUFFLElBQUc7Z0JBQUMsSUFBRSxDQUFDO2dCQUFFO1lBQUs7WUFBQyxJQUFHLEdBQUUsT0FBTztRQUFDO1FBQUMsT0FBTTtJQUFFO0lBQUMsRUFBRSxVQUFVLFdBQVMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUksQ0FBQyxRQUFRLEdBQUUsR0FBRSxPQUFLO0lBQUU7SUFBRSxFQUFFLFVBQVUsVUFBUSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsQ0FBQztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLENBQUM7SUFBRTtJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxPQUFPLE1BQUk7UUFBRSxJQUFJLElBQUUsRUFBRSxTQUFPO1FBQUUsSUFBRyxDQUFBLElBQUUsT0FBTyxJQUFHLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRTtRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRSxJQUFFLEtBQUksQ0FBQSxJQUFFLElBQUUsQ0FBQTtRQUFHLElBQUk7UUFBRSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFO1lBQUMsSUFBSSxJQUFFLFNBQVMsRUFBRSxPQUFPLElBQUUsR0FBRSxJQUFHO1lBQUksSUFBRyxFQUFFLElBQUcsT0FBTztZQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFDO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsRUFBRSxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLEVBQUUsR0FBRyxHQUFFLEVBQUUsU0FBTyxJQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsRUFBRSxVQUFVLFFBQU0sU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxNQUFJLEtBQUssR0FBRSxJQUFFLFFBQU8sSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxNQUFJLEtBQUssS0FBRyxPQUFPLEtBQUcsVUFBUyxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsUUFBTyxJQUFFO2FBQU8sSUFBRyxTQUFTLElBQUcsSUFBRSxNQUFJLEdBQUUsU0FBUyxLQUFJLENBQUEsSUFBRSxNQUFJLEdBQUUsTUFBSSxLQUFLLEtBQUksQ0FBQSxJQUFFLE1BQUssQ0FBQyxJQUFJLENBQUEsSUFBRSxHQUFFLElBQUUsS0FBSyxDQUFBO2FBQVEsTUFBTSxJQUFJLE1BQU07UUFBMkUsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFPO1FBQUUsSUFBRyxBQUFDLENBQUEsTUFBSSxLQUFLLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUEsR0FBRyxFQUFFLFNBQU8sS0FBSSxDQUFBLElBQUUsS0FBRyxJQUFFLENBQUEsS0FBSSxJQUFFLElBQUksQ0FBQyxRQUFPLE1BQU0sSUFBSSxXQUFXO1FBQTBDLEtBQUksQ0FBQSxJQUFFLE1BQUs7UUFBRyxJQUFJLElBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTztZQUFHLEtBQUk7Z0JBQU0sT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtnQkFBUSxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtnQkFBUyxPQUFPLEdBQUcsSUFBSSxFQUFDLEdBQUUsR0FBRTtZQUFHLEtBQUk7Z0JBQVMsT0FBTyxHQUFHLElBQUksRUFBQyxHQUFFLEdBQUU7WUFBRyxLQUFJO1lBQU8sS0FBSTtZQUFRLEtBQUk7WUFBVSxLQUFJO2dCQUFXLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFO1lBQUc7Z0JBQVEsSUFBRyxHQUFFLE1BQU0sSUFBSSxVQUFVLHVCQUFxQjtnQkFBRyxJQUFFLEFBQUMsQ0FBQSxLQUFHLENBQUEsRUFBRyxlQUFjLElBQUUsQ0FBQztRQUFDO0lBQUM7SUFBRSxFQUFFLFVBQVUsU0FBTztRQUFXLE9BQU07WUFBQyxNQUFLO1lBQVMsTUFBSyxNQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFNLElBQUksRUFBQztRQUFFO0lBQUM7SUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxNQUFJLEtBQUcsTUFBSSxFQUFFLFNBQU8sRUFBRSxjQUFjLEtBQUcsRUFBRSxjQUFjLEVBQUUsTUFBTSxHQUFFO0lBQUc7SUFBQyxTQUFTLEdBQUcsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxLQUFLLElBQUksRUFBRSxRQUFPO1FBQUcsSUFBSSxJQUFFLEVBQUUsRUFBQyxJQUFFO1FBQUUsTUFBSyxJQUFFLEdBQUc7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFFLE1BQUssSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRSxJQUFFLE1BQUksSUFBRTtZQUFFLElBQUcsSUFBRSxLQUFHLEdBQUU7Z0JBQUMsSUFBSSxHQUFFLEdBQUUsR0FBRTtnQkFBRSxPQUFPO29CQUFHLEtBQUs7d0JBQUUsSUFBRSxPQUFNLENBQUEsSUFBRSxDQUFBO3dCQUFHO29CQUFNLEtBQUs7d0JBQUUsSUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEVBQUMsQUFBQyxDQUFBLElBQUUsR0FBRSxNQUFLLE9BQU0sQ0FBQSxJQUFFLEFBQUMsQ0FBQSxJQUFFLEVBQUMsS0FBSSxJQUFFLElBQUUsSUFBRyxJQUFFLE9BQU0sQ0FBQSxJQUFFLENBQUEsQ0FBQzt3QkFBRztvQkFBTSxLQUFLO3dCQUFFLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLElBQUUsQ0FBQyxDQUFDLElBQUUsRUFBRSxFQUFDLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFLLEFBQUMsQ0FBQSxJQUFFLEdBQUUsTUFBSyxPQUFNLENBQUEsSUFBRSxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksS0FBRyxBQUFDLENBQUEsSUFBRSxFQUFDLEtBQUksSUFBRSxJQUFFLElBQUcsSUFBRSxRQUFPLENBQUEsSUFBRSxTQUFPLElBQUUsS0FBSSxLQUFLLENBQUEsSUFBRSxDQUFBLENBQUM7d0JBQUc7b0JBQU0sS0FBSzt3QkFBRSxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxJQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsRUFBQyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBSyxBQUFDLENBQUEsSUFBRSxHQUFFLE1BQUssT0FBTSxDQUFBLElBQUUsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLEtBQUcsQUFBQyxDQUFBLElBQUUsRUFBQyxLQUFJLElBQUUsSUFBRSxJQUFHLElBQUUsU0FBTyxJQUFFLFdBQVUsQ0FBQSxJQUFFLENBQUEsQ0FBQztnQkFBRTtZQUFDO1lBQUMsTUFBSSxPQUFNLENBQUEsSUFBRSxPQUFNLElBQUUsQ0FBQSxJQUFHLElBQUUsU0FBUSxDQUFBLEtBQUcsT0FBTSxFQUFFLEtBQUssTUFBSSxLQUFHLE9BQUssUUFBTyxJQUFFLFFBQU0sSUFBRSxJQUFHLEdBQUcsRUFBRSxLQUFLLElBQUcsS0FBRztRQUFDO1FBQUMsT0FBTyxHQUFHO0lBQUU7SUFBQyxJQUFJLEtBQUc7SUFBSyxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUksSUFBRSxFQUFFO1FBQU8sSUFBRyxLQUFHLElBQUcsT0FBTyxPQUFPLGFBQWEsTUFBTSxRQUFPO1FBQUcsSUFBSSxJQUFFLElBQUcsSUFBRTtRQUFFLE1BQUssSUFBRSxHQUFHLEtBQUcsT0FBTyxhQUFhLE1BQU0sUUFBTyxFQUFFLE1BQU0sR0FBRSxLQUFHO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDO1FBQUssT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksSUFBRTtRQUFHLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTztRQUFHLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLEVBQUUsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRTtRQUFFLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFRLENBQUEsQ0FBQyxLQUFHLElBQUUsQ0FBQSxLQUFLLENBQUEsSUFBRSxDQUFBLEdBQUcsQUFBQyxDQUFBLENBQUMsS0FBRyxJQUFFLEtBQUcsSUFBRSxDQUFBLEtBQUssQ0FBQSxJQUFFLENBQUE7UUFBRyxJQUFJLElBQUU7UUFBRyxJQUFJLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxFQUFFLEVBQUUsS0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUFDLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRSxNQUFNLEdBQUUsSUFBRyxJQUFFO1FBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsU0FBTyxHQUFFLEtBQUcsRUFBRSxLQUFHLE9BQU8sYUFBYSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFLLE9BQU87SUFBQztJQUFDLEVBQUUsVUFBVSxRQUFNLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFJLElBQUUsSUFBSSxDQUFDO1FBQU8sSUFBRSxDQUFDLENBQUMsR0FBRSxJQUFFLE1BQUksS0FBSyxJQUFFLElBQUUsQ0FBQyxDQUFDLEdBQUUsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxJQUFHLENBQUEsS0FBRyxHQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsQ0FBQSxDQUFDLElBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsSUFBRSxLQUFJLENBQUEsSUFBRSxDQUFBO1FBQUcsSUFBSSxJQUFFLElBQUksQ0FBQyxTQUFTLEdBQUU7UUFBRyxPQUFPLE9BQU8sZUFBZSxHQUFFLEVBQUUsWUFBVztJQUFDO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsSUFBRSxNQUFJLEtBQUcsSUFBRSxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsSUFBRSxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7SUFBd0M7SUFBQyxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxHQUFFLElBQUU7UUFBRSxNQUFLLEVBQUUsSUFBRSxLQUFJLENBQUEsS0FBRyxHQUFFLEdBQUksS0FBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDO1FBQVEsSUFBSSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsRUFBRSxFQUFDLElBQUU7UUFBRSxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLElBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEFBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxFQUFDLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDO0lBQVE7SUFBRSxFQUFFLFVBQVUsZUFBYSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsV0FBVSxDQUFBLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsQUFBRDtJQUFFO0lBQUUsRUFBRSxVQUFVLGtCQUFnQixFQUFFLFNBQVMsQ0FBQztRQUFFLElBQUUsTUFBSSxHQUFFLEVBQUUsR0FBRTtRQUFVLElBQUksSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtRQUFFLENBQUEsTUFBSSxLQUFLLEtBQUcsTUFBSSxLQUFLLENBQUEsS0FBSSxFQUFFLEdBQUUsSUFBSSxDQUFDLFNBQU87UUFBRyxJQUFJLElBQUUsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLElBQUcsSUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFFLEtBQUc7UUFBRyxPQUFPLE9BQU8sS0FBSSxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUU7SUFBRTtJQUFHLEVBQUUsVUFBVSxrQkFBZ0IsRUFBRSxTQUFTLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxFQUFFLEdBQUU7UUFBVSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUU7UUFBRSxDQUFBLE1BQUksS0FBSyxLQUFHLE1BQUksS0FBSyxDQUFBLEtBQUksRUFBRSxHQUFFLElBQUksQ0FBQyxTQUFPO1FBQUcsSUFBSSxJQUFFLElBQUUsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxLQUFHLEtBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFDLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO1FBQUUsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU87SUFBRTtJQUFHLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFFLEdBQUUsSUFBRTtRQUFFLE1BQUssRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQztRQUFFLE9BQU8sS0FBRyxLQUFJLEtBQUcsS0FBSSxDQUFBLEtBQUcsS0FBSyxJQUFJLEdBQUUsSUFBRSxFQUFDLEdBQUc7SUFBQztJQUFFLEVBQUUsVUFBVSxZQUFVLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEVBQUU7UUFBQyxNQUFLLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxFQUFFLEdBQUM7UUFBRSxPQUFPLEtBQUcsS0FBSSxLQUFHLEtBQUksQ0FBQSxLQUFHLEtBQUssSUFBSSxHQUFFLElBQUUsRUFBQyxHQUFHO0lBQUM7SUFBRSxFQUFFLFVBQVUsV0FBUyxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxBQUFDLENBQUEsTUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUEsSUFBRyxLQUFHLElBQUksQ0FBQyxFQUFFO0lBQUE7SUFBRSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUM7UUFBUSxJQUFJLElBQUUsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFJLENBQUMsSUFBRSxFQUFFLElBQUU7UUFBRSxPQUFPLElBQUUsUUFBTSxJQUFFLGFBQVc7SUFBQztJQUFFLEVBQUUsVUFBVSxjQUFZLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQztRQUFRLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsSUFBRTtRQUFFLE9BQU8sSUFBRSxRQUFNLElBQUUsYUFBVztJQUFDO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxJQUFFLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRSxLQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsSUFBRTtJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxJQUFJLENBQUMsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLEtBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxJQUFFLElBQUUsSUFBSSxDQUFDLElBQUUsRUFBRTtJQUFBO0lBQUUsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLEtBQUcsS0FBSSxDQUFBLEtBQUcsRUFBQztRQUFHLE9BQU0sQUFBQyxDQUFBLE9BQU8sTUFBSSxPQUFPLEdBQUUsSUFBRyxPQUFPLElBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLE1BQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRztJQUFHO0lBQUcsRUFBRSxVQUFVLGlCQUFlLEVBQUUsU0FBUyxDQUFDO1FBQUUsSUFBRSxNQUFJLEdBQUUsRUFBRSxHQUFFO1FBQVUsSUFBSSxJQUFFLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsSUFBRSxFQUFFO1FBQUUsQ0FBQSxNQUFJLEtBQUssS0FBRyxNQUFJLEtBQUssQ0FBQSxLQUFJLEVBQUUsR0FBRSxJQUFJLENBQUMsU0FBTztRQUFHLElBQUksSUFBRSxBQUFDLENBQUEsS0FBRyxFQUFDLElBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsTUFBSyxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQUMsT0FBTSxBQUFDLENBQUEsT0FBTyxNQUFJLE9BQU8sR0FBRSxJQUFHLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFDLEtBQUcsS0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUMsS0FBRyxLQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBQyxNQUFLO0lBQUU7SUFBRyxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLEdBQUUsR0FBRSxJQUFJLENBQUMsU0FBUSxFQUFFLEtBQUssSUFBSSxFQUFDLEdBQUUsQ0FBQyxHQUFFLElBQUc7SUFBRTtJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxHQUFFLEdBQUUsSUFBSSxDQUFDLFNBQVEsRUFBRSxLQUFLLElBQUksRUFBQyxHQUFFLENBQUMsR0FBRSxJQUFHO0lBQUU7SUFBRSxFQUFFLFVBQVUsZUFBYSxTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsR0FBRSxHQUFFLElBQUksQ0FBQyxTQUFRLEVBQUUsS0FBSyxJQUFJLEVBQUMsR0FBRSxDQUFDLEdBQUUsSUFBRztJQUFFO0lBQUUsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsQ0FBQyxFQUFFLFNBQVMsSUFBRyxNQUFNLElBQUksVUFBVTtRQUErQyxJQUFHLElBQUUsS0FBRyxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBcUMsSUFBRyxJQUFFLElBQUUsRUFBRSxRQUFPLE1BQU0sSUFBSSxXQUFXO0lBQXFCO0lBQUMsRUFBRSxVQUFVLGNBQVksRUFBRSxVQUFVLGNBQVksU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxLQUFHO1lBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRTtRQUFFO1FBQUMsSUFBSSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxJQUFFLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsY0FBWSxFQUFFLFVBQVUsY0FBWSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLEtBQUc7WUFBRSxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUU7UUFBQyxJQUFJLElBQUUsSUFBRSxHQUFFLElBQUU7UUFBRSxJQUFJLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxJQUFFLEtBQUksRUFBRSxLQUFHLEtBQUksQ0FBQSxLQUFHLEdBQUUsR0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBRTtJQUFDO0lBQUUsRUFBRSxVQUFVLGdCQUFjLEVBQUUsVUFBVSxnQkFBYyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxPQUFNLElBQUcsSUFBSSxDQUFDLEVBQUUsR0FBQyxJQUFFLEtBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsZ0JBQWMsRUFBRSxVQUFVLGdCQUFjLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sSUFBRyxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksSUFBRyxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxnQkFBYyxFQUFFLFVBQVUsZ0JBQWMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLEtBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsWUFBVyxJQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsTUFBSSxJQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxNQUFJLElBQUcsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLEdBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFO1FBQUcsSUFBSSxJQUFFLE9BQU8sSUFBRSxPQUFPO1FBQWEsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQztRQUFFLElBQUksSUFBRSxPQUFPLEtBQUcsT0FBTyxNQUFJLE9BQU87UUFBYSxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBSSxHQUFDLEdBQUUsSUFBRSxLQUFHLEdBQUUsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFFLElBQUUsS0FBRyxHQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUMsR0FBRTtJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsR0FBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUU7UUFBRyxJQUFJLElBQUUsT0FBTyxJQUFFLE9BQU87UUFBYSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUM7UUFBRSxJQUFJLElBQUUsT0FBTyxLQUFHLE9BQU8sTUFBSSxPQUFPO1FBQWEsT0FBTyxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxDQUFDLENBQUMsRUFBRSxHQUFDLEdBQUUsSUFBRTtJQUFDO0lBQUMsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLG1CQUFpQixFQUFFLFNBQVMsQ0FBQyxFQUFDLElBQUUsQ0FBQztRQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUMsR0FBRSxHQUFFLE9BQU8sSUFBRyxPQUFPO0lBQXNCO0lBQUcsRUFBRSxVQUFVLGFBQVcsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxDQUFDLEdBQUU7WUFBQyxJQUFJLElBQUUsS0FBSyxJQUFJLEdBQUUsSUFBRSxJQUFFO1lBQUcsRUFBRSxJQUFJLEVBQUMsR0FBRSxHQUFFLEdBQUUsSUFBRSxHQUFFLENBQUM7UUFBRTtRQUFDLElBQUksSUFBRSxHQUFFLElBQUUsR0FBRSxJQUFFO1FBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLElBQUUsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsYUFBVyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLElBQUUsQ0FBQyxHQUFFLElBQUUsTUFBSSxHQUFFLENBQUMsR0FBRTtZQUFDLElBQUksSUFBRSxLQUFLLElBQUksR0FBRSxJQUFFLElBQUU7WUFBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxJQUFFLEdBQUUsQ0FBQztRQUFFO1FBQUMsSUFBSSxJQUFFLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRTtRQUFFLElBQUksSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLElBQUUsS0FBSSxFQUFFLEtBQUcsS0FBSSxDQUFBLEtBQUcsR0FBRSxHQUFJLElBQUUsS0FBRyxNQUFJLEtBQUcsSUFBSSxDQUFDLElBQUUsSUFBRSxFQUFFLEtBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxJQUFFLEVBQUUsR0FBQyxBQUFDLENBQUEsSUFBRSxLQUFHLENBQUEsSUFBRyxJQUFFO1FBQUksT0FBTyxJQUFFO0lBQUM7SUFBRSxFQUFFLFVBQVUsWUFBVSxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sSUFBRSxDQUFDLEdBQUUsSUFBRSxNQUFJLEdBQUUsS0FBRyxFQUFFLElBQUksRUFBQyxHQUFFLEdBQUUsR0FBRSxLQUFJLE9BQU0sSUFBRSxLQUFJLENBQUEsSUFBRSxNQUFJLElBQUUsQ0FBQSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUMsSUFBRSxLQUFJLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLElBQUUsS0FBSSxJQUFJLENBQUMsSUFBRSxFQUFFLEdBQUMsTUFBSSxHQUFFLElBQUU7SUFBQztJQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTyxJQUFFLENBQUMsR0FBRSxJQUFFLE1BQUksR0FBRSxLQUFHLEVBQUUsSUFBSSxFQUFDLEdBQUUsR0FBRSxHQUFFLE9BQU0sU0FBUSxJQUFJLENBQUMsRUFBRSxHQUFDLE1BQUksR0FBRSxJQUFJLENBQUMs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QyxHQUFFO0lBQUU7SUFBRSxFQUFFLFVBQVUsT0FBSyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLENBQUMsRUFBRSxTQUFTLElBQUcsTUFBTSxJQUFJLFVBQVU7UUFBK0IsSUFBRyxLQUFJLENBQUEsSUFBRSxDQUFBLEdBQUcsQ0FBQyxLQUFHLE1BQUksS0FBSSxDQUFBLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxLQUFHLEVBQUUsVUFBUyxDQUFBLElBQUUsRUFBRSxNQUFLLEdBQUcsS0FBSSxDQUFBLElBQUUsQ0FBQSxHQUFHLElBQUUsS0FBRyxJQUFFLEtBQUksQ0FBQSxJQUFFLENBQUEsR0FBRyxNQUFJLEtBQUcsRUFBRSxXQUFTLEtBQUcsSUFBSSxDQUFDLFdBQVMsR0FBRSxPQUFPO1FBQUUsSUFBRyxJQUFFLEdBQUUsTUFBTSxJQUFJLFdBQVc7UUFBNkIsSUFBRyxJQUFFLEtBQUcsS0FBRyxJQUFJLENBQUMsUUFBTyxNQUFNLElBQUksV0FBVztRQUFzQixJQUFHLElBQUUsR0FBRSxNQUFNLElBQUksV0FBVztRQUEyQixJQUFFLElBQUksQ0FBQyxVQUFTLENBQUEsSUFBRSxJQUFJLENBQUMsTUFBSyxHQUFHLEVBQUUsU0FBTyxJQUFFLElBQUUsS0FBSSxDQUFBLElBQUUsRUFBRSxTQUFPLElBQUUsQ0FBQTtRQUFHLElBQUksSUFBRSxJQUFFO1FBQUUsT0FBTyxJQUFJLEtBQUcsS0FBRyxPQUFPLFdBQVcsVUFBVSxjQUFZLGFBQVcsSUFBSSxDQUFDLFdBQVcsR0FBRSxHQUFFLEtBQUcsV0FBVyxVQUFVLElBQUksS0FBSyxHQUFFLElBQUksQ0FBQyxTQUFTLEdBQUUsSUFBRyxJQUFHO0lBQUM7SUFBRSxFQUFFLFVBQVUsT0FBSyxTQUFTLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFHLE9BQU8sS0FBRyxVQUFTO1lBQUMsSUFBRyxPQUFPLEtBQUcsV0FBVSxDQUFBLElBQUUsR0FBRSxJQUFFLEdBQUUsSUFBRSxJQUFJLENBQUMsTUFBSyxJQUFHLE9BQU8sS0FBRyxZQUFXLENBQUEsSUFBRSxHQUFFLElBQUUsSUFBSSxDQUFDLE1BQUssR0FBRyxNQUFJLEtBQUssS0FBRyxPQUFPLEtBQUcsVUFBUyxNQUFNLElBQUksVUFBVTtZQUE2QixJQUFHLE9BQU8sS0FBRyxZQUFVLENBQUMsRUFBRSxXQUFXLElBQUcsTUFBTSxJQUFJLFVBQVUsdUJBQXFCO1lBQUcsSUFBRyxFQUFFLFdBQVMsR0FBRTtnQkFBQyxJQUFJLElBQUUsRUFBRSxXQUFXO2dCQUFJLENBQUEsTUFBSSxVQUFRLElBQUUsT0FBSyxNQUFJLFFBQU8sS0FBSyxDQUFBLElBQUUsQ0FBQTtZQUFFO1FBQUMsT0FBTSxPQUFPLEtBQUcsV0FBUyxJQUFFLElBQUUsTUFBSSxPQUFPLEtBQUcsYUFBWSxDQUFBLElBQUUsT0FBTyxFQUFDO1FBQUcsSUFBRyxJQUFFLEtBQUcsSUFBSSxDQUFDLFNBQU8sS0FBRyxJQUFJLENBQUMsU0FBTyxHQUFFLE1BQU0sSUFBSSxXQUFXO1FBQXNCLElBQUcsS0FBRyxHQUFFLE9BQU8sSUFBSTtRQUFDLElBQUUsTUFBSSxHQUFFLElBQUUsTUFBSSxLQUFLLElBQUUsSUFBSSxDQUFDLFNBQU8sTUFBSSxHQUFFLEtBQUksQ0FBQSxJQUFFLENBQUE7UUFBRyxJQUFJO1FBQUUsSUFBRyxPQUFPLEtBQUcsVUFBUyxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUM7YUFBTTtZQUFDLElBQUksSUFBRSxFQUFFLFNBQVMsS0FBRyxJQUFFLEVBQUUsS0FBSyxHQUFFLElBQUcsSUFBRSxFQUFFO1lBQU8sSUFBRyxNQUFJLEdBQUUsTUFBTSxJQUFJLFVBQVUsZ0JBQWMsSUFBRTtZQUFxQyxJQUFJLElBQUUsR0FBRSxJQUFFLElBQUUsR0FBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLElBQUUsRUFBRSxHQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUU7UUFBQTtRQUFDLE9BQU8sSUFBSTtJQUFBO0lBQUUsSUFBSSxJQUFFLENBQUM7SUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQyxjQUFjO1lBQUUsYUFBYTtnQkFBQyxLQUFLLElBQUcsT0FBTyxlQUFlLElBQUksRUFBQyxXQUFVO29CQUFDLE9BQU0sRUFBRSxNQUFNLElBQUksRUFBQztvQkFBVyxVQUFTLENBQUM7b0JBQUUsY0FBYSxDQUFDO2dCQUFDLElBQUcsSUFBSSxDQUFDLE9BQUssR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFLLE1BQU0sT0FBTyxHQUFFLE1BQUssSUFBSSxDQUFDLE9BQU0sT0FBTyxJQUFJLENBQUM7WUFBSTtZQUFDLElBQUksT0FBTTtnQkFBQyxPQUFPO1lBQUM7WUFBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO2dCQUFDLE9BQU8sZUFBZSxJQUFJLEVBQUMsUUFBTztvQkFBQyxjQUFhLENBQUM7b0JBQUUsWUFBVyxDQUFDO29CQUFFLE9BQU07b0JBQUUsVUFBUyxDQUFDO2dCQUFDO1lBQUU7WUFBQyxXQUFVO2dCQUFDLE9BQU0sR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFLLE1BQU0sT0FBTyxHQUFFLE9BQU8sT0FBTyxJQUFJLENBQUM7WUFBUTtRQUFDO0lBQUM7SUFBQyxFQUFFLDRCQUEyQixTQUFTLENBQUM7UUFBRSxPQUFPLElBQUUsR0FBRyxPQUFPLEdBQUUsa0NBQWdDO0lBQWdELEdBQUU7SUFBWSxFQUFFLHdCQUF1QixTQUFTLENBQUMsRUFBQyxDQUFDO1FBQUUsT0FBTSxRQUFRLE9BQU8sR0FBRSxxREFBcUQsT0FBTyxPQUFPO0lBQUUsR0FBRTtJQUFXLEVBQUUsb0JBQW1CLFNBQVMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBSSxJQUFFLGlCQUFpQixPQUFPLEdBQUUsdUJBQXNCLElBQUU7UUFBRSxPQUFPLE9BQU8sVUFBVSxNQUFJLEtBQUssSUFBSSxLQUFHLEtBQUcsS0FBRyxJQUFFLEdBQUcsT0FBTyxNQUFJLE9BQU8sS0FBRyxZQUFXLENBQUEsSUFBRSxPQUFPLElBQUcsQUFBQyxDQUFBLElBQUUsT0FBTyxNQUFJLE9BQU8sT0FBSyxJQUFFLENBQUUsQ0FBQSxPQUFPLE1BQUksT0FBTyxHQUFFLENBQUMsS0FBSyxDQUFBLElBQUUsR0FBRyxFQUFDLEdBQUcsS0FBRyxHQUFFLEdBQUcsS0FBRyxlQUFlLE9BQU8sR0FBRSxlQUFlLE9BQU8sSUFBRztJQUFDLEdBQUU7SUFBWSxTQUFTLEdBQUcsQ0FBQztRQUFFLElBQUksSUFBRSxJQUFHLElBQUUsRUFBRSxRQUFPLElBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBRyxNQUFJLElBQUU7UUFBRSxNQUFLLEtBQUcsSUFBRSxHQUFFLEtBQUcsRUFBRSxJQUFFLElBQUksT0FBTyxFQUFFLE1BQU0sSUFBRSxHQUFFLElBQUksT0FBTztRQUFHLE9BQU0sR0FBRyxPQUFPLEVBQUUsTUFBTSxHQUFFLElBQUksT0FBTztJQUFFO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLEVBQUUsR0FBRSxXQUFVLEFBQUMsQ0FBQSxDQUFDLENBQUMsRUFBRSxLQUFHLEtBQUssS0FBRyxDQUFDLENBQUMsSUFBRSxFQUFFLEtBQUcsS0FBSyxDQUFBLEtBQUksRUFBRSxHQUFFLEVBQUUsU0FBUSxDQUFBLElBQUUsQ0FBQTtJQUFHO0lBQUMsU0FBUyxHQUFHLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUcsSUFBRSxLQUFHLElBQUUsR0FBRTtZQUFDLElBQUksSUFBRSxPQUFPLEtBQUcsV0FBUyxNQUFJLElBQUc7WUFBRSxNQUFNLElBQUUsSUFBRSxNQUFJLEtBQUcsTUFBSSxPQUFPLEtBQUcsSUFBRSxPQUFPLE9BQU8sR0FBRSxZQUFZLE9BQU8sR0FBRSxRQUFRLE9BQU8sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLEdBQUcsT0FBTyxLQUFHLElBQUUsU0FBUyxPQUFPLEdBQUUsUUFBUSxPQUFPLEFBQUMsQ0FBQSxJQUFFLENBQUEsSUFBRyxJQUFFLEdBQUcsT0FBTyxHQUFFLG1CQUFpQixHQUFHLE9BQU8sQUFBQyxDQUFBLElBQUUsQ0FBQSxJQUFHLElBQUUsR0FBRyxPQUFPLEtBQUcsSUFBRSxNQUFNLE9BQU8sR0FBRyxPQUFPLEdBQUUsWUFBWSxPQUFPLEdBQUcsT0FBTyxJQUFHLElBQUksRUFBRSxpQkFBaUIsU0FBUSxHQUFFO1FBQUU7UUFBQyxHQUFHLEdBQUUsR0FBRTtJQUFFO0lBQUMsU0FBUyxFQUFFLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBRyxPQUFPLEtBQUcsVUFBUyxNQUFNLElBQUksRUFBRSxxQkFBcUIsR0FBRSxVQUFTO0lBQUU7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsTUFBTSxLQUFLLE1BQU0sT0FBSyxJQUFHLENBQUEsRUFBRSxHQUFFLElBQUcsSUFBSSxFQUFFLGlCQUFpQixLQUFHLFVBQVMsY0FBYSxFQUFDLElBQUcsSUFBRSxJQUFFLElBQUksRUFBRSwyQkFBeUIsSUFBSSxFQUFFLGlCQUFpQixLQUFHLFVBQVMsTUFBTSxPQUFPLElBQUUsSUFBRSxHQUFFLFlBQVksT0FBTyxJQUFHO0lBQUU7SUFBQyxJQUFJLEtBQUc7SUFBb0IsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFHLElBQUUsRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBRSxFQUFFLE9BQU8sUUFBUSxJQUFHLEtBQUksRUFBRSxTQUFPLEdBQUUsT0FBTTtRQUFHLE1BQUssRUFBRSxTQUFPLE1BQUksR0FBRyxJQUFFLElBQUU7UUFBSSxPQUFPO0lBQUM7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFBRSxJQUFFLEtBQUcsSUFBRTtRQUFFLElBQUksR0FBRSxJQUFFLEVBQUUsUUFBTyxJQUFFLE1BQUssSUFBRSxFQUFFO1FBQUMsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEdBQUUsRUFBRSxFQUFFO1lBQUMsSUFBRyxJQUFFLEVBQUUsV0FBVyxJQUFHLElBQUUsU0FBTyxJQUFFLE9BQU07Z0JBQUMsSUFBRyxDQUFDLEdBQUU7b0JBQUMsSUFBRyxJQUFFLE9BQU07d0JBQUUsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUk7d0JBQUs7b0JBQVEsT0FBTSxJQUFHLElBQUUsTUFBSSxHQUFFO3dCQUFFLENBQUEsS0FBRyxDQUFBLElBQUcsTUFBSSxFQUFFLEtBQUssS0FBSSxLQUFJO3dCQUFLO29CQUFRO29CQUFDLElBQUU7b0JBQUU7Z0JBQVE7Z0JBQUMsSUFBRyxJQUFFLE9BQU07b0JBQUUsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUksTUFBSyxJQUFFO29CQUFFO2dCQUFRO2dCQUFDLElBQUUsQUFBQyxDQUFBLElBQUUsU0FBTyxLQUFHLElBQUUsS0FBSSxJQUFHO1lBQUssT0FBTSxLQUFHLEFBQUMsQ0FBQSxLQUFHLENBQUEsSUFBRyxNQUFJLEVBQUUsS0FBSyxLQUFJLEtBQUk7WUFBSyxJQUFHLElBQUUsTUFBSyxJQUFFLEtBQUk7Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUs7WUFBRSxPQUFNLElBQUcsSUFBRSxNQUFLO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsSUFBRSxLQUFJLElBQUUsS0FBRztZQUFJLE9BQU0sSUFBRyxJQUFFLE9BQU07Z0JBQUMsSUFBRyxBQUFDLENBQUEsS0FBRyxDQUFBLElBQUcsR0FBRTtnQkFBTSxFQUFFLEtBQUssS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLElBQUcsSUFBRSxTQUFRO2dCQUFDLElBQUcsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLEdBQUU7Z0JBQU0sRUFBRSxLQUFLLEtBQUcsS0FBRyxLQUFJLEtBQUcsS0FBRyxLQUFHLEtBQUksS0FBRyxJQUFFLEtBQUcsS0FBSSxJQUFFLEtBQUc7WUFBSSxPQUFNLE1BQU0sSUFBSSxNQUFNO1FBQXFCO1FBQUMsT0FBTztJQUFDO0lBQUMsU0FBUyxHQUFHLENBQUM7UUFBRSxJQUFJLElBQUUsRUFBRTtRQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLFFBQU8sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLFdBQVcsS0FBRztRQUFLLE9BQU87SUFBQztJQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUMsQ0FBQztRQUFFLElBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxFQUFFO1FBQUMsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLEVBQUUsVUFBUSxDQUFFLENBQUEsQUFBQyxDQUFBLEtBQUcsQ0FBQSxJQUFHLENBQUEsR0FBRyxFQUFFLEVBQUUsSUFBRSxFQUFFLFdBQVcsSUFBRyxJQUFFLEtBQUcsR0FBRSxJQUFFLElBQUUsS0FBSSxFQUFFLEtBQUssSUFBRyxFQUFFLEtBQUs7UUFBRyxPQUFPO0lBQUM7SUFBQyxTQUFTLEdBQUcsQ0FBQztRQUFFLE9BQU8sRUFBRSxZQUFZLEdBQUc7SUFBRztJQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDO1FBQUUsSUFBSTtRQUFFLElBQUksSUFBRSxHQUFFLElBQUUsS0FBRyxDQUFFLENBQUEsSUFBRSxLQUFHLEVBQUUsVUFBUSxLQUFHLEVBQUUsTUFBSyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBRSxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUU7UUFBQyxPQUFPO0lBQUM7SUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFBRSxPQUFPLGFBQWEsS0FBRyxLQUFHLFFBQU0sRUFBRSxlQUFhLFFBQU0sRUFBRSxZQUFZLFFBQU0sUUFBTSxFQUFFLFlBQVksU0FBTyxFQUFFO0lBQUk7SUFBQyxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sTUFBSTtJQUFDO0lBQUMsSUFBSSxLQUFHO1FBQVcsSUFBSSxJQUFFLG9CQUFtQixJQUFFLElBQUksTUFBTTtRQUFLLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxJQUFHLEVBQUUsRUFBRTtZQUFDLElBQUksSUFBRSxJQUFFO1lBQUcsSUFBSSxJQUFJLElBQUUsR0FBRSxJQUFFLElBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPO0lBQUM7SUFBSSxTQUFTLEVBQUUsQ0FBQztRQUFFLE9BQU8sT0FBTyxTQUFPLE1BQUksS0FBRztJQUFDO0lBQUMsU0FBUztRQUFLLE1BQU0sSUFBSSxNQUFNO0lBQXVCO0FBQUM7QUFBRyxJQUFJLElBQUUsQ0FBQztBQUFFLEdBQUcsR0FBRTtJQUFDLFNBQVEsSUFBSTtBQUFFO0FBQUcsT0FBTyxVQUFRLEdBQUc7QUFBRyxJQUFJLEtBQUcsRUFBRTtBQUFLLEVBQUUsR0FBRSxFQUFFLE1BQUssT0FBTztBQUFTLElBQUksS0FBRyxHQUFHLFNBQzkwM0I7Ozs7Ozs7Ozs7OztBQVlBIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vQHBsYXNtb2hxK3BhcmNlbC1ydW50aW1lQDAuMjUuMi9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1ydW50aW1lL2Rpc3QvcnVudGltZS00NjBiNDVlYjdhNzA1ZjZlLmpzIiwiLnBsYXNtby9zdGF0aWMvYmFja2dyb3VuZC9pbmRleC50cyIsInNyYy9iYWNrZ3JvdW5kLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL2NsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvY2xpZW50L2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3NoYXJlZC9wcm90b2NvbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy90eXBlcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9sb2NhbGVzL2VuLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvWm9kRXJyb3IuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHBhcmNlbCt0cmFuc2Zvcm1lci1qc0AyLjkuM19AcGFyY2VsK2NvcmVAMi45LjMvbm9kZV9tb2R1bGVzL0BwYXJjZWwvdHJhbnNmb3JtZXItanMvc3JjL2VzbW9kdWxlLWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3BhcnNlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvdHlwZUFsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4tdXVpZC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4udHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvc3JjL3NjaGVtZXMvbWFpbHRvLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy93cy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwcy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy91cmkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS91cmktanNANC40LjEvbm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy1pcmkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vdXJpLWpzQDQuNC4xL25vZGVfbW9kdWxlcy91cmktanMvc3JjL3JlZ2V4cHMtdXJpLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3VyaS1qc0A0LjQuMS9ub2RlX21vZHVsZXMvdXJpLWpzL3NyYy91dGlsLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QtZGVlcC1lcXVhbEAzLjEuMy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91Y3MybGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9zY2hlbWFfb2JqLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2pzb24tc2NoZW1hLXRyYXZlcnNlQDAuNC4xL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvZXJyb3JfY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeUAyLjEuMC9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9mb3JtYXRzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcmVmLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvYWxsT2YuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbnlPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9jb25zdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZW51bS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2lmLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaXRlbXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRJdGVtcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL19saW1pdExlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL19saW1pdFByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tdWx0aXBsZU9mLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbm90LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvb25lT2YuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3Byb3BlcnR5TmFtZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3VuaXF1ZUl0ZW1zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9hanZANi4xMi42L25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9rZXl3b3JkLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvY3VzdG9tLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2FqdkA2LjEyLjYvbm9kZV9tb2R1bGVzL2Fqdi9saWIvZGVmaW5pdGlvbl9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb24iLCJub2RlX21vZHVsZXMvLnBucG0vYWp2QDYuMTIuNi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2RhdGEuanNvbiIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9jbGllbnQvc3NlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9jbGllbnQvc3NlLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9zcmMvZXJyb3JzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlQDMuMC43L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS9zcmMvRXZlbnRTb3VyY2UudHMiLCJub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC42L25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNvdXJjZS1wYXJzZXJAMy4wLjYvbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlLXBhcnNlci9zcmMvZXJyb3JzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c291cmNlLXBhcnNlckAzLjAuNi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UtcGFyc2VyL3NyYy9wYXJzZS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9jbGllbnQvYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvY2xpZW50L2F1dGgudHMiLCJub2RlX21vZHVsZXMvLnBucG0vcGtjZS1jaGFsbGVuZ2VANS4wLjAvbm9kZV9tb2R1bGVzL3BrY2UtY2hhbGxlbmdlL2Rpc3QvaW5kZXguYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2Nqcy9zaGFyZWQvYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL2F1dGgudHMiLCJub2RlX21vZHVsZXMvLnBucG0vQG1vZGVsY29udGV4dHByb3RvY29sK3Nka0AxLjIwLjAvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvZGlzdC9janMvc2hhcmVkL2F1dGgtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQG1vZGVsY29udGV4dHByb3RvY29sK3Nka0AxLjIwLjAvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NoYXJlZC9hdXRoLXV0aWxzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0Btb2RlbGNvbnRleHRwcm90b2NvbCtzZGtAMS4yMC4wL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvY2pzL3NlcnZlci9hdXRoL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AbW9kZWxjb250ZXh0cHJvdG9jb2wrc2RrQDEuMjAuMC9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2VydmVyL2F1dGgvZXJyb3JzLnRzIiwic3JjL21jcC9ub3Rpb25DbGllbnQudHMiLCJzcmMvY29uc3RhbnRzLnRzIiwic3JjL21jcC9vYXV0aC50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9AcGxhc21vaHErcGFyY2VsLXJlc29sdmVyQDAuMTQuMS9ub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1yZXNvbHZlci9kaXN0L3BvbHlmaWxscy9idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHU9Z2xvYmFsVGhpcy5wcm9jZXNzPy5hcmd2fHxbXTt2YXIgaD0oKT0+Z2xvYmFsVGhpcy5wcm9jZXNzPy5lbnZ8fHt9O3ZhciBCPW5ldyBTZXQodSksXz1lPT5CLmhhcyhlKSxHPXUuZmlsdGVyKGU9PmUuc3RhcnRzV2l0aChcIi0tXCIpJiZlLmluY2x1ZGVzKFwiPVwiKSkubWFwKGU9PmUuc3BsaXQoXCI9XCIpKS5yZWR1Y2UoKGUsW3Qsb10pPT4oZVt0XT1vLGUpLHt9KTt2YXIgVT1fKFwiLS1kcnktcnVuXCIpLGc9KCk9Pl8oXCItLXZlcmJvc2VcIil8fGgoKS5WRVJCT1NFPT09XCJ0cnVlXCIsTj1nKCk7dmFyIG09KGU9XCJcIiwuLi50KT0+Y29uc29sZS5sb2coZS5wYWRFbmQoOSksXCJ8XCIsLi4udCk7dmFyIHk9KC4uLmUpPT5jb25zb2xlLmVycm9yKFwiXFx1ezFGNTM0fSBFUlJPUlwiLnBhZEVuZCg5KSxcInxcIiwuLi5lKSx2PSguLi5lKT0+bShcIlxcdXsxRjUzNX0gSU5GT1wiLC4uLmUpLGY9KC4uLmUpPT5tKFwiXFx1ezFGN0UwfSBXQVJOXCIsLi4uZSksTT0wLGk9KC4uLmUpPT5nKCkmJm0oYFxcdXsxRjdFMX0gJHtNKyt9YCwuLi5lKTt2YXIgYj0oKT0+e2xldCBlPWdsb2JhbFRoaXMuYnJvd3Nlcj8ucnVudGltZXx8Z2xvYmFsVGhpcy5jaHJvbWU/LnJ1bnRpbWUsdD0oKT0+c2V0SW50ZXJ2YWwoZS5nZXRQbGF0Zm9ybUluZm8sMjRlMyk7ZS5vblN0YXJ0dXAuYWRkTGlzdGVuZXIodCksdCgpfTt2YXIgbj17XCJpc0NvbnRlbnRTY3JpcHRcIjpmYWxzZSxcImlzQmFja2dyb3VuZFwiOnRydWUsXCJpc1JlYWN0XCI6ZmFsc2UsXCJydW50aW1lc1wiOltcImJhY2tncm91bmQtc2VydmljZS1ydW50aW1lXCJdLFwiaG9zdFwiOlwibG9jYWxob3N0XCIsXCJwb3J0XCI6MTgxNSxcImVudHJ5RmlsZVBhdGhcIjpcIkM6XFxcXFVzZXJzXFxcXEhQXFxcXERvd25sb2Fkc1xcXFxDSFJPTUVcXFxcY2hyb21lLWFpLTFcXFxcLnBsYXNtb1xcXFxzdGF0aWNcXFxcYmFja2dyb3VuZFxcXFxpbmRleC50c1wiLFwiYnVuZGxlSWRcIjpcImMzMzg5MDhlNzA0YzkxZjFcIixcImVudkhhc2hcIjpcImQ5OWE1ZmZhNTdhY2Q2MzhcIixcInZlcmJvc2VcIjpcImZhbHNlXCIsXCJzZWN1cmVcIjpmYWxzZSxcInNlcnZlclBvcnRcIjoxMDEyfTttb2R1bGUuYnVuZGxlLkhNUl9CVU5ETEVfSUQ9bi5idW5kbGVJZDtnbG9iYWxUaGlzLnByb2Nlc3M9e2FyZ3Y6W10sZW52OntWRVJCT1NFOm4udmVyYm9zZX19O3ZhciBEPW1vZHVsZS5idW5kbGUuTW9kdWxlO2Z1bmN0aW9uIEgoZSl7RC5jYWxsKHRoaXMsZSksdGhpcy5ob3Q9e2RhdGE6bW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdLF9hY2NlcHRDYWxsYmFja3M6W10sX2Rpc3Bvc2VDYWxsYmFja3M6W10sYWNjZXB0OmZ1bmN0aW9uKHQpe3RoaXMuX2FjY2VwdENhbGxiYWNrcy5wdXNoKHR8fGZ1bmN0aW9uKCl7fSl9LGRpc3Bvc2U6ZnVuY3Rpb24odCl7dGhpcy5fZGlzcG9zZUNhbGxiYWNrcy5wdXNoKHQpfX0sbW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdPXZvaWQgMH1tb2R1bGUuYnVuZGxlLk1vZHVsZT1IO21vZHVsZS5idW5kbGUuaG90RGF0YT17fTt2YXIgYz1nbG9iYWxUaGlzLmJyb3dzZXJ8fGdsb2JhbFRoaXMuY2hyb21lfHxudWxsO2Z1bmN0aW9uIFIoKXtyZXR1cm4hbi5ob3N0fHxuLmhvc3Q9PT1cIjAuMC4wLjBcIj9sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKFwiaHR0cFwiKT09PTA/bG9jYXRpb24uaG9zdG5hbWU6XCJsb2NhbGhvc3RcIjpuLmhvc3R9ZnVuY3Rpb24geCgpe3JldHVybiFuLmhvc3R8fG4uaG9zdD09PVwiMC4wLjAuMFwiP1wibG9jYWxob3N0XCI6bi5ob3N0fWZ1bmN0aW9uIGQoKXtyZXR1cm4gbi5wb3J0fHxsb2NhdGlvbi5wb3J0fXZhciBQPVwiX19wbGFzbW9fcnVudGltZV9wYWdlX1wiLFM9XCJfX3BsYXNtb19ydW50aW1lX3NjcmlwdF9cIjt2YXIgTz1gJHtuLnNlY3VyZT9cImh0dHBzXCI6XCJodHRwXCJ9Oi8vJHtSKCl9OiR7ZCgpfS9gO2FzeW5jIGZ1bmN0aW9uIGsoZT0xNDcwKXtmb3IoOzspdHJ5e2F3YWl0IGZldGNoKE8pO2JyZWFrfWNhdGNoe2F3YWl0IG5ldyBQcm9taXNlKG89PnNldFRpbWVvdXQobyxlKSl9fWlmKGMucnVudGltZS5nZXRNYW5pZmVzdCgpLm1hbmlmZXN0X3ZlcnNpb249PT0zKXtsZXQgZT1jLnJ1bnRpbWUuZ2V0VVJMKFwiL19fcGxhc21vX2htcl9wcm94eV9fP3VybD1cIik7Z2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZmV0Y2hcIixmdW5jdGlvbih0KXtsZXQgbz10LnJlcXVlc3QudXJsO2lmKG8uc3RhcnRzV2l0aChlKSl7bGV0IHM9bmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQoby5zbGljZShlLmxlbmd0aCkpKTtzLmhvc3RuYW1lPT09bi5ob3N0JiZzLnBvcnQ9PT1gJHtuLnBvcnR9YD8ocy5zZWFyY2hQYXJhbXMuc2V0KFwidFwiLERhdGUubm93KCkudG9TdHJpbmcoKSksdC5yZXNwb25kV2l0aChmZXRjaChzKS50aGVuKHI9Pm5ldyBSZXNwb25zZShyLmJvZHkse2hlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6ci5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8/XCJ0ZXh0L2phdmFzY3JpcHRcIn19KSkpKTp0LnJlc3BvbmRXaXRoKG5ldyBSZXNwb25zZShcIlBsYXNtbyBITVJcIix7c3RhdHVzOjIwMCxzdGF0dXNUZXh0OlwiVGVzdGluZ1wifSkpfX0pfWZ1bmN0aW9uIEUoZSx0KXtsZXR7bW9kdWxlczpvfT1lO3JldHVybiBvPyEhb1t0XTohMX1mdW5jdGlvbiBDKGU9ZCgpKXtsZXQgdD14KCk7cmV0dXJuYCR7bi5zZWN1cmV8fGxvY2F0aW9uLnByb3RvY29sPT09XCJodHRwczpcIiYmIS9sb2NhbGhvc3R8MTI3LjAuMC4xfDAuMC4wLjAvLnRlc3QodCk/XCJ3c3NcIjpcIndzXCJ9Oi8vJHt0fToke2V9L2B9ZnVuY3Rpb24gTChlKXt0eXBlb2YgZS5tZXNzYWdlPT1cInN0cmluZ1wiJiZ5KFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK2UubWVzc2FnZSl9ZnVuY3Rpb24gVChlKXtpZih0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQ+XCJ1XCIpcmV0dXJuO2xldCB0PW5ldyBXZWJTb2NrZXQoQyhOdW1iZXIoZCgpKSsxKSk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhc3luYyBmdW5jdGlvbihvKXtsZXQgcz1KU09OLnBhcnNlKG8uZGF0YSk7YXdhaXQgZShzKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsTCksdH1mdW5jdGlvbiBBKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChDKCkpO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYXN5bmMgZnVuY3Rpb24obyl7bGV0IHM9SlNPTi5wYXJzZShvLmRhdGEpO2lmKHMudHlwZT09PVwidXBkYXRlXCImJmF3YWl0IGUocy5hc3NldHMpLHMudHlwZT09PVwiZXJyb3JcIilmb3IobGV0IHIgb2Ygcy5kaWFnbm9zdGljcy5hbnNpKXtsZXQgbD1yLmNvZGVmcmFtZXx8ci5zdGFjaztmKFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK3IubWVzc2FnZStgXG5gK2wrYFxuXG5gK3IuaGludHMuam9pbihgXG5gKSl9fSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixMKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsKCk9Pnt2KGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGVkIHRvIEhNUiBzZXJ2ZXIgZm9yICR7bi5lbnRyeUZpbGVQYXRofWApfSksdC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwoKT0+e2YoYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0aW9uIHRvIHRoZSBITVIgc2VydmVyIGlzIGNsb3NlZCBmb3IgJHtuLmVudHJ5RmlsZVBhdGh9YCl9KSx0fXZhciB3PW1vZHVsZS5idW5kbGUucGFyZW50LGE9e2J1aWxkUmVhZHk6ITEsYmdDaGFuZ2VkOiExLGNzQ2hhbmdlZDohMSxwYWdlQ2hhbmdlZDohMSxzY3JpcHRQb3J0czpuZXcgU2V0LHBhZ2VQb3J0czpuZXcgU2V0fTthc3luYyBmdW5jdGlvbiBwKGU9ITEpe2lmKGV8fGEuYnVpbGRSZWFkeSYmYS5wYWdlQ2hhbmdlZCl7aShcIkJHU1cgUnVudGltZSAtIHJlbG9hZGluZyBQYWdlXCIpO2ZvcihsZXQgdCBvZiBhLnBhZ2VQb3J0cyl0LnBvc3RNZXNzYWdlKG51bGwpfWlmKGV8fGEuYnVpbGRSZWFkeSYmKGEuYmdDaGFuZ2VkfHxhLmNzQ2hhbmdlZCkpe2koXCJCR1NXIFJ1bnRpbWUgLSByZWxvYWRpbmcgQ1NcIik7bGV0IHQ9YXdhaXQgYz8udGFicy5xdWVyeSh7YWN0aXZlOiEwfSk7Zm9yKGxldCBvIG9mIGEuc2NyaXB0UG9ydHMpe2xldCBzPXQuc29tZShyPT5yLmlkPT09by5zZW5kZXIudGFiPy5pZCk7by5wb3N0TWVzc2FnZSh7X19wbGFzbW9fY3NfYWN0aXZlX3RhYl9fOnN9KX1jLnJ1bnRpbWUucmVsb2FkKCl9fWlmKCF3fHwhdy5pc1BhcmNlbFJlcXVpcmUpe2IoKTtsZXQgZT1BKGFzeW5jIHQ9PntpKFwiQkdTVyBSdW50aW1lIC0gT24gSE1SIFVwZGF0ZVwiKSxhLmJnQ2hhbmdlZHx8PXQuZmlsdGVyKHM9PnMuZW52SGFzaD09PW4uZW52SGFzaCkuc29tZShzPT5FKG1vZHVsZS5idW5kbGUscy5pZCkpO2xldCBvPXQuZmluZChzPT5zLnR5cGU9PT1cImpzb25cIik7aWYobyl7bGV0IHM9bmV3IFNldCh0Lm1hcChsPT5sLmlkKSkscj1PYmplY3QudmFsdWVzKG8uZGVwc0J5QnVuZGxlKS5tYXAobD0+T2JqZWN0LnZhbHVlcyhsKSkuZmxhdCgpO2EuYmdDaGFuZ2VkfHw9ci5ldmVyeShsPT5zLmhhcyhsKSl9cCgpfSk7ZS5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCgpPT57bGV0IHQ9c2V0SW50ZXJ2YWwoKCk9PmUuc2VuZChcInBpbmdcIiksMjRlMyk7ZS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwoKT0+Y2xlYXJJbnRlcnZhbCh0KSl9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLGFzeW5jKCk9Pnthd2FpdCBrKCkscCghMCl9KX1UKGFzeW5jIGU9Pntzd2l0Y2goaShcIkJHU1cgUnVudGltZSAtIE9uIEJ1aWxkIFJlcGFja2FnZWRcIiksZS50eXBlKXtjYXNlXCJidWlsZF9yZWFkeVwiOnthLmJ1aWxkUmVhZHl8fD0hMCxwKCk7YnJlYWt9Y2FzZVwiY3NfY2hhbmdlZFwiOnthLmNzQ2hhbmdlZHx8PSEwLHAoKTticmVha319fSk7Yy5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihmdW5jdGlvbihlKXtsZXQgdD1lLm5hbWUuc3RhcnRzV2l0aChQKSxvPWUubmFtZS5zdGFydHNXaXRoKFMpO2lmKHR8fG8pe2xldCBzPXQ/YS5wYWdlUG9ydHM6YS5zY3JpcHRQb3J0cztzLmFkZChlKSxlLm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKT0+e3MuZGVsZXRlKGUpfSksZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocil7aShcIkJHU1cgUnVudGltZSAtIE9uIHNvdXJjZSBjaGFuZ2VkXCIsciksci5fX3BsYXNtb19jc19jaGFuZ2VkX18mJihhLmNzQ2hhbmdlZHx8PSEwKSxyLl9fcGxhc21vX3BhZ2VfY2hhbmdlZF9fJiYoYS5wYWdlQ2hhbmdlZHx8PSEwKSxwKCl9KX19KTtjLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcGxhc21vX2Z1bGxfcmVsb2FkX18mJihpKFwiQkdTVyBSdW50aW1lIC0gT24gdG9wLWxldmVsIGNvZGUgY2hhbmdlZFwiKSxwKCkpLCEwfSk7XG4iLCJpbXBvcnQgXCIuLi8uLi8uLi9zcmMvYmFja2dyb3VuZFwiIiwiLyoqXHJcbiAqIE1WMyBCYWNrZ3JvdW5kIFNlcnZpY2UgV29ya2VyIC0gTWFpbiBFbnRyeSBQb2ludFxyXG4gKiBcclxuICogSGFuZGxlczpcclxuICogLSBTaWRlIHBhbmVsIGluaXRpYWxpemF0aW9uXHJcbiAqIC0gRXh0ZW5zaW9uIGxpZmVjeWNsZSBldmVudHNcclxuICogLSBOb3Rpb24gTUNQIE9BdXRoIGFuZCBTU0UgY29ubmVjdGlvblxyXG4gKi9cclxuXHJcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2NsaWVudC9pbmRleC5qc1wiO1xyXG5pbXBvcnQgeyBTU0VDbGllbnRUcmFuc3BvcnQgfSBmcm9tIFwiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9jbGllbnQvc3NlLmpzXCI7XHJcbmltcG9ydCB7IE1jcFNTRUNsaWVudCB9IGZyb20gJy4vbWNwL25vdGlvbkNsaWVudCc7XHJcbmltcG9ydCB7XHJcbiAgICByZWdpc3RlckR5bmFtaWNDbGllbnQsXHJcbiAgICBnZW5lcmF0ZVN0YXRlLFxyXG4gICAgY3JlYXRlQ29kZVZlcmlmaWVyLFxyXG4gICAgYnVpbGRBdXRoVXJsLFxyXG4gICAgZXhjaGFuZ2VDb2RlRm9yVG9rZW5zLFxyXG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuLFxyXG4gICAgaXNUb2tlbkV4cGlyZWQsXHJcbiAgICBzdG9yZVRva2VucyxcclxuICAgIGdldFN0b3JlZFRva2VucyxcclxuICAgIGNsZWFyVG9rZW5zLFxyXG4gICAgc3RvcmVDbGllbnRDcmVkZW50aWFscyxcclxuICAgIGdldFN0b3JlZENsaWVudENyZWRlbnRpYWxzLFxyXG4gICAgY2xlYXJDbGllbnRDcmVkZW50aWFscyxcclxuICAgIHR5cGUgRHluYW1pY0NsaWVudENyZWRlbnRpYWxzXHJcbn0gZnJvbSAnLi9tY3Avb2F1dGgnO1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgICBOb3Rpb25PQXV0aFRva2VucyxcclxuICAgIE9BdXRoU3RhdGUsXHJcbiAgICBOb3Rpb25NY3BTdGF0dXMsXHJcbiAgICBOb3Rpb25NY3BNZXNzYWdlLFxyXG4gICAgTm90aW9uTWNwUmVzcG9uc2UsXHJcbiAgICBNY3BNZXNzYWdlXHJcbn0gZnJvbSAnLi9tY3AvdHlwZXMnO1xyXG5pbXBvcnQgeyBOT1RJT05fQ09ORklHIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBOb3Rpb24gTUNQIFN0YXRlXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmxldCBub3Rpb25NY3BDbGllbnQ6IE1jcFNTRUNsaWVudCB8IG51bGwgPSBudWxsO1xyXG5sZXQgbm90aW9uVG9rZW5zOiBOb3Rpb25PQXV0aFRva2VucyB8IG51bGwgPSBudWxsO1xyXG5sZXQgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHM6IER5bmFtaWNDbGllbnRDcmVkZW50aWFscyB8IG51bGwgPSBudWxsO1xyXG5sZXQgb2F1dGhTdGF0ZTogT0F1dGhTdGF0ZSB8IG51bGwgPSBudWxsO1xyXG5sZXQgbm90aW9uU3RhdHVzOiBOb3Rpb25NY3BTdGF0dXMgPSB7IHN0YXRlOiAnZGlzY29ubmVjdGVkJyB9O1xyXG5sZXQgaXNFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTdGFydCBPQXV0aCBmbG93IGZvciBOb3Rpb24gTUNQIHdpdGggZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzdGFydE5vdGlvbkF1dGgoKTogUHJvbWlzZTxOb3Rpb25NY3BSZXNwb25zZT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFN0YXJ0aW5nIE5vdGlvbiBPQXV0aCBmbG93IHdpdGggZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uJyk7XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMTogUmVnaXN0ZXIgYSBkeW5hbWljIGNsaWVudFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUmVnaXN0ZXJpbmcgZHluYW1pYyBjbGllbnQuLi4nKTtcclxuICAgICAgICBub3Rpb25TdGF0dXMgPSB7IHN0YXRlOiAncmVnaXN0ZXJpbmcnIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNsaWVudENyZWRlbnRpYWxzID0gYXdhaXQgcmVnaXN0ZXJEeW5hbWljQ2xpZW50KE5PVElPTl9DT05GSUcuT0FVVEhfUkVESVJFQ1RfVVJJKTtcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgY2xpZW50IGNyZWRlbnRpYWxzXHJcbiAgICAgICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMgPSBjbGllbnRDcmVkZW50aWFscztcclxuICAgICAgICBhd2FpdCBzdG9yZUNsaWVudENyZWRlbnRpYWxzKGNsaWVudENyZWRlbnRpYWxzKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBEeW5hbWljIGNsaWVudCByZWdpc3RlcmVkOicsIGNsaWVudENyZWRlbnRpYWxzLmNsaWVudF9pZCk7XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMjogR2VuZXJhdGUgc3RhdGUgZm9yIENTUkYgcHJvdGVjdGlvblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2VuZXJhdGVTdGF0ZSgpO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBzdGF0ZSBpbiBtZW1vcnkgZm9yIHRoZSBjYWxsYmFja1xyXG4gICAgICAgIG9hdXRoU3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICBjb2RlVmVyaWZpZXI6ICcnLCAvLyBOb3QgbmVlZGVkIGZvciBzdGFuZGFyZCBPQXV0aFxyXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU3RlcCAzOiBCdWlsZCBhdXRob3JpemF0aW9uIFVSTCB1c2luZyB0aGUgZHluYW1pYyBjbGllbnQgSURcclxuICAgICAgICBjb25zdCBhdXRoVXJsID0gYnVpbGRBdXRoVXJsKFxyXG4gICAgICAgICAgICBjbGllbnRDcmVkZW50aWFscy5jbGllbnRfaWQsXHJcbiAgICAgICAgICAgIE5PVElPTl9DT05GSUcuT0FVVEhfUkVESVJFQ1RfVVJJLFxyXG4gICAgICAgICAgICBzdGF0ZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gTGF1bmNoaW5nIE9BdXRoIHdpdGggVVJMOicsIGF1dGhVcmwpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzXHJcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2F1dGhvcml6aW5nJyB9O1xyXG4gICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xyXG5cclxuICAgICAgICAvLyBTdGVwIDQ6IExhdW5jaCBPQXV0aCBmbG93IHVzaW5nIENocm9tZSBJZGVudGl0eSBBUElcclxuICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IGF3YWl0IGNocm9tZS5pZGVudGl0eS5sYXVuY2hXZWJBdXRoRmxvdyh7XHJcbiAgICAgICAgICAgIHVybDogYXV0aFVybCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZWRpcmVjdFVybCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09BdXRoIGZsb3cgY2FuY2VsbGVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIE9BdXRoIHJlZGlyZWN0IFVSTDonLCByZWRpcmVjdFVybCk7XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgNTogRXh0cmFjdCBjb2RlIGFuZCBzdGF0ZSBmcm9tIHJlZGlyZWN0IFVSTFxyXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnY29kZScpO1xyXG4gICAgICAgIGNvbnN0IHJldHVybmVkU3RhdGUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnc3RhdGUnKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXV0aG9yaXphdGlvbiBjb2RlIHJlY2VpdmVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWZXJpZnkgc3RhdGVcclxuICAgICAgICBpZiAoIW9hdXRoU3RhdGUgfHwgcmV0dXJuZWRTdGF0ZSAhPT0gb2F1dGhTdGF0ZS5zdGF0ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG1pc21hdGNoIC0gcG9zc2libGUgQ1NSRiBhdHRhY2snKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gRXhjaGFuZ2luZyBjb2RlIGZvciB0b2tlbnMnKTtcclxuXHJcbiAgICAgICAgLy8gU3RlcCA2OiBFeGNoYW5nZSBjb2RlIGZvciB0b2tlbnMgdXNpbmcgZHluYW1pYyBjbGllbnQgY3JlZGVudGlhbHNcclxuICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBleGNoYW5nZUNvZGVGb3JUb2tlbnMoXHJcbiAgICAgICAgICAgIGNvZGUsXHJcbiAgICAgICAgICAgIGNsaWVudENyZWRlbnRpYWxzLmNsaWVudF9pZCxcclxuICAgICAgICAgICAgY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50X3NlY3JldCxcclxuICAgICAgICAgICAgTk9USU9OX0NPTkZJRy5PQVVUSF9SRURJUkVDVF9VUklcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSB0b2tlbnNcclxuICAgICAgICBub3Rpb25Ub2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgICAgYXdhaXQgc3RvcmVUb2tlbnModG9rZW5zKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBUb2tlbnMgc3RvcmVkIHN1Y2Nlc3NmdWxseScpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzXHJcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2F1dGhlbnRpY2F0ZWQnIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gTm90aW9uIE1DUCBPQXV0aCBzdWNjZXNzZnVsJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgc3RhdGU6ICdhdXRoZW50aWNhdGVkJyB9IH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBOb3Rpb24gTUNQIE9BdXRoIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICBub3Rpb25TdGF0dXMgPSB7XHJcbiAgICAgICAgICAgIHN0YXRlOiAnZXJyb3InLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXHJcbiAgICAgICAgfTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgb2F1dGhTdGF0ZSA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWZyZXNoIE5vdGlvbiBhY2Nlc3MgdG9rZW5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hOb3Rpb25Ub2tlbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIGlmICghbm90aW9uVG9rZW5zPy5yZWZyZXNoX3Rva2VuKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIE5vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ25lZWRzLWF1dGgnLCBlcnJvcjogJ05vIHJlZnJlc2ggdG9rZW4nIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvYWQgY2xpZW50IGNyZWRlbnRpYWxzIGlmIG5vdCBpbiBtZW1vcnlcclxuICAgIGlmICghbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMpIHtcclxuICAgICAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscyA9IGF3YWl0IGdldFN0b3JlZENsaWVudENyZWRlbnRpYWxzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFub3Rpb25DbGllbnRDcmVkZW50aWFscykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBObyBjbGllbnQgY3JlZGVudGlhbHMgYXZhaWxhYmxlIGZvciB0b2tlbiByZWZyZXNoJyk7XHJcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ25lZWRzLWF1dGgnLCBlcnJvcjogJ05vIGNsaWVudCBjcmVkZW50aWFscycgfTtcclxuICAgICAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFJlZnJlc2hpbmcgTm90aW9uIHRva2VuJyk7XHJcbiAgICAgICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ3Rva2VuLXJlZnJlc2gnIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld1Rva2VucyA9IGF3YWl0IHJlZnJlc2hBY2Nlc3NUb2tlbihcclxuICAgICAgICAgICAgbm90aW9uVG9rZW5zLnJlZnJlc2hfdG9rZW4sXHJcbiAgICAgICAgICAgIG5vdGlvbkNsaWVudENyZWRlbnRpYWxzLmNsaWVudF9pZCxcclxuICAgICAgICAgICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMuY2xpZW50X3NlY3JldFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbm90aW9uVG9rZW5zID0gbmV3VG9rZW5zO1xyXG4gICAgICAgIGF3YWl0IHN0b3JlVG9rZW5zKG5ld1Rva2Vucyk7XHJcblxyXG4gICAgICAgIG5vdGlvblN0YXR1cyA9IHsgc3RhdGU6ICdhdXRoZW50aWNhdGVkJyB9O1xyXG4gICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIFRva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgICAvLyBDbGVhciBpbnZhbGlkIHRva2Vuc1xyXG4gICAgICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XHJcbiAgICAgICAgbm90aW9uVG9rZW5zID0gbnVsbDtcclxuICAgICAgICBub3Rpb25TdGF0dXMgPSB7XHJcbiAgICAgICAgICAgIHN0YXRlOiAnbmVlZHMtYXV0aCcsXHJcbiAgICAgICAgICAgIGVycm9yOiAnVG9rZW4gcmVmcmVzaCBmYWlsZWQuIFBsZWFzZSByZS1hdXRoZW50aWNhdGUuJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBhY2Nlc3MgdG9rZW5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZVZhbGlkVG9rZW4oKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgICBpZiAoIW5vdGlvblRva2Vucykge1xyXG4gICAgICAgIC8vIFRyeSB0byBsb2FkIGZyb20gc3RvcmFnZVxyXG4gICAgICAgIG5vdGlvblRva2VucyA9IGF3YWl0IGdldFN0b3JlZFRva2VucygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm90aW9uVG9rZW5zKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgZXhwaXJlZFxyXG4gICAgaWYgKGlzVG9rZW5FeHBpcmVkKG5vdGlvblRva2VucykpIHtcclxuICAgICAgICAvLyBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCByZWZyZXNoTm90aW9uVG9rZW4oKTtcclxuICAgICAgICAvLyBpZiAoIXJlZnJlc2hlZCkge1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vdGlvblRva2Vucy5hY2Nlc3NfdG9rZW47XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gTm90aW9uIE1DUCBDb25uZWN0aW9uIEZ1bmN0aW9uc1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogQ29ubmVjdCB0byBOb3Rpb24gTUNQIHNlcnZlclxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdE5vdGlvbk1jcCgpOiBQcm9taXNlPE5vdGlvbk1jcFJlc3BvbnNlPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQ29ubmVjdGluZyB0byBOb3Rpb24gTUNQJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgZW5zdXJlVmFsaWRUb2tlbigpO1xyXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBTU0UgY2xpZW50XHJcbiAgICAgICAgbm90aW9uTWNwQ2xpZW50ID0gbmV3IE1jcFNTRUNsaWVudChcclxuICAgICAgICAgICAgTk9USU9OX0NPTkZJRy5NQ1BfU1NFX1VSTCxcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9uU3RhdHVzQ2hhbmdlOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aW9uU3RhdHVzID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdG9rZW4gZXhwaXJ5IChidXQgbm90IGZvcm1hdCBlcnJvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5zdGF0ZSA9PT0gJ25lZWRzLWF1dGgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZVRva2VuRXhwaXJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMuc3RhdGUgPT09ICdpbnZhbGlkLXRva2VuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2tlbiBmb3JtYXQgaXMgaW52YWxpZCAtIGNsZWFyIHRva2VucyBhbmQgcmVxdWlyZSByZS1hdXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZUludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBNQ1AgbWVzc2FnZTonLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3RcclxuICAgICAgICBhd2FpdCBub3Rpb25NY3BDbGllbnQuY29ubmVjdCgpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIE1DUCBwcm90b2NvbFxyXG4gICAgICAgIGF3YWl0IG5vdGlvbk1jcENsaWVudC5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5vdGlvbk1jcENsaWVudC5nZXRTdGF0dXMoKSB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gTm90aW9uIE1DUCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Nvbm5lY3Rpb24gZmFpbGVkJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNjb25uZWN0IGZyb20gTm90aW9uIE1DUCBzZXJ2ZXJcclxuICovXHJcbmZ1bmN0aW9uIGRpc2Nvbm5lY3ROb3Rpb25NY3AoKTogdm9pZCB7XHJcbiAgICBpZiAobm90aW9uTWNwQ2xpZW50KSB7XHJcbiAgICAgICAgbm90aW9uTWNwQ2xpZW50LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBub3Rpb25NY3BDbGllbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2F1dGhlbnRpY2F0ZWQnIH07XHJcbiAgICBicm9hZGNhc3RTdGF0dXNVcGRhdGUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSB0b2tlbiBleHBpcnkgLSBhdHRlbXB0IHJlZnJlc2ggYW5kIHJlY29ubmVjdFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlVG9rZW5FeHBpcnkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIEhhbmRsaW5nIHRva2VuIGV4cGlyeScpO1xyXG5cclxuICAgIC8vIERpc2Nvbm5lY3QgY3VycmVudCBjbGllbnRcclxuICAgIGlmIChub3Rpb25NY3BDbGllbnQpIHtcclxuICAgICAgICBub3Rpb25NY3BDbGllbnQuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIG5vdGlvbk1jcENsaWVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHRvIHJlZnJlc2hcclxuICAgIGNvbnN0IHJlZnJlc2hlZCA9IGF3YWl0IHJlZnJlc2hOb3Rpb25Ub2tlbigpO1xyXG5cclxuICAgIC8vIElmIGVuYWJsZWQgYW5kIHJlZnJlc2ggc3VjY2VlZGVkLCByZWNvbm5lY3RcclxuICAgIGlmIChyZWZyZXNoZWQgJiYgaXNFbmFibGVkKSB7XHJcbiAgICAgICAgYXdhaXQgY29ubmVjdE5vdGlvbk1jcCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlIGludmFsaWQgdG9rZW4gZm9ybWF0IC0gY2xlYXIgdG9rZW5zIGFuZCByZXF1aXJlIHJlLWF1dGhcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUludmFsaWRUb2tlbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gSGFuZGxpbmcgaW52YWxpZCB0b2tlbiBmb3JtYXQnKTtcclxuXHJcbiAgICAvLyBEaXNjb25uZWN0IGN1cnJlbnQgY2xpZW50XHJcbiAgICBpZiAobm90aW9uTWNwQ2xpZW50KSB7XHJcbiAgICAgICAgbm90aW9uTWNwQ2xpZW50LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBub3Rpb25NY3BDbGllbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFyIGludmFsaWQgdG9rZW5zIGFuZCBjbGllbnQgY3JlZGVudGlhbHMgLSBkb24ndCB0cnkgdG8gcmVmcmVzaFxyXG4gICAgYXdhaXQgY2xlYXJUb2tlbnMoKTtcclxuICAgIGF3YWl0IGNsZWFyQ2xpZW50Q3JlZGVudGlhbHMoKTtcclxuICAgIG5vdGlvblRva2VucyA9IG51bGw7XHJcbiAgICBub3Rpb25DbGllbnRDcmVkZW50aWFscyA9IG51bGw7XHJcbiAgICBub3Rpb25TdGF0dXMgPSB7XHJcbiAgICAgICAgc3RhdGU6ICdpbnZhbGlkLXRva2VuJyxcclxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgdG9rZW4gZm9ybWF0IC0gcGxlYXNlIHJlLWF1dGhlbnRpY2F0ZSdcclxuICAgIH07XHJcbiAgICBpc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7ICdtY3Aubm90aW9uLmVuYWJsZWQnOiBmYWxzZSB9KTtcclxuICAgIGJyb2FkY2FzdFN0YXR1c1VwZGF0ZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogRW5hYmxlIE5vdGlvbiBNQ1AgKGNvbm5lY3QgaWYgYXV0aGVudGljYXRlZClcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZU5vdGlvbk1jcCgpOiBQcm9taXNlPE5vdGlvbk1jcFJlc3BvbnNlPiB7XHJcbiAgICBpc0VuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIFN0b3JlIGVuYWJsZWQgc3RhdGVcclxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7ICdtY3Aubm90aW9uLmVuYWJsZWQnOiB0cnVlIH0pO1xyXG5cclxuICAgIC8vIElmIGFscmVhZHkgY29ubmVjdGVkLCBwZXJmb3JtIGhlYWx0aCBjaGVja1xyXG4gICAgaWYgKG5vdGlvbk1jcENsaWVudCAmJiBub3Rpb25TdGF0dXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBBbHJlYWR5IGNvbm5lY3RlZCwgcGVyZm9ybWluZyBoZWFsdGggY2hlY2snKTtcclxuICAgICAgICBjb25zdCBoZWFsdGhDaGVjayA9IGF3YWl0IHBlcmZvcm1IZWFsdGhDaGVjaygpO1xyXG5cclxuICAgICAgICBpZiAoaGVhbHRoQ2hlY2suc3VjY2Vzcykge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBub3Rpb25TdGF0dXMgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tCYWNrZ3JvdW5kXSBIZWFsdGggY2hlY2sgZmFpbGVkLCByZWNvbm5lY3RpbmcuLi4nLCBoZWFsdGhDaGVjay5lcnJvcik7XHJcbiAgICAgICAgICAgIC8vIEhlYWx0aCBjaGVjayBmYWlsZWQsIHRyeSB0byByZWNvbm5lY3RcclxuICAgICAgICAgICAgZGlzY29ubmVjdE5vdGlvbk1jcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhdXRoZW50aWNhdGVkLCBjb25uZWN0XHJcbiAgICBpZiAobm90aW9uVG9rZW5zIHx8IGF3YWl0IGdldFN0b3JlZFRva2VucygpKSB7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdFJlc3VsdCA9IGF3YWl0IGNvbm5lY3ROb3Rpb25NY3AoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBzdWNjZXNzZnVsLCBwZXJmb3JtIGhlYWx0aCBjaGVja1xyXG4gICAgICAgIGlmIChjb25uZWN0UmVzdWx0LnN1Y2Nlc3MgJiYgbm90aW9uTWNwQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQ29ubmVjdGlvbiBzdWNjZXNzZnVsLCBwZXJmb3JtaW5nIGhlYWx0aCBjaGVjaycpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWFsdGhDaGVjayA9IGF3YWl0IHBlcmZvcm1IZWFsdGhDaGVjaygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFoZWFsdGhDaGVjay5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tCYWNrZ3JvdW5kXSBIZWFsdGggY2hlY2sgZmFpbGVkIGFmdGVyIGNvbm5lY3Rpb246JywgaGVhbHRoQ2hlY2suZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgbm90aW9uU3RhdHVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vdGlvblN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvbm5lY3RlZCBidXQgaGVhbHRoIGNoZWNrIGZhaWxlZDogJHtoZWFsdGhDaGVjay5lcnJvcn1gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBwYXNzZWQ6JywgaGVhbHRoQ2hlY2suZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE90aGVyd2lzZSwgbmVlZCBhdXRoXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQuIFBsZWFzZSBjb25uZWN0IGZpcnN0LidcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlIE5vdGlvbiBNQ1AgKGRpc2Nvbm5lY3QpXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkaXNhYmxlTm90aW9uTWNwKCk6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcclxuICAgIGlzRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgJ21jcC5ub3Rpb24uZW5hYmxlZCc6IGZhbHNlIH0pO1xyXG4gICAgZGlzY29ubmVjdE5vdGlvbk1jcCgpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogRGlzY29ubmVjdCBhbmQgY2xlYXIgYXV0aGVudGljYXRpb25cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3ROb3Rpb25BdXRoKCk6IFByb21pc2U8Tm90aW9uTWNwUmVzcG9uc2U+IHtcclxuICAgIGRpc2Nvbm5lY3ROb3Rpb25NY3AoKTtcclxuICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XHJcbiAgICBhd2FpdCBjbGVhckNsaWVudENyZWRlbnRpYWxzKCk7XHJcbiAgICBub3Rpb25Ub2tlbnMgPSBudWxsO1xyXG4gICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMgPSBudWxsO1xyXG4gICAgbm90aW9uU3RhdHVzID0geyBzdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcclxuICAgIGlzRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgJ21jcC5ub3Rpb24uZW5hYmxlZCc6IGZhbHNlIH0pO1xyXG4gICAgYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgY3VycmVudCBOb3Rpb24gTUNQIHN0YXR1c1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Tm90aW9uU3RhdHVzKCk6IE5vdGlvbk1jcFN0YXR1cyB7XHJcbiAgICByZXR1cm4gbm90aW9uU3RhdHVzO1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBoZWFsdGggY2hlY2sgb24gTm90aW9uIE1DUCBjb25uZWN0aW9uIHVzaW5nIG9mZmljaWFsIE1DUCBTREtcclxuICogVmFsaWRhdGVzIGNvbm5lY3Rpb24gYW5kIHJldHJpZXZlcyBhdmFpbGFibGUgdG9vbHNcclxuICogU2ltaWxhciB0bzogaHR0cHM6Ly9tb2RlbGNvbnRleHRwcm90b2NvbC5pby9kb2NzL3Rvb2xzL2NsaWVudHNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1IZWFsdGhDaGVjaygpOiBQcm9taXNlPE5vdGlvbk1jcFJlc3BvbnNlPiB7XHJcbiAgICBsZXQgY2xpZW50OiBDbGllbnQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFBlcmZvcm1pbmcgTm90aW9uIE1DUCBoZWFsdGggY2hlY2sgd2l0aCBTREsnKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGFjY2VzcyB0b2tlblxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgZW5zdXJlVmFsaWRUb2tlbigpO1xyXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdObyB2YWxpZCBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChOT1RJT05fQ09ORklHLk1DUF9TU0VfVVJMKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIE1DUCBjbGllbnRcclxuICAgICAgICAgICAgY2xpZW50ID0gbmV3IENsaWVudCh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hyb21lLWFpLWhlYWx0aC1jaGVjaycsXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzOiB7IGxpc3RDaGFuZ2VkOiB0cnVlIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIENvbm5lY3RpbmcgdG8gTUNQIHNlcnZlciB3aXRoIFNTRSB0cmFuc3BvcnQuLi4nKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTU0UgdHJhbnNwb3J0IHdpdGggYXV0aG9yaXphdGlvblxyXG4gICAgICAgICAgICAvLyBVc2UgcmVxdWVzdEluaXQgdG8gYWRkIEF1dGhvcml6YXRpb24gaGVhZGVyIHRvIFBPU1QgcmVxdWVzdHNcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFNTRUNsaWVudFRyYW5zcG9ydCh1cmwsIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJbml0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvZXZlbnQtc3RyZWFtJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGZldGNoIHRvIGFkZCBBdXRob3JpemF0aW9uIGhlYWRlciB0byBTU0UgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgZmV0Y2g6IGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0Py5oZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQWNjZXB0JywgJ3RleHQvZXZlbnQtc3RyZWFtLCBhcHBsaWNhdGlvbi9qc29uJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaChpbnB1dCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5pbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jb25uZWN0KHRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQ29ubmVjdGVkIHVzaW5nIFNTRSB0cmFuc3BvcnQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0b29scyBmcm9tIHRoZSBjb25uZWN0ZWQgY2xpZW50XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2xzUmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubGlzdFRvb2xzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gVG9vbHMgcmVzcG9uc2U6JywgdG9vbHNSZXNwb25zZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IGFmdGVyIGdldHRpbmcgdG9vbHNcclxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsb3NlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9vbHNSZXNwb25zZSAmJiB0b29sc1Jlc3BvbnNlLnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sQ291bnQgPSB0b29sc1Jlc3BvbnNlLnRvb2xzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gSGVhbHRoIGNoZWNrIHBhc3NlZC4gVG9vbHMgYXZhaWxhYmxlOicsIHRvb2xDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdjb25uZWN0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogdG9vbHNSZXNwb25zZS50b29scy5tYXAodG9vbCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYTogdG9vbC5pbnB1dFNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDb3VudDogdG9vbENvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdObyB0b29scyBhdmFpbGFibGUgZnJvbSBzZXJ2ZXInXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAodHJhbnNwb3J0RXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBmYWlsZWQ6JywgdHJhbnNwb3J0RXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgY2xpZW50IGlmIGV4aXN0c1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBFcnJvciBjbG9zaW5nIGNsaWVudDonLCBjbG9zZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IHRyYW5zcG9ydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB0cmFuc3BvcnRFcnJvci5tZXNzYWdlIDogJ0Nvbm5lY3Rpb24gZmFpbGVkJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEhlYWx0aCBjaGVjayBlcnJvcjonLCBlcnJvcik7XHJcblxyXG4gICAgICAgIC8vIENsZWFuIHVwIGNsaWVudCBpZiBleGlzdHNcclxuICAgICAgICBpZiAoY2xpZW50KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEVycm9yIGNsb3NpbmcgY2xpZW50OicsIGNsb3NlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0hlYWx0aCBjaGVjayBmYWlsZWQnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgYSBOb3Rpb24gTUNQIHRvb2xcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNhbGxOb3Rpb25Ub29sKG5hbWU6IHN0cmluZywgYXJncz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPE5vdGlvbk1jcFJlc3BvbnNlPiB7XHJcbiAgICBpZiAoIW5vdGlvbk1jcENsaWVudCkge1xyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vdCBjb25uZWN0ZWQnIH07XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBub3Rpb25NY3BDbGllbnQuY2FsbFRvb2wobmFtZSwgYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0IH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBUb29sIGNhbGwgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVG9vbCBjYWxsIGZhaWxlZCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQnJvYWRjYXN0IHN0YXR1cyB1cGRhdGUgdG8gYWxsIGxpc3RlbmVyc1xyXG4gKi9cclxuZnVuY3Rpb24gYnJvYWRjYXN0U3RhdHVzVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgIHR5cGU6ICdtY3Avbm90aW9uL3N0YXR1cy91cGRhdGUnLFxyXG4gICAgICAgIHBheWxvYWQ6IG5vdGlvblN0YXR1c1xyXG4gICAgfSkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgaWYgbm8gbGlzdGVuZXJzXHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBNZXNzYWdlIEhhbmRsZXJcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKChtZXNzYWdlOiBOb3Rpb25NY3BNZXNzYWdlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xyXG4gICAgLy8gSGFuZGxlIE5vdGlvbiBNQ1AgbWVzc2FnZXNcclxuICAgIGlmIChtZXNzYWdlLnR5cGU/LnN0YXJ0c1dpdGgoJ21jcC9ub3Rpb24vJykpIHtcclxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U6IE5vdGlvbk1jcFJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vYXV0aC9zdGFydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzdGFydE5vdGlvbkF1dGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtY3Avbm90aW9uL2VuYWJsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBlbmFibGVOb3Rpb25NY3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtY3Avbm90aW9uL2Rpc2FibGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZGlzYWJsZU5vdGlvbk1jcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vZGlzY29ubmVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBkaXNjb25uZWN0Tm90aW9uQXV0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vc3RhdHVzL2dldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGdldE5vdGlvblN0YXR1cygpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWNwL25vdGlvbi90b29sL2NhbGwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbE5vdGlvblRvb2woXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZD8ubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkPy5hcmd1bWVudHNcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21jcC9ub3Rpb24vaGVhbHRoL2NoZWNrJzpcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHBlcmZvcm1IZWFsdGhDaGVjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1Vua25vd24gbWVzc2FnZSB0eXBlJyB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBXaWxsIHJlc3BvbmQgYXN5bmNocm9ub3VzbHlcclxuICAgIH1cclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFJ1bnRpbWUgTGlzdGVuZXJzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbi8vIEdsb2JhbCBub3RpZmljYXRpb24gY2xpY2sgaGFuZGxlciBmb3IgcmVtaW5kZXJzXHJcbmNocm9tZS5ub3RpZmljYXRpb25zLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihhc3luYyAobm90aWZpY2F0aW9uSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFub3RpZmljYXRpb25JZC5zdGFydHNXaXRoKCdyZW1pbmRlcjonKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpZCA9IG5vdGlmaWNhdGlvbklkLnNwbGl0KCc6JylbMV07XHJcbiAgICAgICAgY29uc3QgeyByZW1pbmRlcnMgPSB7fSB9ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCdyZW1pbmRlcnMnKTtcclxuICAgICAgICBjb25zdCByZW1pbmRlcjogUmVtaW5kZXIgfCB1bmRlZmluZWQgPSByZW1pbmRlcnNbaWRdO1xyXG5cclxuICAgICAgICBpZiAocmVtaW5kZXI/LnVybCkge1xyXG4gICAgICAgICAgICBhd2FpdCBjaHJvbWUudGFicy5jcmVhdGUoeyB1cmw6IHJlbWluZGVyLnVybCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsZWFudXA6IHJlbW92ZSByZW1pbmRlciBhbmQgY2xlYXIgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgaWYgKHJlbWluZGVyc1tpZF0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHJlbWluZGVyc1tpZF07XHJcbiAgICAgICAgICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7IHJlbWluZGVycyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNocm9tZS5ub3RpZmljYXRpb25zLmNsZWFyKG5vdGlmaWNhdGlvbklkKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEVycm9yIGhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazonLCBlcnJvcik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBpbnN0YWxsL3VwZGF0ZSBoYW5kbGVyXHJcbiAqL1xyXG5jaHJvbWUucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcihhc3luYyAoZGV0YWlscykgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBvbkluc3RhbGxlZDonLCBkZXRhaWxzLnJlYXNvbik7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBFbmFibGUgc2lkZSBwYW5lbCBvbiBhbGwgZXhpc3RpbmcgdGFic1xyXG4gICAgICAgIGlmIChjaHJvbWUuc2lkZVBhbmVsKSB7XHJcbiAgICAgICAgICAgIGNocm9tZS5zaWRlUGFuZWwuc2V0UGFuZWxCZWhhdmlvcih7IG9wZW5QYW5lbE9uQWN0aW9uQ2xpY2s6IHRydWUgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2FkIHNhdmVkIHN0YXRlXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFsnbWNwLm5vdGlvbi5lbmFibGVkJ10pO1xyXG4gICAgICAgIGlzRW5hYmxlZCA9IHN0b3JlZFsnbWNwLm5vdGlvbi5lbmFibGVkJ10gfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIElmIGVuYWJsZWQsIHRyeSB0byByZXN0b3JlIGNvbm5lY3Rpb25cclxuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IGdldFN0b3JlZFRva2VucygpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IGdldFN0b3JlZENsaWVudENyZWRlbnRpYWxzKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbnMgJiYgY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlvblRva2VucyA9IHRva2VucztcclxuICAgICAgICAgICAgICAgIG5vdGlvbkNsaWVudENyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0Tm90aW9uTWNwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gU2lkZSBwYW5lbCBjb25maWd1cmVkJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tCYWNrZ3JvdW5kXSBvbkluc3RhbGxlZCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBzdGFydHVwIGhhbmRsZXJcclxuICovXHJcbmNocm9tZS5ydW50aW1lLm9uU3RhcnR1cC5hZGRMaXN0ZW5lcihhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIG9uU3RhcnR1cCAtIEV4dGVuc2lvbiByZWFkeScpO1xyXG5cclxuICAgIC8vIExvYWQgc2F2ZWQgc3RhdGVcclxuICAgIGNvbnN0IHN0b3JlZCA9IGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChbJ21jcC5ub3Rpb24uZW5hYmxlZCddKTtcclxuICAgIGlzRW5hYmxlZCA9IHN0b3JlZFsnbWNwLm5vdGlvbi5lbmFibGVkJ10gfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gSWYgZW5hYmxlZCwgdHJ5IHRvIHJlc3RvcmUgY29ubmVjdGlvblxyXG4gICAgaWYgKGlzRW5hYmxlZCkge1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IGdldFN0b3JlZFRva2VucygpO1xyXG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gYXdhaXQgZ2V0U3RvcmVkQ2xpZW50Q3JlZGVudGlhbHMoKTtcclxuICAgICAgICBpZiAodG9rZW5zICYmIGNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIG5vdGlvblRva2VucyA9IHRva2VucztcclxuICAgICAgICAgICAgbm90aW9uQ2xpZW50Q3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcclxuICAgICAgICAgICAgYXdhaXQgY29ubmVjdE5vdGlvbk1jcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQWN0aW9uIGNsaWNrIGhhbmRsZXIgLSBvcGVuIHNpZGUgcGFuZWxcclxuICovXHJcbmlmIChjaHJvbWUuYWN0aW9uKSB7XHJcbiAgICBjaHJvbWUuYWN0aW9uLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihhc3luYyAodGFiKSA9PiB7XHJcbiAgICAgICAgaWYgKGNocm9tZS5zaWRlUGFuZWwgJiYgdGFiLmlkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjaHJvbWUuc2lkZVBhbmVsLm9wZW4oeyB0YWJJZDogdGFiLmlkIH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0JhY2tncm91bmRdIEVycm9yIG9wZW5pbmcgc2lkZSBwYW5lbDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbi8vIENyZWF0ZSBjbGVhbnVwIGFsYXJtIChydW5zIGV2ZXJ5IGhvdXIpXHJcbmNocm9tZS5hbGFybXMuY3JlYXRlKCdjbGVhbnVwLWV4cGlyZWQtc2Vzc2lvbnMnLCB7XHJcbiAgICBwZXJpb2RJbk1pbnV0ZXM6IDYwXHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBSZW1pbmRlciBBbGFybXMgSGFuZGxlclxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbnRlcmZhY2UgUmVtaW5kZXIge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICB3aGVuOiBudW1iZXI7XHJcbiAgICB1cmw/OiBzdHJpbmc7XHJcbiAgICBjcmVhdGVkQXQ6IG51bWJlcjtcclxuICAgIGdlbmVyYXRlZFRpdGxlPzogc3RyaW5nO1xyXG4gICAgZ2VuZXJhdGVkRGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgcmVtaW5kZXIgYWxhcm1zIC0gc2hvdyBub3RpZmljYXRpb24gd2hlbiByZW1pbmRlciBmaXJlc1xyXG4gKi9cclxuY2hyb21lLmFsYXJtcy5vbkFsYXJtLmFkZExpc3RlbmVyKGFzeW5jIChhbGFybSkgPT4ge1xyXG4gICAgLy8gT25seSBoYW5kbGUgcmVtaW5kZXIgYWxhcm1zXHJcbiAgICBpZiAoIWFsYXJtLm5hbWUuc3RhcnRzV2l0aCgncmVtaW5kZXI6JykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWQgPSBhbGFybS5uYW1lLnNwbGl0KCc6JylbMV07XHJcbiAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIFJlbWluZGVyIGFsYXJtIGZpcmVkOicsIGlkKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEdldCB0aGUgcmVtaW5kZXIgZnJvbSBzdG9yYWdlXHJcbiAgICAgICAgY29uc3QgeyByZW1pbmRlcnMgPSB7fSB9ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCdyZW1pbmRlcnMnKTtcclxuICAgICAgICBjb25zdCByZW1pbmRlcjogUmVtaW5kZXIgfCB1bmRlZmluZWQgPSByZW1pbmRlcnNbaWRdO1xyXG5cclxuICAgICAgICBpZiAoIXJlbWluZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0JhY2tncm91bmRdIFJlbWluZGVyIG5vdCBmb3VuZDonLCBpZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb24gd2l0aCBBSS1nZW5lcmF0ZWQgY29udGVudCBvciBmYWxsYmFjayB0byBvcmlnaW5hbCB0aXRsZVxyXG4gICAgICAgIGNvbnN0IHNpbXBsZUljb24gPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlI0Mm1OaytNOVFEd0FEaGdHQVdqUjlhd0FBQUFCSlJVNUVya0pnZ2c9PSc7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvblRpdGxlID0gcmVtaW5kZXIuZ2VuZXJhdGVkVGl0bGUgfHwgJ+KPsCBSZW1pbmRlcic7XHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uTWVzc2FnZSA9IHJlbWluZGVyLmdlbmVyYXRlZERlc2NyaXB0aW9uIHx8IHJlbWluZGVyLnRpdGxlO1xyXG5cclxuICAgICAgICAvLyBVc2UgYSBuYW1lc3BhY2VkIG5vdGlmaWNhdGlvbiBJRCB0byBkaXN0aW5ndWlzaCByZW1pbmRlcnNcclxuICAgICAgICBjaHJvbWUubm90aWZpY2F0aW9ucy5jcmVhdGUoYHJlbWluZGVyOiR7aWR9YCwge1xyXG4gICAgICAgICAgICB0eXBlOiAnYmFzaWMnLFxyXG4gICAgICAgICAgICBpY29uVXJsOiBzaW1wbGVJY29uLFxyXG4gICAgICAgICAgICB0aXRsZTogbm90aWZpY2F0aW9uVGl0bGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5vdGlmaWNhdGlvbk1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHByaW9yaXR5OiAyLFxyXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb246IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gUmVtaW5kZXIgbm90aWZpY2F0aW9uIGNyZWF0ZWQ6Jywge1xyXG4gICAgICAgICAgICB0aXRsZTogbm90aWZpY2F0aW9uVGl0bGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5vdGlmaWNhdGlvbk1lc3NhZ2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IHJlbW92ZSB0aGUgcmVtaW5kZXIgaGVyZTsgaXQgd2lsbCBiZSByZW1vdmVkIGJ5IHRoZSBnbG9iYWxcclxuICAgICAgICAvLyBub3RpZmljYXRpb24gY2xpY2sgaGFuZGxlciB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgYW5kIGVuc3VyZSB0aGVcclxuICAgICAgICAvLyBjbGljayBoYW5kbGVyIGhhcyBhY2Nlc3MgdG8gdGhlIHN0b3JlZCByZW1pbmRlciBkYXRhLlxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbQmFja2dyb3VuZF0gRXJyb3IgaGFuZGxpbmcgcmVtaW5kZXIgYWxhcm06JywgZXJyb3IpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gSW5pdGlhbGl6YXRpb25cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuY29uc29sZS5sb2coJ1tCYWNrZ3JvdW5kXSBTZXJ2aWNlIHdvcmtlciBsb2FkZWQgLSBDb3BpbG90S2l0IHBvd2VyZWQgZXh0ZW5zaW9uIHJlYWR5Jyk7XHJcbmNvbnNvbGUubG9nKCdbQmFja2dyb3VuZF0gQnJvd3NlciBhY3Rpb25zIGV2ZW50IGxpc3RlbmVycyBpbml0aWFsaXplZCcpO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBPZmZzY3JlZW4gRG9jdW1lbnQ6IFN1bW1hcml6ZXIgQnJva2VyXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbi8vIEVuc3VyZSBhIHNpbmdsZSBvZmZzY3JlZW4gZG9jdW1lbnQgZXhpc3RzXHJcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9mZnNjcmVlbkRvY3VtZW50KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaHJvbWUgMTE2KyBoYXMgY2hyb21lLm9mZnNjcmVlbi5oYXNEb2N1bWVudFxyXG4gICAgICAgIC8vIEZhbGxiYWNrOiB0cnkgY3JlYXRpbmcgYW5kIGlnbm9yZSBpZiBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IGhhc0RvYzogYm9vbGVhbiA9IHR5cGVvZiBjaHJvbWUub2Zmc2NyZWVuPy5oYXNEb2N1bWVudCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICA/IGF3YWl0IGNocm9tZS5vZmZzY3JlZW4uaGFzRG9jdW1lbnQoKVxyXG4gICAgICAgICAgICA6IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIWhhc0RvYykge1xyXG4gICAgICAgICAgICBhd2FpdCBjaHJvbWUub2Zmc2NyZWVuLmNyZWF0ZURvY3VtZW50KHtcclxuICAgICAgICAgICAgICAgIHVybDogJ29mZnNjcmVlbi5odG1sJyxcclxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIElGUkFNRV9TQ1JJUFRJTkcgaXMgYXBwcm9wcmlhdGUgZm9yIHJ1bm5pbmcgRE9NIEFQSXMgJiBzY3JpcHRzXHJcbiAgICAgICAgICAgICAgICByZWFzb25zOiBbY2hyb21lLm9mZnNjcmVlbi5SZWFzb24uSUZSQU1FX1NDUklQVElOR10sXHJcbiAgICAgICAgICAgICAgICBqdXN0aWZpY2F0aW9uOiAnUnVuIENocm9tZSBTdW1tYXJpemVyIEFQSSBpbiBhbiBpc29sYXRlZCBvZmZzY3JlZW4gZG9jdW1lbnQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0JhY2tncm91bmRdIE9mZnNjcmVlbiBkb2N1bWVudCBjcmVhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBTb21lIENocm9tZSB2ZXJzaW9ucyB0aHJvdyBpZiBhIGRvY3VtZW50IGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbQmFja2dyb3VuZF0gZW5zdXJlT2Zmc2NyZWVuRG9jdW1lbnQgd2FybmluZzonLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgU3VtbWFyaXplQXZhaWxhYmlsaXR5TWVzc2FnZSA9IHsgdHlwZTogJ3N1bW1hcml6ZTphdmFpbGFiaWxpdHknIH07XHJcbnR5cGUgU3VtbWFyaXplUmVxdWVzdE1lc3NhZ2UgPSB7XHJcbiAgICB0eXBlOiAnc3VtbWFyaXplOnJlcXVlc3QnO1xyXG4gICAgcGF5bG9hZDoge1xyXG4gICAgICAgIHJlcXVlc3RJZDogc3RyaW5nO1xyXG4gICAgICAgIHRleHQ6IHN0cmluZztcclxuICAgICAgICBvcHRpb25zPzoge1xyXG4gICAgICAgICAgICB0eXBlPzogJ2tleS1wb2ludHMnIHwgJ3RsZHInIHwgJ3RlYXNlcicgfCAnaGVhZGxpbmUnO1xyXG4gICAgICAgICAgICBmb3JtYXQ/OiAnbWFya2Rvd24nIHwgJ3BsYWluLXRleHQnO1xyXG4gICAgICAgICAgICBsZW5ndGg/OiAnc2hvcnQnIHwgJ21lZGl1bScgfCAnbG9uZyc7XHJcbiAgICAgICAgICAgIHNoYXJlZENvbnRleHQ/OiBzdHJpbmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0Pzogc3RyaW5nO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8vIFdpcmUgc3VtbWFyaXplIG1lc3NhZ2VzIGNvbWluZyBmcm9tIFVJIHRvIHRoZSBvZmZzY3JlZW4gZG9jdW1lbnRcclxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKChtZXNzYWdlOiBhbnksIF9zZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xyXG4gICAgaWYgKG1lc3NhZ2U/LnR5cGUgPT09ICdzdW1tYXJpemU6YXZhaWxhYmlsaXR5Jykge1xyXG4gICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGVuc3VyZU9mZnNjcmVlbkRvY3VtZW50KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7IHR5cGU6ICdvZmZzY3JlZW4vc3VtbWFyaXplL2F2YWlsYWJpbGl0eScgfSk7XHJcbiAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IG9rOiBmYWxzZSwgY29kZTogJ2Vycm9yJywgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bicgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXNzYWdlPy50eXBlID09PSAnc3VtbWFyaXplOnJlcXVlc3QnKSB7XHJcbiAgICAgICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbXNnID0gbWVzc2FnZSBhcyBTdW1tYXJpemVSZXF1ZXN0TWVzc2FnZTtcclxuICAgICAgICAgICAgYXdhaXQgZW5zdXJlT2Zmc2NyZWVuRG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2Zmc2NyZWVuL3N1bW1hcml6ZS9yZXF1ZXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBtc2cucGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IG9rOiBmYWxzZSwgY29kZTogJ2Vycm9yJywgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bicgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBhanZfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYWp2XCIpKTtcbi8qKlxuICogQW4gTUNQIGNsaWVudCBvbiB0b3Agb2YgYSBwbHVnZ2FibGUgdHJhbnNwb3J0LlxuICpcbiAqIFRoZSBjbGllbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlZ2luIHRoZSBpbml0aWFsaXphdGlvbiBmbG93IHdpdGggdGhlIHNlcnZlciB3aGVuIGNvbm5lY3QoKSBpcyBjYWxsZWQuXG4gKlxuICogVG8gdXNlIHdpdGggY3VzdG9tIHR5cGVzLCBleHRlbmQgdGhlIGJhc2UgUmVxdWVzdC9Ob3RpZmljYXRpb24vUmVzdWx0IHR5cGVzIGFuZCBwYXNzIHRoZW0gYXMgdHlwZSBwYXJhbWV0ZXJzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIEN1c3RvbSBzY2hlbWFzXG4gKiBjb25zdCBDdXN0b21SZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoey4uLn0pXG4gKiBjb25zdCBDdXN0b21Ob3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHsuLi59KVxuICogY29uc3QgQ3VzdG9tUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7Li4ufSlcbiAqXG4gKiAvLyBUeXBlIGFsaWFzZXNcbiAqIHR5cGUgQ3VzdG9tUmVxdWVzdCA9IHouaW5mZXI8dHlwZW9mIEN1c3RvbVJlcXVlc3RTY2hlbWE+XG4gKiB0eXBlIEN1c3RvbU5vdGlmaWNhdGlvbiA9IHouaW5mZXI8dHlwZW9mIEN1c3RvbU5vdGlmaWNhdGlvblNjaGVtYT5cbiAqIHR5cGUgQ3VzdG9tUmVzdWx0ID0gei5pbmZlcjx0eXBlb2YgQ3VzdG9tUmVzdWx0U2NoZW1hPlxuICpcbiAqIC8vIENyZWF0ZSB0eXBlZCBjbGllbnRcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQ8Q3VzdG9tUmVxdWVzdCwgQ3VzdG9tTm90aWZpY2F0aW9uLCBDdXN0b21SZXN1bHQ+KHtcbiAqICAgbmFtZTogXCJDdXN0b21DbGllbnRcIixcbiAqICAgdmVyc2lvbjogXCIxLjAuMFwiXG4gKiB9KVxuICogYGBgXG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIHByb3RvY29sX2pzXzEuUHJvdG9jb2wge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgY2xpZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZlcnNpb24gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2NsaWVudEluZm8sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY2xpZW50SW5mbyA9IF9jbGllbnRJbmZvO1xuICAgICAgICB0aGlzLl9jYWNoZWRUb29sT3V0cHV0VmFsaWRhdG9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FwYWJpbGl0aWVzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcGFiaWxpdGllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgIHRoaXMuX2FqdiA9IG5ldyBhanZfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgY2FwYWJpbGl0aWVzLiBUaGlzIGNhbiBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY29ubmVjdGluZyB0byBhIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgY2FwYWJpbGl0aWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggYW55IGV4aXN0aW5nIGNhcGFiaWxpdGllcyBwcmV2aW91c2x5IGdpdmVuIChlLmcuLCBhdCBpbml0aWFsaXphdGlvbikuXG4gICAgICovXG4gICAgcmVnaXN0ZXJDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgY2FwYWJpbGl0aWVzIGFmdGVyIGNvbm5lY3RpbmcgdG8gdHJhbnNwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FwYWJpbGl0aWVzID0gKDAsIHByb3RvY29sX2pzXzEubWVyZ2VDYXBhYmlsaXRpZXMpKHRoaXMuX2NhcGFiaWxpdGllcywgY2FwYWJpbGl0aWVzKTtcbiAgICB9XG4gICAgYXNzZXJ0Q2FwYWJpbGl0eShjYXBhYmlsaXR5LCBtZXRob2QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLl9zZXJ2ZXJDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjYXBhYmlsaXR5XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgJHtjYXBhYmlsaXR5fSAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICBhd2FpdCBzdXBlci5jb25uZWN0KHRyYW5zcG9ydCk7XG4gICAgICAgIC8vIFdoZW4gdHJhbnNwb3J0IHNlc3Npb25JZCBpcyBhbHJlYWR5IHNldCB0aGlzIG1lYW5zIHdlIGFyZSB0cnlpbmcgdG8gcmVjb25uZWN0LlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBpbml0aWFsaXplIGFnYWluLlxuICAgICAgICBpZiAodHJhbnNwb3J0LnNlc3Npb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnaW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogdHlwZXNfanNfMS5MQVRFU1RfUFJPVE9DT0xfVkVSU0lPTixcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLl9jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEluZm86IHRoaXMuX2NsaWVudEluZm9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0eXBlc19qc18xLkluaXRpYWxpemVSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgc2VudCBpbnZhbGlkIGluaXRpYWxpemUgcmVzdWx0OiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHlwZXNfanNfMS5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMuaW5jbHVkZXMocmVzdWx0LnByb3RvY29sVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlcidzIHByb3RvY29sIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZDogJHtyZXN1bHQucHJvdG9jb2xWZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzID0gcmVzdWx0LmNhcGFiaWxpdGllcztcbiAgICAgICAgICAgIHRoaXMuX3NlcnZlclZlcnNpb24gPSByZXN1bHQuc2VydmVySW5mbztcbiAgICAgICAgICAgIC8vIEhUVFAgdHJhbnNwb3J0cyBtdXN0IHNldCB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiBlYWNoIGhlYWRlciBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2V0UHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNldFByb3RvY29sVmVyc2lvbihyZXN1bHQucHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IHJlc3VsdC5pbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnbm90aWZpY2F0aW9ucy9pbml0aWFsaXplZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBpZiBpbml0aWFsaXphdGlvbiBmYWlscy5cbiAgICAgICAgICAgIHZvaWQgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZCwgdGhpcyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHRoZSBzZXJ2ZXIncyByZXBvcnRlZCBjYXBhYmlsaXRpZXMuXG4gICAgICovXG4gICAgZ2V0U2VydmVyQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZnRlciBpbml0aWFsaXphdGlvbiBoYXMgY29tcGxldGVkLCB0aGlzIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlcnZlcidzIG5hbWUgYW5kIHZlcnNpb24uXG4gICAgICovXG4gICAgZ2V0U2VydmVyVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlclZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFmdGVyIGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWQsIHRoaXMgbWF5IGJlIHBvcHVsYXRlZCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZXJ2ZXIncyBpbnN0cnVjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBhc3NlcnRDYXBhYmlsaXR5Rm9yTWV0aG9kKG1ldGhvZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnbG9nZ2luZy9zZXRMZXZlbCc6XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9nZ2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBsb2dnaW5nIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Byb21wdHMvZ2V0JzpcbiAgICAgICAgICAgIGNhc2UgJ3Byb21wdHMvbGlzdCc6XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9iID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHJvbXB0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBwcm9tcHRzIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc291cmNlcy9saXN0JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jlc291cmNlcy90ZW1wbGF0ZXMvbGlzdCc6XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZXMvcmVhZCc6XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZXMvc3Vic2NyaWJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Jlc291cmNlcy91bnN1YnNjcmliZSc6XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9jID0gdGhpcy5fc2VydmVyQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzb3VyY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHJlc291cmNlcyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3Jlc291cmNlcy9zdWJzY3JpYmUnICYmICF0aGlzLl9zZXJ2ZXJDYXBhYmlsaXRpZXMucmVzb3VyY2VzLnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHJlc291cmNlIHN1YnNjcmlwdGlvbnMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9vbHMvY2FsbCc6XG4gICAgICAgICAgICBjYXNlICd0b29scy9saXN0JzpcbiAgICAgICAgICAgICAgICBpZiAoISgoX2QgPSB0aGlzLl9zZXJ2ZXJDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b29scykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0b29scyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21wbGV0aW9uL2NvbXBsZXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoISgoX2UgPSB0aGlzLl9zZXJ2ZXJDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jb21wbGV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV0aW9ucyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsaXplJzpcbiAgICAgICAgICAgICAgICAvLyBObyBzcGVjaWZpYyBjYXBhYmlsaXR5IHJlcXVpcmVkIGZvciBpbml0aWFsaXplXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwaW5nJzpcbiAgICAgICAgICAgICAgICAvLyBObyBzcGVjaWZpYyBjYXBhYmlsaXR5IHJlcXVpcmVkIGZvciBwaW5nXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0Tm90aWZpY2F0aW9uQ2FwYWJpbGl0eShtZXRob2QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnbm90aWZpY2F0aW9ucy9yb290cy9saXN0X2NoYW5nZWQnOlxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IHRoaXMuX2NhcGFiaWxpdGllcy5yb290cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpc3RDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCBkb2VzIG5vdCBzdXBwb3J0IHJvb3RzIGxpc3QgY2hhbmdlZCBub3RpZmljYXRpb25zIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgICAgIC8vIE5vIHNwZWNpZmljIGNhcGFiaWxpdHkgcmVxdWlyZWQgZm9yIGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub3RpZmljYXRpb25zL2NhbmNlbGxlZCc6XG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbnMgYXJlIGFsd2F5cyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub3RpZmljYXRpb25zL3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgICAvLyBQcm9ncmVzcyBub3RpZmljYXRpb25zIGFyZSBhbHdheXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydFJlcXVlc3RIYW5kbGVyQ2FwYWJpbGl0eShtZXRob2QpIHtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsaW5nL2NyZWF0ZU1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FwYWJpbGl0aWVzLnNhbXBsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IGRvZXMgbm90IHN1cHBvcnQgc2FtcGxpbmcgY2FwYWJpbGl0eSAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbGljaXRhdGlvbi9jcmVhdGUnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FwYWJpbGl0aWVzLmVsaWNpdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IGRvZXMgbm90IHN1cHBvcnQgZWxpY2l0YXRpb24gY2FwYWJpbGl0eSAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb290cy9saXN0JzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcy5yb290cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCBkb2VzIG5vdCBzdXBwb3J0IHJvb3RzIGNhcGFiaWxpdHkgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGluZyc6XG4gICAgICAgICAgICAgICAgLy8gTm8gc3BlY2lmaWMgY2FwYWJpbGl0eSByZXF1aXJlZCBmb3IgcGluZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncGluZycgfSwgdHlwZXNfanNfMS5FbXB0eVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnY29tcGxldGlvbi9jb21wbGV0ZScsIHBhcmFtcyB9LCB0eXBlc19qc18xLkNvbXBsZXRlUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TG9nZ2luZ0xldmVsKGxldmVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdsb2dnaW5nL3NldExldmVsJywgcGFyYW1zOiB7IGxldmVsIH0gfSwgdHlwZXNfanNfMS5FbXB0eVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFByb21wdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3Byb21wdHMvZ2V0JywgcGFyYW1zIH0sIHR5cGVzX2pzXzEuR2V0UHJvbXB0UmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFByb21wdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdwcm9tcHRzL2xpc3QnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5MaXN0UHJvbXB0c1Jlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RSZXNvdXJjZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdyZXNvdXJjZXMvbGlzdCcsIHBhcmFtcyB9LCB0eXBlc19qc18xLkxpc3RSZXNvdXJjZXNSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0UmVzb3VyY2VUZW1wbGF0ZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdyZXNvdXJjZXMvdGVtcGxhdGVzL2xpc3QnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5MaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkUmVzb3VyY2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdyZXNvdXJjZXMvcmVhZCcsIHBhcmFtcyB9LCB0eXBlc19qc18xLlJlYWRSZXNvdXJjZVJlc3VsdFNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZVJlc291cmNlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAncmVzb3VyY2VzL3N1YnNjcmliZScsIHBhcmFtcyB9LCB0eXBlc19qc18xLkVtcHR5UmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVSZXNvdXJjZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3Jlc291cmNlcy91bnN1YnNjcmliZScsIHBhcmFtcyB9LCB0eXBlc19qc18xLkVtcHR5UmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2wocGFyYW1zLCByZXN1bHRTY2hlbWEgPSB0eXBlc19qc18xLkNhbGxUb29sUmVzdWx0U2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3Rvb2xzL2NhbGwnLCBwYXJhbXMgfSwgcmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRvb2wgaGFzIGFuIG91dHB1dFNjaGVtYVxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLmdldFRvb2xPdXRwdXRWYWxpZGF0b3IocGFyYW1zLm5hbWUpO1xuICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0b29sIGhhcyBvdXRwdXRTY2hlbWEsIGl0IE1VU1QgcmV0dXJuIHN0cnVjdHVyZWRDb250ZW50ICh1bmxlc3MgaXQncyBhbiBlcnJvcilcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0cnVjdHVyZWRDb250ZW50ICYmICFyZXN1bHQuaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc19qc18xLk1jcEVycm9yKHR5cGVzX2pzXzEuRXJyb3JDb2RlLkludmFsaWRSZXF1ZXN0LCBgVG9vbCAke3BhcmFtcy5uYW1lfSBoYXMgYW4gb3V0cHV0IHNjaGVtYSBidXQgZGlkIG5vdCByZXR1cm4gc3RydWN0dXJlZCBjb250ZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHZhbGlkYXRlIHN0cnVjdHVyZWQgY29udGVudCBpZiBwcmVzZW50IChub3Qgd2hlbiB0aGVyZSdzIGFuIGVycm9yKVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdHJ1Y3R1cmVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzdHJ1Y3R1cmVkIGNvbnRlbnQgKHdoaWNoIGlzIGFscmVhZHkgYW4gb2JqZWN0KSBhZ2FpbnN0IHRoZSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvcihyZXN1bHQuc3RydWN0dXJlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc19qc18xLk1jcEVycm9yKHR5cGVzX2pzXzEuRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsIGBTdHJ1Y3R1cmVkIGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggdGhlIHRvb2wncyBvdXRwdXQgc2NoZW1hOiAke3RoaXMuX2Fqdi5lcnJvcnNUZXh0KHZhbGlkYXRvci5lcnJvcnMpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiB0eXBlc19qc18xLk1jcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgRmFpbGVkIHRvIHZhbGlkYXRlIHN0cnVjdHVyZWQgY29udGVudDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhY2hlVG9vbE91dHB1dFNjaGVtYXModG9vbHMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkVG9vbE91dHB1dFZhbGlkYXRvcnMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdG9vbCBoYXMgYW4gb3V0cHV0U2NoZW1hLCBjcmVhdGUgYW5kIGNhY2hlIHRoZSBBanYgdmFsaWRhdG9yXG4gICAgICAgICAgICBpZiAodG9vbC5vdXRwdXRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLl9hanYuY29tcGlsZSh0b29sLm91dHB1dFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFRvb2xPdXRwdXRWYWxpZGF0b3JzLnNldCh0b29sLm5hbWUsIHZhbGlkYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2NoZW1hIGNvbXBpbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUb29sT3V0cHV0VmFsaWRhdG9yKHRvb2xOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRUb29sT3V0cHV0VmFsaWRhdG9ycy5nZXQodG9vbE5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0VG9vbHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ3Rvb2xzL2xpc3QnLCBwYXJhbXMgfSwgdHlwZXNfanNfMS5MaXN0VG9vbHNSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICAvLyBDYWNoZSB0aGUgdG9vbHMgYW5kIHRoZWlyIG91dHB1dCBzY2hlbWFzIGZvciBmdXR1cmUgdmFsaWRhdGlvblxuICAgICAgICB0aGlzLmNhY2hlVG9vbE91dHB1dFNjaGVtYXMocmVzdWx0LnRvb2xzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFJvb3RzTGlzdENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmaWNhdGlvbih7IG1ldGhvZDogJ25vdGlmaWNhdGlvbnMvcm9vdHMvbGlzdF9jaGFuZ2VkJyB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsbnVsbCwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3RvY29sID0gZXhwb3J0cy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVF9NU0VDID0gdm9pZCAwO1xuZXhwb3J0cy5tZXJnZUNhcGFiaWxpdGllcyA9IG1lcmdlQ2FwYWJpbGl0aWVzO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgcmVxdWVzdCB0aW1lb3V0LCBpbiBtaWxpc2Vjb25kcy5cbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVF9NU0VDID0gNjAwMDA7XG4vKipcbiAqIEltcGxlbWVudHMgTUNQIHByb3RvY29sIGZyYW1pbmcgb24gdG9wIG9mIGEgcGx1Z2dhYmxlIHRyYW5zcG9ydCwgaW5jbHVkaW5nXG4gKiBmZWF0dXJlcyBsaWtlIHJlcXVlc3QvcmVzcG9uc2UgbGlua2luZywgbm90aWZpY2F0aW9ucywgYW5kIHByb2dyZXNzLlxuICovXG5jbGFzcyBQcm90b2NvbCB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TWVzc2FnZUlkID0gMDtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uSGFuZGxlcih0eXBlc19qc18xLkNhbmNlbGxlZE5vdGlmaWNhdGlvblNjaGVtYSwgbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMuZ2V0KG5vdGlmaWNhdGlvbi5wYXJhbXMucmVxdWVzdElkKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgfHwgY29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydChub3RpZmljYXRpb24ucGFyYW1zLnJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldE5vdGlmaWNhdGlvbkhhbmRsZXIodHlwZXNfanNfMS5Qcm9ncmVzc05vdGlmaWNhdGlvblNjaGVtYSwgbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29ucHJvZ3Jlc3Mobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UmVxdWVzdEhhbmRsZXIodHlwZXNfanNfMS5QaW5nUmVxdWVzdFNjaGVtYSwgXG4gICAgICAgIC8vIEF1dG9tYXRpYyBwb25nIGJ5IGRlZmF1bHQuXG4gICAgICAgIF9yZXF1ZXN0ID0+ICh7fSkpO1xuICAgIH1cbiAgICBfc2V0dXBUaW1lb3V0KG1lc3NhZ2VJZCwgdGltZW91dCwgbWF4VG90YWxUaW1lb3V0LCBvblRpbWVvdXQsIHJlc2V0VGltZW91dE9uUHJvZ3Jlc3MgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lb3V0SW5mby5zZXQobWVzc2FnZUlkLCB7XG4gICAgICAgICAgICB0aW1lb3V0SWQ6IHNldFRpbWVvdXQob25UaW1lb3V0LCB0aW1lb3V0KSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBtYXhUb3RhbFRpbWVvdXQsXG4gICAgICAgICAgICByZXNldFRpbWVvdXRPblByb2dyZXNzLFxuICAgICAgICAgICAgb25UaW1lb3V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVzZXRUaW1lb3V0KG1lc3NhZ2VJZCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5fdGltZW91dEluZm8uZ2V0KG1lc3NhZ2VJZCk7XG4gICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdG90YWxFbGFwc2VkID0gRGF0ZS5ub3coKSAtIGluZm8uc3RhcnRUaW1lO1xuICAgICAgICBpZiAoaW5mby5tYXhUb3RhbFRpbWVvdXQgJiYgdG90YWxFbGFwc2VkID49IGluZm8ubWF4VG90YWxUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0SW5mby5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc19qc18xLk1jcEVycm9yKHR5cGVzX2pzXzEuRXJyb3JDb2RlLlJlcXVlc3RUaW1lb3V0LCAnTWF4aW11bSB0b3RhbCB0aW1lb3V0IGV4Y2VlZGVkJywge1xuICAgICAgICAgICAgICAgIG1heFRvdGFsVGltZW91dDogaW5mby5tYXhUb3RhbFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgdG90YWxFbGFwc2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQoaW5mby50aW1lb3V0SWQpO1xuICAgICAgICBpbmZvLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoaW5mby5vblRpbWVvdXQsIGluZm8udGltZW91dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfY2xlYW51cFRpbWVvdXQobWVzc2FnZUlkKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl90aW1lb3V0SW5mby5nZXQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmZvLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0SW5mby5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0byB0aGUgZ2l2ZW4gdHJhbnNwb3J0LCBzdGFydHMgaXQsIGFuZCBzdGFydHMgbGlzdGVuaW5nIGZvciBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIFRoZSBQcm90b2NvbCBvYmplY3QgYXNzdW1lcyBvd25lcnNoaXAgb2YgdGhlIFRyYW5zcG9ydCwgcmVwbGFjaW5nIGFueSBjYWxsYmFja3MgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBzZXQsIGFuZCBleHBlY3RzIHRoYXQgaXQgaXMgdGhlIG9ubHkgdXNlciBvZiB0aGUgVHJhbnNwb3J0IGluc3RhbmNlIGdvaW5nIGZvcndhcmQuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCh0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgY29uc3QgX29uY2xvc2UgPSAoX2EgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uY2xvc2U7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgX29uY2xvc2UgPT09IG51bGwgfHwgX29uY2xvc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vbmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vbmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9vbmVycm9yID0gKF9iID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbmVycm9yO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgX29uZXJyb3IgPT09IG51bGwgfHwgX29uZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX29uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfb25tZXNzYWdlID0gKF9jID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub25tZXNzYWdlO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQub25tZXNzYWdlID0gKG1lc3NhZ2UsIGV4dHJhKSA9PiB7XG4gICAgICAgICAgICBfb25tZXNzYWdlID09PSBudWxsIHx8IF9vbm1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vbm1lc3NhZ2UobWVzc2FnZSwgZXh0cmEpO1xuICAgICAgICAgICAgaWYgKCgwLCB0eXBlc19qc18xLmlzSlNPTlJQQ1Jlc3BvbnNlKShtZXNzYWdlKSB8fCAoMCwgdHlwZXNfanNfMS5pc0pTT05SUENFcnJvcikobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbnJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHR5cGVzX2pzXzEuaXNKU09OUlBDUmVxdWVzdCkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbnJlcXVlc3QobWVzc2FnZSwgZXh0cmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHR5cGVzX2pzXzEuaXNKU09OUlBDTm90aWZpY2F0aW9uKShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29ubm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYFVua25vd24gbWVzc2FnZSB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0LnN0YXJ0KCk7XG4gICAgfVxuICAgIF9vbmNsb3NlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlcnMgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9hID0gdGhpcy5vbmNsb3NlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcih0eXBlc19qc18xLkVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkLCAnQ29ubmVjdGlvbiBjbG9zZWQnKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHJlc3BvbnNlSGFuZGxlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbmVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICAgIF9vbm5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gKF9hID0gdGhpcy5fbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG5vdGlmaWNhdGlvbi5tZXRob2QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZhbGxiYWNrTm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgLy8gSWdub3JlIG5vdGlmaWNhdGlvbnMgbm90IGJlaW5nIHN1YnNjcmliZWQgdG8uXG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydGluZyB3aXRoIFByb21pc2UucmVzb2x2ZSgpIHB1dHMgYW55IHN5bmNocm9ub3VzIGVycm9ycyBpbnRvIHRoZSBtb25hZCBhcyB3ZWxsLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gaGFuZGxlcihub3RpZmljYXRpb24pKVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBVbmNhdWdodCBlcnJvciBpbiBub3RpZmljYXRpb24gaGFuZGxlcjogJHtlcnJvcn1gKSkpO1xuICAgIH1cbiAgICBfb25yZXF1ZXN0KHJlcXVlc3QsIGV4dHJhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoX2EgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3QubWV0aG9kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5mYWxsYmFja1JlcXVlc3RIYW5kbGVyO1xuICAgICAgICAvLyBDYXB0dXJlIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBhdCByZXF1ZXN0IHRpbWUgdG8gZW5zdXJlIHJlc3BvbnNlcyBnbyB0byB0aGUgY29ycmVjdCBjbGllbnRcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQ7XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhcHR1cmVkVHJhbnNwb3J0ID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zcG9ydC5zZW5kKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0eXBlc19qc18xLkVycm9yQ29kZS5NZXRob2ROb3RGb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ01ldGhvZCBub3QgZm91bmQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIGFuIGVycm9yIHJlc3BvbnNlOiAke2Vycm9yfWApKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMuc2V0KHJlcXVlc3QuaWQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IGZ1bGxFeHRyYSA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgIHNlc3Npb25JZDogY2FwdHVyZWRUcmFuc3BvcnQgPT09IG51bGwgfHwgY2FwdHVyZWRUcmFuc3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNwb3J0LnNlc3Npb25JZCxcbiAgICAgICAgICAgIF9tZXRhOiAoX2IgPSByZXF1ZXN0LnBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9tZXRhLFxuICAgICAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uID0+IHRoaXMubm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbiwgeyByZWxhdGVkUmVxdWVzdElkOiByZXF1ZXN0LmlkIH0pLFxuICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IChyLCByZXN1bHRTY2hlbWEsIG9wdGlvbnMpID0+IHRoaXMucmVxdWVzdChyLCByZXN1bHRTY2hlbWEsIHsgLi4ub3B0aW9ucywgcmVsYXRlZFJlcXVlc3RJZDogcmVxdWVzdC5pZCB9KSxcbiAgICAgICAgICAgIGF1dGhJbmZvOiBleHRyYSA9PT0gbnVsbCB8fCBleHRyYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0cmEuYXV0aEluZm8sXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICByZXF1ZXN0SW5mbzogZXh0cmEgPT09IG51bGwgfHwgZXh0cmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dHJhLnJlcXVlc3RJbmZvXG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggUHJvbWlzZS5yZXNvbHZlKCkgcHV0cyBhbnkgc3luY2hyb25vdXMgZXJyb3JzIGludG8gdGhlIG1vbmFkIGFzIHdlbGwuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBoYW5kbGVyKHJlcXVlc3QsIGZ1bGxFeHRyYSkpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwdHVyZWRUcmFuc3BvcnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0LmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwdHVyZWRUcmFuc3BvcnQuc2VuZCh7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogTnVtYmVyLmlzU2FmZUludGVnZXIoZXJyb3JbJ2NvZGUnXSkgPyBlcnJvclsnY29kZSddIDogdHlwZXNfanNfMS5FcnJvckNvZGUuSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9hID0gZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0ludGVybmFsIGVycm9yJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gc2VuZCByZXNwb25zZTogJHtlcnJvcn1gKSkpXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMuZGVsZXRlKHJlcXVlc3QuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29ucHJvZ3Jlc3Mobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3NUb2tlbiwgLi4ucGFyYW1zIH0gPSBub3RpZmljYXRpb24ucGFyYW1zO1xuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSBOdW1iZXIocHJvZ3Jlc3NUb2tlbik7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBSZWNlaXZlZCBhIHByb2dyZXNzIG5vdGlmaWNhdGlvbiBmb3IgYW4gdW5rbm93biB0b2tlbjogJHtKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb24pfWApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgICAgICBjb25zdCB0aW1lb3V0SW5mbyA9IHRoaXMuX3RpbWVvdXRJbmZvLmdldChtZXNzYWdlSWQpO1xuICAgICAgICBpZiAodGltZW91dEluZm8gJiYgcmVzcG9uc2VIYW5kbGVyICYmIHRpbWVvdXRJbmZvLnJlc2V0VGltZW91dE9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRUaW1lb3V0KG1lc3NhZ2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyKHBhcmFtcyk7XG4gICAgfVxuICAgIF9vbnJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IE51bWJlcihyZXNwb25zZS5pZCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgUmVjZWl2ZWQgYSByZXNwb25zZSBmb3IgYW4gdW5rbm93biBtZXNzYWdlIElEOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cFRpbWVvdXQobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKCgwLCB0eXBlc19qc18xLmlzSlNPTlJQQ1Jlc3BvbnNlKShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgdHlwZXNfanNfMS5NY3BFcnJvcihyZXNwb25zZS5lcnJvci5jb2RlLCByZXNwb25zZS5lcnJvci5tZXNzYWdlLCByZXNwb25zZS5lcnJvci5kYXRhKTtcbiAgICAgICAgICAgIGhhbmRsZXIoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0cmFuc3BvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCAoKF9hID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVxdWVzdCBhbmQgd2FpdCBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gZW1pdCBub3RpZmljYXRpb25zISBVc2Ugbm90aWZpY2F0aW9uKCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICByZXF1ZXN0KHJlcXVlc3QsIHJlc3VsdFNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRSZXF1ZXN0SWQsIHJlc3VtcHRpb25Ub2tlbiwgb25yZXN1bXB0aW9udG9rZW4gfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5mb3JjZVN0cmljdENhcGFiaWxpdGllcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydENhcGFiaWxpdHlGb3JNZXRob2QocmVxdWVzdC5tZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLl9yZXF1ZXN0TWVzc2FnZUlkKys7XG4gICAgICAgICAgICBjb25zdCBqc29ucnBjUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9ucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLnNldChtZXNzYWdlSWQsIG9wdGlvbnMub25wcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAganNvbnJwY1JlcXVlc3QucGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgX21ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLigoKF9jID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5fbWV0YSkgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NUb2tlbjogbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cFRpbWVvdXQobWVzc2FnZUlkKTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl90cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ25vdGlmaWNhdGlvbnMvY2FuY2VsbGVkJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogU3RyaW5nKHJlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHsgcmVsYXRlZFJlcXVlc3RJZCwgcmVzdW1wdGlvblRva2VuLCBvbnJlc3VtcHRpb250b2tlbiB9KS5jYXRjaChlcnJvciA9PiB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIHNlbmQgY2FuY2VsbGF0aW9uOiAke2Vycm9yfWApKSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zZXQobWVzc2FnZUlkLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRTY2hlbWEucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY2FuY2VsKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGV4cG9ydHMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVRfTVNFQztcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGVyID0gKCkgPT4gY2FuY2VsKG5ldyB0eXBlc19qc18xLk1jcEVycm9yKHR5cGVzX2pzXzEuRXJyb3JDb2RlLlJlcXVlc3RUaW1lb3V0LCAnUmVxdWVzdCB0aW1lZCBvdXQnLCB7IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBUaW1lb3V0KG1lc3NhZ2VJZCwgdGltZW91dCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heFRvdGFsVGltZW91dCwgdGltZW91dEhhbmRsZXIsIChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXNldFRpbWVvdXRPblByb2dyZXNzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQuc2VuZChqc29ucnBjUmVxdWVzdCwgeyByZWxhdGVkUmVxdWVzdElkLCByZXN1bXB0aW9uVG9rZW4sIG9ucmVzdW1wdGlvbnRva2VuIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwVGltZW91dChtZXNzYWdlSWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgbm90aWZpY2F0aW9uLCB3aGljaCBpcyBhIG9uZS13YXkgbWVzc2FnZSB0aGF0IGRvZXMgbm90IGV4cGVjdCBhIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90aWZpY2F0aW9uQ2FwYWJpbGl0eShub3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICAgICAgY29uc3QgZGVib3VuY2VkTWV0aG9kcyA9IChfYiA9IChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWJvdW5jZWROb3RpZmljYXRpb25NZXRob2RzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgLy8gQSBub3RpZmljYXRpb24gY2FuIG9ubHkgYmUgZGVib3VuY2VkIGlmIGl0J3MgaW4gdGhlIGxpc3QgQU5EIGl0J3MgXCJzaW1wbGVcIlxuICAgICAgICAvLyAoaS5lLiwgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIG5vIHJlbGF0ZWQgcmVxdWVzdCBJRCB0aGF0IGNvdWxkIGJlIGxvc3QpLlxuICAgICAgICBjb25zdCBjYW5EZWJvdW5jZSA9IGRlYm91bmNlZE1ldGhvZHMuaW5jbHVkZXMobm90aWZpY2F0aW9uLm1ldGhvZCkgJiYgIW5vdGlmaWNhdGlvbi5wYXJhbXMgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVsYXRlZFJlcXVlc3RJZCk7XG4gICAgICAgIGlmIChjYW5EZWJvdW5jZSkge1xuICAgICAgICAgICAgLy8gSWYgYSBub3RpZmljYXRpb24gb2YgdGhpcyB0eXBlIGlzIGFscmVhZHkgc2NoZWR1bGVkLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zLmhhcyhub3RpZmljYXRpb24ubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgdGhpcyBub3RpZmljYXRpb24gdHlwZSBhcyBwZW5kaW5nLlxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMuYWRkKG5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBzZW5kIHRvIGhhcHBlbiBpbiB0aGUgbmV4dCBtaWNyb3Rhc2suXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhbGwgc3luY2hyb25vdXMgY2FsbHMgaW4gdGhlIGN1cnJlbnQgZXZlbnQgbG9vcCB0aWNrIHRvIGJlIGNvYWxlc2NlZC5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBVbi1tYXJrIHRoZSBub3RpZmljYXRpb24gc28gdGhlIG5leHQgb25lIGNhbiBiZSBzY2hlZHVsZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMuZGVsZXRlKG5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWSBDSEVDSzogSWYgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCB3aGlsZSB0aGlzIHdhcyBwZW5kaW5nLCBhYm9ydC5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ycGNOb3RpZmljYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIG5vdGlmaWNhdGlvbiwgYnV0IGRvbid0IGF3YWl0IGl0IGhlcmUgdG8gYXZvaWQgYmxvY2tpbmcuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHBvdGVudGlhbCBlcnJvcnMgd2l0aCBhIC5jYXRjaCgpLlxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX3RyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQoanNvbnJwY05vdGlmaWNhdGlvbiwgb3B0aW9ucykuY2F0Y2goZXJyb3IgPT4gdGhpcy5fb25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbnJwY05vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5zZW5kKGpzb25ycGNOb3RpZmljYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRvIGludm9rZSB3aGVuIHRoaXMgcHJvdG9jb2wgb2JqZWN0IHJlY2VpdmVzIGEgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJlcGxhY2UgYW55IHByZXZpb3VzIHJlcXVlc3QgaGFuZGxlciBmb3IgdGhlIHNhbWUgbWV0aG9kLlxuICAgICAqL1xuICAgIHNldFJlcXVlc3RIYW5kbGVyKHJlcXVlc3RTY2hlbWEsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdFNjaGVtYS5zaGFwZS5tZXRob2QudmFsdWU7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVxdWVzdEhhbmRsZXJDYXBhYmlsaXR5KG1ldGhvZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVycy5zZXQobWV0aG9kLCAocmVxdWVzdCwgZXh0cmEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlcihyZXF1ZXN0U2NoZW1hLnBhcnNlKHJlcXVlc3QpLCBleHRyYSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcmVxdWVzdCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbWV0aG9kLlxuICAgICAqL1xuICAgIHJlbW92ZVJlcXVlc3RIYW5kbGVyKG1ldGhvZCkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VydHMgdGhhdCBhIHJlcXVlc3QgaGFuZGxlciBoYXMgbm90IGFscmVhZHkgYmVlbiBzZXQgZm9yIHRoZSBnaXZlbiBtZXRob2QsIGluIHByZXBhcmF0aW9uIGZvciBhIG5ldyBvbmUgYmVpbmcgYXV0b21hdGljYWxseSBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgYXNzZXJ0Q2FuU2V0UmVxdWVzdEhhbmRsZXIobWV0aG9kKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SGFuZGxlcnMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSByZXF1ZXN0IGhhbmRsZXIgZm9yICR7bWV0aG9kfSBhbHJlYWR5IGV4aXN0cywgd2hpY2ggd291bGQgYmUgb3ZlcnJpZGRlbmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgdG8gaW52b2tlIHdoZW4gdGhpcyBwcm90b2NvbCBvYmplY3QgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXBsYWNlIGFueSBwcmV2aW91cyBub3RpZmljYXRpb24gaGFuZGxlciBmb3IgdGhlIHNhbWUgbWV0aG9kLlxuICAgICAqL1xuICAgIHNldE5vdGlmaWNhdGlvbkhhbmRsZXIobm90aWZpY2F0aW9uU2NoZW1hLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbkhhbmRsZXJzLnNldChub3RpZmljYXRpb25TY2hlbWEuc2hhcGUubWV0aG9kLnZhbHVlLCBub3RpZmljYXRpb24gPT4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIobm90aWZpY2F0aW9uU2NoZW1hLnBhcnNlKG5vdGlmaWNhdGlvbikpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG5vdGlmaWNhdGlvbiBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbWV0aG9kLlxuICAgICAqL1xuICAgIHJlbW92ZU5vdGlmaWNhdGlvbkhhbmRsZXIobWV0aG9kKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbkhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2wgPSBQcm90b2NvbDtcbmZ1bmN0aW9uIG1lcmdlQ2FwYWJpbGl0aWVzKGJhc2UsIGFkZGl0aW9uYWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWRkaXRpb25hbCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBhY2Nba2V5XSA/IHsgLi4uYWNjW2tleV0sIC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7IC4uLmJhc2UgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm90b2NvbC5qcy5tYXAiLG51bGwsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvdXJjZUxpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5SZWFkUmVzb3VyY2VSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlYWRSZXNvdXJjZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkxpc3RSZXNvdXJjZVRlbXBsYXRlc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFJlc291cmNlVGVtcGxhdGVzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFJlc291cmNlc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFJlc291cmNlc1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlVGVtcGxhdGVTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlU2NoZW1hID0gZXhwb3J0cy5CbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IGV4cG9ydHMuVGV4dFJlc291cmNlQ29udGVudHNTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlQ29udGVudHNTY2hlbWEgPSBleHBvcnRzLlBhZ2luYXRlZFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUHJvZ3Jlc3NOb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLlByb2dyZXNzU2NoZW1hID0gZXhwb3J0cy5QaW5nUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuaXNJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLkluaXRpYWxpemVSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSA9IGV4cG9ydHMuaXNJbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkNsaWVudENhcGFiaWxpdGllc1NjaGVtYSA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25TY2hlbWEgPSBleHBvcnRzLkJhc2VNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuSWNvbnNTY2hlbWEgPSBleHBvcnRzLkljb25TY2hlbWEgPSBleHBvcnRzLkNhbmNlbGxlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuRW1wdHlSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkpTT05SUENNZXNzYWdlU2NoZW1hID0gZXhwb3J0cy5pc0pTT05SUENFcnJvciA9IGV4cG9ydHMuSlNPTlJQQ0Vycm9yU2NoZW1hID0gZXhwb3J0cy5FcnJvckNvZGUgPSBleHBvcnRzLmlzSlNPTlJQQ1Jlc3BvbnNlID0gZXhwb3J0cy5KU09OUlBDUmVzcG9uc2VTY2hlbWEgPSBleHBvcnRzLmlzSlNPTlJQQ05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuaXNKU09OUlBDUmVxdWVzdCA9IGV4cG9ydHMuSlNPTlJQQ1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RJZFNjaGVtYSA9IGV4cG9ydHMuUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkN1cnNvclNjaGVtYSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlblNjaGVtYSA9IGV4cG9ydHMuSlNPTlJQQ19WRVJTSU9OID0gZXhwb3J0cy5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBleHBvcnRzLkRFRkFVTFRfTkVHT1RJQVRFRF9QUk9UT0NPTF9WRVJTSU9OID0gZXhwb3J0cy5MQVRFU1RfUFJPVE9DT0xfVkVSU0lPTiA9IHZvaWQgMDtcbmV4cG9ydHMuQ2xpZW50UmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUm9vdHNMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuTGlzdFJvb3RzUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5MaXN0Um9vdHNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5Sb290U2NoZW1hID0gZXhwb3J0cy5Db21wbGV0ZVJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuQ29tcGxldGVSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5Qcm9tcHRSZWZlcmVuY2VTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlUmVmZXJlbmNlU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlUmVmZXJlbmNlU2NoZW1hID0gZXhwb3J0cy5FbGljaXRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkVsaWNpdFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlByaW1pdGl2ZVNjaGVtYURlZmluaXRpb25TY2hlbWEgPSBleHBvcnRzLkVudW1TY2hlbWFTY2hlbWEgPSBleHBvcnRzLk51bWJlclNjaGVtYVNjaGVtYSA9IGV4cG9ydHMuU3RyaW5nU2NoZW1hU2NoZW1hID0gZXhwb3J0cy5Cb29sZWFuU2NoZW1hU2NoZW1hID0gZXhwb3J0cy5DcmVhdGVNZXNzYWdlUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5DcmVhdGVNZXNzYWdlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuU2FtcGxpbmdNZXNzYWdlU2NoZW1hID0gZXhwb3J0cy5Nb2RlbFByZWZlcmVuY2VzU2NoZW1hID0gZXhwb3J0cy5Nb2RlbEhpbnRTY2hlbWEgPSBleHBvcnRzLkxvZ2dpbmdNZXNzYWdlTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5TZXRMZXZlbFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkxvZ2dpbmdMZXZlbFNjaGVtYSA9IGV4cG9ydHMuVG9vbExpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5DYWxsVG9vbFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLkNvbXBhdGliaWxpdHlDYWxsVG9vbFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuQ2FsbFRvb2xSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkxpc3RUb29sc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuVG9vbFNjaGVtYSA9IGV4cG9ydHMuVG9vbEFubm90YXRpb25zU2NoZW1hID0gZXhwb3J0cy5Qcm9tcHRMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuR2V0UHJvbXB0UmVzdWx0U2NoZW1hID0gZXhwb3J0cy5Qcm9tcHRNZXNzYWdlU2NoZW1hID0gZXhwb3J0cy5Db250ZW50QmxvY2tTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlTGlua1NjaGVtYSA9IGV4cG9ydHMuRW1iZWRkZWRSZXNvdXJjZVNjaGVtYSA9IGV4cG9ydHMuQXVkaW9Db250ZW50U2NoZW1hID0gZXhwb3J0cy5JbWFnZUNvbnRlbnRTY2hlbWEgPSBleHBvcnRzLlRleHRDb250ZW50U2NoZW1hID0gZXhwb3J0cy5HZXRQcm9tcHRSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5MaXN0UHJvbXB0c1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5Qcm9tcHRTY2hlbWEgPSBleHBvcnRzLlByb21wdEFyZ3VtZW50U2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVVwZGF0ZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLlVuc3Vic2NyaWJlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuU3Vic2NyaWJlUmVxdWVzdFNjaGVtYSA9IHZvaWQgMDtcbmV4cG9ydHMuTWNwRXJyb3IgPSBleHBvcnRzLlNlcnZlclJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuU2VydmVyTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5TZXJ2ZXJSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5DbGllbnRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLkNsaWVudE5vdGlmaWNhdGlvblNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmV4cG9ydHMuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSAnMjAyNS0wNi0xOCc7XG5leHBvcnRzLkRFRkFVTFRfTkVHT1RJQVRFRF9QUk9UT0NPTF9WRVJTSU9OID0gJzIwMjUtMDMtMjYnO1xuZXhwb3J0cy5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBbZXhwb3J0cy5MQVRFU1RfUFJPVE9DT0xfVkVSU0lPTiwgJzIwMjUtMDMtMjYnLCAnMjAyNC0xMS0wNScsICcyMDI0LTEwLTA3J107XG4vKiBKU09OLVJQQyB0eXBlcyAqL1xuZXhwb3J0cy5KU09OUlBDX1ZFUlNJT04gPSAnMi4wJztcbi8qKlxuICogQSBwcm9ncmVzcyB0b2tlbiwgdXNlZCB0byBhc3NvY2lhdGUgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyB3aXRoIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICovXG5leHBvcnRzLlByb2dyZXNzVG9rZW5TY2hlbWEgPSB6b2RfMS56LnVuaW9uKFt6b2RfMS56LnN0cmluZygpLCB6b2RfMS56Lm51bWJlcigpLmludCgpXSk7XG4vKipcbiAqIEFuIG9wYXF1ZSB0b2tlbiB1c2VkIHRvIHJlcHJlc2VudCBhIGN1cnNvciBmb3IgcGFnaW5hdGlvbi5cbiAqL1xuZXhwb3J0cy5DdXJzb3JTY2hlbWEgPSB6b2RfMS56LnN0cmluZygpO1xuY29uc3QgUmVxdWVzdE1ldGFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogSWYgc3BlY2lmaWVkLCB0aGUgY2FsbGVyIGlzIHJlcXVlc3Rpbmcgb3V0LW9mLWJhbmQgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmb3IgdGhpcyByZXF1ZXN0IChhcyByZXByZXNlbnRlZCBieSBub3RpZmljYXRpb25zL3Byb2dyZXNzKS4gVGhlIHZhbHVlIG9mIHRoaXMgcGFyYW1ldGVyIGlzIGFuIG9wYXF1ZSB0b2tlbiB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gYW55IHN1YnNlcXVlbnQgbm90aWZpY2F0aW9ucy4gVGhlIHJlY2VpdmVyIGlzIG5vdCBvYmxpZ2F0ZWQgdG8gcHJvdmlkZSB0aGVzZSBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIHByb2dyZXNzVG9rZW46IHpvZF8xLnoub3B0aW9uYWwoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuU2NoZW1hKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbmNvbnN0IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKFJlcXVlc3RNZXRhU2NoZW1hKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbmV4cG9ydHMuUmVxdWVzdFNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBtZXRob2Q6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgcGFyYW1zOiB6b2RfMS56Lm9wdGlvbmFsKEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hKVxufSk7XG5jb25zdCBCYXNlTm90aWZpY2F0aW9uUGFyYW1zU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHBhcmFtczogem9kXzEuei5vcHRpb25hbChCYXNlTm90aWZpY2F0aW9uUGFyYW1zU2NoZW1hKVxufSk7XG5leHBvcnRzLlJlc3VsdFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQSB1bmlxdWVseSBpZGVudGlmeWluZyBJRCBmb3IgYSByZXF1ZXN0IGluIEpTT04tUlBDLlxuICovXG5leHBvcnRzLlJlcXVlc3RJZFNjaGVtYSA9IHpvZF8xLnoudW5pb24oW3pvZF8xLnouc3RyaW5nKCksIHpvZF8xLnoubnVtYmVyKCkuaW50KCldKTtcbi8qKlxuICogQSByZXF1ZXN0IHRoYXQgZXhwZWN0cyBhIHJlc3BvbnNlLlxuICovXG5leHBvcnRzLkpTT05SUENSZXF1ZXN0U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGpzb25ycGM6IHpvZF8xLnoubGl0ZXJhbChleHBvcnRzLkpTT05SUENfVkVSU0lPTiksXG4gICAgaWQ6IGV4cG9ydHMuUmVxdWVzdElkU2NoZW1hXG59KVxuICAgIC5tZXJnZShleHBvcnRzLlJlcXVlc3RTY2hlbWEpXG4gICAgLnN0cmljdCgpO1xuY29uc3QgaXNKU09OUlBDUmVxdWVzdCA9ICh2YWx1ZSkgPT4gZXhwb3J0cy5KU09OUlBDUmVxdWVzdFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpLnN1Y2Nlc3M7XG5leHBvcnRzLmlzSlNPTlJQQ1JlcXVlc3QgPSBpc0pTT05SUENSZXF1ZXN0O1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiB3aGljaCBkb2VzIG5vdCBleHBlY3QgYSByZXNwb25zZS5cbiAqL1xuZXhwb3J0cy5KU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGpzb25ycGM6IHpvZF8xLnoubGl0ZXJhbChleHBvcnRzLkpTT05SUENfVkVSU0lPTilcbn0pXG4gICAgLm1lcmdlKGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hKVxuICAgIC5zdHJpY3QoKTtcbmNvbnN0IGlzSlNPTlJQQ05vdGlmaWNhdGlvbiA9ICh2YWx1ZSkgPT4gZXhwb3J0cy5KU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbmV4cG9ydHMuaXNKU09OUlBDTm90aWZpY2F0aW9uID0gaXNKU09OUlBDTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBBIHN1Y2Nlc3NmdWwgKG5vbi1lcnJvcikgcmVzcG9uc2UgdG8gYSByZXF1ZXN0LlxuICovXG5leHBvcnRzLkpTT05SUENSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBqc29ucnBjOiB6b2RfMS56LmxpdGVyYWwoZXhwb3J0cy5KU09OUlBDX1ZFUlNJT04pLFxuICAgIGlkOiBleHBvcnRzLlJlcXVlc3RJZFNjaGVtYSxcbiAgICByZXN1bHQ6IGV4cG9ydHMuUmVzdWx0U2NoZW1hXG59KVxuICAgIC5zdHJpY3QoKTtcbmNvbnN0IGlzSlNPTlJQQ1Jlc3BvbnNlID0gKHZhbHVlKSA9PiBleHBvcnRzLkpTT05SUENSZXNwb25zZVNjaGVtYS5zYWZlUGFyc2UodmFsdWUpLnN1Y2Nlc3M7XG5leHBvcnRzLmlzSlNPTlJQQ1Jlc3BvbnNlID0gaXNKU09OUlBDUmVzcG9uc2U7XG4vKipcbiAqIEVycm9yIGNvZGVzIGRlZmluZWQgYnkgdGhlIEpTT04tUlBDIHNwZWNpZmljYXRpb24uXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vIFNESyBlcnJvciBjb2Rlc1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb25uZWN0aW9uQ2xvc2VkXCJdID0gLTMyMDAwXSA9IFwiQ29ubmVjdGlvbkNsb3NlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJSZXF1ZXN0VGltZW91dFwiXSA9IC0zMjAwMV0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gICAgLy8gU3RhbmRhcmQgSlNPTi1SUEMgZXJyb3IgY29kZXNcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUGFyc2VFcnJvclwiXSA9IC0zMjcwMF0gPSBcIlBhcnNlRXJyb3JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZFJlcXVlc3RcIl0gPSAtMzI2MDBdID0gXCJJbnZhbGlkUmVxdWVzdFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJNZXRob2ROb3RGb3VuZFwiXSA9IC0zMjYwMV0gPSBcIk1ldGhvZE5vdEZvdW5kXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRQYXJhbXNcIl0gPSAtMzI2MDJdID0gXCJJbnZhbGlkUGFyYW1zXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSAtMzI2MDNdID0gXCJJbnRlcm5hbEVycm9yXCI7XG59KShFcnJvckNvZGUgfHwgKGV4cG9ydHMuRXJyb3JDb2RlID0gRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogQSByZXNwb25zZSB0byBhIHJlcXVlc3QgdGhhdCBpbmRpY2F0ZXMgYW4gZXJyb3Igb2NjdXJyZWQuXG4gKi9cbmV4cG9ydHMuSlNPTlJQQ0Vycm9yU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGpzb25ycGM6IHpvZF8xLnoubGl0ZXJhbChleHBvcnRzLkpTT05SUENfVkVSU0lPTiksXG4gICAgaWQ6IGV4cG9ydHMuUmVxdWVzdElkU2NoZW1hLFxuICAgIGVycm9yOiB6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXJyb3IgdHlwZSB0aGF0IG9jY3VycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29kZTogem9kXzEuei5udW1iZXIoKS5pbnQoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yLiBUaGUgbWVzc2FnZSBTSE9VTEQgYmUgbGltaXRlZCB0byBhIGNvbmNpc2Ugc2luZ2xlIHNlbnRlbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgbWVzc2FnZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLiBUaGUgdmFsdWUgb2YgdGhpcyBtZW1iZXIgaXMgZGVmaW5lZCBieSB0aGUgc2VuZGVyIChlLmcuIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uLCBuZXN0ZWQgZXJyb3JzIGV0Yy4pLlxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnVua25vd24oKSlcbiAgICB9KVxufSlcbiAgICAuc3RyaWN0KCk7XG5jb25zdCBpc0pTT05SUENFcnJvciA9ICh2YWx1ZSkgPT4gZXhwb3J0cy5KU09OUlBDRXJyb3JTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xuZXhwb3J0cy5pc0pTT05SUENFcnJvciA9IGlzSlNPTlJQQ0Vycm9yO1xuZXhwb3J0cy5KU09OUlBDTWVzc2FnZVNjaGVtYSA9IHpvZF8xLnoudW5pb24oW2V4cG9ydHMuSlNPTlJQQ1JlcXVlc3RTY2hlbWEsIGV4cG9ydHMuSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSwgZXhwb3J0cy5KU09OUlBDUmVzcG9uc2VTY2hlbWEsIGV4cG9ydHMuSlNPTlJQQ0Vycm9yU2NoZW1hXSk7XG4vKiBFbXB0eSByZXN1bHQgKi9cbi8qKlxuICogQSByZXNwb25zZSB0aGF0IGluZGljYXRlcyBzdWNjZXNzIGJ1dCBjYXJyaWVzIG5vIGRhdGEuXG4gKi9cbmV4cG9ydHMuRW1wdHlSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5zdHJpY3QoKTtcbi8qIENhbmNlbGxhdGlvbiAqL1xuLyoqXG4gKiBUaGlzIG5vdGlmaWNhdGlvbiBjYW4gYmUgc2VudCBieSBlaXRoZXIgc2lkZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGlzIGNhbmNlbGxpbmcgYSBwcmV2aW91c2x5LWlzc3VlZCByZXF1ZXN0LlxuICpcbiAqIFRoZSByZXF1ZXN0IFNIT1VMRCBzdGlsbCBiZSBpbi1mbGlnaHQsIGJ1dCBkdWUgdG8gY29tbXVuaWNhdGlvbiBsYXRlbmN5LCBpdCBpcyBhbHdheXMgcG9zc2libGUgdGhhdCB0aGlzIG5vdGlmaWNhdGlvbiBNQVkgYXJyaXZlIGFmdGVyIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkLlxuICpcbiAqIFRoaXMgbm90aWZpY2F0aW9uIGluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgd2lsbCBiZSB1bnVzZWQsIHNvIGFueSBhc3NvY2lhdGVkIHByb2Nlc3NpbmcgU0hPVUxEIGNlYXNlLlxuICpcbiAqIEEgY2xpZW50IE1VU1QgTk9UIGF0dGVtcHQgdG8gY2FuY2VsIGl0cyBgaW5pdGlhbGl6ZWAgcmVxdWVzdC5cbiAqL1xuZXhwb3J0cy5DYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL2NhbmNlbGxlZCcpLFxuICAgIHBhcmFtczogQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSByZXF1ZXN0IHRvIGNhbmNlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBNVVNUIGNvcnJlc3BvbmQgdG8gdGhlIElEIG9mIGEgcmVxdWVzdCBwcmV2aW91c2x5IGlzc3VlZCBpbiB0aGUgc2FtZSBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0SWQ6IGV4cG9ydHMuUmVxdWVzdElkU2NoZW1hLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHJlYXNvbiBmb3IgdGhlIGNhbmNlbGxhdGlvbi4gVGhpcyBNQVkgYmUgbG9nZ2VkIG9yIHByZXNlbnRlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHJlYXNvbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgfSlcbn0pO1xuLyogQmFzZSBNZXRhZGF0YSAqL1xuLyoqXG4gKiBJY29uIHNjaGVtYSBmb3IgdXNlIGluIHRvb2xzLCBwcm9tcHRzLCByZXNvdXJjZXMsIGFuZCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmV4cG9ydHMuSWNvblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBVUkwgb3IgZGF0YSBVUkkgZm9yIHRoZSBpY29uLlxuICAgICAqL1xuICAgIHNyYzogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBNSU1FIHR5cGUgZm9yIHRoZSBpY29uLlxuICAgICAqL1xuICAgIG1pbWVUeXBlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBzcGVjaWZ5IHNpemVzIGF0IHdoaWNoIHRoZSBpY29uIGNhbiBiZSB1c2VkLlxuICAgICAqIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBpbiBXeEggZm9ybWF0IChlLmcuLCBgXCI0OHg0OFwiYCwgYFwiOTZ4OTZcImApIG9yIGBcImFueVwiYCBmb3Igc2NhbGFibGUgZm9ybWF0cyBsaWtlIFNWRy5cbiAgICAgKlxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGNsaWVudCBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIGljb24gY2FuIGJlIHVzZWQgYXQgYW55IHNpemUuXG4gICAgICovXG4gICAgc2l6ZXM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEJhc2Ugc2NoZW1hIHRvIGFkZCBgaWNvbnNgIHByb3BlcnR5LlxuICpcbiAqL1xuZXhwb3J0cy5JY29uc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBzZXQgb2Ygc2l6ZWQgaWNvbnMgdGhhdCB0aGUgY2xpZW50IGNhbiBkaXNwbGF5IGluIGEgdXNlciBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIHRoYXQgc3VwcG9ydCByZW5kZXJpbmcgaWNvbnMgTVVTVCBzdXBwb3J0IGF0IGxlYXN0IHRoZSBmb2xsb3dpbmcgTUlNRSB0eXBlczpcbiAgICAgKiAtIGBpbWFnZS9wbmdgIC0gUE5HIGltYWdlcyAoc2FmZSwgdW5pdmVyc2FsIGNvbXBhdGliaWxpdHkpXG4gICAgICogLSBgaW1hZ2UvanBlZ2AgKGFuZCBgaW1hZ2UvanBnYCkgLSBKUEVHIGltYWdlcyAoc2FmZSwgdW5pdmVyc2FsIGNvbXBhdGliaWxpdHkpXG4gICAgICpcbiAgICAgKiBDbGllbnRzIHRoYXQgc3VwcG9ydCByZW5kZXJpbmcgaWNvbnMgU0hPVUxEIGFsc28gc3VwcG9ydDpcbiAgICAgKiAtIGBpbWFnZS9zdmcreG1sYCAtIFNWRyBpbWFnZXMgKHNjYWxhYmxlIGJ1dCByZXF1aXJlcyBzZWN1cml0eSBwcmVjYXV0aW9ucylcbiAgICAgKiAtIGBpbWFnZS93ZWJwYCAtIFdlYlAgaW1hZ2VzIChtb2Rlcm4sIGVmZmljaWVudCBmb3JtYXQpXG4gICAgICovXG4gICAgaWNvbnM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5JY29uU2NoZW1hKS5vcHRpb25hbCgpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBCYXNlIG1ldGFkYXRhIGludGVyZmFjZSBmb3IgY29tbW9uIHByb3BlcnRpZXMgYWNyb3NzIHJlc291cmNlcywgdG9vbHMsIHByb21wdHMsIGFuZCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmV4cG9ydHMuQmFzZU1ldGFkYXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKiBJbnRlbmRlZCBmb3IgcHJvZ3JhbW1hdGljIG9yIGxvZ2ljYWwgdXNlLCBidXQgdXNlZCBhcyBhIGRpc3BsYXkgbmFtZSBpbiBwYXN0IHNwZWNzIG9yIGZhbGxiYWNrICovXG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBJbnRlbmRlZCBmb3IgVUkgYW5kIGVuZC11c2VyIGNvbnRleHRzIOKAlCBvcHRpbWl6ZWQgdG8gYmUgaHVtYW4tcmVhZGFibGUgYW5kIGVhc2lseSB1bmRlcnN0b29kLFxuICAgICAqIGV2ZW4gYnkgdGhvc2UgdW5mYW1pbGlhciB3aXRoIGRvbWFpbi1zcGVjaWZpYyB0ZXJtaW5vbG9neS5cbiAgICAgKlxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIG5hbWUgc2hvdWxkIGJlIHVzZWQgZm9yIGRpc3BsYXkgKGV4Y2VwdCBmb3IgVG9vbCxcbiAgICAgKiB3aGVyZSBgYW5ub3RhdGlvbnMudGl0bGVgIHNob3VsZCBiZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgdXNpbmcgYG5hbWVgLFxuICAgICAqIGlmIHByZXNlbnQpLlxuICAgICAqL1xuICAgIHRpdGxlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyogSW5pdGlhbGl6YXRpb24gKi9cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBuYW1lIGFuZCB2ZXJzaW9uIG9mIGFuIE1DUCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblNjaGVtYSA9IGV4cG9ydHMuQmFzZU1ldGFkYXRhU2NoZW1hLmV4dGVuZCh7XG4gICAgdmVyc2lvbjogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBVUkwgb2YgdGhlIHdlYnNpdGUgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgd2Vic2l0ZVVybDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKVxufSkubWVyZ2UoZXhwb3J0cy5JY29uc1NjaGVtYSk7XG4vKipcbiAqIENhcGFiaWxpdGllcyBhIGNsaWVudCBtYXkgc3VwcG9ydC4gS25vd24gY2FwYWJpbGl0aWVzIGFyZSBkZWZpbmVkIGhlcmUsIGluIHRoaXMgc2NoZW1hLCBidXQgdGhpcyBpcyBub3QgYSBjbG9zZWQgc2V0OiBhbnkgY2xpZW50IGNhbiBkZWZpbmUgaXRzIG93biwgYWRkaXRpb25hbCBjYXBhYmlsaXRpZXMuXG4gKi9cbmV4cG9ydHMuQ2xpZW50Q2FwYWJpbGl0aWVzU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbCwgbm9uLXN0YW5kYXJkIGNhcGFiaWxpdGllcyB0aGF0IHRoZSBjbGllbnQgc3VwcG9ydHMuXG4gICAgICovXG4gICAgZXhwZXJpbWVudGFsOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgICAvKipcbiAgICAgKiBQcmVzZW50IGlmIHRoZSBjbGllbnQgc3VwcG9ydHMgc2FtcGxpbmcgZnJvbSBhbiBMTE0uXG4gICAgICovXG4gICAgc2FtcGxpbmc6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgaWYgdGhlIGNsaWVudCBzdXBwb3J0cyBlbGljaXRpbmcgdXNlciBpbnB1dC5cbiAgICAgKi9cbiAgICBlbGljaXRhdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgY2xpZW50IHN1cHBvcnRzIGxpc3Rpbmcgcm9vdHMuXG4gICAgICovXG4gICAgcm9vdHM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBzdXBwb3J0cyBpc3N1aW5nIG5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gdGhlIHJvb3RzIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q2hhbmdlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSlcbiAgICB9KVxuICAgICAgICAucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIFRoaXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gaXQgZmlyc3QgY29ubmVjdHMsIGFza2luZyBpdCB0byBiZWdpbiBpbml0aWFsaXphdGlvbi5cbiAqL1xuZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdpbml0aWFsaXplJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBNb2RlbCBDb250ZXh0IFByb3RvY29sIHRoYXQgdGhlIGNsaWVudCBzdXBwb3J0cy4gVGhlIGNsaWVudCBNQVkgZGVjaWRlIHRvIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgYXMgd2VsbC5cbiAgICAgICAgICovXG4gICAgICAgIHByb3RvY29sVmVyc2lvbjogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgY2FwYWJpbGl0aWVzOiBleHBvcnRzLkNsaWVudENhcGFiaWxpdGllc1NjaGVtYSxcbiAgICAgICAgY2xpZW50SW5mbzogZXhwb3J0cy5JbXBsZW1lbnRhdGlvblNjaGVtYVxuICAgIH0pXG59KTtcbmNvbnN0IGlzSW5pdGlhbGl6ZVJlcXVlc3QgPSAodmFsdWUpID0+IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3RTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xuZXhwb3J0cy5pc0luaXRpYWxpemVSZXF1ZXN0ID0gaXNJbml0aWFsaXplUmVxdWVzdDtcbi8qKlxuICogQ2FwYWJpbGl0aWVzIHRoYXQgYSBzZXJ2ZXIgbWF5IHN1cHBvcnQuIEtub3duIGNhcGFiaWxpdGllcyBhcmUgZGVmaW5lZCBoZXJlLCBpbiB0aGlzIHNjaGVtYSwgYnV0IHRoaXMgaXMgbm90IGEgY2xvc2VkIHNldDogYW55IHNlcnZlciBjYW4gZGVmaW5lIGl0cyBvd24sIGFkZGl0aW9uYWwgY2FwYWJpbGl0aWVzLlxuICovXG5leHBvcnRzLlNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwsIG5vbi1zdGFuZGFyZCBjYXBhYmlsaXRpZXMgdGhhdCB0aGUgc2VydmVyIHN1cHBvcnRzLlxuICAgICAqL1xuICAgIGV4cGVyaW1lbnRhbDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHNlbmRpbmcgbG9nIG1lc3NhZ2VzIHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgbG9nZ2luZzogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHNlbmRpbmcgY29tcGxldGlvbnMgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjb21wbGV0aW9uczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgc2VydmVyIG9mZmVycyBhbnkgcHJvbXB0IHRlbXBsYXRlcy5cbiAgICAgKi9cbiAgICBwcm9tcHRzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc2VydmVyIHN1cHBvcnRzIGlzc3Vpbmcgbm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byB0aGUgcHJvbXB0IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q2hhbmdlZDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSlcbiAgICB9KVxuICAgICAgICAucGFzc3Rocm91Z2goKSksXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBpZiB0aGUgc2VydmVyIG9mZmVycyBhbnkgcmVzb3VyY2VzIHRvIHJlYWQuXG4gICAgICovXG4gICAgcmVzb3VyY2VzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc2VydmVyIHN1cHBvcnRzIGNsaWVudHMgc3Vic2NyaWJpbmcgdG8gcmVzb3VyY2UgdXBkYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHN1YnNjcmliZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmJvb2xlYW4oKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc2VydmVyIHN1cHBvcnRzIGlzc3Vpbmcgbm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byB0aGUgcmVzb3VyY2UgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDaGFuZ2VkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxuICAgIH0pXG4gICAgICAgIC5wYXNzdGhyb3VnaCgpKSxcbiAgICAvKipcbiAgICAgKiBQcmVzZW50IGlmIHRoZSBzZXJ2ZXIgb2ZmZXJzIGFueSB0b29scyB0byBjYWxsLlxuICAgICAqL1xuICAgIHRvb2xzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc2VydmVyIHN1cHBvcnRzIGlzc3Vpbmcgbm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byB0aGUgdG9vbCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENoYW5nZWQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBZnRlciByZWNlaXZpbmcgYW4gaW5pdGlhbGl6ZSByZXF1ZXN0IGZyb20gdGhlIGNsaWVudCwgdGhlIHNlcnZlciBzZW5kcyB0aGlzIHJlc3BvbnNlLlxuICovXG5leHBvcnRzLkluaXRpYWxpemVSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBNb2RlbCBDb250ZXh0IFByb3RvY29sIHRoYXQgdGhlIHNlcnZlciB3YW50cyB0byB1c2UuIFRoaXMgbWF5IG5vdCBtYXRjaCB0aGUgdmVyc2lvbiB0aGF0IHRoZSBjbGllbnQgcmVxdWVzdGVkLiBJZiB0aGUgY2xpZW50IGNhbm5vdCBzdXBwb3J0IHRoaXMgdmVyc2lvbiwgaXQgTVVTVCBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIHByb3RvY29sVmVyc2lvbjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBjYXBhYmlsaXRpZXM6IGV4cG9ydHMuU2VydmVyQ2FwYWJpbGl0aWVzU2NoZW1hLFxuICAgIHNlcnZlckluZm86IGV4cG9ydHMuSW1wbGVtZW50YXRpb25TY2hlbWEsXG4gICAgLyoqXG4gICAgICogSW5zdHJ1Y3Rpb25zIGRlc2NyaWJpbmcgaG93IHRvIHVzZSB0aGUgc2VydmVyIGFuZCBpdHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGNsaWVudHMgdG8gaW1wcm92ZSB0aGUgTExNJ3MgdW5kZXJzdGFuZGluZyBvZiBhdmFpbGFibGUgdG9vbHMsIHJlc291cmNlcywgZXRjLiBJdCBjYW4gYmUgdGhvdWdodCBvZiBsaWtlIGEgXCJoaW50XCIgdG8gdGhlIG1vZGVsLiBGb3IgZXhhbXBsZSwgdGhpcyBpbmZvcm1hdGlvbiBNQVkgYmUgYWRkZWQgdG8gdGhlIHN5c3RlbSBwcm9tcHQuXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpXG59KTtcbi8qKlxuICogVGhpcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBhZnRlciBpbml0aWFsaXphdGlvbiBoYXMgZmluaXNoZWQuXG4gKi9cbmV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL2luaXRpYWxpemVkJylcbn0pO1xuY29uc3QgaXNJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9ICh2YWx1ZSkgPT4gZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvblNjaGVtYS5zYWZlUGFyc2UodmFsdWUpLnN1Y2Nlc3M7XG5leHBvcnRzLmlzSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBpc0luaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuLyogUGluZyAqL1xuLyoqXG4gKiBBIHBpbmcsIGlzc3VlZCBieSBlaXRoZXIgdGhlIHNlcnZlciBvciB0aGUgY2xpZW50LCB0byBjaGVjayB0aGF0IHRoZSBvdGhlciBwYXJ0eSBpcyBzdGlsbCBhbGl2ZS4gVGhlIHJlY2VpdmVyIG11c3QgcHJvbXB0bHkgcmVzcG9uZCwgb3IgZWxzZSBtYXkgYmUgZGlzY29ubmVjdGVkLlxuICovXG5leHBvcnRzLlBpbmdSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3BpbmcnKVxufSk7XG4vKiBQcm9ncmVzcyBub3RpZmljYXRpb25zICovXG5leHBvcnRzLlByb2dyZXNzU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9ncmVzcyB0aHVzIGZhci4gVGhpcyBzaG91bGQgaW5jcmVhc2UgZXZlcnkgdGltZSBwcm9ncmVzcyBpcyBtYWRlLCBldmVuIGlmIHRoZSB0b3RhbCBpcyB1bmtub3duLlxuICAgICAqL1xuICAgIHByb2dyZXNzOiB6b2RfMS56Lm51bWJlcigpLFxuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiBpdGVtcyB0byBwcm9jZXNzIChvciB0b3RhbCBwcm9ncmVzcyByZXF1aXJlZCksIGlmIGtub3duLlxuICAgICAqL1xuICAgIHRvdGFsOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkpLFxuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBbiBvdXQtb2YtYmFuZCBub3RpZmljYXRpb24gdXNlZCB0byBpbmZvcm0gdGhlIHJlY2VpdmVyIG9mIGEgcHJvZ3Jlc3MgdXBkYXRlIGZvciBhIGxvbmctcnVubmluZyByZXF1ZXN0LlxuICovXG5leHBvcnRzLlByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9wcm9ncmVzcycpLFxuICAgIHBhcmFtczogQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYS5tZXJnZShleHBvcnRzLlByb2dyZXNzU2NoZW1hKS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIHRva2VuIHdoaWNoIHdhcyBnaXZlbiBpbiB0aGUgaW5pdGlhbCByZXF1ZXN0LCB1c2VkIHRvIGFzc29jaWF0ZSB0aGlzIG5vdGlmaWNhdGlvbiB3aXRoIHRoZSByZXF1ZXN0IHRoYXQgaXMgcHJvY2VlZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzVG9rZW46IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlblNjaGVtYVxuICAgIH0pXG59KTtcbi8qIFBhZ2luYXRpb24gKi9cbmV4cG9ydHMuUGFnaW5hdGVkUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wYXF1ZSB0b2tlbiByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcGFnaW5hdGlvbiBwb3NpdGlvbi5cbiAgICAgICAgICogSWYgcHJvdmlkZWQsIHRoZSBzZXJ2ZXIgc2hvdWxkIHJldHVybiByZXN1bHRzIHN0YXJ0aW5nIGFmdGVyIHRoaXMgY3Vyc29yLlxuICAgICAgICAgKi9cbiAgICAgICAgY3Vyc29yOiB6b2RfMS56Lm9wdGlvbmFsKGV4cG9ydHMuQ3Vyc29yU2NoZW1hKVxuICAgIH0pLm9wdGlvbmFsKClcbn0pO1xuZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEFuIG9wYXF1ZSB0b2tlbiByZXByZXNlbnRpbmcgdGhlIHBhZ2luYXRpb24gcG9zaXRpb24gYWZ0ZXIgdGhlIGxhc3QgcmV0dXJuZWQgcmVzdWx0LlxuICAgICAqIElmIHByZXNlbnQsIHRoZXJlIG1heSBiZSBtb3JlIHJlc3VsdHMgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIG5leHRDdXJzb3I6IHpvZF8xLnoub3B0aW9uYWwoZXhwb3J0cy5DdXJzb3JTY2hlbWEpXG59KTtcbi8qIFJlc291cmNlcyAqL1xuLyoqXG4gKiBUaGUgY29udGVudHMgb2YgYSBzcGVjaWZpYyByZXNvdXJjZSBvciBzdWItcmVzb3VyY2UuXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBUaGUgVVJJIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAgICovXG4gICAgdXJpOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhpcyByZXNvdXJjZSwgaWYga25vd24uXG4gICAgICovXG4gICAgbWltZVR5cGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG5leHBvcnRzLlRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgb2YgdGhlIGl0ZW0uIFRoaXMgbXVzdCBvbmx5IGJlIHNldCBpZiB0aGUgaXRlbSBjYW4gYWN0dWFsbHkgYmUgcmVwcmVzZW50ZWQgYXMgdGV4dCAobm90IGJpbmFyeSBkYXRhKS5cbiAgICAgKi9cbiAgICB0ZXh0OiB6b2RfMS56LnN0cmluZygpXG59KTtcbi8qKlxuICogQSBab2Qgc2NoZW1hIGZvciB2YWxpZGF0aW5nIEJhc2U2NCBzdHJpbmdzIHRoYXQgaXMgbW9yZSBwZXJmb3JtYW50IGFuZFxuICogcm9idXN0IGZvciB2ZXJ5IGxhcmdlIGlucHV0cyB0aGFuIHRoZSBkZWZhdWx0IHJlZ2V4LWJhc2VkIGNoZWNrLiBJdCBhdm9pZHNcbiAqIHN0YWNrIG92ZXJmbG93cyBieSB1c2luZyB0aGUgbmF0aXZlIGBhdG9iYCBmdW5jdGlvbiBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuY29uc3QgQmFzZTY0U2NoZW1hID0gem9kXzEuei5zdHJpbmcoKS5yZWZpbmUodmFsID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBhdG9iIHRocm93cyBhIERPTUV4Y2VwdGlvbiBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIEJhc2U2NCBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICBhdG9iKHZhbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sIHsgbWVzc2FnZTogJ0ludmFsaWQgQmFzZTY0IHN0cmluZycgfSk7XG5leHBvcnRzLkJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBiaW5hcnkgZGF0YSBvZiB0aGUgaXRlbS5cbiAgICAgKi9cbiAgICBibG9iOiBCYXNlNjRTY2hlbWFcbn0pO1xuLyoqXG4gKiBBIGtub3duIHJlc291cmNlIHRoYXQgdGhlIHNlcnZlciBpcyBjYXBhYmxlIG9mIHJlYWRpbmcuXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VTY2hlbWEgPSBleHBvcnRzLkJhc2VNZXRhZGF0YVNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIFRoZSBVUkkgb2YgdGhpcyByZXNvdXJjZS5cbiAgICAgKi9cbiAgICB1cmk6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgcmVzb3VyY2UgcmVwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgYnkgY2xpZW50cyB0byBpbXByb3ZlIHRoZSBMTE0ncyB1bmRlcnN0YW5kaW5nIG9mIGF2YWlsYWJsZSByZXNvdXJjZXMuIEl0IGNhbiBiZSB0aG91Z2h0IG9mIGxpa2UgYSBcImhpbnRcIiB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogVGhlIE1JTUUgdHlwZSBvZiB0aGlzIHJlc291cmNlLCBpZiBrbm93bi5cbiAgICAgKi9cbiAgICBtaW1lVHlwZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkubWVyZ2UoZXhwb3J0cy5JY29uc1NjaGVtYSk7XG4vKipcbiAqIEEgdGVtcGxhdGUgZGVzY3JpcHRpb24gZm9yIHJlc291cmNlcyBhdmFpbGFibGUgb24gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlU2NoZW1hID0gZXhwb3J0cy5CYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBBIFVSSSB0ZW1wbGF0ZSAoYWNjb3JkaW5nIHRvIFJGQyA2NTcwKSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCByZXNvdXJjZSBVUklzLlxuICAgICAqL1xuICAgIHVyaVRlbXBsYXRlOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHRlbXBsYXRlIGlzIGZvci5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgYnkgY2xpZW50cyB0byBpbXByb3ZlIHRoZSBMTE0ncyB1bmRlcnN0YW5kaW5nIG9mIGF2YWlsYWJsZSByZXNvdXJjZXMuIEl0IGNhbiBiZSB0aG91Z2h0IG9mIGxpa2UgYSBcImhpbnRcIiB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogVGhlIE1JTUUgdHlwZSBmb3IgYWxsIHJlc291cmNlcyB0aGF0IG1hdGNoIHRoaXMgdGVtcGxhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW5jbHVkZWQgaWYgYWxsIHJlc291cmNlcyBtYXRjaGluZyB0aGlzIHRlbXBsYXRlIGhhdmUgdGhlIHNhbWUgdHlwZS5cbiAgICAgKi9cbiAgICBtaW1lVHlwZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkubWVyZ2UoZXhwb3J0cy5JY29uc1NjaGVtYSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHJlcXVlc3QgYSBsaXN0IG9mIHJlc291cmNlcyB0aGUgc2VydmVyIGhhcy5cbiAqL1xuZXhwb3J0cy5MaXN0UmVzb3VyY2VzUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdyZXNvdXJjZXMvbGlzdCcpXG59KTtcbi8qKlxuICogVGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvIGEgcmVzb3VyY2VzL2xpc3QgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuTGlzdFJlc291cmNlc1Jlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgcmVzb3VyY2VzOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuUmVzb3VyY2VTY2hlbWEpXG59KTtcbi8qKlxuICogU2VudCBmcm9tIHRoZSBjbGllbnQgdG8gcmVxdWVzdCBhIGxpc3Qgb2YgcmVzb3VyY2UgdGVtcGxhdGVzIHRoZSBzZXJ2ZXIgaGFzLlxuICovXG5leHBvcnRzLkxpc3RSZXNvdXJjZVRlbXBsYXRlc1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlBhZ2luYXRlZFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgncmVzb3VyY2VzL3RlbXBsYXRlcy9saXN0Jylcbn0pO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcmVzcG9uc2UgdG8gYSByZXNvdXJjZXMvdGVtcGxhdGVzL2xpc3QgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuTGlzdFJlc291cmNlVGVtcGxhdGVzUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICByZXNvdXJjZVRlbXBsYXRlczogem9kXzEuei5hcnJheShleHBvcnRzLlJlc291cmNlVGVtcGxhdGVTY2hlbWEpXG59KTtcbi8qKlxuICogU2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciwgdG8gcmVhZCBhIHNwZWNpZmljIHJlc291cmNlIFVSSS5cbiAqL1xuZXhwb3J0cy5SZWFkUmVzb3VyY2VSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Jlc291cmNlcy9yZWFkJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSSSBvZiB0aGUgcmVzb3VyY2UgdG8gcmVhZC4gVGhlIFVSSSBjYW4gdXNlIGFueSBwcm90b2NvbDsgaXQgaXMgdXAgdG8gdGhlIHNlcnZlciBob3cgdG8gaW50ZXJwcmV0IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdXJpOiB6b2RfMS56LnN0cmluZygpXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBUaGUgc2VydmVyJ3MgcmVzcG9uc2UgdG8gYSByZXNvdXJjZXMvcmVhZCByZXF1ZXN0IGZyb20gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0cy5SZWFkUmVzb3VyY2VSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIGNvbnRlbnRzOiB6b2RfMS56LmFycmF5KHpvZF8xLnoudW5pb24oW2V4cG9ydHMuVGV4dFJlc291cmNlQ29udGVudHNTY2hlbWEsIGV4cG9ydHMuQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWFdKSlcbn0pO1xuLyoqXG4gKiBBbiBvcHRpb25hbCBub3RpZmljYXRpb24gZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQsIGluZm9ybWluZyBpdCB0aGF0IHRoZSBsaXN0IG9mIHJlc291cmNlcyBpdCBjYW4gcmVhZCBmcm9tIGhhcyBjaGFuZ2VkLiBUaGlzIG1heSBiZSBpc3N1ZWQgYnkgc2VydmVycyB3aXRob3V0IGFueSBwcmV2aW91cyBzdWJzY3JpcHRpb24gZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLlJlc291cmNlTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL3Jlc291cmNlcy9saXN0X2NoYW5nZWQnKVxufSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHJlcXVlc3QgcmVzb3VyY2VzL3VwZGF0ZWQgbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBzZXJ2ZXIgd2hlbmV2ZXIgYSBwYXJ0aWN1bGFyIHJlc291cmNlIGNoYW5nZXMuXG4gKi9cbmV4cG9ydHMuU3Vic2NyaWJlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdyZXNvdXJjZXMvc3Vic2NyaWJlJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSSSBvZiB0aGUgcmVzb3VyY2UgdG8gc3Vic2NyaWJlIHRvLiBUaGUgVVJJIGNhbiB1c2UgYW55IHByb3RvY29sOyBpdCBpcyB1cCB0byB0aGUgc2VydmVyIGhvdyB0byBpbnRlcnByZXQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICB1cmk6IHpvZF8xLnouc3RyaW5nKClcbiAgICB9KVxufSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHJlc291cmNlcy91cGRhdGVkIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgc2VydmVyLiBUaGlzIHNob3VsZCBmb2xsb3cgYSBwcmV2aW91cyByZXNvdXJjZXMvc3Vic2NyaWJlIHJlcXVlc3QuXG4gKi9cbmV4cG9ydHMuVW5zdWJzY3JpYmVSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Jlc291cmNlcy91bnN1YnNjcmliZScpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkkgb2YgdGhlIHJlc291cmNlIHRvIHVuc3Vic2NyaWJlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICB1cmk6IHpvZF8xLnouc3RyaW5nKClcbiAgICB9KVxufSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LCBpbmZvcm1pbmcgaXQgdGhhdCBhIHJlc291cmNlIGhhcyBjaGFuZ2VkIGFuZCBtYXkgbmVlZCB0byBiZSByZWFkIGFnYWluLiBUaGlzIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgdGhlIGNsaWVudCBwcmV2aW91c2x5IHNlbnQgYSByZXNvdXJjZXMvc3Vic2NyaWJlIHJlcXVlc3QuXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VVcGRhdGVkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy9yZXNvdXJjZXMvdXBkYXRlZCcpLFxuICAgIHBhcmFtczogQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSSSBvZiB0aGUgcmVzb3VyY2UgdGhhdCBoYXMgYmVlbiB1cGRhdGVkLiBUaGlzIG1pZ2h0IGJlIGEgc3ViLXJlc291cmNlIG9mIHRoZSBvbmUgdGhhdCB0aGUgY2xpZW50IGFjdHVhbGx5IHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB1cmk6IHpvZF8xLnouc3RyaW5nKClcbiAgICB9KVxufSk7XG4vKiBQcm9tcHRzICovXG4vKipcbiAqIERlc2NyaWJlcyBhbiBhcmd1bWVudCB0aGF0IGEgcHJvbXB0IGNhbiBhY2NlcHQuXG4gKi9cbmV4cG9ydHMuUHJvbXB0QXJndW1lbnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgYXJndW1lbnQuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGFyZ3VtZW50IG11c3QgYmUgcHJvdmlkZWQuXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBBIHByb21wdCBvciBwcm9tcHQgdGVtcGxhdGUgdGhhdCB0aGUgc2VydmVyIG9mZmVycy5cbiAqL1xuZXhwb3J0cy5Qcm9tcHRTY2hlbWEgPSBleHBvcnRzLkJhc2VNZXRhZGF0YVNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyBwcm9tcHQgcHJvdmlkZXNcbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgYXJndW1lbnRzIHRvIHVzZSBmb3IgdGVtcGxhdGluZyB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KGV4cG9ydHMuUHJvbXB0QXJndW1lbnRTY2hlbWEpKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkubWVyZ2UoZXhwb3J0cy5JY29uc1NjaGVtYSk7XG4vKipcbiAqIFNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHJlcXVlc3QgYSBsaXN0IG9mIHByb21wdHMgYW5kIHByb21wdCB0ZW1wbGF0ZXMgdGhlIHNlcnZlciBoYXMuXG4gKi9cbmV4cG9ydHMuTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Byb21wdHMvbGlzdCcpXG59KTtcbi8qKlxuICogVGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvIGEgcHJvbXB0cy9saXN0IHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkxpc3RQcm9tcHRzUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICBwcm9tcHRzOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuUHJvbXB0U2NoZW1hKVxufSk7XG4vKipcbiAqIFVzZWQgYnkgdGhlIGNsaWVudCB0byBnZXQgYSBwcm9tcHQgcHJvdmlkZWQgYnkgdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0cy5HZXRQcm9tcHRSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Byb21wdHMvZ2V0JyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHByb21wdCBvciBwcm9tcHQgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJndW1lbnRzIHRvIHVzZSBmb3IgdGVtcGxhdGluZyB0aGUgcHJvbXB0LlxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnRzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoucmVjb3JkKHpvZF8xLnouc3RyaW5nKCkpKVxuICAgIH0pXG59KTtcbi8qKlxuICogVGV4dCBwcm92aWRlZCB0byBvciBmcm9tIGFuIExMTS5cbiAqL1xuZXhwb3J0cy5UZXh0Q29udGVudFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ3RleHQnKSxcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIHRleHQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEFuIGltYWdlIHByb3ZpZGVkIHRvIG9yIGZyb20gYW4gTExNLlxuICovXG5leHBvcnRzLkltYWdlQ29udGVudFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ2ltYWdlJyksXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2U2NC1lbmNvZGVkIGltYWdlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTogQmFzZTY0U2NoZW1hLFxuICAgIC8qKlxuICAgICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGltYWdlLiBEaWZmZXJlbnQgcHJvdmlkZXJzIG1heSBzdXBwb3J0IGRpZmZlcmVudCBpbWFnZSB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW1lVHlwZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAvKipcbiAgICAgKiBTZWUgW01DUCBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9kZWxjb250ZXh0cHJvdG9jb2wvbW9kZWxjb250ZXh0cHJvdG9jb2wvYmxvYi80NzMzOWMwM2MxNDNiYjRlYzAxYTI2ZTcyMWExYjhmZTY2NjM0ZWJlL2RvY3Mvc3BlY2lmaWNhdGlvbi9kcmFmdC9iYXNpYy9pbmRleC5tZHgjZ2VuZXJhbC1maWVsZHMpXG4gICAgICogZm9yIG5vdGVzIG9uIF9tZXRhIHVzYWdlLlxuICAgICAqL1xuICAgIF9tZXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQW4gQXVkaW8gcHJvdmlkZWQgdG8gb3IgZnJvbSBhbiBMTE0uXG4gKi9cbmV4cG9ydHMuQXVkaW9Db250ZW50U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgnYXVkaW8nKSxcbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZTY0LWVuY29kZWQgYXVkaW8gZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhOiBCYXNlNjRTY2hlbWEsXG4gICAgLyoqXG4gICAgICogVGhlIE1JTUUgdHlwZSBvZiB0aGUgYXVkaW8uIERpZmZlcmVudCBwcm92aWRlcnMgbWF5IHN1cHBvcnQgZGlmZmVyZW50IGF1ZGlvIHR5cGVzLlxuICAgICAqL1xuICAgIG1pbWVUeXBlOiB6b2RfMS56LnN0cmluZygpLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBUaGUgY29udGVudHMgb2YgYSByZXNvdXJjZSwgZW1iZWRkZWQgaW50byBhIHByb21wdCBvciB0b29sIGNhbGwgcmVzdWx0LlxuICovXG5leHBvcnRzLkVtYmVkZGVkUmVzb3VyY2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdyZXNvdXJjZScpLFxuICAgIHJlc291cmNlOiB6b2RfMS56LnVuaW9uKFtleHBvcnRzLlRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLCBleHBvcnRzLkJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hXSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEEgcmVzb3VyY2UgdGhhdCB0aGUgc2VydmVyIGlzIGNhcGFibGUgb2YgcmVhZGluZywgaW5jbHVkZWQgaW4gYSBwcm9tcHQgb3IgdG9vbCBjYWxsIHJlc3VsdC5cbiAqXG4gKiBOb3RlOiByZXNvdXJjZSBsaW5rcyByZXR1cm5lZCBieSB0b29scyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYXBwZWFyIGluIHRoZSByZXN1bHRzIG9mIGByZXNvdXJjZXMvbGlzdGAgcmVxdWVzdHMuXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VMaW5rU2NoZW1hID0gZXhwb3J0cy5SZXNvdXJjZVNjaGVtYS5leHRlbmQoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgncmVzb3VyY2VfbGluaycpXG59KTtcbi8qKlxuICogQSBjb250ZW50IGJsb2NrIHRoYXQgY2FuIGJlIHVzZWQgaW4gcHJvbXB0cyBhbmQgdG9vbCByZXN1bHRzLlxuICovXG5leHBvcnRzLkNvbnRlbnRCbG9ja1NjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIGV4cG9ydHMuVGV4dENvbnRlbnRTY2hlbWEsXG4gICAgZXhwb3J0cy5JbWFnZUNvbnRlbnRTY2hlbWEsXG4gICAgZXhwb3J0cy5BdWRpb0NvbnRlbnRTY2hlbWEsXG4gICAgZXhwb3J0cy5SZXNvdXJjZUxpbmtTY2hlbWEsXG4gICAgZXhwb3J0cy5FbWJlZGRlZFJlc291cmNlU2NoZW1hXG5dKTtcbi8qKlxuICogRGVzY3JpYmVzIGEgbWVzc2FnZSByZXR1cm5lZCBhcyBwYXJ0IG9mIGEgcHJvbXB0LlxuICovXG5leHBvcnRzLlByb21wdE1lc3NhZ2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgcm9sZTogem9kXzEuei5lbnVtKFsndXNlcicsICdhc3Npc3RhbnQnXSksXG4gICAgY29udGVudDogZXhwb3J0cy5Db250ZW50QmxvY2tTY2hlbWFcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIHByb21wdHMvZ2V0IHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkdldFByb21wdFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgZGVzY3JpcHRpb24gZm9yIHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgbWVzc2FnZXM6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5Qcm9tcHRNZXNzYWdlU2NoZW1hKVxufSk7XG4vKipcbiAqIEFuIG9wdGlvbmFsIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCwgaW5mb3JtaW5nIGl0IHRoYXQgdGhlIGxpc3Qgb2YgcHJvbXB0cyBpdCBvZmZlcnMgaGFzIGNoYW5nZWQuIFRoaXMgbWF5IGJlIGlzc3VlZCBieSBzZXJ2ZXJzIHdpdGhvdXQgYW55IHByZXZpb3VzIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuUHJvbXB0TGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL3Byb21wdHMvbGlzdF9jaGFuZ2VkJylcbn0pO1xuLyogVG9vbHMgKi9cbi8qKlxuICogQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgYSBUb29sIHRvIGNsaWVudHMuXG4gKlxuICogTk9URTogYWxsIHByb3BlcnRpZXMgaW4gVG9vbEFubm90YXRpb25zIGFyZSAqKmhpbnRzKiouXG4gKiBUaGV5IGFyZSBub3QgZ3VhcmFudGVlZCB0byBwcm92aWRlIGEgZmFpdGhmdWwgZGVzY3JpcHRpb24gb2ZcbiAqIHRvb2wgYmVoYXZpb3IgKGluY2x1ZGluZyBkZXNjcmlwdGl2ZSBwcm9wZXJ0aWVzIGxpa2UgYHRpdGxlYCkuXG4gKlxuICogQ2xpZW50cyBzaG91bGQgbmV2ZXIgbWFrZSB0b29sIHVzZSBkZWNpc2lvbnMgYmFzZWQgb24gVG9vbEFubm90YXRpb25zXG4gKiByZWNlaXZlZCBmcm9tIHVudHJ1c3RlZCBzZXJ2ZXJzLlxuICovXG5leHBvcnRzLlRvb2xBbm5vdGF0aW9uc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIHRpdGxlIGZvciB0aGUgdG9vbC5cbiAgICAgKi9cbiAgICB0aXRsZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgdG9vbCBkb2VzIG5vdCBtb2RpZnkgaXRzIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogRGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgICByZWFkT25seUhpbnQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpLFxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSB0b29sIG1heSBwZXJmb3JtIGRlc3RydWN0aXZlIHVwZGF0ZXMgdG8gaXRzIGVudmlyb25tZW50LlxuICAgICAqIElmIGZhbHNlLCB0aGUgdG9vbCBwZXJmb3JtcyBvbmx5IGFkZGl0aXZlIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiAoVGhpcyBwcm9wZXJ0eSBpcyBtZWFuaW5nZnVsIG9ubHkgd2hlbiBgcmVhZE9ubHlIaW50ID09IGZhbHNlYClcbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IHRydWVcbiAgICAgKi9cbiAgICBkZXN0cnVjdGl2ZUhpbnQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpLFxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGNhbGxpbmcgdGhlIHRvb2wgcmVwZWF0ZWRseSB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgaGF2ZSBubyBhZGRpdGlvbmFsIGVmZmVjdCBvbiB0aGUgaXRzIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogKFRoaXMgcHJvcGVydHkgaXMgbWVhbmluZ2Z1bCBvbmx5IHdoZW4gYHJlYWRPbmx5SGludCA9PSBmYWxzZWApXG4gICAgICpcbiAgICAgKiBEZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIGlkZW1wb3RlbnRIaW50OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGlzIHRvb2wgbWF5IGludGVyYWN0IHdpdGggYW4gXCJvcGVuIHdvcmxkXCIgb2YgZXh0ZXJuYWxcbiAgICAgKiBlbnRpdGllcy4gSWYgZmFsc2UsIHRoZSB0b29sJ3MgZG9tYWluIG9mIGludGVyYWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhlIHdvcmxkIG9mIGEgd2ViIHNlYXJjaCB0b29sIGlzIG9wZW4sIHdoZXJlYXMgdGhhdFxuICAgICAqIG9mIGEgbWVtb3J5IHRvb2wgaXMgbm90LlxuICAgICAqXG4gICAgICogRGVmYXVsdDogdHJ1ZVxuICAgICAqL1xuICAgIG9wZW5Xb3JsZEhpbnQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBEZWZpbml0aW9uIGZvciBhIHRvb2wgdGhlIGNsaWVudCBjYW4gY2FsbC5cbiAqL1xuZXhwb3J0cy5Ub29sU2NoZW1hID0gZXhwb3J0cy5CYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIEEgSlNPTiBTY2hlbWEgb2JqZWN0IGRlZmluaW5nIHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzIGZvciB0aGUgdG9vbC5cbiAgICAgKi9cbiAgICBpbnB1dFNjaGVtYTogem9kXzEuelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdvYmplY3QnKSxcbiAgICAgICAgcHJvcGVydGllczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgICAgIHJlcXVpcmVkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKCksXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgSlNPTiBTY2hlbWEgb2JqZWN0IGRlZmluaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHRvb2wncyBvdXRwdXQgcmV0dXJuZWQgaW5cbiAgICAgKiB0aGUgc3RydWN0dXJlZENvbnRlbnQgZmllbGQgb2YgYSBDYWxsVG9vbFJlc3VsdC5cbiAgICAgKi9cbiAgICBvdXRwdXRTY2hlbWE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdvYmplY3QnKSxcbiAgICAgICAgcHJvcGVydGllczogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gICAgICAgIHJlcXVpcmVkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKCkpLFxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGFkZGl0aW9uYWwgdG9vbCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBhbm5vdGF0aW9uczogem9kXzEuei5vcHRpb25hbChleHBvcnRzLlRvb2xBbm5vdGF0aW9uc1NjaGVtYSksXG4gICAgLyoqXG4gICAgICogU2VlIFtNQ1Agc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21vZGVsY29udGV4dHByb3RvY29sL21vZGVsY29udGV4dHByb3RvY29sL2Jsb2IvNDczMzljMDNjMTQzYmI0ZWMwMWEyNmU3MjFhMWI4ZmU2NjYzNGViZS9kb2NzL3NwZWNpZmljYXRpb24vZHJhZnQvYmFzaWMvaW5kZXgubWR4I2dlbmVyYWwtZmllbGRzKVxuICAgICAqIGZvciBub3RlcyBvbiBfbWV0YSB1c2FnZS5cbiAgICAgKi9cbiAgICBfbWV0YTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLm1lcmdlKGV4cG9ydHMuSWNvbnNTY2hlbWEpO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIGNsaWVudCB0byByZXF1ZXN0IGEgbGlzdCBvZiB0b29scyB0aGUgc2VydmVyIGhhcy5cbiAqL1xuZXhwb3J0cy5MaXN0VG9vbHNSZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ3Rvb2xzL2xpc3QnKVxufSk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIHRvb2xzL2xpc3QgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuTGlzdFRvb2xzUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICB0b29sczogem9kXzEuei5hcnJheShleHBvcnRzLlRvb2xTY2hlbWEpXG59KTtcbi8qKlxuICogVGhlIHNlcnZlcidzIHJlc3BvbnNlIHRvIGEgdG9vbCBjYWxsLlxuICovXG5leHBvcnRzLkNhbGxUb29sUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgY29udGVudCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSByZXN1bHQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBUb29sIGRvZXMgbm90IGRlZmluZSBhbiBvdXRwdXRTY2hlbWEsIHRoaXMgZmllbGQgTVVTVCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHQuXG4gICAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIGZpZWxkIGlzIGFsd2F5cyBwcmVzZW50LCBidXQgaXQgbWF5IGJlIGVtcHR5LlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHpvZF8xLnouYXJyYXkoZXhwb3J0cy5Db250ZW50QmxvY2tTY2hlbWEpLmRlZmF1bHQoW10pLFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHN0cnVjdHVyZWQgdG9vbCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVG9vbCBkZWZpbmVzIGFuIG91dHB1dFNjaGVtYSwgdGhpcyBmaWVsZCBNVVNUIGJlIHByZXNlbnQgaW4gdGhlIHJlc3VsdCwgYW5kIGNvbnRhaW4gYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdHJ1Y3R1cmVkQ29udGVudDogem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkub3B0aW9uYWwoKSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0b29sIGNhbGwgZW5kZWQgaW4gYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBJZiBub3Qgc2V0LCB0aGlzIGlzIGFzc3VtZWQgdG8gYmUgZmFsc2UgKHRoZSBjYWxsIHdhcyBzdWNjZXNzZnVsKS5cbiAgICAgKlxuICAgICAqIEFueSBlcnJvcnMgdGhhdCBvcmlnaW5hdGUgZnJvbSB0aGUgdG9vbCBTSE9VTEQgYmUgcmVwb3J0ZWQgaW5zaWRlIHRoZSByZXN1bHRcbiAgICAgKiBvYmplY3QsIHdpdGggYGlzRXJyb3JgIHNldCB0byB0cnVlLCBfbm90XyBhcyBhbiBNQ1AgcHJvdG9jb2wtbGV2ZWwgZXJyb3JcbiAgICAgKiByZXNwb25zZS4gT3RoZXJ3aXNlLCB0aGUgTExNIHdvdWxkIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGF0IGFuIGVycm9yIG9jY3VycmVkXG4gICAgICogYW5kIHNlbGYtY29ycmVjdC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGFueSBlcnJvcnMgaW4gX2ZpbmRpbmdfIHRoZSB0b29sLCBhbiBlcnJvciBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAgICogc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdG9vbCBjYWxscywgb3IgYW55IG90aGVyIGV4Y2VwdGlvbmFsIGNvbmRpdGlvbnMsXG4gICAgICogc2hvdWxkIGJlIHJlcG9ydGVkIGFzIGFuIE1DUCBlcnJvciByZXNwb25zZS5cbiAgICAgKi9cbiAgICBpc0Vycm9yOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYm9vbGVhbigpKVxufSk7XG4vKipcbiAqIENhbGxUb29sUmVzdWx0U2NoZW1hIGV4dGVuZGVkIHdpdGggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8gcHJvdG9jb2wgdmVyc2lvbiAyMDI0LTEwLTA3LlxuICovXG5leHBvcnRzLkNvbXBhdGliaWxpdHlDYWxsVG9vbFJlc3VsdFNjaGVtYSA9IGV4cG9ydHMuQ2FsbFRvb2xSZXN1bHRTY2hlbWEub3IoZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICB0b29sUmVzdWx0OiB6b2RfMS56LnVua25vd24oKVxufSkpO1xuLyoqXG4gKiBVc2VkIGJ5IHRoZSBjbGllbnQgdG8gaW52b2tlIGEgdG9vbCBwcm92aWRlZCBieSB0aGUgc2VydmVyLlxuICovXG5leHBvcnRzLkNhbGxUb29sUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCd0b29scy9jYWxsJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICBhcmd1bWVudHM6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5yZWNvcmQoem9kXzEuei51bmtub3duKCkpKVxuICAgIH0pXG59KTtcbi8qKlxuICogQW4gb3B0aW9uYWwgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LCBpbmZvcm1pbmcgaXQgdGhhdCB0aGUgbGlzdCBvZiB0b29scyBpdCBvZmZlcnMgaGFzIGNoYW5nZWQuIFRoaXMgbWF5IGJlIGlzc3VlZCBieSBzZXJ2ZXJzIHdpdGhvdXQgYW55IHByZXZpb3VzIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydHMuVG9vbExpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0cy5Ob3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbm90aWZpY2F0aW9ucy90b29scy9saXN0X2NoYW5nZWQnKVxufSk7XG4vKiBMb2dnaW5nICovXG4vKipcbiAqIFRoZSBzZXZlcml0eSBvZiBhIGxvZyBtZXNzYWdlLlxuICovXG5leHBvcnRzLkxvZ2dpbmdMZXZlbFNjaGVtYSA9IHpvZF8xLnouZW51bShbJ2RlYnVnJywgJ2luZm8nLCAnbm90aWNlJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnY3JpdGljYWwnLCAnYWxlcnQnLCAnZW1lcmdlbmN5J10pO1xuLyoqXG4gKiBBIHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIsIHRvIGVuYWJsZSBvciBhZGp1c3QgbG9nZ2luZy5cbiAqL1xuZXhwb3J0cy5TZXRMZXZlbFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnbG9nZ2luZy9zZXRMZXZlbCcpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsZXZlbCBvZiBsb2dnaW5nIHRoYXQgdGhlIGNsaWVudCB3YW50cyB0byByZWNlaXZlIGZyb20gdGhlIHNlcnZlci4gVGhlIHNlcnZlciBzaG91bGQgc2VuZCBhbGwgbG9ncyBhdCB0aGlzIGxldmVsIGFuZCBoaWdoZXIgKGkuZS4sIG1vcmUgc2V2ZXJlKSB0byB0aGUgY2xpZW50IGFzIG5vdGlmaWNhdGlvbnMvbG9nZ2luZy9tZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV2ZWw6IGV4cG9ydHMuTG9nZ2luZ0xldmVsU2NoZW1hXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBOb3RpZmljYXRpb24gb2YgYSBsb2cgbWVzc2FnZSBwYXNzZWQgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50LiBJZiBubyBsb2dnaW5nL3NldExldmVsIHJlcXVlc3QgaGFzIGJlZW4gc2VudCBmcm9tIHRoZSBjbGllbnQsIHRoZSBzZXJ2ZXIgTUFZIGRlY2lkZSB3aGljaCBtZXNzYWdlcyB0byBzZW5kIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmV4cG9ydHMuTG9nZ2luZ01lc3NhZ2VOb3RpZmljYXRpb25TY2hlbWEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdub3RpZmljYXRpb25zL21lc3NhZ2UnKSxcbiAgICBwYXJhbXM6IEJhc2VOb3RpZmljYXRpb25QYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXZlcml0eSBvZiB0aGlzIGxvZyBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV2ZWw6IGV4cG9ydHMuTG9nZ2luZ0xldmVsU2NoZW1hLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgbmFtZSBvZiB0aGUgbG9nZ2VyIGlzc3VpbmcgdGhpcyBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgbG9nZ2VyOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgdG8gYmUgbG9nZ2VkLCBzdWNoIGFzIGEgc3RyaW5nIG1lc3NhZ2Ugb3IgYW4gb2JqZWN0LiBBbnkgSlNPTiBzZXJpYWxpemFibGUgdHlwZSBpcyBhbGxvd2VkIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB6b2RfMS56LnVua25vd24oKVxuICAgIH0pXG59KTtcbi8qIFNhbXBsaW5nICovXG4vKipcbiAqIEhpbnRzIHRvIHVzZSBmb3IgbW9kZWwgc2VsZWN0aW9uLlxuICovXG5leHBvcnRzLk1vZGVsSGludFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBBIGhpbnQgZm9yIGEgbW9kZWwgbmFtZS5cbiAgICAgKi9cbiAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyBwcmVmZXJlbmNlcyBmb3IgbW9kZWwgc2VsZWN0aW9uLCByZXF1ZXN0ZWQgb2YgdGhlIGNsaWVudCBkdXJpbmcgc2FtcGxpbmcuXG4gKi9cbmV4cG9ydHMuTW9kZWxQcmVmZXJlbmNlc1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBoaW50cyB0byB1c2UgZm9yIG1vZGVsIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBoaW50czogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LmFycmF5KGV4cG9ydHMuTW9kZWxIaW50U2NoZW1hKSksXG4gICAgLyoqXG4gICAgICogSG93IG11Y2ggdG8gcHJpb3JpdGl6ZSBjb3N0IHdoZW4gc2VsZWN0aW5nIGEgbW9kZWwuXG4gICAgICovXG4gICAgY29zdFByaW9yaXR5OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxKSksXG4gICAgLyoqXG4gICAgICogSG93IG11Y2ggdG8gcHJpb3JpdGl6ZSBzYW1wbGluZyBzcGVlZCAobGF0ZW5jeSkgd2hlbiBzZWxlY3RpbmcgYSBtb2RlbC5cbiAgICAgKi9cbiAgICBzcGVlZFByaW9yaXR5OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxKSksXG4gICAgLyoqXG4gICAgICogSG93IG11Y2ggdG8gcHJpb3JpdGl6ZSBpbnRlbGxpZ2VuY2UgYW5kIGNhcGFiaWxpdGllcyB3aGVuIHNlbGVjdGluZyBhIG1vZGVsLlxuICAgICAqL1xuICAgIGludGVsbGlnZW5jZVByaW9yaXR5OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIERlc2NyaWJlcyBhIG1lc3NhZ2UgaXNzdWVkIHRvIG9yIHJlY2VpdmVkIGZyb20gYW4gTExNIEFQSS5cbiAqL1xuZXhwb3J0cy5TYW1wbGluZ01lc3NhZ2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgcm9sZTogem9kXzEuei5lbnVtKFsndXNlcicsICdhc3Npc3RhbnQnXSksXG4gICAgY29udGVudDogem9kXzEuei51bmlvbihbZXhwb3J0cy5UZXh0Q29udGVudFNjaGVtYSwgZXhwb3J0cy5JbWFnZUNvbnRlbnRTY2hlbWEsIGV4cG9ydHMuQXVkaW9Db250ZW50U2NoZW1hXSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIEEgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgdG8gc2FtcGxlIGFuIExMTSB2aWEgdGhlIGNsaWVudC4gVGhlIGNsaWVudCBoYXMgZnVsbCBkaXNjcmV0aW9uIG92ZXIgd2hpY2ggbW9kZWwgdG8gc2VsZWN0LiBUaGUgY2xpZW50IHNob3VsZCBhbHNvIGluZm9ybSB0aGUgdXNlciBiZWZvcmUgYmVnaW5uaW5nIHNhbXBsaW5nLCB0byBhbGxvdyB0aGVtIHRvIGluc3BlY3QgdGhlIHJlcXVlc3QgKGh1bWFuIGluIHRoZSBsb29wKSBhbmQgZGVjaWRlIHdoZXRoZXIgdG8gYXBwcm92ZSBpdC5cbiAqL1xuZXhwb3J0cy5DcmVhdGVNZXNzYWdlUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdzYW1wbGluZy9jcmVhdGVNZXNzYWdlJyksXG4gICAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgICAgICBtZXNzYWdlczogem9kXzEuei5hcnJheShleHBvcnRzLlNhbXBsaW5nTWVzc2FnZVNjaGVtYSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCBzeXN0ZW0gcHJvbXB0IHRoZSBzZXJ2ZXIgd2FudHMgdG8gdXNlIGZvciBzYW1wbGluZy4gVGhlIGNsaWVudCBNQVkgbW9kaWZ5IG9yIG9taXQgdGhpcyBwcm9tcHQuXG4gICAgICAgICAqL1xuICAgICAgICBzeXN0ZW1Qcm9tcHQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlcXVlc3QgdG8gaW5jbHVkZSBjb250ZXh0IGZyb20gb25lIG9yIG1vcmUgTUNQIHNlcnZlcnMgKGluY2x1ZGluZyB0aGUgY2FsbGVyKSwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHByb21wdC4gVGhlIGNsaWVudCBNQVkgaWdub3JlIHRoaXMgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIGluY2x1ZGVDb250ZXh0OiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouZW51bShbJ25vbmUnLCAndGhpc1NlcnZlcicsICdhbGxTZXJ2ZXJzJ10pKSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5udW1iZXIoKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRvIHNhbXBsZSwgYXMgcmVxdWVzdGVkIGJ5IHRoZSBzZXJ2ZXIuIFRoZSBjbGllbnQgTUFZIGNob29zZSB0byBzYW1wbGUgZmV3ZXIgdG9rZW5zIHRoYW4gcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgbWF4VG9rZW5zOiB6b2RfMS56Lm51bWJlcigpLmludCgpLFxuICAgICAgICBzdG9wU2VxdWVuY2VzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0aHJvdWdoIHRvIHRoZSBMTE0gcHJvdmlkZXIuIFRoZSBmb3JtYXQgb2YgdGhpcyBtZXRhZGF0YSBpcyBwcm92aWRlci1zcGVjaWZpYy5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGFkYXRhOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJ2ZXIncyBwcmVmZXJlbmNlcyBmb3Igd2hpY2ggbW9kZWwgdG8gc2VsZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWxQcmVmZXJlbmNlczogem9kXzEuei5vcHRpb25hbChleHBvcnRzLk1vZGVsUHJlZmVyZW5jZXNTY2hlbWEpXG4gICAgfSlcbn0pO1xuLyoqXG4gKiBUaGUgY2xpZW50J3MgcmVzcG9uc2UgdG8gYSBzYW1wbGluZy9jcmVhdGVfbWVzc2FnZSByZXF1ZXN0IGZyb20gdGhlIHNlcnZlci4gVGhlIGNsaWVudCBzaG91bGQgaW5mb3JtIHRoZSB1c2VyIGJlZm9yZSByZXR1cm5pbmcgdGhlIHNhbXBsZWQgbWVzc2FnZSwgdG8gYWxsb3cgdGhlbSB0byBpbnNwZWN0IHRoZSByZXNwb25zZSAoaHVtYW4gaW4gdGhlIGxvb3ApIGFuZCBkZWNpZGUgd2hldGhlciB0byBhbGxvdyB0aGUgc2VydmVyIHRvIHNlZSBpdC5cbiAqL1xuZXhwb3J0cy5DcmVhdGVNZXNzYWdlUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdGhhdCBnZW5lcmF0ZWQgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbW9kZWw6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB3aHkgc2FtcGxpbmcgc3RvcHBlZC5cbiAgICAgKi9cbiAgICBzdG9wUmVhc29uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouZW51bShbJ2VuZFR1cm4nLCAnc3RvcFNlcXVlbmNlJywgJ21heFRva2VucyddKS5vcih6b2RfMS56LnN0cmluZygpKSksXG4gICAgcm9sZTogem9kXzEuei5lbnVtKFsndXNlcicsICdhc3Npc3RhbnQnXSksXG4gICAgY29udGVudDogem9kXzEuei5kaXNjcmltaW5hdGVkVW5pb24oJ3R5cGUnLCBbZXhwb3J0cy5UZXh0Q29udGVudFNjaGVtYSwgZXhwb3J0cy5JbWFnZUNvbnRlbnRTY2hlbWEsIGV4cG9ydHMuQXVkaW9Db250ZW50U2NoZW1hXSlcbn0pO1xuLyogRWxpY2l0YXRpb24gKi9cbi8qKlxuICogUHJpbWl0aXZlIHNjaGVtYSBkZWZpbml0aW9uIGZvciBib29sZWFuIGZpZWxkcy5cbiAqL1xuZXhwb3J0cy5Cb29sZWFuU2NoZW1hU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgnYm9vbGVhbicpLFxuICAgIHRpdGxlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGRlZmF1bHQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBQcmltaXRpdmUgc2NoZW1hIGRlZmluaXRpb24gZm9yIHN0cmluZyBmaWVsZHMuXG4gKi9cbmV4cG9ydHMuU3RyaW5nU2NoZW1hU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgnc3RyaW5nJyksXG4gICAgdGl0bGU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5zdHJpbmcoKSksXG4gICAgbWluTGVuZ3RoOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkpLFxuICAgIG1heExlbmd0aDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm51bWJlcigpKSxcbiAgICBmb3JtYXQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5lbnVtKFsnZW1haWwnLCAndXJpJywgJ2RhdGUnLCAnZGF0ZS10aW1lJ10pKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogUHJpbWl0aXZlIHNjaGVtYSBkZWZpbml0aW9uIGZvciBudW1iZXIgZmllbGRzLlxuICovXG5leHBvcnRzLk51bWJlclNjaGVtYVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmVudW0oWydudW1iZXInLCAnaW50ZWdlciddKSxcbiAgICB0aXRsZTogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBkZXNjcmlwdGlvbjogem9kXzEuei5vcHRpb25hbCh6b2RfMS56LnN0cmluZygpKSxcbiAgICBtaW5pbXVtOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkpLFxuICAgIG1heGltdW06IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5udW1iZXIoKSlcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIFByaW1pdGl2ZSBzY2hlbWEgZGVmaW5pdGlvbiBmb3IgZW51bSBmaWVsZHMuXG4gKi9cbmV4cG9ydHMuRW51bVNjaGVtYVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ3N0cmluZycpLFxuICAgIHRpdGxlOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGRlc2NyaXB0aW9uOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGVudW06IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSksXG4gICAgZW51bU5hbWVzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBVbmlvbiBvZiBhbGwgcHJpbWl0aXZlIHNjaGVtYSBkZWZpbml0aW9ucy5cbiAqL1xuZXhwb3J0cy5QcmltaXRpdmVTY2hlbWFEZWZpbml0aW9uU2NoZW1hID0gem9kXzEuei51bmlvbihbZXhwb3J0cy5Cb29sZWFuU2NoZW1hU2NoZW1hLCBleHBvcnRzLlN0cmluZ1NjaGVtYVNjaGVtYSwgZXhwb3J0cy5OdW1iZXJTY2hlbWFTY2hlbWEsIGV4cG9ydHMuRW51bVNjaGVtYVNjaGVtYV0pO1xuLyoqXG4gKiBBIHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIHRvIGVsaWNpdCB1c2VyIGlucHV0IHZpYSB0aGUgY2xpZW50LlxuICogVGhlIGNsaWVudCBzaG91bGQgcHJlc2VudCB0aGUgbWVzc2FnZSBhbmQgZm9ybSBmaWVsZHMgdG8gdGhlIHVzZXIuXG4gKi9cbmV4cG9ydHMuRWxpY2l0UmVxdWVzdFNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICAgIG1ldGhvZDogem9kXzEuei5saXRlcmFsKCdlbGljaXRhdGlvbi9jcmVhdGUnKSxcbiAgICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWVzc2FnZSB0byBwcmVzZW50IHRvIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgbWVzc2FnZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY2hlbWEgZm9yIHRoZSByZXF1ZXN0ZWQgdXNlciBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RlZFNjaGVtYTogem9kXzEuelxuICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoJ29iamVjdCcpLFxuICAgICAgICAgICAgcHJvcGVydGllczogem9kXzEuei5yZWNvcmQoem9kXzEuei5zdHJpbmcoKSwgZXhwb3J0cy5QcmltaXRpdmVTY2hlbWFEZWZpbml0aW9uU2NoZW1hKSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucGFzc3Rocm91Z2goKVxuICAgIH0pXG59KTtcbi8qKlxuICogVGhlIGNsaWVudCdzIHJlc3BvbnNlIHRvIGFuIGVsaWNpdGF0aW9uL2NyZWF0ZSByZXF1ZXN0IGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0cy5FbGljaXRSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyJ3MgcmVzcG9uc2UgYWN0aW9uLlxuICAgICAqL1xuICAgIGFjdGlvbjogem9kXzEuei5lbnVtKFsnYWNjZXB0JywgJ2RlY2xpbmUnLCAnY2FuY2VsJ10pLFxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0ZWQgdXNlciBpbnB1dCBjb250ZW50IChvbmx5IHByZXNlbnQgaWYgYWN0aW9uIGlzIFwiYWNjZXB0XCIpLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5yZWNvcmQoem9kXzEuei5zdHJpbmcoKSwgem9kXzEuei51bmtub3duKCkpKVxufSk7XG4vKiBBdXRvY29tcGxldGUgKi9cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSByZXNvdXJjZSBvciByZXNvdXJjZSB0ZW1wbGF0ZSBkZWZpbml0aW9uLlxuICovXG5leHBvcnRzLlJlc291cmNlVGVtcGxhdGVSZWZlcmVuY2VTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKCdyZWYvcmVzb3VyY2UnKSxcbiAgICAvKipcbiAgICAgKiBUaGUgVVJJIG9yIFVSSSB0ZW1wbGF0ZSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgdXJpOiB6b2RfMS56LnN0cmluZygpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgUmVzb3VyY2VUZW1wbGF0ZVJlZmVyZW5jZVNjaGVtYSBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuUmVzb3VyY2VSZWZlcmVuY2VTY2hlbWEgPSBleHBvcnRzLlJlc291cmNlVGVtcGxhdGVSZWZlcmVuY2VTY2hlbWE7XG4vKipcbiAqIElkZW50aWZpZXMgYSBwcm9tcHQuXG4gKi9cbmV4cG9ydHMuUHJvbXB0UmVmZXJlbmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbCgncmVmL3Byb21wdCcpLFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9tcHQgb3IgcHJvbXB0IHRlbXBsYXRlXG4gICAgICovXG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKVxufSlcbiAgICAucGFzc3Rocm91Z2goKTtcbi8qKlxuICogQSByZXF1ZXN0IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLCB0byBhc2sgZm9yIGNvbXBsZXRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0cy5Db21wbGV0ZVJlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgnY29tcGxldGlvbi9jb21wbGV0ZScpLFxuICAgIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgcmVmOiB6b2RfMS56LnVuaW9uKFtleHBvcnRzLlByb21wdFJlZmVyZW5jZVNjaGVtYSwgZXhwb3J0cy5SZXNvdXJjZVRlbXBsYXRlUmVmZXJlbmNlU2NoZW1hXSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJndW1lbnQncyBpbmZvcm1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnQ6IHpvZF8xLnpcbiAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudCB0byB1c2UgZm9yIGNvbXBsZXRpb24gbWF0Y2hpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhbHVlOiB6b2RfMS56LnN0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucGFzc3Rocm91Z2goKSxcbiAgICAgICAgY29udGV4dDogem9kXzEuei5vcHRpb25hbCh6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZpb3VzbHktcmVzb2x2ZWQgdmFyaWFibGVzIGluIGEgVVJJIHRlbXBsYXRlIG9yIHByb21wdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXJndW1lbnRzOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoucmVjb3JkKHpvZF8xLnouc3RyaW5nKCksIHpvZF8xLnouc3RyaW5nKCkpKVxuICAgICAgICB9KSlcbiAgICB9KVxufSk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIncyByZXNwb25zZSB0byBhIGNvbXBsZXRpb24vY29tcGxldGUgcmVxdWVzdFxuICovXG5leHBvcnRzLkNvbXBsZXRlUmVzdWx0U2NoZW1hID0gZXhwb3J0cy5SZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICBjb21wbGV0aW9uOiB6b2RfMS56XG4gICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgY29tcGxldGlvbiB2YWx1ZXMuIE11c3Qgbm90IGV4Y2VlZCAxMDAgaXRlbXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZXM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkubWF4KDEwMCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGNvbXBsZXRpb24gb3B0aW9ucyBhdmFpbGFibGUuIFRoaXMgY2FuIGV4Y2VlZCB0aGUgbnVtYmVyIG9mIHZhbHVlcyBhY3R1YWxseSBzZW50IGluIHRoZSByZXNwb25zZS5cbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnoubnVtYmVyKCkuaW50KCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgYXJlIGFkZGl0aW9uYWwgY29tcGxldGlvbiBvcHRpb25zIGJleW9uZCB0aG9zZSBwcm92aWRlZCBpbiB0aGUgY3VycmVudCByZXNwb25zZSwgZXZlbiBpZiB0aGUgZXhhY3QgdG90YWwgaXMgdW5rbm93bi5cbiAgICAgICAgICovXG4gICAgICAgIGhhc01vcmU6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5ib29sZWFuKCkpXG4gICAgfSlcbiAgICAgICAgLnBhc3N0aHJvdWdoKClcbn0pO1xuLyogUm9vdHMgKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIHJvb3QgZGlyZWN0b3J5IG9yIGZpbGUgdGhhdCB0aGUgc2VydmVyIGNhbiBvcGVyYXRlIG9uLlxuICovXG5leHBvcnRzLlJvb3RTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogVGhlIFVSSSBpZGVudGlmeWluZyB0aGUgcm9vdC4gVGhpcyAqbXVzdCogc3RhcnQgd2l0aCBmaWxlOi8vIGZvciBub3cuXG4gICAgICovXG4gICAgdXJpOiB6b2RfMS56LnN0cmluZygpLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSxcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgcm9vdC5cbiAgICAgKi9cbiAgICBuYW1lOiB6b2RfMS56Lm9wdGlvbmFsKHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIC8qKlxuICAgICAqIFNlZSBbTUNQIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2RlbGNvbnRleHRwcm90b2NvbC9tb2RlbGNvbnRleHRwcm90b2NvbC9ibG9iLzQ3MzM5YzAzYzE0M2JiNGVjMDFhMjZlNzIxYTFiOGZlNjY2MzRlYmUvZG9jcy9zcGVjaWZpY2F0aW9uL2RyYWZ0L2Jhc2ljL2luZGV4Lm1keCNnZW5lcmFsLWZpZWxkcylcbiAgICAgKiBmb3Igbm90ZXMgb24gX21ldGEgdXNhZ2UuXG4gICAgICovXG4gICAgX21ldGE6IHpvZF8xLnoub3B0aW9uYWwoem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBTZW50IGZyb20gdGhlIHNlcnZlciB0byByZXF1ZXN0IGEgbGlzdCBvZiByb290IFVSSXMgZnJvbSB0aGUgY2xpZW50LlxuICovXG5leHBvcnRzLkxpc3RSb290c1JlcXVlc3RTY2hlbWEgPSBleHBvcnRzLlJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgICBtZXRob2Q6IHpvZF8xLnoubGl0ZXJhbCgncm9vdHMvbGlzdCcpXG59KTtcbi8qKlxuICogVGhlIGNsaWVudCdzIHJlc3BvbnNlIHRvIGEgcm9vdHMvbGlzdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZXhwb3J0cy5MaXN0Um9vdHNSZXN1bHRTY2hlbWEgPSBleHBvcnRzLlJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIHJvb3RzOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuUm9vdFNjaGVtYSlcbn0pO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciwgaW5mb3JtaW5nIGl0IHRoYXQgdGhlIGxpc3Qgb2Ygcm9vdHMgaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydHMuUm9vdHNMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gICAgbWV0aG9kOiB6b2RfMS56LmxpdGVyYWwoJ25vdGlmaWNhdGlvbnMvcm9vdHMvbGlzdF9jaGFuZ2VkJylcbn0pO1xuLyogQ2xpZW50IG1lc3NhZ2VzICovXG5leHBvcnRzLkNsaWVudFJlcXVlc3RTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtcbiAgICBleHBvcnRzLlBpbmdSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5Db21wbGV0ZVJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5TZXRMZXZlbFJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5HZXRQcm9tcHRSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuTGlzdFJlc291cmNlc1JlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXF1ZXN0U2NoZW1hLFxuICAgIGV4cG9ydHMuUmVhZFJlc291cmNlUmVxdWVzdFNjaGVtYSxcbiAgICBleHBvcnRzLlN1YnNjcmliZVJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5VbnN1YnNjcmliZVJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5DYWxsVG9vbFJlcXVlc3RTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0VG9vbHNSZXF1ZXN0U2NoZW1hXG5dKTtcbmV4cG9ydHMuQ2xpZW50Tm90aWZpY2F0aW9uU2NoZW1hID0gem9kXzEuei51bmlvbihbXG4gICAgZXhwb3J0cy5DYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5Qcm9ncmVzc05vdGlmaWNhdGlvblNjaGVtYSxcbiAgICBleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuUm9vdHNMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYVxuXSk7XG5leHBvcnRzLkNsaWVudFJlc3VsdFNjaGVtYSA9IHpvZF8xLnoudW5pb24oW2V4cG9ydHMuRW1wdHlSZXN1bHRTY2hlbWEsIGV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlc3VsdFNjaGVtYSwgZXhwb3J0cy5FbGljaXRSZXN1bHRTY2hlbWEsIGV4cG9ydHMuTGlzdFJvb3RzUmVzdWx0U2NoZW1hXSk7XG4vKiBTZXJ2ZXIgbWVzc2FnZXMgKi9cbmV4cG9ydHMuU2VydmVyUmVxdWVzdFNjaGVtYSA9IHpvZF8xLnoudW5pb24oW2V4cG9ydHMuUGluZ1JlcXVlc3RTY2hlbWEsIGV4cG9ydHMuQ3JlYXRlTWVzc2FnZVJlcXVlc3RTY2hlbWEsIGV4cG9ydHMuRWxpY2l0UmVxdWVzdFNjaGVtYSwgZXhwb3J0cy5MaXN0Um9vdHNSZXF1ZXN0U2NoZW1hXSk7XG5leHBvcnRzLlNlcnZlck5vdGlmaWNhdGlvblNjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIGV4cG9ydHMuQ2FuY2VsbGVkTm90aWZpY2F0aW9uU2NoZW1hLFxuICAgIGV4cG9ydHMuUHJvZ3Jlc3NOb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5Mb2dnaW5nTWVzc2FnZU5vdGlmaWNhdGlvblNjaGVtYSxcbiAgICBleHBvcnRzLlJlc291cmNlVXBkYXRlZE5vdGlmaWNhdGlvblNjaGVtYSxcbiAgICBleHBvcnRzLlJlc291cmNlTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5Ub29sTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEsXG4gICAgZXhwb3J0cy5Qcm9tcHRMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYVxuXSk7XG5leHBvcnRzLlNlcnZlclJlc3VsdFNjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIGV4cG9ydHMuRW1wdHlSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5Jbml0aWFsaXplUmVzdWx0U2NoZW1hLFxuICAgIGV4cG9ydHMuQ29tcGxldGVSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5HZXRQcm9tcHRSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0UHJvbXB0c1Jlc3VsdFNjaGVtYSxcbiAgICBleHBvcnRzLkxpc3RSZXNvdXJjZXNSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5MaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5SZWFkUmVzb3VyY2VSZXN1bHRTY2hlbWEsXG4gICAgZXhwb3J0cy5DYWxsVG9vbFJlc3VsdFNjaGVtYSxcbiAgICBleHBvcnRzLkxpc3RUb29sc1Jlc3VsdFNjaGVtYVxuXSk7XG5jbGFzcyBNY3BFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKGBNQ1AgZXJyb3IgJHtjb2RlfTogJHttZXNzYWdlfWApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWNwRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydHMuTWNwRXJyb3IgPSBNY3BFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsbnVsbCwiaW1wb3J0ICogYXMgeiBmcm9tIFwiLi92My9leHRlcm5hbC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdjMvZXh0ZXJuYWwuanNcIjtcbmV4cG9ydCB7IHogfTtcbmV4cG9ydCBkZWZhdWx0IHo7XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2hlbHBlcnMvcGFyc2VVdGlsLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzL3R5cGVBbGlhc2VzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ab2RFcnJvci5qc1wiO1xuIiwiaW1wb3J0IGRlZmF1bHRFcnJvck1hcCBmcm9tIFwiLi9sb2NhbGVzL2VuLmpzXCI7XG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGRlZmF1bHRFcnJvck1hcDtcbmV4cG9ydCB7IGRlZmF1bHRFcnJvck1hcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG4iLCJpbXBvcnQgeyBab2RJc3N1ZUNvZGUgfSBmcm9tIFwiLi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsLmpzXCI7XG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2AgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgZXJyb3JNYXA7XG4iLCJpbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuZXhwb3J0IGNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXSA9IGZpZWxkRXJyb3JzW2ZpcnN0RWxdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4iLCJleHBvcnQgdmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKF8pID0+IHsgfTtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmV4cG9ydCB2YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmV4cG9ydCBjb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcbiIsImV4cG9ydHMuaW50ZXJvcERlZmF1bHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhIDoge2RlZmF1bHQ6IGF9O1xufTtcblxuZXhwb3J0cy5kZWZpbmVJbnRlcm9wRmxhZyA9IGZ1bmN0aW9uIChhKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xufTtcblxuZXhwb3J0cy5leHBvcnRBbGwgPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ2RlZmF1bHQnIHx8IGtleSA9PT0gJ19fZXNNb2R1bGUnIHx8IGRlc3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5leHBvcnRzLmV4cG9ydCA9IGZ1bmN0aW9uIChkZXN0LCBkZXN0TmFtZSwgZ2V0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBkZXN0TmFtZSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXQsXG4gIH0pO1xufTtcbiIsImltcG9ydCB7IGdldEVycm9yTWFwIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IGRlZmF1bHRFcnJvck1hcCBmcm9tIFwiLi4vbG9jYWxlcy9lbi5qc1wiO1xuZXhwb3J0IGNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAsIC8vIHRoZW4gZ2xvYmFsIG92ZXJyaWRlIG1hcFxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAgPT09IGRlZmF1bHRFcnJvck1hcCA/IHVuZGVmaW5lZCA6IGRlZmF1bHRFcnJvck1hcCwgLy8gdGhlbiBnbG9iYWwgZGVmYXVsdCBtYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgfSk7XG4gICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XG59XG5leHBvcnQgY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuZXhwb3J0IGNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuZXhwb3J0IGNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmV4cG9ydCBjb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5leHBvcnQgY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcbiIsImV4cG9ydCB7fTtcbiIsImltcG9ydCB7IFpvZEVycm9yLCBab2RJc3N1ZUNvZGUsIH0gZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRFcnJvck1hcCwgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGVycm9yVXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvZXJyb3JVdGlsLmpzXCI7XG5pbXBvcnQgeyBESVJUWSwgSU5WQUxJRCwgT0ssIFBhcnNlU3RhdHVzLCBhZGRJc3N1ZVRvQ29udGV4dCwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBtYWtlSXNzdWUsIH0gZnJvbSBcIi4vaGVscGVycy9wYXJzZVV0aWwuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUsIGdldFBhcnNlZFR5cGUgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmV4cG9ydCBjbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnI/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCk/LmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSbigJkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcbiAgICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gICAgY29uc3Qgb3B0cyA9IFtdO1xuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XG4gICAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgICAgICBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06P1xcXFxkezJ9KWApO1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xuICAgIGlmICghand0UmVnZXgudGVzdChqd3QpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChcInR5cFwiIGluIGRlY29kZWQgJiYgZGVjb2RlZD8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IFN0cmluZyhpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IG9wdGlvbnM/LmxvY2FsID8/IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnM/LnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcbiAgICAgKi9cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgIH1cbiAgICB0cmltKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Mb3dlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9VcHBlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1haWwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1haWxcIik7XG4gICAgfVxuICAgIGdldCBpc1VSTCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gICAgfVxuICAgIGdldCBpc0Vtb2ppKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc05BTk9JRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZDJcIik7XG4gICAgfVxuICAgIGdldCBpc1VMSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzSVAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gICAgfVxuICAgIGdldCBpc0NJRFIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY2lkclwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0dXJsKCkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIDEwICoqIGRlY0NvdW50O1xufVxuZXhwb3J0IGNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJvb2xlYW4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gcGFzcyB0aHJvdWdoIHVua25vd24gcHJvcGVydGllcywgdXNlIGAucGFzc3Rocm91Z2goKWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcbiAgICAgICAgLy8gZXh0ZW5kPFxuICAgICAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlLFxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAgICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PixcbiAgICAgICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAgICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+XG4gICAgICAgIC8vID4oXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gKTogWm9kT2JqZWN0PFxuICAgICAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIEF1Z21lbnRhdGlvbj4sXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXG4gICAgICAgIC8vICAgQ2F0Y2hhbGwsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0LFxuICAgICAgICAvLyAgIE5ld0lucHV0XG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgLy8gICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAvLyAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAvLyAgICAgfSksXG4gICAgICAgIC8vICAgfSkgYXMgYW55O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYC5leHRlbmRgIGluc3RlYWRcbiAgICAgICAgICogICovXG4gICAgICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICAgIH1cbiAgICBfZ2V0Q2FjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHV0aWwub2JqZWN0S2V5cyhzaGFwZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgc2hhcGUsIGtleXM6IHNoYXBlS2V5cyB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCk7XG4gICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJiB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHRoaXMuX2RlZi5lcnJvck1hcD8uKGlzc3VlLCBjdHgpLm1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UgPz8gZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKG1hc2spKSB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kUmVhZG9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gdHlwZSBab2RUdXBsZUl0ZW1zID0gW1pvZFR5cGVBbnksIC4uLlpvZFR5cGVBbnlbXV07XG5leHBvcnQgY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBbaW5kZXgsIFwidmFsdWVcIl0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5leHBvcnQgY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJiBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC5yZWZpbmVtZW50KGFjYywgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgeyBab2RFZmZlY3RzIGFzIFpvZFRyYW5zZm9ybWVyIH07XG5leHBvcnQgY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RSZWFkb25seSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShjaGVjaywgX3BhcmFtcyA9IHt9LCBcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpIHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmV4cG9ydCB7IFpvZFR5cGUgYXMgU2NoZW1hLCBab2RUeXBlIGFzIFpvZFNjaGVtYSB9O1xuZXhwb3J0IGNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4vLyByZXF1aXJlcyBUUyA0LjQrXG5jbGFzcyBDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoLi4uXykgeyB9XG59XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydCBjb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5leHBvcnQgeyBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgZGF0ZVR5cGUgYXMgZGF0ZSwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFwVHlwZSBhcyBtYXAsIG5hblR5cGUgYXMgbmFuLCBuYXRpdmVFbnVtVHlwZSBhcyBuYXRpdmVFbnVtLCBuZXZlclR5cGUgYXMgbmV2ZXIsIG51bGxUeXBlIGFzIG51bGwsIG51bGxhYmxlVHlwZSBhcyBudWxsYWJsZSwgbnVtYmVyVHlwZSBhcyBudW1iZXIsIG9iamVjdFR5cGUgYXMgb2JqZWN0LCBvYm9vbGVhbiwgb251bWJlciwgb3B0aW9uYWxUeXBlIGFzIG9wdGlvbmFsLCBvc3RyaW5nLCBwaXBlbGluZVR5cGUgYXMgcGlwZWxpbmUsIHByZXByb2Nlc3NUeXBlIGFzIHByZXByb2Nlc3MsIHByb21pc2VUeXBlIGFzIHByb21pc2UsIHJlY29yZFR5cGUgYXMgcmVjb3JkLCBzZXRUeXBlIGFzIHNldCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdm9pZFR5cGUgYXMgdm9pZCwgfTtcbmV4cG9ydCBjb25zdCBORVZFUiA9IElOVkFMSUQ7XG4iLCJleHBvcnQgdmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50OlxuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tcGlsZVNjaGVtYSA9IHJlcXVpcmUoJy4vY29tcGlsZScpXG4gICwgcmVzb2x2ZSA9IHJlcXVpcmUoJy4vY29tcGlsZS9yZXNvbHZlJylcbiAgLCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuICAsIFNjaGVtYU9iamVjdCA9IHJlcXVpcmUoJy4vY29tcGlsZS9zY2hlbWFfb2JqJylcbiAgLCBzdGFibGVTdHJpbmdpZnkgPSByZXF1aXJlKCdmYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeScpXG4gICwgZm9ybWF0cyA9IHJlcXVpcmUoJy4vY29tcGlsZS9mb3JtYXRzJylcbiAgLCBydWxlcyA9IHJlcXVpcmUoJy4vY29tcGlsZS9ydWxlcycpXG4gICwgJGRhdGFNZXRhU2NoZW1hID0gcmVxdWlyZSgnLi9kYXRhJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi9jb21waWxlL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBanY7XG5cbkFqdi5wcm90b3R5cGUudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbkFqdi5wcm90b3R5cGUuY29tcGlsZSA9IGNvbXBpbGU7XG5BanYucHJvdG90eXBlLmFkZFNjaGVtYSA9IGFkZFNjaGVtYTtcbkFqdi5wcm90b3R5cGUuYWRkTWV0YVNjaGVtYSA9IGFkZE1ldGFTY2hlbWE7XG5BanYucHJvdG90eXBlLnZhbGlkYXRlU2NoZW1hID0gdmFsaWRhdGVTY2hlbWE7XG5BanYucHJvdG90eXBlLmdldFNjaGVtYSA9IGdldFNjaGVtYTtcbkFqdi5wcm90b3R5cGUucmVtb3ZlU2NoZW1hID0gcmVtb3ZlU2NoZW1hO1xuQWp2LnByb3RvdHlwZS5hZGRGb3JtYXQgPSBhZGRGb3JtYXQ7XG5BanYucHJvdG90eXBlLmVycm9yc1RleHQgPSBlcnJvcnNUZXh0O1xuXG5BanYucHJvdG90eXBlLl9hZGRTY2hlbWEgPSBfYWRkU2NoZW1hO1xuQWp2LnByb3RvdHlwZS5fY29tcGlsZSA9IF9jb21waWxlO1xuXG5BanYucHJvdG90eXBlLmNvbXBpbGVBc3luYyA9IHJlcXVpcmUoJy4vY29tcGlsZS9hc3luYycpO1xudmFyIGN1c3RvbUtleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbkFqdi5wcm90b3R5cGUuYWRkS2V5d29yZCA9IGN1c3RvbUtleXdvcmQuYWRkO1xuQWp2LnByb3RvdHlwZS5nZXRLZXl3b3JkID0gY3VzdG9tS2V5d29yZC5nZXQ7XG5BanYucHJvdG90eXBlLnJlbW92ZUtleXdvcmQgPSBjdXN0b21LZXl3b3JkLnJlbW92ZTtcbkFqdi5wcm90b3R5cGUudmFsaWRhdGVLZXl3b3JkID0gY3VzdG9tS2V5d29yZC52YWxpZGF0ZTtcblxudmFyIGVycm9yQ2xhc3NlcyA9IHJlcXVpcmUoJy4vY29tcGlsZS9lcnJvcl9jbGFzc2VzJyk7XG5BanYuVmFsaWRhdGlvbkVycm9yID0gZXJyb3JDbGFzc2VzLlZhbGlkYXRpb247XG5BanYuTWlzc2luZ1JlZkVycm9yID0gZXJyb3JDbGFzc2VzLk1pc3NpbmdSZWY7XG5BanYuJGRhdGFNZXRhU2NoZW1hID0gJGRhdGFNZXRhU2NoZW1hO1xuXG52YXIgTUVUQV9TQ0hFTUFfSUQgPSAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEnO1xuXG52YXIgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFsgJ3JlbW92ZUFkZGl0aW9uYWwnLCAndXNlRGVmYXVsdHMnLCAnY29lcmNlVHlwZXMnLCAnc3RyaWN0RGVmYXVsdHMnIF07XG52YXIgTUVUQV9TVVBQT1JUX0RBVEEgPSBbJy9wcm9wZXJ0aWVzJ107XG5cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBVc2FnZTogYEFqdihvcHRzKWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gYWp2IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEFqdihvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBanYpKSByZXR1cm4gbmV3IEFqdihvcHRzKTtcbiAgb3B0cyA9IHRoaXMuX29wdHMgPSB1dGlsLmNvcHkob3B0cykgfHwge307XG4gIHNldExvZ2dlcih0aGlzKTtcbiAgdGhpcy5fc2NoZW1hcyA9IHt9O1xuICB0aGlzLl9yZWZzID0ge307XG4gIHRoaXMuX2ZyYWdtZW50cyA9IHt9O1xuICB0aGlzLl9mb3JtYXRzID0gZm9ybWF0cyhvcHRzLmZvcm1hdCk7XG5cbiAgdGhpcy5fY2FjaGUgPSBvcHRzLmNhY2hlIHx8IG5ldyBDYWNoZTtcbiAgdGhpcy5fbG9hZGluZ1NjaGVtYXMgPSB7fTtcbiAgdGhpcy5fY29tcGlsYXRpb25zID0gW107XG4gIHRoaXMuUlVMRVMgPSBydWxlcygpO1xuICB0aGlzLl9nZXRJZCA9IGNob29zZUdldElkKG9wdHMpO1xuXG4gIG9wdHMubG9vcFJlcXVpcmVkID0gb3B0cy5sb29wUmVxdWlyZWQgfHwgSW5maW5pdHk7XG4gIGlmIChvcHRzLmVycm9yRGF0YVBhdGggPT0gJ3Byb3BlcnR5Jykgb3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5ID0gdHJ1ZTtcbiAgaWYgKG9wdHMuc2VyaWFsaXplID09PSB1bmRlZmluZWQpIG9wdHMuc2VyaWFsaXplID0gc3RhYmxlU3RyaW5naWZ5O1xuICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zKHRoaXMpO1xuXG4gIGlmIChvcHRzLmZvcm1hdHMpIGFkZEluaXRpYWxGb3JtYXRzKHRoaXMpO1xuICBpZiAob3B0cy5rZXl3b3JkcykgYWRkSW5pdGlhbEtleXdvcmRzKHRoaXMpO1xuICBhZGREZWZhdWx0TWV0YVNjaGVtYSh0aGlzKTtcbiAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gJ29iamVjdCcpIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICBpZiAob3B0cy5udWxsYWJsZSkgdGhpcy5hZGRLZXl3b3JkKCdudWxsYWJsZScsIHttZXRhU2NoZW1hOiB7dHlwZTogJ2Jvb2xlYW4nfX0pO1xuICBhZGRJbml0aWFsU2NoZW1hcyh0aGlzKTtcbn1cblxuXG5cbi8qKlxuICogVmFsaWRhdGUgZGF0YSB1c2luZyBzY2hlbWFcbiAqIFNjaGVtYSB3aWxsIGJlIGNvbXBpbGVkIGFuZCBjYWNoZWQgKHVzaW5nIHNlcmlhbGl6ZWQgSlNPTiBhcyBrZXkuIFtmYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtanNvbi1zdGFibGUtc3RyaW5naWZ5KSBpcyB1c2VkIHRvIHNlcmlhbGl6ZS5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFLZXlSZWYga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICogQHBhcmFtICB7QW55fSBkYXRhIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gdmFsaWRhdGlvbiByZXN1bHQuIEVycm9ycyBmcm9tIHRoZSBsYXN0IHZhbGlkYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgaW4gYGFqdi5lcnJvcnNgIChhbmQgYWxzbyBpbiBjb21waWxlZCBzY2hlbWE6IGBzY2hlbWEuZXJyb3JzYCkuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgZGF0YSkge1xuICB2YXIgdjtcbiAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gJ3N0cmluZycpIHtcbiAgICB2ID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hS2V5UmVmKTtcbiAgICBpZiAoIXYpIHRocm93IG5ldyBFcnJvcignbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIicgKyBzY2hlbWFLZXlSZWYgKyAnXCInKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZW1hT2JqID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgdiA9IHNjaGVtYU9iai52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHNjaGVtYU9iaik7XG4gIH1cblxuICB2YXIgdmFsaWQgPSB2KGRhdGEpO1xuICBpZiAodi4kYXN5bmMgIT09IHRydWUpIHRoaXMuZXJyb3JzID0gdi5lcnJvcnM7XG4gIHJldHVybiB2YWxpZDtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hLlxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSAge0Jvb2xlYW59IF9tZXRhIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSB0byBjb21waWxlIG1ldGEgc2NoZW1hcyBvZiBjdXN0b20ga2V5d29yZHMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdmFsaWRhdGluZyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgdmFyIHNjaGVtYU9iaiA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIHVuZGVmaW5lZCwgX21ldGEpO1xuICByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUoc2NoZW1hT2JqKTtcbn1cblxuXG4vKipcbiAqIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZS5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc2NoZW1hIHNjaGVtYSBvciBhcnJheSBvZiBzY2hlbWFzLiBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIGFuZCBvdGhlciBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gX3NraXBWYWxpZGF0aW9uIHRydWUgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gX21ldGEgdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRTY2hlbWEoc2NoZW1hLCBrZXksIF9za2lwVmFsaWRhdGlvbiwgX21ldGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSl7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykgdGhpcy5hZGRTY2hlbWEoc2NoZW1hW2ldLCB1bmRlZmluZWQsIF9za2lwVmFsaWRhdGlvbiwgX21ldGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBpZCA9IHRoaXMuX2dldElkKHNjaGVtYSk7XG4gIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpZCAhPSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSBpZCBtdXN0IGJlIHN0cmluZycpO1xuICBrZXkgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleSB8fCBpZCk7XG4gIGNoZWNrVW5pcXVlKHRoaXMsIGtleSk7XG4gIHRoaXMuX3NjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9za2lwVmFsaWRhdGlvbiwgX21ldGEsIHRydWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICogb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgb3B0aW9uYWwgc2NoZW1hIGtleVxuICogQHBhcmFtIHtCb29sZWFufSBza2lwVmFsaWRhdGlvbiB0cnVlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAqIEByZXR1cm4ge0Fqdn0gdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gKi9cbmZ1bmN0aW9uIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIHNraXBWYWxpZGF0aW9uKSB7XG4gIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBza2lwVmFsaWRhdGlvbiwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogVmFsaWRhdGUgc2NoZW1hXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdGhyb3dPckxvZ0Vycm9yIHBhc3MgdHJ1ZSB0byB0aHJvdyAob3IgbG9nKSBhbiBlcnJvciBpZiBpbnZhbGlkXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjaGVtYSBpcyB2YWxpZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICB2YXIgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMuX29wdHMuZGVmYXVsdE1ldGEgfHwgZGVmYXVsdE1ldGEodGhpcyk7XG4gIGlmICghJHNjaGVtYSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ21ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGUnKTtcbiAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgIHZhciBtZXNzYWdlID0gJ3NjaGVtYSBpcyBpbnZhbGlkOiAnICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgaWYgKHRoaXMuX29wdHMudmFsaWRhdGVTY2hlbWEgPT0gJ2xvZycpIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0TWV0YShzZWxmKSB7XG4gIHZhciBtZXRhID0gc2VsZi5fb3B0cy5tZXRhO1xuICBzZWxmLl9vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuX2dldElkKG1ldGEpIHx8IG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBNRVRBX1NDSEVNQV9JRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZWxmLl9vcHRzLmRlZmF1bHRNZXRhO1xufVxuXG5cbi8qKlxuICogR2V0IGNvbXBpbGVkIHNjaGVtYSBmcm9tIHRoZSBpbnN0YW5jZSBieSBga2V5YCBvciBgcmVmYC5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGtleVJlZiBga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIChgc2NoZW1hLmlkYCBvciByZXNvbHZlZCBpZCkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gc2NoZW1hIHZhbGlkYXRpbmcgZnVuY3Rpb24gKHdpdGggcHJvcGVydHkgYHNjaGVtYWApLlxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKHRoaXMsIGtleVJlZik7XG4gIHN3aXRjaCAodHlwZW9mIHNjaGVtYU9iaikge1xuICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShzY2hlbWFPYmopO1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0aGlzLmdldFNjaGVtYShzY2hlbWFPYmopO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiBfZ2V0U2NoZW1hRnJhZ21lbnQodGhpcywga2V5UmVmKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIF9nZXRTY2hlbWFGcmFnbWVudChzZWxmLCByZWYpIHtcbiAgdmFyIHJlcyA9IHJlc29sdmUuc2NoZW1hLmNhbGwoc2VsZiwgeyBzY2hlbWE6IHt9IH0sIHJlZik7XG4gIGlmIChyZXMpIHtcbiAgICB2YXIgc2NoZW1hID0gcmVzLnNjaGVtYVxuICAgICAgLCByb290ID0gcmVzLnJvb3RcbiAgICAgICwgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICB2YXIgdiA9IGNvbXBpbGVTY2hlbWEuY2FsbChzZWxmLCBzY2hlbWEsIHJvb3QsIHVuZGVmaW5lZCwgYmFzZUlkKTtcbiAgICBzZWxmLl9mcmFnbWVudHNbcmVmXSA9IG5ldyBTY2hlbWFPYmplY3Qoe1xuICAgICAgcmVmOiByZWYsXG4gICAgICBmcmFnbWVudDogdHJ1ZSxcbiAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIGJhc2VJZDogYmFzZUlkLFxuICAgICAgdmFsaWRhdGU6IHZcbiAgICB9KTtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIF9nZXRTY2hlbWFPYmooc2VsZiwga2V5UmVmKSB7XG4gIGtleVJlZiA9IHJlc29sdmUubm9ybWFsaXplSWQoa2V5UmVmKTtcbiAgcmV0dXJuIHNlbGYuX3NjaGVtYXNba2V5UmVmXSB8fCBzZWxmLl9yZWZzW2tleVJlZl0gfHwgc2VsZi5fZnJhZ21lbnRzW2tleVJlZl07XG59XG5cblxuLyoqXG4gKiBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAqIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAqIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICogRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBzY2hlbWFLZXlSZWYga2V5LCByZWYsIHBhdHRlcm4gdG8gbWF0Y2gga2V5L3JlZiBvciBzY2hlbWEgb2JqZWN0XG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9zY2hlbWFzLCBzY2hlbWFLZXlSZWYpO1xuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3JlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3NjaGVtYXMpO1xuICAgICAgX3JlbW92ZUFsbFNjaGVtYXModGhpcywgdGhpcy5fcmVmcyk7XG4gICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICBpZiAoc2NoZW1hT2JqKSB0aGlzLl9jYWNoZS5kZWwoc2NoZW1hT2JqLmNhY2hlS2V5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICBkZWxldGUgdGhpcy5fcmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9vcHRzLnNlcmlhbGl6ZTtcbiAgICAgIHZhciBjYWNoZUtleSA9IHNlcmlhbGl6ZSA/IHNlcmlhbGl6ZShzY2hlbWFLZXlSZWYpIDogc2NoZW1hS2V5UmVmO1xuICAgICAgdGhpcy5fY2FjaGUuZGVsKGNhY2hlS2V5KTtcbiAgICAgIHZhciBpZCA9IHRoaXMuX2dldElkKHNjaGVtYUtleVJlZik7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgaWQgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGlkKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVtYXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmc1tpZF07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuZnVuY3Rpb24gX3JlbW92ZUFsbFNjaGVtYXMoc2VsZiwgc2NoZW1hcywgcmVnZXgpIHtcbiAgZm9yICh2YXIga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICB2YXIgc2NoZW1hT2JqID0gc2NoZW1hc1trZXlSZWZdO1xuICAgIGlmICghc2NoZW1hT2JqLm1ldGEgJiYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpKSB7XG4gICAgICBzZWxmLl9jYWNoZS5kZWwoc2NoZW1hT2JqLmNhY2hlS2V5KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgfVxuICB9XG59XG5cblxuLyogQHRoaXMgICBBanYgKi9cbmZ1bmN0aW9uIF9hZGRTY2hlbWEoc2NoZW1hLCBza2lwVmFsaWRhdGlvbiwgbWV0YSwgc2hvdWxkQWRkU2NoZW1hKSB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnICYmIHR5cGVvZiBzY2hlbWEgIT0gJ2Jvb2xlYW4nKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hIHNob3VsZCBiZSBvYmplY3Qgb3IgYm9vbGVhbicpO1xuICB2YXIgc2VyaWFsaXplID0gdGhpcy5fb3B0cy5zZXJpYWxpemU7XG4gIHZhciBjYWNoZUtleSA9IHNlcmlhbGl6ZSA/IHNlcmlhbGl6ZShzY2hlbWEpIDogc2NoZW1hO1xuICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcblxuICBzaG91bGRBZGRTY2hlbWEgPSBzaG91bGRBZGRTY2hlbWEgfHwgdGhpcy5fb3B0cy5hZGRVc2VkU2NoZW1hICE9PSBmYWxzZTtcblxuICB2YXIgaWQgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKHRoaXMuX2dldElkKHNjaGVtYSkpO1xuICBpZiAoaWQgJiYgc2hvdWxkQWRkU2NoZW1hKSBjaGVja1VuaXF1ZSh0aGlzLCBpZCk7XG5cbiAgdmFyIHdpbGxWYWxpZGF0ZSA9IHRoaXMuX29wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlICYmICFza2lwVmFsaWRhdGlvbjtcbiAgdmFyIHJlY3Vyc2l2ZU1ldGE7XG4gIGlmICh3aWxsVmFsaWRhdGUgJiYgIShyZWN1cnNpdmVNZXRhID0gaWQgJiYgaWQgPT0gcmVzb2x2ZS5ub3JtYWxpemVJZChzY2hlbWEuJHNjaGVtYSkpKVxuICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKTtcblxuICB2YXIgbG9jYWxSZWZzID0gcmVzb2x2ZS5pZHMuY2FsbCh0aGlzLCBzY2hlbWEpO1xuXG4gIHZhciBzY2hlbWFPYmogPSBuZXcgU2NoZW1hT2JqZWN0KHtcbiAgICBpZDogaWQsXG4gICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgbG9jYWxSZWZzOiBsb2NhbFJlZnMsXG4gICAgY2FjaGVLZXk6IGNhY2hlS2V5LFxuICAgIG1ldGE6IG1ldGFcbiAgfSk7XG5cbiAgaWYgKGlkWzBdICE9ICcjJyAmJiBzaG91bGRBZGRTY2hlbWEpIHRoaXMuX3JlZnNbaWRdID0gc2NoZW1hT2JqO1xuICB0aGlzLl9jYWNoZS5wdXQoY2FjaGVLZXksIHNjaGVtYU9iaik7XG5cbiAgaWYgKHdpbGxWYWxpZGF0ZSAmJiByZWN1cnNpdmVNZXRhKSB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHNjaGVtYU9iajtcbn1cblxuXG4vKiBAdGhpcyAgIEFqdiAqL1xuZnVuY3Rpb24gX2NvbXBpbGUoc2NoZW1hT2JqLCByb290KSB7XG4gIGlmIChzY2hlbWFPYmouY29tcGlsaW5nKSB7XG4gICAgc2NoZW1hT2JqLnZhbGlkYXRlID0gY2FsbFZhbGlkYXRlO1xuICAgIGNhbGxWYWxpZGF0ZS5zY2hlbWEgPSBzY2hlbWFPYmouc2NoZW1hO1xuICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgIGNhbGxWYWxpZGF0ZS5yb290ID0gcm9vdCA/IHJvb3QgOiBjYWxsVmFsaWRhdGU7XG4gICAgaWYgKHNjaGVtYU9iai5zY2hlbWEuJGFzeW5jID09PSB0cnVlKVxuICAgICAgY2FsbFZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgcmV0dXJuIGNhbGxWYWxpZGF0ZTtcbiAgfVxuICBzY2hlbWFPYmouY29tcGlsaW5nID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudE9wdHM7XG4gIGlmIChzY2hlbWFPYmoubWV0YSkge1xuICAgIGN1cnJlbnRPcHRzID0gdGhpcy5fb3B0cztcbiAgICB0aGlzLl9vcHRzID0gdGhpcy5fbWV0YU9wdHM7XG4gIH1cblxuICB2YXIgdjtcbiAgdHJ5IHsgdiA9IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWFPYmouc2NoZW1hLCByb290LCBzY2hlbWFPYmoubG9jYWxSZWZzKTsgfVxuICBjYXRjaChlKSB7XG4gICAgZGVsZXRlIHNjaGVtYU9iai52YWxpZGF0ZTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIGZpbmFsbHkge1xuICAgIHNjaGVtYU9iai5jb21waWxpbmcgPSBmYWxzZTtcbiAgICBpZiAoc2NoZW1hT2JqLm1ldGEpIHRoaXMuX29wdHMgPSBjdXJyZW50T3B0cztcbiAgfVxuXG4gIHNjaGVtYU9iai52YWxpZGF0ZSA9IHY7XG4gIHNjaGVtYU9iai5yZWZzID0gdi5yZWZzO1xuICBzY2hlbWFPYmoucmVmVmFsID0gdi5yZWZWYWw7XG4gIHNjaGVtYU9iai5yb290ID0gdi5yb290O1xuICByZXR1cm4gdjtcblxuXG4gIC8qIEB0aGlzICAgeyp9IC0gY3VzdG9tIGNvbnRleHQsIHNlZSBwYXNzQ29udGV4dCBvcHRpb24gKi9cbiAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKCkge1xuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICB2YXIgX3ZhbGlkYXRlID0gc2NoZW1hT2JqLnZhbGlkYXRlO1xuICAgIHZhciByZXN1bHQgPSBfdmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gX3ZhbGlkYXRlLmVycm9ycztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hvb3NlR2V0SWQob3B0cykge1xuICBzd2l0Y2ggKG9wdHMuc2NoZW1hSWQpIHtcbiAgICBjYXNlICdhdXRvJzogcmV0dXJuIF9nZXQkSWRPcklkO1xuICAgIGNhc2UgJ2lkJzogcmV0dXJuIF9nZXRJZDtcbiAgICBkZWZhdWx0OiByZXR1cm4gX2dldCRJZDtcbiAgfVxufVxuXG4vKiBAdGhpcyAgIEFqdiAqL1xuZnVuY3Rpb24gX2dldElkKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLiRpZCkgdGhpcy5sb2dnZXIud2Fybignc2NoZW1hICRpZCBpZ25vcmVkJywgc2NoZW1hLiRpZCk7XG4gIHJldHVybiBzY2hlbWEuaWQ7XG59XG5cbi8qIEB0aGlzICAgQWp2ICovXG5mdW5jdGlvbiBfZ2V0JElkKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmlkKSB0aGlzLmxvZ2dlci53YXJuKCdzY2hlbWEgaWQgaWdub3JlZCcsIHNjaGVtYS5pZCk7XG4gIHJldHVybiBzY2hlbWEuJGlkO1xufVxuXG5cbmZ1bmN0aW9uIF9nZXQkSWRPcklkKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLiRpZCAmJiBzY2hlbWEuaWQgJiYgc2NoZW1hLiRpZCAhPSBzY2hlbWEuaWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgJGlkIGlzIGRpZmZlcmVudCBmcm9tIGlkJyk7XG4gIHJldHVybiBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgZXJyb3IgbWVzc2FnZSBvYmplY3RzIHRvIHN0cmluZ1xuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge0FycmF5PE9iamVjdD59IGVycm9ycyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9ycywgaWYgbm90IHBhc3NlZCBlcnJvcnMgZnJvbSB0aGUgaW5zdGFuY2UgYXJlIHVzZWQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYC5cbiAqIEByZXR1cm4ge1N0cmluZ30gaHVtYW4gcmVhZGFibGUgc3RyaW5nIHdpdGggYWxsIGVycm9ycyBkZXNjcmlwdGlvbnNcbiAqL1xuZnVuY3Rpb24gZXJyb3JzVGV4dChlcnJvcnMsIG9wdGlvbnMpIHtcbiAgZXJyb3JzID0gZXJyb3JzIHx8IHRoaXMuZXJyb3JzO1xuICBpZiAoIWVycm9ycykgcmV0dXJuICdObyBlcnJvcnMnO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCAnIDogb3B0aW9ucy5zZXBhcmF0b3I7XG4gIHZhciBkYXRhVmFyID0gb3B0aW9ucy5kYXRhVmFyID09PSB1bmRlZmluZWQgPyAnZGF0YScgOiBvcHRpb25zLmRhdGFWYXI7XG5cbiAgdmFyIHRleHQgPSAnJztcbiAgZm9yICh2YXIgaT0wOyBpPGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZXJyb3JzW2ldO1xuICAgIGlmIChlKSB0ZXh0ICs9IGRhdGFWYXIgKyBlLmRhdGFQYXRoICsgJyAnICsgZS5tZXNzYWdlICsgc2VwYXJhdG9yO1xuICB9XG4gIHJldHVybiB0ZXh0LnNsaWNlKDAsIC1zZXBhcmF0b3IubGVuZ3RoKTtcbn1cblxuXG4vKipcbiAqIEFkZCBjdXN0b20gZm9ybWF0XG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZm9ybWF0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cHxGdW5jdGlvbn0gZm9ybWF0IHN0cmluZyBpcyBjb252ZXJ0ZWQgdG8gUmVnRXhwOyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGJvb2xlYW4gKHRydWUgd2hlbiB2YWxpZClcbiAqIEByZXR1cm4ge0Fqdn0gdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gKi9cbmZ1bmN0aW9uIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gJ3N0cmluZycpIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgdGhpcy5fZm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuZnVuY3Rpb24gYWRkRGVmYXVsdE1ldGFTY2hlbWEoc2VsZikge1xuICB2YXIgJGRhdGFTY2hlbWE7XG4gIGlmIChzZWxmLl9vcHRzLiRkYXRhKSB7XG4gICAgJGRhdGFTY2hlbWEgPSByZXF1aXJlKCcuL3JlZnMvZGF0YS5qc29uJyk7XG4gICAgc2VsZi5hZGRNZXRhU2NoZW1hKCRkYXRhU2NoZW1hLCAkZGF0YVNjaGVtYS4kaWQsIHRydWUpO1xuICB9XG4gIGlmIChzZWxmLl9vcHRzLm1ldGEgPT09IGZhbHNlKSByZXR1cm47XG4gIHZhciBtZXRhU2NoZW1hID0gcmVxdWlyZSgnLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb24nKTtcbiAgaWYgKHNlbGYuX29wdHMuJGRhdGEpIG1ldGFTY2hlbWEgPSAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TVVBQT1JUX0RBVEEpO1xuICBzZWxmLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIHRydWUpO1xuICBzZWxmLl9yZWZzWydodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSddID0gTUVUQV9TQ0hFTUFfSUQ7XG59XG5cblxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoc2VsZikge1xuICB2YXIgb3B0c1NjaGVtYXMgPSBzZWxmLl9vcHRzLnNjaGVtYXM7XG4gIGlmICghb3B0c1NjaGVtYXMpIHJldHVybjtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKSBzZWxmLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gIGVsc2UgZm9yICh2YXIga2V5IGluIG9wdHNTY2hlbWFzKSBzZWxmLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldLCBrZXkpO1xufVxuXG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKHNlbGYpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBzZWxmLl9vcHRzLmZvcm1hdHMpIHtcbiAgICB2YXIgZm9ybWF0ID0gc2VsZi5fb3B0cy5mb3JtYXRzW25hbWVdO1xuICAgIHNlbGYuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoc2VsZikge1xuICBmb3IgKHZhciBuYW1lIGluIHNlbGYuX29wdHMua2V5d29yZHMpIHtcbiAgICB2YXIga2V5d29yZCA9IHNlbGYuX29wdHMua2V5d29yZHNbbmFtZV07XG4gICAgc2VsZi5hZGRLZXl3b3JkKG5hbWUsIGtleXdvcmQpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hlY2tVbmlxdWUoc2VsZiwgaWQpIHtcbiAgaWYgKHNlbGYuX3NjaGVtYXNbaWRdIHx8IHNlbGYuX3JlZnNbaWRdKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG59XG5cblxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoc2VsZikge1xuICB2YXIgbWV0YU9wdHMgPSB1dGlsLmNvcHkoc2VsZi5fb3B0cyk7XG4gIGZvciAodmFyIGk9MDsgaTxNRVRBX0lHTk9SRV9PUFRJT05TLmxlbmd0aDsgaSsrKVxuICAgIGRlbGV0ZSBtZXRhT3B0c1tNRVRBX0lHTk9SRV9PUFRJT05TW2ldXTtcbiAgcmV0dXJuIG1ldGFPcHRzO1xufVxuXG5cbmZ1bmN0aW9uIHNldExvZ2dlcihzZWxmKSB7XG4gIHZhciBsb2dnZXIgPSBzZWxmLl9vcHRzLmxvZ2dlcjtcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLmxvZ2dlciA9IHtsb2c6IG5vb3AsIHdhcm46IG5vb3AsIGVycm9yOiBub29wfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIGxvZ2dlciA9IGNvbnNvbGU7XG4gICAgaWYgKCEodHlwZW9mIGxvZ2dlciA9PSAnb2JqZWN0JyAmJiBsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHMnKTtcbiAgICBzZWxmLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoJy4vcmVzb2x2ZScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICwgZXJyb3JDbGFzc2VzID0gcmVxdWlyZSgnLi9lcnJvcl9jbGFzc2VzJylcbiAgLCBzdGFibGVTdHJpbmdpZnkgPSByZXF1aXJlKCdmYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeScpO1xuXG52YXIgdmFsaWRhdGVHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9kb3Rqcy92YWxpZGF0ZScpO1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBiZWxvdyBhcmUgdXNlZCBpbnNpZGUgY29tcGlsZWQgdmFsaWRhdGlvbnMgZnVuY3Rpb25cbiAqL1xuXG52YXIgdWNzMmxlbmd0aCA9IHV0aWwudWNzMmxlbmd0aDtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpO1xuXG4vLyB0aGlzIGVycm9yIGlzIHRocm93biBieSBhc3luYyBzY2hlbWFzIHRvIHJldHVybiB2YWxpZGF0aW9uIGVycm9ycyB2aWEgZXhjZXB0aW9uXG52YXIgVmFsaWRhdGlvbkVycm9yID0gZXJyb3JDbGFzc2VzLlZhbGlkYXRpb247XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcblxuXG4vKipcbiAqIENvbXBpbGVzIHNjaGVtYSB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIG9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSByb290IG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb290IHNjaGVtYSBmb3IgdGhpcyBzY2hlbWFcbiAqIEBwYXJhbSAge09iamVjdH0gbG9jYWxSZWZzIHRoZSBoYXNoIG9mIGxvY2FsIHJlZmVyZW5jZXMgaW5zaWRlIHRoZSBzY2hlbWEgKGNyZWF0ZWQgYnkgcmVzb2x2ZS5pZCksIHVzZWQgZm9yIGlubGluZSByZXNvbHV0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJhc2VJZCBiYXNlIElEIGZvciBJRHMgaW4gdGhlIHNjaGVtYVxuICogQHJldHVybiB7RnVuY3Rpb259IHZhbGlkYXRpb24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUsIGV2aWw6IHRydWUgKi9cbiAgLyogZXNsaW50IG5vLXNoYWRvdzogMCAqL1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIG9wdHMgPSB0aGlzLl9vcHRzXG4gICAgLCByZWZWYWwgPSBbIHVuZGVmaW5lZCBdXG4gICAgLCByZWZzID0ge31cbiAgICAsIHBhdHRlcm5zID0gW11cbiAgICAsIHBhdHRlcm5zSGFzaCA9IHt9XG4gICAgLCBkZWZhdWx0cyA9IFtdXG4gICAgLCBkZWZhdWx0c0hhc2ggPSB7fVxuICAgICwgY3VzdG9tUnVsZXMgPSBbXTtcblxuICByb290ID0gcm9vdCB8fCB7IHNjaGVtYTogc2NoZW1hLCByZWZWYWw6IHJlZlZhbCwgcmVmczogcmVmcyB9O1xuXG4gIHZhciBjID0gY2hlY2tDb21waWxpbmcuY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIGJhc2VJZCk7XG4gIHZhciBjb21waWxhdGlvbiA9IHRoaXMuX2NvbXBpbGF0aW9uc1tjLmluZGV4XTtcbiAgaWYgKGMuY29tcGlsaW5nKSByZXR1cm4gKGNvbXBpbGF0aW9uLmNhbGxWYWxpZGF0ZSA9IGNhbGxWYWxpZGF0ZSk7XG5cbiAgdmFyIGZvcm1hdHMgPSB0aGlzLl9mb3JtYXRzO1xuICB2YXIgUlVMRVMgPSB0aGlzLlJVTEVTO1xuXG4gIHRyeSB7XG4gICAgdmFyIHYgPSBsb2NhbENvbXBpbGUoc2NoZW1hLCByb290LCBsb2NhbFJlZnMsIGJhc2VJZCk7XG4gICAgY29tcGlsYXRpb24udmFsaWRhdGUgPSB2O1xuICAgIHZhciBjdiA9IGNvbXBpbGF0aW9uLmNhbGxWYWxpZGF0ZTtcbiAgICBpZiAoY3YpIHtcbiAgICAgIGN2LnNjaGVtYSA9IHYuc2NoZW1hO1xuICAgICAgY3YuZXJyb3JzID0gbnVsbDtcbiAgICAgIGN2LnJlZnMgPSB2LnJlZnM7XG4gICAgICBjdi5yZWZWYWwgPSB2LnJlZlZhbDtcbiAgICAgIGN2LnJvb3QgPSB2LnJvb3Q7XG4gICAgICBjdi4kYXN5bmMgPSB2LiRhc3luYztcbiAgICAgIGlmIChvcHRzLnNvdXJjZUNvZGUpIGN2LnNvdXJjZSA9IHYuc291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRDb21waWxpbmcuY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIGJhc2VJZCk7XG4gIH1cblxuICAvKiBAdGhpcyAgIHsqfSAtIGN1c3RvbSBjb250ZXh0LCBzZWUgcGFzc0NvbnRleHQgb3B0aW9uICovXG4gIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgdmFyIHZhbGlkYXRlID0gY29tcGlsYXRpb24udmFsaWRhdGU7XG4gICAgdmFyIHJlc3VsdCA9IHZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY2FsbFZhbGlkYXRlLmVycm9ycyA9IHZhbGlkYXRlLmVycm9ycztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxDb21waWxlKF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAgIHZhciBpc1Jvb3QgPSAhX3Jvb3QgfHwgKF9yb290ICYmIF9yb290LnNjaGVtYSA9PSBfc2NoZW1hKTtcbiAgICBpZiAoX3Jvb3Quc2NoZW1hICE9IHJvb3Quc2NoZW1hKVxuICAgICAgcmV0dXJuIGNvbXBpbGUuY2FsbChzZWxmLCBfc2NoZW1hLCBfcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuXG4gICAgdmFyICRhc3luYyA9IF9zY2hlbWEuJGFzeW5jID09PSB0cnVlO1xuXG4gICAgdmFyIHNvdXJjZUNvZGUgPSB2YWxpZGF0ZUdlbmVyYXRvcih7XG4gICAgICBpc1RvcDogdHJ1ZSxcbiAgICAgIHNjaGVtYTogX3NjaGVtYSxcbiAgICAgIGlzUm9vdDogaXNSb290LFxuICAgICAgYmFzZUlkOiBiYXNlSWQsXG4gICAgICByb290OiBfcm9vdCxcbiAgICAgIHNjaGVtYVBhdGg6ICcnLFxuICAgICAgZXJyU2NoZW1hUGF0aDogJyMnLFxuICAgICAgZXJyb3JQYXRoOiAnXCJcIicsXG4gICAgICBNaXNzaW5nUmVmRXJyb3I6IGVycm9yQ2xhc3Nlcy5NaXNzaW5nUmVmLFxuICAgICAgUlVMRVM6IFJVTEVTLFxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlR2VuZXJhdG9yLFxuICAgICAgdXRpbDogdXRpbCxcbiAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICByZXNvbHZlUmVmOiByZXNvbHZlUmVmLFxuICAgICAgdXNlUGF0dGVybjogdXNlUGF0dGVybixcbiAgICAgIHVzZURlZmF1bHQ6IHVzZURlZmF1bHQsXG4gICAgICB1c2VDdXN0b21SdWxlOiB1c2VDdXN0b21SdWxlLFxuICAgICAgb3B0czogb3B0cyxcbiAgICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgICBsb2dnZXI6IHNlbGYubG9nZ2VyLFxuICAgICAgc2VsZjogc2VsZlxuICAgIH0pO1xuXG4gICAgc291cmNlQ29kZSA9IHZhcnMocmVmVmFsLCByZWZWYWxDb2RlKSArIHZhcnMocGF0dGVybnMsIHBhdHRlcm5Db2RlKVxuICAgICAgICAgICAgICAgICAgICsgdmFycyhkZWZhdWx0cywgZGVmYXVsdENvZGUpICsgdmFycyhjdXN0b21SdWxlcywgY3VzdG9tUnVsZUNvZGUpXG4gICAgICAgICAgICAgICAgICAgKyBzb3VyY2VDb2RlO1xuXG4gICAgaWYgKG9wdHMucHJvY2Vzc0NvZGUpIHNvdXJjZUNvZGUgPSBvcHRzLnByb2Nlc3NDb2RlKHNvdXJjZUNvZGUsIF9zY2hlbWEpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG4gKioqIFxcbicsIEpTT04uc3RyaW5naWZ5KHNvdXJjZUNvZGUpKTtcbiAgICB2YXIgdmFsaWRhdGU7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oXG4gICAgICAgICdzZWxmJyxcbiAgICAgICAgJ1JVTEVTJyxcbiAgICAgICAgJ2Zvcm1hdHMnLFxuICAgICAgICAncm9vdCcsXG4gICAgICAgICdyZWZWYWwnLFxuICAgICAgICAnZGVmYXVsdHMnLFxuICAgICAgICAnY3VzdG9tUnVsZXMnLFxuICAgICAgICAnZXF1YWwnLFxuICAgICAgICAndWNzMmxlbmd0aCcsXG4gICAgICAgICdWYWxpZGF0aW9uRXJyb3InLFxuICAgICAgICBzb3VyY2VDb2RlXG4gICAgICApO1xuXG4gICAgICB2YWxpZGF0ZSA9IG1ha2VWYWxpZGF0ZShcbiAgICAgICAgc2VsZixcbiAgICAgICAgUlVMRVMsXG4gICAgICAgIGZvcm1hdHMsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlZlZhbCxcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIGN1c3RvbVJ1bGVzLFxuICAgICAgICBlcXVhbCxcbiAgICAgICAgdWNzMmxlbmd0aCxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yXG4gICAgICApO1xuXG4gICAgICByZWZWYWxbMF0gPSB2YWxpZGF0ZTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNlbGYubG9nZ2VyLmVycm9yKCdFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOicsIHNvdXJjZUNvZGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBfc2NoZW1hO1xuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgdmFsaWRhdGUucmVmcyA9IHJlZnM7XG4gICAgdmFsaWRhdGUucmVmVmFsID0gcmVmVmFsO1xuICAgIHZhbGlkYXRlLnJvb3QgPSBpc1Jvb3QgPyB2YWxpZGF0ZSA6IF9yb290O1xuICAgIGlmICgkYXN5bmMpIHZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgaWYgKG9wdHMuc291cmNlQ29kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGUuc291cmNlID0ge1xuICAgICAgICBjb2RlOiBzb3VyY2VDb2RlLFxuICAgICAgICBwYXR0ZXJuczogcGF0dGVybnMsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlUmVmKGJhc2VJZCwgcmVmLCBpc1Jvb3QpIHtcbiAgICByZWYgPSByZXNvbHZlLnVybChiYXNlSWQsIHJlZik7XG4gICAgdmFyIHJlZkluZGV4ID0gcmVmc1tyZWZdO1xuICAgIHZhciBfcmVmVmFsLCByZWZDb2RlO1xuICAgIGlmIChyZWZJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBfcmVmVmFsID0gcmVmVmFsW3JlZkluZGV4XTtcbiAgICAgIHJlZkNvZGUgPSAncmVmVmFsWycgKyByZWZJbmRleCArICddJztcbiAgICAgIHJldHVybiByZXNvbHZlZFJlZihfcmVmVmFsLCByZWZDb2RlKTtcbiAgICB9XG4gICAgaWYgKCFpc1Jvb3QgJiYgcm9vdC5yZWZzKSB7XG4gICAgICB2YXIgcm9vdFJlZklkID0gcm9vdC5yZWZzW3JlZl07XG4gICAgICBpZiAocm9vdFJlZklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3JlZlZhbCA9IHJvb3QucmVmVmFsW3Jvb3RSZWZJZF07XG4gICAgICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYsIF9yZWZWYWwpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmQ29kZSA9IGFkZExvY2FsUmVmKHJlZik7XG4gICAgdmFyIHYgPSByZXNvbHZlLmNhbGwoc2VsZiwgbG9jYWxDb21waWxlLCByb290LCByZWYpO1xuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBsb2NhbFNjaGVtYSA9IGxvY2FsUmVmcyAmJiBsb2NhbFJlZnNbcmVmXTtcbiAgICAgIGlmIChsb2NhbFNjaGVtYSkge1xuICAgICAgICB2ID0gcmVzb2x2ZS5pbmxpbmVSZWYobG9jYWxTY2hlbWEsIG9wdHMuaW5saW5lUmVmcylcbiAgICAgICAgICAgID8gbG9jYWxTY2hlbWFcbiAgICAgICAgICAgIDogY29tcGlsZS5jYWxsKHNlbGYsIGxvY2FsU2NoZW1hLCByb290LCBsb2NhbFJlZnMsIGJhc2VJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVtb3ZlTG9jYWxSZWYocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZUxvY2FsUmVmKHJlZiwgdik7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRSZWYodiwgcmVmQ29kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTG9jYWxSZWYocmVmLCB2KSB7XG4gICAgdmFyIHJlZklkID0gcmVmVmFsLmxlbmd0aDtcbiAgICByZWZWYWxbcmVmSWRdID0gdjtcbiAgICByZWZzW3JlZl0gPSByZWZJZDtcbiAgICByZXR1cm4gJ3JlZlZhbCcgKyByZWZJZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxvY2FsUmVmKHJlZikge1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlTG9jYWxSZWYocmVmLCB2KSB7XG4gICAgdmFyIHJlZklkID0gcmVmc1tyZWZdO1xuICAgIHJlZlZhbFtyZWZJZF0gPSB2O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZWRSZWYocmVmVmFsLCBjb2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiByZWZWYWwgPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlZlZhbCA9PSAnYm9vbGVhbidcbiAgICAgICAgICAgID8geyBjb2RlOiBjb2RlLCBzY2hlbWE6IHJlZlZhbCwgaW5saW5lOiB0cnVlIH1cbiAgICAgICAgICAgIDogeyBjb2RlOiBjb2RlLCAkYXN5bmM6IHJlZlZhbCAmJiAhIXJlZlZhbC4kYXN5bmMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZVBhdHRlcm4ocmVnZXhTdHIpIHtcbiAgICB2YXIgaW5kZXggPSBwYXR0ZXJuc0hhc2hbcmVnZXhTdHJdO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IHBhdHRlcm5zSGFzaFtyZWdleFN0cl0gPSBwYXR0ZXJucy5sZW5ndGg7XG4gICAgICBwYXR0ZXJuc1tpbmRleF0gPSByZWdleFN0cjtcbiAgICB9XG4gICAgcmV0dXJuICdwYXR0ZXJuJyArIGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRGVmYXVsdCh2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHV0aWwudG9RdW90ZWRTdHJpbmcodmFsdWUpO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICAgICAgICB2YXIgdmFsdWVTdHIgPSBzdGFibGVTdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB2YXIgaW5kZXggPSBkZWZhdWx0c0hhc2hbdmFsdWVTdHJdO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gZGVmYXVsdHNIYXNoW3ZhbHVlU3RyXSA9IGRlZmF1bHRzLmxlbmd0aDtcbiAgICAgICAgICBkZWZhdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RlZmF1bHQnICsgaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlQ3VzdG9tUnVsZShydWxlLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIHtcbiAgICBpZiAoc2VsZi5fb3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBkZXBzID0gcnVsZS5kZWZpbml0aW9uLmRlcGVuZGVuY2llcztcbiAgICAgIGlmIChkZXBzICYmICFkZXBzLmV2ZXJ5KGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnRTY2hlbWEsIGtleXdvcmQpO1xuICAgICAgfSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgYWxsIHJlcXVpcmVkIGtleXdvcmRzOiAnICsgZGVwcy5qb2luKCcsJykpO1xuXG4gICAgICB2YXIgdmFsaWRhdGVTY2hlbWEgPSBydWxlLmRlZmluaXRpb24udmFsaWRhdGVTY2hlbWE7XG4gICAgICBpZiAodmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gdmFsaWRhdGVTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gJ2tleXdvcmQgc2NoZW1hIGlzIGludmFsaWQ6ICcgKyBzZWxmLmVycm9yc1RleHQodmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICBpZiAoc2VsZi5fb3B0cy52YWxpZGF0ZVNjaGVtYSA9PSAnbG9nJykgc2VsZi5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZSA9IHJ1bGUuZGVmaW5pdGlvbi5jb21waWxlXG4gICAgICAsIGlubGluZSA9IHJ1bGUuZGVmaW5pdGlvbi5pbmxpbmVcbiAgICAgICwgbWFjcm8gPSBydWxlLmRlZmluaXRpb24ubWFjcm87XG5cbiAgICB2YXIgdmFsaWRhdGU7XG4gICAgaWYgKGNvbXBpbGUpIHtcbiAgICAgIHZhbGlkYXRlID0gY29tcGlsZS5jYWxsKHNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgfSBlbHNlIGlmIChtYWNybykge1xuICAgICAgdmFsaWRhdGUgPSBtYWNyby5jYWxsKHNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIHNlbGYudmFsaWRhdGVTY2hlbWEodmFsaWRhdGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoaW5saW5lKSB7XG4gICAgICB2YWxpZGF0ZSA9IGlubGluZS5jYWxsKHNlbGYsIGl0LCBydWxlLmtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGUgPSBydWxlLmRlZmluaXRpb24udmFsaWRhdGU7XG4gICAgICBpZiAoIXZhbGlkYXRlKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRlID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1c3RvbSBrZXl3b3JkIFwiJyArIHJ1bGUua2V5d29yZCArICdcImZhaWxlZCB0byBjb21waWxlJyk7XG5cbiAgICB2YXIgaW5kZXggPSBjdXN0b21SdWxlcy5sZW5ndGg7XG4gICAgY3VzdG9tUnVsZXNbaW5kZXhdID0gdmFsaWRhdGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogJ2N1c3RvbVJ1bGUnICsgaW5kZXgsXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbiAgICB9O1xuICB9XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjaGVtYSBpcyBjdXJyZW50bHkgY29tcGlsZWRcbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgdG8gY29tcGlsZVxuICogQHBhcmFtICB7T2JqZWN0fSByb290IHJvb3Qgb2JqZWN0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJhc2VJZCBiYXNlIHNjaGVtYSBJRFxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIFwiaW5kZXhcIiAoY29tcGlsYXRpb24gaW5kZXgpIGFuZCBcImNvbXBpbGluZ1wiIChib29sZWFuKVxuICovXG5mdW5jdGlvbiBjaGVja0NvbXBpbGluZyhzY2hlbWEsIHJvb3QsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBpbmRleCA9IGNvbXBJbmRleC5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgYmFzZUlkKTtcbiAgaWYgKGluZGV4ID49IDApIHJldHVybiB7IGluZGV4OiBpbmRleCwgY29tcGlsaW5nOiB0cnVlIH07XG4gIGluZGV4ID0gdGhpcy5fY29tcGlsYXRpb25zLmxlbmd0aDtcbiAgdGhpcy5fY29tcGlsYXRpb25zW2luZGV4XSA9IHtcbiAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICByb290OiByb290LFxuICAgIGJhc2VJZDogYmFzZUlkXG4gIH07XG4gIHJldHVybiB7IGluZGV4OiBpbmRleCwgY29tcGlsaW5nOiBmYWxzZSB9O1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2NoZW1hIGZyb20gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdFxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBzY2hlbWEgSURcbiAqL1xuZnVuY3Rpb24gZW5kQ29tcGlsaW5nKHNjaGVtYSwgcm9vdCwgYmFzZUlkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIGkgPSBjb21wSW5kZXguY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIGJhc2VJZCk7XG4gIGlmIChpID49IDApIHRoaXMuX2NvbXBpbGF0aW9ucy5zcGxpY2UoaSwgMSk7XG59XG5cblxuLyoqXG4gKiBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdFxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBzY2hlbWEgSURcbiAqIEByZXR1cm4ge0ludGVnZXJ9IGNvbXBpbGF0aW9uIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGNvbXBJbmRleChzY2hlbWEsIHJvb3QsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIGZvciAodmFyIGk9MDsgaTx0aGlzLl9jb21waWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IHRoaXMuX2NvbXBpbGF0aW9uc1tpXTtcbiAgICBpZiAoYy5zY2hlbWEgPT0gc2NoZW1hICYmIGMucm9vdCA9PSByb290ICYmIGMuYmFzZUlkID09IGJhc2VJZCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbmZ1bmN0aW9uIHBhdHRlcm5Db2RlKGksIHBhdHRlcm5zKSB7XG4gIHJldHVybiAndmFyIHBhdHRlcm4nICsgaSArICcgPSBuZXcgUmVnRXhwKCcgKyB1dGlsLnRvUXVvdGVkU3RyaW5nKHBhdHRlcm5zW2ldKSArICcpOyc7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENvZGUoaSkge1xuICByZXR1cm4gJ3ZhciBkZWZhdWx0JyArIGkgKyAnID0gZGVmYXVsdHNbJyArIGkgKyAnXTsnO1xufVxuXG5cbmZ1bmN0aW9uIHJlZlZhbENvZGUoaSwgcmVmVmFsKSB7XG4gIHJldHVybiByZWZWYWxbaV0gPT09IHVuZGVmaW5lZCA/ICcnIDogJ3ZhciByZWZWYWwnICsgaSArICcgPSByZWZWYWxbJyArIGkgKyAnXTsnO1xufVxuXG5cbmZ1bmN0aW9uIGN1c3RvbVJ1bGVDb2RlKGkpIHtcbiAgcmV0dXJuICd2YXIgY3VzdG9tUnVsZScgKyBpICsgJyA9IGN1c3RvbVJ1bGVzWycgKyBpICsgJ107Jztcbn1cblxuXG5mdW5jdGlvbiB2YXJzKGFyciwgc3RhdGVtZW50KSB7XG4gIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuICcnO1xuICB2YXIgY29kZSA9ICcnO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKVxuICAgIGNvZGUgKz0gc3RhdGVtZW50KGksIGFycik7XG4gIHJldHVybiBjb2RlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJJID0gcmVxdWlyZSgndXJpLWpzJylcbiAgLCBlcXVhbCA9IHJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICwgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZSgnLi9zY2hlbWFfb2JqJylcbiAgLCB0cmF2ZXJzZSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hLXRyYXZlcnNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZTtcblxucmVzb2x2ZS5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xucmVzb2x2ZS5mdWxsUGF0aCA9IGdldEZ1bGxQYXRoO1xucmVzb2x2ZS51cmwgPSByZXNvbHZlVXJsO1xucmVzb2x2ZS5pZHMgPSByZXNvbHZlSWRzO1xucmVzb2x2ZS5pbmxpbmVSZWYgPSBpbmxpbmVSZWY7XG5yZXNvbHZlLnNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG5cbi8qKlxuICogW3Jlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXVxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjb21waWxlIHJlZmVyZW5jZSB0byBzY2hlbWEgY29tcGlsYXRpb24gZnVuY2l0b24gKGxvY2FsQ29tcGlsZSlcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxuICogQHBhcmFtICB7U3RyaW5nfSByZWYgcmVmZXJlbmNlIHRvIHJlc29sdmVcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn0gc2NoZW1hIG9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuICovXG5mdW5jdGlvbiByZXNvbHZlKGNvbXBpbGUsIHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZl07XG4gIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHRoaXMuX3JlZnNbcmVmVmFsXSkgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgIGVsc2UgcmV0dXJuIHJlc29sdmUuY2FsbCh0aGlzLCBjb21waWxlLCByb290LCByZWZWYWwpO1xuICB9XG5cbiAgcmVmVmFsID0gcmVmVmFsIHx8IHRoaXMuX3NjaGVtYXNbcmVmXTtcbiAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgIHJldHVybiBpbmxpbmVSZWYocmVmVmFsLnNjaGVtYSwgdGhpcy5fb3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICAgICAgPyByZWZWYWwuc2NoZW1hXG4gICAgICAgICAgICA6IHJlZlZhbC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gIH1cblxuICB2YXIgcmVzID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gIHZhciBzY2hlbWEsIHYsIGJhc2VJZDtcbiAgaWYgKHJlcykge1xuICAgIHNjaGVtYSA9IHJlcy5zY2hlbWE7XG4gICAgcm9vdCA9IHJlcy5yb290O1xuICAgIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gIH1cblxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KSB7XG4gICAgdiA9IHNjaGVtYS52YWxpZGF0ZSB8fCBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLnNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IGlubGluZVJlZihzY2hlbWEsIHRoaXMuX29wdHMuaW5saW5lUmVmcylcbiAgICAgICAgPyBzY2hlbWFcbiAgICAgICAgOiBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuXG4vKipcbiAqIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG4gKiBAdGhpcyBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZWYWwsIHJlZnNcbiAqIEBwYXJhbSAge1N0cmluZ30gcmVmICByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcm9vdCwgYmFzZUlkXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEocm9vdCwgcmVmKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHAgPSBVUkkucGFyc2UocmVmKVxuICAgICwgcmVmUGF0aCA9IF9nZXRGdWxsUGF0aChwKVxuICAgICwgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5fZ2V0SWQocm9vdC5zY2hlbWEpKTtcbiAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPT09IDAgfHwgcmVmUGF0aCAhPT0gYmFzZUlkKSB7XG4gICAgdmFyIGlkID0gbm9ybWFsaXplSWQocmVmUGF0aCk7XG4gICAgdmFyIHJlZlZhbCA9IHRoaXMuX3JlZnNbaWRdO1xuICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVJlY3Vyc2l2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZlZhbCwgcCk7XG4gICAgfSBlbHNlIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKSB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gICAgICByb290ID0gcmVmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZWYWwgPSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgICAgaWYgKCFyZWZWYWwudmFsaWRhdGUpIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgICAgaWYgKGlkID09IG5vcm1hbGl6ZUlkKHJlZikpXG4gICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiByZWZWYWwsIHJvb3Q6IHJvb3QsIGJhc2VJZDogYmFzZUlkIH07XG4gICAgICAgIHJvb3QgPSByZWZWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcm9vdC5zY2hlbWEpIHJldHVybjtcbiAgICBiYXNlSWQgPSBnZXRGdWxsUGF0aCh0aGlzLl9nZXRJZChyb290LnNjaGVtYSkpO1xuICB9XG4gIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIGJhc2VJZCwgcm9vdC5zY2hlbWEsIHJvb3QpO1xufVxuXG5cbi8qIEB0aGlzIEFqdiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlY3Vyc2l2ZShyb290LCByZWYsIHBhcnNlZFJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZXMgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgaWYgKHJlcykge1xuICAgIHZhciBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHZhciBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWEpO1xuICAgIGlmIChpZCkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIGlkKTtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwYXJzZWRSZWYsIGJhc2VJZCwgc2NoZW1hLCByb290KTtcbiAgfVxufVxuXG5cbnZhciBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IHV0aWwudG9IYXNoKFsncHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycsICdlbnVtJywgJ2RlcGVuZGVuY2llcycsICdkZWZpbml0aW9ucyddKTtcbi8qIEB0aGlzIEFqdiAqL1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHBhcnNlZFJlZi5mcmFnbWVudCA9IHBhcnNlZFJlZi5mcmFnbWVudCB8fCAnJztcbiAgaWYgKHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgwLDEpICE9ICcvJykgcmV0dXJuO1xuICB2YXIgcGFydHMgPSBwYXJzZWRSZWYuZnJhZ21lbnQuc3BsaXQoJy8nKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydCA9IHV0aWwudW5lc2NhcGVGcmFnbWVudChwYXJ0KTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYVtwYXJ0XTtcbiAgICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICB2YXIgaWQ7XG4gICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFW3BhcnRdKSB7XG4gICAgICAgIGlkID0gdGhpcy5fZ2V0SWQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlkKSBiYXNlSWQgPSByZXNvbHZlVXJsKGJhc2VJZCwgaWQpO1xuICAgICAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICB2YXIgJHJlZiA9IHJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgICAgdmFyIHJlcyA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgICAgICAgICAgcm9vdCA9IHJlcy5yb290O1xuICAgICAgICAgICAgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gcm9vdC5zY2hlbWEpXG4gICAgcmV0dXJuIHsgc2NoZW1hOiBzY2hlbWEsIHJvb3Q6IHJvb3QsIGJhc2VJZDogYmFzZUlkIH07XG59XG5cblxudmFyIFNJTVBMRV9JTkxJTkVEID0gdXRpbC50b0hhc2goW1xuICAndHlwZScsICdmb3JtYXQnLCAncGF0dGVybicsXG4gICdtYXhMZW5ndGgnLCAnbWluTGVuZ3RoJyxcbiAgJ21heFByb3BlcnRpZXMnLCAnbWluUHJvcGVydGllcycsXG4gICdtYXhJdGVtcycsICdtaW5JdGVtcycsXG4gICdtYXhpbXVtJywgJ21pbmltdW0nLFxuICAndW5pcXVlSXRlbXMnLCAnbXVsdGlwbGVPZicsXG4gICdyZXF1aXJlZCcsICdlbnVtJ1xuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCkge1xuICBpZiAobGltaXQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0ID09PSB0cnVlKSByZXR1cm4gY2hlY2tOb1JlZihzY2hlbWEpO1xuICBlbHNlIGlmIChsaW1pdCkgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrTm9SZWYoc2NoZW1hKSB7XG4gIHZhciBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IHNjaGVtYVtpXTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIGZhbHNlO1xuICAgICAgaXRlbSA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnICYmICFjaGVja05vUmVmKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgdmFyIGNvdW50ID0gMCwgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKTtcbiAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIEluZmluaXR5O1xuICAgICAgaWYgKFNJTVBMRV9JTkxJTkVEW2tleV0pIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSBjb3VudCArPSBjb3VudEtleXMoaXRlbSkgKyAxO1xuICAgICAgICBpZiAoY291bnQgPT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkLCBub3JtYWxpemUpIHtcbiAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICB2YXIgcCA9IFVSSS5wYXJzZShpZCk7XG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5cblxuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgcmV0dXJuIFVSSS5zZXJpYWxpemUocCkuc3BsaXQoJyMnKVswXSArICcjJztcbn1cblxuXG52YXIgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCAnJykgOiAnJztcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHJldHVybiBVUkkucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cblxuXG4vKiBAdGhpcyBBanYgKi9cbmZ1bmN0aW9uIHJlc29sdmVJZHMoc2NoZW1hKSB7XG4gIHZhciBzY2hlbWFJZCA9IG5vcm1hbGl6ZUlkKHRoaXMuX2dldElkKHNjaGVtYSkpO1xuICB2YXIgYmFzZUlkcyA9IHsnJzogc2NoZW1hSWR9O1xuICB2YXIgZnVsbFBhdGhzID0geycnOiBnZXRGdWxsUGF0aChzY2hlbWFJZCwgZmFsc2UpfTtcbiAgdmFyIGxvY2FsUmVmcyA9IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJhdmVyc2Uoc2NoZW1hLCB7YWxsS2V5czogdHJ1ZX0sIGZ1bmN0aW9uKHNjaCwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICAgIGlmIChqc29uUHRyID09PSAnJykgcmV0dXJuO1xuICAgIHZhciBpZCA9IHNlbGYuX2dldElkKHNjaCk7XG4gICAgdmFyIGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgdmFyIGZ1bGxQYXRoID0gZnVsbFBhdGhzW3BhcmVudEpzb25QdHJdICsgJy8nICsgcGFyZW50S2V5d29yZDtcbiAgICBpZiAoa2V5SW5kZXggIT09IHVuZGVmaW5lZClcbiAgICAgIGZ1bGxQYXRoICs9ICcvJyArICh0eXBlb2Yga2V5SW5kZXggPT0gJ251bWJlcicgPyBrZXlJbmRleCA6IHV0aWwuZXNjYXBlRnJhZ21lbnQoa2V5SW5kZXgpKTtcblxuICAgIGlmICh0eXBlb2YgaWQgPT0gJ3N0cmluZycpIHtcbiAgICAgIGlkID0gYmFzZUlkID0gbm9ybWFsaXplSWQoYmFzZUlkID8gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCkgOiBpZCk7XG5cbiAgICAgIHZhciByZWZWYWwgPSBzZWxmLl9yZWZzW2lkXTtcbiAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSByZWZWYWwgPSBzZWxmLl9yZWZzW3JlZlZhbF07XG4gICAgICBpZiAocmVmVmFsICYmIHJlZlZhbC5zY2hlbWEpIHtcbiAgICAgICAgaWYgKCFlcXVhbChzY2gsIHJlZlZhbC5zY2hlbWEpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgIH0gZWxzZSBpZiAoaWQgIT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgIGlmIChpZFswXSA9PSAnIycpIHtcbiAgICAgICAgICBpZiAobG9jYWxSZWZzW2lkXSAmJiAhZXF1YWwoc2NoLCBsb2NhbFJlZnNbaWRdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgICBsb2NhbFJlZnNbaWRdID0gc2NoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3JlZnNbaWRdID0gZnVsbFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZDtcbiAgICBmdWxsUGF0aHNbanNvblB0cl0gPSBmdWxsUGF0aDtcbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsUmVmcztcbn1cbiIsIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iLCJpbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4vdXJpXCI7XG5cbmltcG9ydCBodHRwIGZyb20gXCIuL3NjaGVtZXMvaHR0cFwiO1xuU0NIRU1FU1todHRwLnNjaGVtZV0gPSBodHRwO1xuXG5pbXBvcnQgaHR0cHMgZnJvbSBcIi4vc2NoZW1lcy9odHRwc1wiO1xuU0NIRU1FU1todHRwcy5zY2hlbWVdID0gaHR0cHM7XG5cbmltcG9ydCB3cyBmcm9tIFwiLi9zY2hlbWVzL3dzXCI7XG5TQ0hFTUVTW3dzLnNjaGVtZV0gPSB3cztcblxuaW1wb3J0IHdzcyBmcm9tIFwiLi9zY2hlbWVzL3dzc1wiO1xuU0NIRU1FU1t3c3Muc2NoZW1lXSA9IHdzcztcblxuaW1wb3J0IG1haWx0byBmcm9tIFwiLi9zY2hlbWVzL21haWx0b1wiO1xuU0NIRU1FU1ttYWlsdG8uc2NoZW1lXSA9IG1haWx0bztcblxuaW1wb3J0IHVybiBmcm9tIFwiLi9zY2hlbWVzL3VyblwiO1xuU0NIRU1FU1t1cm4uc2NoZW1lXSA9IHVybjtcblxuaW1wb3J0IHV1aWQgZnJvbSBcIi4vc2NoZW1lcy91cm4tdXVpZFwiO1xuU0NIRU1FU1t1dWlkLnNjaGVtZV0gPSB1dWlkO1xuXG5leHBvcnQgKiBmcm9tIFwiLi91cmlcIjtcbiIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBVUk5Db21wb25lbnRzIH0gZnJvbSBcIi4vdXJuXCI7XG5pbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVVSURDb21wb25lbnRzIGV4dGVuZHMgVVJOQ29tcG9uZW50cyB7XG5cdHV1aWQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG5jb25zdCBVVUlEX1BBUlNFID0gL15bMC05QS1GYS1mXFwtXXszNn0vO1xuXG4vL1JGQyA0MTIyXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXI8VVVJRENvbXBvbmVudHMsIFVSSU9wdGlvbnMsIFVSTkNvbXBvbmVudHM+ID0ge1xuXHRzY2hlbWUgOiBcInVybjp1dWlkXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVVSURDb21wb25lbnRzIHtcblx0XHRjb25zdCB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVVJRENvbXBvbmVudHM7XG5cdFx0dXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcblx0XHR1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuXHRcdFx0dXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuXHRcdH1cblxuXHRcdHJldHVybiB1dWlkQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXVpZENvbXBvbmVudHM6VVVJRENvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJOQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0Ly9ub3JtYWxpemUgVVVJRFxuXHRcdHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB7IHBjdEVuY0NoYXIsIFNDSEVNRVMgfSBmcm9tIFwiLi4vdXJpXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJOQ29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMge1xuXHRuaWQ/OnN0cmluZztcblx0bnNzPzpzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJOT3B0aW9ucyBleHRlbmRzIFVSSU9wdGlvbnMge1xuXHRuaWQ/OnN0cmluZztcbn1cblxuY29uc3QgTklEJCA9IFwiKD86WzAtOUEtWmEtel1bMC05QS1aYS16XFxcXC1dezEsMzF9KVwiO1xuY29uc3QgUENUX0VOQ09ERUQkID0gXCIoPzpcXFxcJVswLTlBLUZhLWZdezJ9KVwiO1xuY29uc3QgVFJBTlMkJCA9IFwiWzAtOUEtWmEtelxcXFwoXFxcXClcXFxcK1xcXFwsXFxcXC1cXFxcLlxcXFw6XFxcXD1cXFxcQFxcXFw7XFxcXCRcXFxcX1xcXFwhXFxcXCpcXFxcJ1xcXFwvXFxcXD9cXFxcI11cIjtcbmNvbnN0IE5TUyQgPSBcIig/Oig/OlwiICsgUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBUUkFOUyQkICsgXCIpKylcIjtcbmNvbnN0IFVSTl9TQ0hFTUUgPSBuZXcgUmVnRXhwKFwiXnVyblxcXFw6KFwiICsgTklEJCArIFwiKSRcIik7XG5jb25zdCBVUk5fUEFUSCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgTklEJCArIFwiKVxcXFw6KFwiICsgTlNTJCArIFwiKSRcIik7XG5jb25zdCBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuY29uc3QgVVJOX0VYQ0xVREVEID0gL1tcXHgwMC1cXHgyMFxcXFxcXFwiXFwmXFw8XFw+XFxbXFxdXFxeXFxgXFx7XFx8XFx9XFx+XFx4N0YtXFx4RkZdL2c7XG5cbi8vUkZDIDIxNDFcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxVUk5Db21wb25lbnRzLFVSTk9wdGlvbnM+ID0ge1xuXHRzY2hlbWUgOiBcInVyblwiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUk5PcHRpb25zKTpVUk5Db21wb25lbnRzIHtcblx0XHRjb25zdCBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuXHRcdGxldCB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cyBhcyBVUk5Db21wb25lbnRzO1xuXG5cdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0XHRjb25zdCBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjb25zdCBuc3MgPSBtYXRjaGVzWzJdO1xuXHRcdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdFx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcblxuXHRcdFx0dXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG5cdFx0XHR1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcblx0XHRcdHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKHNjaGVtZUhhbmRsZXIpIHtcblx0XHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykgYXMgVVJOQ29tcG9uZW50cztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybkNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHVybkNvbXBvbmVudHM6VVJOQ29tcG9uZW50cywgb3B0aW9uczpVUk5PcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuXHRcdGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuXHRcdGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YDtcblx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0aWYgKHNjaGVtZUhhbmRsZXIpIHtcblx0XHRcdHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdH1cblxuXHRcdGNvbnN0IHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG5cdFx0dXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gO1xuXG5cdFx0cmV0dXJuIHVyaUNvbXBvbmVudHM7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBwY3RFbmNDaGFyLCBwY3REZWNDaGFycywgdW5lc2NhcGVDb21wb25lbnQgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgcHVueWNvZGUgZnJvbSBcInB1bnljb2RlXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwLCB0b1VwcGVyQ2FzZSwgdG9BcnJheSB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvSGVhZGVycyB7XG5cdFtoZm5hbWU6c3RyaW5nXTpzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWlsdG9Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdHRvOkFycmF5PHN0cmluZz4sXG5cdGhlYWRlcnM/Ok1haWx0b0hlYWRlcnMsXG5cdHN1YmplY3Q/OnN0cmluZyxcblx0Ym9keT86c3RyaW5nXG59XG5cbmNvbnN0IE86TWFpbHRvSGVhZGVycyA9IHt9O1xuY29uc3QgaXNJUkkgPSB0cnVlO1xuXG4vL1JGQyAzOTg2XG5jb25zdCBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG5jb25zdCBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuY29uc3QgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAgLy9leHBhbmRlZFxuXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG5jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbmNvbnN0IFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbmNvbnN0IFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbmNvbnN0IERPVF9BVE9NX1RFWFQkID0gc3ViZXhwKEFURVhUJCQgKyBcIitcIiArIHN1YmV4cChcIlxcXFwuXCIgKyBBVEVYVCQkICsgXCIrXCIpICsgXCIqXCIpO1xuY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIFZDSEFSJCQpO1xuY29uc3QgUUNPTlRFTlQkID0gc3ViZXhwKFFURVhUJCQgKyBcInxcIiArIFFVT1RFRF9QQUlSJCk7XG5jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIFFDT05URU5UJCArIFwiKlwiICsgJ1xcXFxcIicpO1xuXG4vL1JGQyA2MDY4XG5jb25zdCBEVEVYVF9OT19PQlMkJCA9IFwiW1xcXFx4MjEtXFxcXHg1QVxcXFx4NUUtXFxcXHg3RV1cIjsgIC8vJWQzMy05MCAvICVkOTQtMTI2XG5jb25zdCBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbmNvbnN0IFFDSEFSJCA9IHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCArIFwifFwiICsgU09NRV9ERUxJTVMkJCk7XG5jb25zdCBET01BSU4kID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBcIlxcXFxbXCIgKyBEVEVYVF9OT19PQlMkJCArIFwiKlwiICsgXCJcXFxcXVwiKTtcbmNvbnN0IExPQ0FMX1BBUlQkID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBRVU9URURfU1RSSU5HJCk7XG5jb25zdCBBRERSX1NQRUMkID0gc3ViZXhwKExPQ0FMX1BBUlQkICsgXCJcXFxcQFwiICsgRE9NQUlOJCk7XG5jb25zdCBUTyQgPSBzdWJleHAoQUREUl9TUEVDJCArIHN1YmV4cChcIlxcXFwsXCIgKyBBRERSX1NQRUMkKSArIFwiKlwiKTtcbmNvbnN0IEhGTkFNRSQgPSBzdWJleHAoUUNIQVIkICsgXCIqXCIpO1xuY29uc3QgSEZWQUxVRSQgPSBIRk5BTUUkO1xuY29uc3QgSEZJRUxEJCA9IHN1YmV4cChIRk5BTUUkICsgXCJcXFxcPVwiICsgSEZWQUxVRSQpO1xuY29uc3QgSEZJRUxEUzIkID0gc3ViZXhwKEhGSUVMRCQgKyBzdWJleHAoXCJcXFxcJlwiICsgSEZJRUxEJCkgKyBcIipcIik7XG5jb25zdCBIRklFTERTJCA9IHN1YmV4cChcIlxcXFw/XCIgKyBIRklFTERTMiQpO1xuY29uc3QgTUFJTFRPX1VSSSA9IG5ldyBSZWdFeHAoXCJebWFpbHRvXFxcXDpcIiArIFRPJCArIFwiP1wiICsgSEZJRUxEUyQgKyBcIj8kXCIpO1xuXG5jb25zdCBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbmNvbnN0IFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbmNvbnN0IE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9ET01BSU4gPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCBcIltcXFxcW11cIiwgRFRFWFRfTk9fT0JTJCQsIFwiW1xcXFxdXVwiKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuY29uc3QgVE8gPSBuZXcgUmVnRXhwKFwiXlwiICsgVE8kICsgXCIkXCIpO1xuY29uc3QgSEZJRUxEUyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIRklFTERTMiQgKyBcIiRcIik7XG5cbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcblx0cmV0dXJuICghZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcbn1cblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPE1haWx0b0NvbXBvbmVudHM+ID0gIHtcblx0c2NoZW1lIDogXCJtYWlsdG9cIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6TWFpbHRvQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgTWFpbHRvQ29tcG9uZW50cztcblx0XHRjb25zdCB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSAobWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdKTtcblx0XHRtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuXHRcdFx0bGV0IHVua25vd25IZWFkZXJzID0gZmFsc2Vcblx0XHRcdGNvbnN0IGhlYWRlcnM6TWFpbHRvSGVhZGVycyA9IHt9O1xuXHRcdFx0Y29uc3QgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG5cblx0XHRcdFx0c3dpdGNoIChoZmllbGRbMF0pIHtcblx0XHRcdFx0XHRjYXNlIFwidG9cIjpcblx0XHRcdFx0XHRcdGNvbnN0IHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG9BZGRycy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdHRvLnB1c2godG9BZGRyc1t4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic3ViamVjdFwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJib2R5XCI6XG5cdFx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHVua25vd25IZWFkZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG5cblx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRjb25zdCBhZGRyID0gdG9beF0uc3BsaXQoXCJAXCIpO1xuXG5cdFx0XHRhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG5cblx0XHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRvW3hdID0gYWRkci5qb2luKFwiQFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAobWFpbHRvQ29tcG9uZW50czpNYWlsdG9Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuXHRcdGlmICh0bykge1xuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRjb25zdCB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuXHRcdFx0XHRjb25zdCBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG5cdFx0XHRcdGNvbnN0IGxvY2FsUGFydCA9ICh0b0FkZHIuc2xpY2UoMCwgYXRJZHgpKS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG5cdFx0XHRcdGxldCBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcblxuXHRcdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRvbWFpbiA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcblxuXHRcdGNvbnN0IGZpZWxkcyA9IFtdO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBoZWFkZXJzKSB7XG5cdFx0XHRpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuXHRcdFx0XHRmaWVsZHMucHVzaChcblx0XHRcdFx0XHRuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICtcblx0XHRcdFx0XHRcIj1cIiArXG5cdFx0XHRcdFx0aGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcilcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZpZWxkcy5sZW5ndGgpIHtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHdzIGZyb20gXCIuL3dzXCI7XG5cbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlciA9IHtcblx0c2NoZW1lIDogXCJ3c3NcIixcblx0ZG9tYWluSG9zdCA6IHdzLmRvbWFpbkhvc3QsXG5cdHBhcnNlIDogd3MucGFyc2UsXG5cdHNlcmlhbGl6ZSA6IHdzLnNlcmlhbGl6ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV1NDb21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdHJlc291cmNlTmFtZT86IHN0cmluZztcblx0c2VjdXJlPzogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gaXNTZWN1cmUod3NDb21wb25lbnRzOldTQ29tcG9uZW50cyk6Ym9vbGVhbiB7XG5cdHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuXG4vL1JGQyA2NDU1XG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwid3NcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6V1NDb21wb25lbnRzIHtcblx0XHRjb25zdCB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIFdTQ29tcG9uZW50cztcblxuXHRcdC8vaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuXHRcdHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuXG5cdFx0Ly9jb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG5cdFx0d3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcblx0XHR3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcblx0XHR3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG5cblx0XHRyZXR1cm4gd3NDb21wb25lbnRzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZSA6IGZ1bmN0aW9uICh3c0NvbXBvbmVudHM6V1NDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcblx0XHRpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG5cdFx0XHR3c0NvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvL2Vuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuXHRcdGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHR3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpO1xuXHRcdFx0d3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG5cdFx0aWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcblx0XHRcdGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/Jyk7XG5cdFx0XHR3c0NvbXBvbmVudHMucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpO1xuXHRcdFx0d3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnk7XG5cdFx0XHR3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuXHRcdHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcblxuXHRcdHJldHVybiB3c0NvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCBodHRwIGZyb20gXCIuL2h0dHBcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBzXCIsXG5cdGRvbWFpbkhvc3QgOiBodHRwLmRvbWFpbkhvc3QsXG5cdHBhcnNlIDogaHR0cC5wYXJzZSxcblx0c2VyaWFsaXplIDogaHR0cC5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwiaHR0cFwiLFxuXG5cdGRvbWFpbkhvc3QgOiB0cnVlLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHQvL3JlcG9ydCBtaXNzaW5nIGhvc3Rcblx0XHRpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuXHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJodHRwc1wiO1xuXG5cdFx0Ly9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuXHRcdGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG5cdFx0aWYgKCFjb21wb25lbnRzLnBhdGgpIHtcblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IFwiL1wiO1xuXHRcdH1cblxuXHRcdC8vTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuXHRcdC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG5cdFx0Ly9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCIvKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xuXG5pbXBvcnQgVVJJX1BST1RPQ09MIGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5pbXBvcnQgSVJJX1BST1RPQ09MIGZyb20gXCIuL3JlZ2V4cHMtaXJpXCI7XG5pbXBvcnQgcHVueWNvZGUgZnJvbSBcInB1bnljb2RlXCI7XG5pbXBvcnQgeyB0b1VwcGVyQ2FzZSwgdHlwZU9mLCBhc3NpZ24gfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJQ29tcG9uZW50cyB7XG5cdHNjaGVtZT86c3RyaW5nO1xuXHR1c2VyaW5mbz86c3RyaW5nO1xuXHRob3N0PzpzdHJpbmc7XG5cdHBvcnQ/Om51bWJlcnxzdHJpbmc7XG5cdHBhdGg/OnN0cmluZztcblx0cXVlcnk/OnN0cmluZztcblx0ZnJhZ21lbnQ/OnN0cmluZztcblx0cmVmZXJlbmNlPzpzdHJpbmc7XG5cdGVycm9yPzpzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJT3B0aW9ucyB7XG5cdHNjaGVtZT86c3RyaW5nO1xuXHRyZWZlcmVuY2U/OnN0cmluZztcblx0dG9sZXJhbnQ/OmJvb2xlYW47XG5cdGFic29sdXRlUGF0aD86Ym9vbGVhbjtcblx0aXJpPzpib29sZWFuO1xuXHR1bmljb2RlU3VwcG9ydD86Ym9vbGVhbjtcblx0ZG9tYWluSG9zdD86Ym9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUklTY2hlbWVIYW5kbGVyPENvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzID0gVVJJQ29tcG9uZW50cywgT3B0aW9ucyBleHRlbmRzIFVSSU9wdGlvbnMgPSBVUklPcHRpb25zLCBQYXJlbnRDb21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyA9IFVSSUNvbXBvbmVudHM+IHtcblx0c2NoZW1lOnN0cmluZztcblx0cGFyc2UoY29tcG9uZW50czpQYXJlbnRDb21wb25lbnRzLCBvcHRpb25zOk9wdGlvbnMpOkNvbXBvbmVudHM7XG5cdHNlcmlhbGl6ZShjb21wb25lbnRzOkNvbXBvbmVudHMsIG9wdGlvbnM6T3B0aW9ucyk6UGFyZW50Q29tcG9uZW50cztcblx0dW5pY29kZVN1cHBvcnQ/OmJvb2xlYW47XG5cdGRvbWFpbkhvc3Q/OmJvb2xlYW47XG5cdGFic29sdXRlUGF0aD86Ym9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUklSZWdFeHBzIHtcblx0Tk9UX1NDSEVNRSA6IFJlZ0V4cCxcblx0Tk9UX1VTRVJJTkZPIDogUmVnRXhwLFxuXHROT1RfSE9TVCA6IFJlZ0V4cCxcblx0Tk9UX1BBVEggOiBSZWdFeHAsXG5cdE5PVF9QQVRIX05PU0NIRU1FIDogUmVnRXhwLFxuXHROT1RfUVVFUlkgOiBSZWdFeHAsXG5cdE5PVF9GUkFHTUVOVCA6IFJlZ0V4cCxcblx0RVNDQVBFIDogUmVnRXhwLFxuXHRVTlJFU0VSVkVEIDogUmVnRXhwLFxuXHRPVEhFUl9DSEFSUyA6IFJlZ0V4cCxcblx0UENUX0VOQ09ERUQgOiBSZWdFeHAsXG5cdElQVjRBRERSRVNTIDogUmVnRXhwLFxuXHRJUFY2QUREUkVTUyA6IFJlZ0V4cCxcbn1cblxuZXhwb3J0IGNvbnN0IFNDSEVNRVM6e1tzY2hlbWU6c3RyaW5nXTpVUklTY2hlbWVIYW5kbGVyfSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gcGN0RW5jQ2hhcihjaHI6c3RyaW5nKTpzdHJpbmcge1xuXHRjb25zdCBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG5cdGxldCBlOnN0cmluZztcblxuXHRpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ZWxzZSBpZiAoYyA8IDIwNDgpIGUgPSBcIiVcIiArICgoYyA+PiA2KSB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoYyAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgZSA9IFwiJVwiICsgKChjID4+IDEyKSB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoKGMgPj4gNikgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG5cdHJldHVybiBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0bGV0IG5ld1N0ciA9IFwiXCI7XG5cdGxldCBpID0gMDtcblx0Y29uc3QgaWwgPSBzdHIubGVuZ3RoO1xuXG5cdHdoaWxlIChpIDwgaWwpIHtcblx0XHRjb25zdCBjID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KTtcblxuXHRcdGlmIChjIDwgMTI4KSB7XG5cdFx0XHRuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcblx0XHRcdGkgKz0gMztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuXHRcdFx0aWYgKChpbCAtIGkpID49IDYpIHtcblx0XHRcdFx0Y29uc3QgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuXHRcdFx0XHRuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG5cdFx0XHR9XG5cdFx0XHRpICs9IDY7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGMgPj0gMjI0KSB7XG5cdFx0XHRpZiAoKGlsIC0gaSkgPj0gOSkge1xuXHRcdFx0XHRjb25zdCBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG5cdFx0XHRcdGNvbnN0IGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcblx0XHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XG5cdFx0XHR9XG5cdFx0XHRpICs9IDk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG5cdFx0XHRpICs9IDM7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1N0cjtcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgcHJvdG9jb2w6VVJJUmVnRXhwcykge1xuXHRmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdFx0Y29uc3QgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcblx0XHRyZXR1cm4gKCFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHIpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuXHRpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5ob3N0ID0gU3RyaW5nKGNvbXBvbmVudHMuaG9zdCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZSgoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FKSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblxuXHRyZXR1cm4gY29tcG9uZW50cztcbn07XG5cbmZ1bmN0aW9uIF9zdHJpcExlYWRpbmdaZXJvcyhzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL14wKiguKikvLCBcIiQxXCIpIHx8IFwiMFwiO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0OnN0cmluZywgcHJvdG9jb2w6VVJJUmVnRXhwcyk6c3RyaW5nIHtcblx0Y29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNEFERFJFU1MpIHx8IFtdO1xuXHRjb25zdCBbLCBhZGRyZXNzXSA9IG1hdGNoZXM7XG5cdFxuXHRpZiAoYWRkcmVzcykge1xuXHRcdHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gaG9zdDtcblx0fVxufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0OnN0cmluZywgcHJvdG9jb2w6VVJJUmVnRXhwcyk6c3RyaW5nIHtcblx0Y29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXHRjb25zdCBbLCBhZGRyZXNzLCB6b25lXSA9IG1hdGNoZXM7XG5cblx0aWYgKGFkZHJlc3MpIHtcblx0XHRjb25zdCBbbGFzdCwgZmlyc3RdID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKTtcblx0XHRjb25zdCBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG5cdFx0Y29uc3QgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuXHRcdGNvbnN0IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPSBwcm90b2NvbC5JUFY0QUREUkVTUy50ZXN0KGxhc3RGaWVsZHNbbGFzdEZpZWxkcy5sZW5ndGggLSAxXSk7XG5cdFx0Y29uc3QgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcblx0XHRjb25zdCBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG5cdFx0Y29uc3QgZmllbGRzID0gQXJyYXk8c3RyaW5nPihmaWVsZENvdW50KTtcblxuXHRcdGZvciAobGV0IHggPSAwOyB4IDwgZmllbGRDb3VudDsgKyt4KSB7XG5cdFx0XHRmaWVsZHNbeF0gPSBmaXJzdEZpZWxkc1t4XSB8fCBsYXN0RmllbGRzW2xhc3RGaWVsZHNTdGFydCArIHhdIHx8ICcnO1xuXHRcdH1cblxuXHRcdGlmIChpc0xhc3RGaWVsZElQdjRBZGRyZXNzKSB7XG5cdFx0XHRmaWVsZHNbZmllbGRDb3VudCAtIDFdID0gX25vcm1hbGl6ZUlQdjQoZmllbGRzW2ZpZWxkQ291bnQgLSAxXSwgcHJvdG9jb2wpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlPEFycmF5PHtpbmRleDpudW1iZXIsbGVuZ3RoOm51bWJlcn0+PigoYWNjLCBmaWVsZCwgaW5kZXgpID0+IHtcblx0XHRcdGlmICghZmllbGQgfHwgZmllbGQgPT09IFwiMFwiKSB7XG5cdFx0XHRcdGNvbnN0IGxhc3RMb25nZXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcblx0XHRcdFx0aWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuXHRcdFx0XHRcdGxhc3RMb25nZXN0Lmxlbmd0aCsrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFjYy5wdXNoKHsgaW5kZXgsIGxlbmd0aCA6IDEgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwgW10pO1xuXG5cdFx0Y29uc3QgbG9uZ2VzdFplcm9GaWVsZHMgPSBhbGxaZXJvRmllbGRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpWzBdO1xuXG5cdFx0bGV0IG5ld0hvc3Q6c3RyaW5nO1xuXHRcdGlmIChsb25nZXN0WmVyb0ZpZWxkcyAmJiBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRjb25zdCBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCkgO1xuXHRcdFx0Y29uc3QgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG5cdFx0XHRuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuXHRcdH1cblxuXHRcdGlmICh6b25lKSB7XG5cdFx0XHRuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3SG9zdDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gaG9zdDtcblx0fVxufVxuXG5jb25zdCBVUklfUEFSU0UgPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooW15cXC8/I0BdKilAKT8oXFxbW15cXC8/I1xcXV0rXFxdfFteXFwvPyM6XSopKD86XFw6KFxcZCopKT8pKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxcXG58XFxyKSopKT8vaTtcbmNvbnN0IE5PX01BVENIX0lTX1VOREVGSU5FRCA9ICg8UmVnRXhwTWF0Y2hBcnJheT4oXCJcIikubWF0Y2goLygpezB9LykpWzFdID09PSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh1cmlTdHJpbmc6c3RyaW5nLCBvcHRpb25zOlVSSU9wdGlvbnMgPSB7fSk6VVJJQ29tcG9uZW50cyB7XG5cdGNvbnN0IGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cyA9IHt9O1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0wpO1xuXG5cdGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuXG5cdGNvbnN0IG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcblxuXHRpZiAobWF0Y2hlcykge1xuXHRcdGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcblx0XHRcdC8vc3RvcmUgZWFjaCBjb21wb25lbnRcblx0XHRcdGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXTtcblx0XHRcdGNvbXBvbmVudHMudXNlcmluZm8gPSBtYXRjaGVzWzNdO1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gbWF0Y2hlc1s0XTtcblx0XHRcdGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSBtYXRjaGVzWzddO1xuXHRcdFx0Y29tcG9uZW50cy5mcmFnbWVudCA9IG1hdGNoZXNbOF07XG5cblx0XHRcdC8vZml4IHBvcnQgbnVtYmVyXG5cdFx0XHRpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuXHRcdFx0XHRjb21wb25lbnRzLnBvcnQgPSBtYXRjaGVzWzVdO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7ICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG5cdFx0XHQvL3N0b3JlIGVhY2ggY29tcG9uZW50XG5cdFx0XHRjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuXHRcdFx0Y29tcG9uZW50cy51c2VyaW5mbyA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLmhvc3QgPSAodXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSAodXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5mcmFnbWVudCA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIiNcIikgIT09IC0xID8gbWF0Y2hlc1s4XSA6IHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vZml4IHBvcnQgbnVtYmVyXG5cdFx0XHRpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuXHRcdFx0XHRjb21wb25lbnRzLnBvcnQgPSAodXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdC8vbm9ybWFsaXplIElQIGhvc3RzXG5cdFx0XHRjb21wb25lbnRzLmhvc3QgPSBfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChjb21wb25lbnRzLmhvc3QsIHByb3RvY29sKSwgcHJvdG9jb2wpO1xuXHRcdH1cblxuXHRcdC8vZGV0ZXJtaW5lIHJlZmVyZW5jZSB0eXBlXG5cdFx0aWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnRzLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJhYnNvbHV0ZVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG5cdFx0fVxuXG5cdFx0Ly9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuXHRcdGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG5cdFx0fVxuXG5cdFx0Ly9maW5kIHNjaGVtZSBoYW5kbGVyXG5cdFx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuXG5cdFx0Ly9jaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcblx0XHRpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuXHRcdFx0Ly9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG5cdFx0XHRpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkpIHtcblx0XHRcdFx0Ly9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvL2NvbnZlcnQgSVJJIC0+IFVSSVxuXHRcdFx0X25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vbm9ybWFsaXplIGVuY29kaW5nc1xuXHRcdFx0X25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHQvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcblx0XHRpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG5cdFx0XHRzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBjYW4gbm90IGJlIHBhcnNlZC5cIjtcblx0fVxuXG5cdHJldHVybiBjb21wb25lbnRzO1xufTtcblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6c3RyaW5nfHVuZGVmaW5lZCB7XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cdGNvbnN0IHVyaVRva2VuczpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0aWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuXHRcdHVyaVRva2Vucy5wdXNoKF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KFN0cmluZyhjb21wb25lbnRzLmhvc3QpLCBwcm90b2NvbCksIHByb3RvY29sKS5yZXBsYWNlKHByb3RvY29sLklQVjZBRERSRVNTLCAoXywgJDEsICQyKSA9PiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIikpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcblx0XHR1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG5cdH1cblxuXHRyZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufTtcblxuY29uc3QgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG5jb25zdCBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbmNvbnN0IFJEUzMgPSAvXlxcL1xcLlxcLihcXC98JCkvO1xuY29uc3QgUkRTNCA9IC9eXFwuXFwuPyQvO1xuY29uc3QgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0OnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3Qgb3V0cHV0OkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG5cdFx0aWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG5cdFx0fSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgXCIvXCIpO1xuXHRcdFx0b3V0cHV0LnBvcCgpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcblx0XHRcdGlucHV0ID0gXCJcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgaW0gPSBpbnB1dC5tYXRjaChSRFM1KTtcblx0XHRcdGlmIChpbSkge1xuXHRcdFx0XHRjb25zdCBzID0gaW1bMF07XG5cdFx0XHRcdGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuXHRcdFx0XHRvdXRwdXQucHVzaChzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMgPSB7fSk6c3RyaW5nIHtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0wpO1xuXHRjb25zdCB1cmlUb2tlbnM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdC8vZmluZCBzY2hlbWUgaGFuZGxlclxuXHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG5cblx0Ly9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG5cdGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcblxuXHRpZiAoY29tcG9uZW50cy5ob3N0KSB7XG5cdFx0Ly9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3Ncblx0XHRpZiAocHJvdG9jb2wuSVBWNkFERFJFU1MudGVzdChjb21wb25lbnRzLmhvc3QpKSB7XG5cdFx0XHQvL1RPRE86IG5vcm1hbGl6ZSBJUHY2IGFkZHJlc3MgYXMgcGVyIFJGQyA1OTUyXG5cdFx0fVxuXG5cdFx0Ly9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG5cdFx0ZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcblx0XHRcdC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wb25lbnRzLmhvc3QgPSAoIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGNvbXBvbmVudHMuaG9zdCkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL25vcm1hbGl6ZSBlbmNvZGluZ1xuXHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuXG5cdGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcblx0XHR1cmlUb2tlbnMucHVzaChcIjpcIik7XG5cdH1cblxuXHRjb25zdCBhdXRob3JpdHkgPSBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuXHRpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIpIHtcblx0XHRcdHVyaVRva2Vucy5wdXNoKFwiLy9cIik7XG5cdFx0fVxuXG5cdFx0dXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KTtcblxuXHRcdGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcblx0XHRcdHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRsZXQgcyA9IGNvbXBvbmVudHMucGF0aDtcblxuXHRcdGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcblx0XHRcdHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcblx0XHR9XG5cblx0XHRpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7ICAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG5cdFx0fVxuXG5cdFx0dXJpVG9rZW5zLnB1c2gocyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLmZyYWdtZW50KTtcblx0fVxuXG5cdHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgIC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlOlVSSUNvbXBvbmVudHMsIHJlbGF0aXZlOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9LCBza2lwTm9ybWFsaXphdGlvbj86Ym9vbGVhbik6VVJJQ29tcG9uZW50cyB7XG5cdGNvbnN0IHRhcmdldDpVUklDb21wb25lbnRzID0ge307XG5cblx0aWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuXHRcdGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG5cdFx0cmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKTsgIC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcblx0fVxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG5cdFx0dGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcblx0XHQvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG5cdFx0dGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG5cdFx0dGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuXHRcdHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcblx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG5cdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuXHRcdFx0dGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG5cdFx0XHR0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG5cdFx0XHR0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG5cdFx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG5cdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG5cdFx0XHRcdHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuXHRcdFx0XHRpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcblx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IFwiL1wiICsgcmVsYXRpdmUucGF0aDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0XHR9XG5cdFx0XHQvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcblx0XHRcdHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG5cdFx0XHR0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcblx0XHRcdHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuXHRcdH1cblx0XHR0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG5cdH1cblxuXHR0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudDtcblxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSTpzdHJpbmcsIHJlbGF0aXZlVVJJOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nIHtcblx0Y29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWUgOiAnbnVsbCcgfSwgb3B0aW9ucyk7XG5cdHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodXJpOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6VVJJQ29tcG9uZW50cywgb3B0aW9ucz86VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodXJpOmFueSwgb3B0aW9ucz86VVJJT3B0aW9ucyk6YW55IHtcblx0aWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH0gZWxzZSBpZiAodHlwZU9mKHVyaSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmkgPSBwYXJzZShzZXJpYWxpemUoPFVSSUNvbXBvbmVudHM+dXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH1cblxuXHRyZXR1cm4gdXJpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6c3RyaW5nLCB1cmlCOnN0cmluZywgb3B0aW9ucz86IFVSSU9wdGlvbnMpOmJvb2xlYW47XG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodXJpQTpVUklDb21wb25lbnRzLCB1cmlCOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmJvb2xlYW47XG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodXJpQTphbnksIHVyaUI6YW55LCBvcHRpb25zPzpVUklPcHRpb25zKTpib29sZWFuIHtcblx0aWYgKHR5cGVvZiB1cmlBID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH0gZWxzZSBpZiAodHlwZU9mKHVyaUEpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpQSA9IHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmlBLCBvcHRpb25zKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXJpQiA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmlCKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaUIgPSBzZXJpYWxpemUoPFVSSUNvbXBvbmVudHM+dXJpQiwgb3B0aW9ucyk7XG5cdH1cblxuXHRyZXR1cm4gdXJpQSA9PT0gdXJpQjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuRVNDQVBFIDogSVJJX1BST1RPQ09MLkVTQ0FQRSksIHBjdEVuY0NoYXIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlQ29tcG9uZW50KHN0cjpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVEKSwgcGN0RGVjQ2hhcnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0Y29uc3QgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0Y29uc3QgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdGNvbnN0IGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG5jb25zdCB1Y3MyZW5jb2RlID0gYXJyYXkgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uYXJyYXkpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0bGV0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdGNvbnN0IHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdGxldCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbmNvbnN0IHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5jb25zdCB0b0FTQ0lJID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuY29uc3QgcHVueWNvZGUgPSB7XG5cdC8qKlxuXHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHB1bnljb2RlO1xuIiwiaW1wb3J0IHsgVVJJUmVnRXhwcyB9IGZyb20gXCIuL3VyaVwiO1xuaW1wb3J0IHsgYnVpbGRFeHBzIH0gZnJvbSBcIi4vcmVnZXhwcy11cmlcIjtcblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRFeHBzKHRydWUpO1xuIiwiaW1wb3J0IHsgVVJJUmVnRXhwcyB9IGZyb20gXCIuL3VyaVwiO1xuaW1wb3J0IHsgbWVyZ2UsIHN1YmV4cCB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSTpib29sZWFuKTpVUklSZWdFeHBzIHtcblx0Y29uc3Rcblx0XHRBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuXHRcdENSJCA9IFwiW1xcXFx4MERdXCIsXG5cdFx0RElHSVQkJCA9IFwiWzAtOV1cIixcblx0XHREUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG5cdFx0SEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLCAgLy9jYXNlLWluc2Vuc2l0aXZlXG5cdFx0TEYkJCA9IFwiW1xcXFx4MEFdXCIsXG5cdFx0U1AkJCA9IFwiW1xcXFx4MjBdXCIsXG5cdFx0UENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLCAgLy9leHBhbmRlZFxuXHRcdEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuXHRcdFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsXG5cdFx0UkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcblx0XHRVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIiwgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuXHRcdElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsICAvL3N1YnNldFxuXHRcdFVOUkVTRVJWRUQkJCA9IG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwtXFxcXC5cXFxcX1xcXFx+XVwiLCBVQ1NDSEFSJCQpLFxuXHRcdFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG5cdFx0VVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuXHRcdERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLFxuXHRcdERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksICAvL3JlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHRcdElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQpLFxuXHRcdEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuXHRcdExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG5cdFx0SVBWNkFERFJFU1MxJCA9IHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns2fVwiICsgTFMzMiQpLCAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzIkID0gc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLCAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSwgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSwgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgICAgICAgIEgxNiQgKyBcIlxcXFw6XCIgICAgICAgICAgKyBMUzMyJCksIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcblx0XHRJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBMUzMyJCksIC8vWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG5cdFx0SVBWNkFERFJFU1M4JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw1fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgSDE2JCApLCAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG5cdFx0SVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLCAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuXHRcdElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuXHRcdFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSwgIC8vUkZDIDY4NzRcblx0XHRJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksICAvL1JGQyA2ODc0XG5cdFx0SVBWNkFERFJaX1JFTEFYRUQkID0gc3ViZXhwKElQVjZBRERSRVNTJCArIHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHRcdElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuXHRcdElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLCAgLy9SRkMgNjg3NFxuXHRcdFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuXHRcdEhPU1QkID0gc3ViZXhwKElQX0xJVEVSQUwkICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQgKyBcIig/IVwiICsgUkVHX05BTUUkICsgXCIpXCIgKyBcInxcIiArIFJFR19OQU1FJCksXG5cdFx0UE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcblx0XHRBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcblx0XHRQQ0hBUiQgPSBzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLFxuXHRcdFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcblx0XHRTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG5cdFx0U0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFxAXVwiKSkgKyBcIitcIiksXG5cdFx0UEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuXHRcdFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfUk9PVExFU1MkID0gc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcblx0XHRQQVRIJCA9IHN1YmV4cChQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0UVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcblx0XHRGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcblx0XHRISUVSX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0VVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcblx0XHRSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFJFTEFUSVZFJCA9IHN1YmV4cChSRUxBVElWRV9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcblx0XHRVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuXHRcdEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcblxuXHRcdEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0QUJTT0xVVEVfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0QVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIlxuXHQ7XG5cblx0cmV0dXJuIHtcblx0XHROT1RfU0NIRU1FIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG5cdFx0Tk9UX1VTRVJJTkZPIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX0hPU1QgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1BBVEggOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1BBVEhfTk9TQ0hFTUUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9RVUVSWSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG5cdFx0Tk9UX0ZSQUdNRU5UIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcblx0XHRFU0NBUEUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdFVOUkVTRVJWRUQgOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuXHRcdE9USEVSX0NIQVJTIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcblx0XHRQQ1RfRU5DT0RFRCA6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG5cdFx0SVBWNEFERFJFU1MgOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG5cdFx0SVBWNkFERFJFU1MgOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRFeHBzKGZhbHNlKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBtZXJnZSguLi5zZXRzOkFycmF5PHN0cmluZz4pOnN0cmluZyB7XG5cdGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcblx0XHRzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG5cdFx0Y29uc3QgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG5cdFx0Zm9yIChsZXQgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG5cdFx0fVxuXHRcdHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG5cdFx0cmV0dXJuIHNldHMuam9pbignJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHNldHNbMF07XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmV4cChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZU9mKG86YW55KTpzdHJpbmcge1xuXHRyZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IChvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShvYmo6YW55KTpBcnJheTxhbnk+IHtcblx0cmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IChvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6ICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKSkgOiBbXTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogb2JqZWN0LCBzb3VyY2U6IGFueSk6IGFueSB7XG5cdGNvbnN0IG9iaiA9IHRhcmdldCBhcyBhbnk7XG5cdGlmIChzb3VyY2UpIHtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdG9ialtrZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IGNvcHksXG4gIGNoZWNrRGF0YVR5cGU6IGNoZWNrRGF0YVR5cGUsXG4gIGNoZWNrRGF0YVR5cGVzOiBjaGVja0RhdGFUeXBlcyxcbiAgY29lcmNlVG9UeXBlczogY29lcmNlVG9UeXBlcyxcbiAgdG9IYXNoOiB0b0hhc2gsXG4gIGdldFByb3BlcnR5OiBnZXRQcm9wZXJ0eSxcbiAgZXNjYXBlUXVvdGVzOiBlc2NhcGVRdW90ZXMsXG4gIGVxdWFsOiByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKSxcbiAgdWNzMmxlbmd0aDogcmVxdWlyZSgnLi91Y3MybGVuZ3RoJyksXG4gIHZhck9jY3VyZW5jZXM6IHZhck9jY3VyZW5jZXMsXG4gIHZhclJlcGxhY2U6IHZhclJlcGxhY2UsXG4gIHNjaGVtYUhhc1J1bGVzOiBzY2hlbWFIYXNSdWxlcyxcbiAgc2NoZW1hSGFzUnVsZXNFeGNlcHQ6IHNjaGVtYUhhc1J1bGVzRXhjZXB0LFxuICBzY2hlbWFVbmtub3duUnVsZXM6IHNjaGVtYVVua25vd25SdWxlcyxcbiAgdG9RdW90ZWRTdHJpbmc6IHRvUXVvdGVkU3RyaW5nLFxuICBnZXRQYXRoRXhwcjogZ2V0UGF0aEV4cHIsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIGdldERhdGE6IGdldERhdGEsXG4gIHVuZXNjYXBlRnJhZ21lbnQ6IHVuZXNjYXBlRnJhZ21lbnQsXG4gIHVuZXNjYXBlSnNvblBvaW50ZXI6IHVuZXNjYXBlSnNvblBvaW50ZXIsXG4gIGVzY2FwZUZyYWdtZW50OiBlc2NhcGVGcmFnbWVudCxcbiAgZXNjYXBlSnNvblBvaW50ZXI6IGVzY2FwZUpzb25Qb2ludGVyXG59O1xuXG5cbmZ1bmN0aW9uIGNvcHkobywgdG8pIHtcbiAgdG8gPSB0byB8fCB7fTtcbiAgZm9yICh2YXIga2V5IGluIG8pIHRvW2tleV0gPSBvW2tleV07XG4gIHJldHVybiB0bztcbn1cblxuXG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1iZXJzLCBuZWdhdGUpIHtcbiAgdmFyIEVRVUFMID0gbmVnYXRlID8gJyAhPT0gJyA6ICcgPT09ICdcbiAgICAsIEFORCA9IG5lZ2F0ZSA/ICcgfHwgJyA6ICcgJiYgJ1xuICAgICwgT0sgPSBuZWdhdGUgPyAnIScgOiAnJ1xuICAgICwgTk9UID0gbmVnYXRlID8gJycgOiAnISc7XG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlICdudWxsJzogcmV0dXJuIGRhdGEgKyBFUVVBTCArICdudWxsJztcbiAgICBjYXNlICdhcnJheSc6IHJldHVybiBPSyArICdBcnJheS5pc0FycmF5KCcgKyBkYXRhICsgJyknO1xuICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiAnKCcgKyBPSyArIGRhdGEgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCJvYmplY3RcIicgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBOT1QgKyAnQXJyYXkuaXNBcnJheSgnICsgZGF0YSArICcpKSc7XG4gICAgY2FzZSAnaW50ZWdlcic6IHJldHVybiAnKHR5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wibnVtYmVyXCInICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIE5PVCArICcoJyArIGRhdGEgKyAnICUgMSknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEFORCArIGRhdGEgKyBFUVVBTCArIGRhdGEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0cmljdE51bWJlcnMgPyAoQU5EICsgT0sgKyAnaXNGaW5pdGUoJyArIGRhdGEgKyAnKScpIDogJycpICsgJyknO1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnKHR5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wiJyArIGRhdGFUeXBlICsgJ1wiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChzdHJpY3ROdW1iZXJzID8gKEFORCArIE9LICsgJ2lzRmluaXRlKCcgKyBkYXRhICsgJyknKSA6ICcnKSArICcpJztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ3R5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wiJyArIGRhdGFUeXBlICsgJ1wiJztcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSwgc3RyaWN0TnVtYmVycykge1xuICBzd2l0Y2ggKGRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtYmVycywgdHJ1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICB2YXIgdHlwZXMgPSB0b0hhc2goZGF0YVR5cGVzKTtcbiAgICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29kZSA9IHR5cGVzLm51bGwgPyAnKCc6ICcoIScgKyBkYXRhICsgJyB8fCAnO1xuICAgICAgICBjb2RlICs9ICd0eXBlb2YgJyArIGRhdGEgKyAnICE9PSBcIm9iamVjdFwiKSc7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMubnVtYmVyKSBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICAgIGZvciAodmFyIHQgaW4gdHlwZXMpXG4gICAgICAgIGNvZGUgKz0gKGNvZGUgPyAnICYmICcgOiAnJyApICsgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1iZXJzLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIGNvZGU7XG4gIH1cbn1cblxuXG52YXIgQ09FUkNFX1RPX1RZUEVTID0gdG9IYXNoKFsgJ3N0cmluZycsICdudW1iZXInLCAnaW50ZWdlcicsICdib29sZWFuJywgJ251bGwnIF0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyhvcHRpb25Db2VyY2VUeXBlcywgZGF0YVR5cGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGFUeXBlcykpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdCA9IGRhdGFUeXBlc1tpXTtcbiAgICAgIGlmIChDT0VSQ0VfVE9fVFlQRVNbdF0pIHR5cGVzW3R5cGVzLmxlbmd0aF0gPSB0O1xuICAgICAgZWxzZSBpZiAob3B0aW9uQ29lcmNlVHlwZXMgPT09ICdhcnJheScgJiYgdCA9PT0gJ2FycmF5JykgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IHQ7XG4gICAgfVxuICAgIGlmICh0eXBlcy5sZW5ndGgpIHJldHVybiB0eXBlcztcbiAgfSBlbHNlIGlmIChDT0VSQ0VfVE9fVFlQRVNbZGF0YVR5cGVzXSkge1xuICAgIHJldHVybiBbZGF0YVR5cGVzXTtcbiAgfSBlbHNlIGlmIChvcHRpb25Db2VyY2VUeXBlcyA9PT0gJ2FycmF5JyAmJiBkYXRhVHlwZXMgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gWydhcnJheSddO1xuICB9XG59XG5cblxuZnVuY3Rpb24gdG9IYXNoKGFycikge1xuICB2YXIgaGFzaCA9IHt9O1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSBoYXNoW2FycltpXV0gPSB0cnVlO1xuICByZXR1cm4gaGFzaDtcbn1cblxuXG52YXIgSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xudmFyIFNJTkdMRV9RVU9URSA9IC8nfFxcXFwvZztcbmZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gJ1snICsga2V5ICsgJ10nXG4gICAgICAgICAgOiBJREVOVElGSUVSLnRlc3Qoa2V5KVxuICAgICAgICAgICAgPyAnLicgKyBrZXlcbiAgICAgICAgICAgIDogXCJbJ1wiICsgZXNjYXBlUXVvdGVzKGtleSkgKyBcIiddXCI7XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlUXVvdGVzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoU0lOR0xFX1FVT1RFLCAnXFxcXCQmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jyk7XG59XG5cblxuZnVuY3Rpb24gdmFyT2NjdXJlbmNlcyhzdHIsIGRhdGFWYXIpIHtcbiAgZGF0YVZhciArPSAnW14wLTldJztcbiAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2gobmV3IFJlZ0V4cChkYXRhVmFyLCAnZycpKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzLmxlbmd0aCA6IDA7XG59XG5cblxuZnVuY3Rpb24gdmFyUmVwbGFjZShzdHIsIGRhdGFWYXIsIGV4cHIpIHtcbiAgZGF0YVZhciArPSAnKFteMC05XSknO1xuICBleHByID0gZXhwci5yZXBsYWNlKC9cXCQvZywgJyQkJCQnKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoZGF0YVZhciwgJ2cnKSwgZXhwciArICckMScpO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gJ2Jvb2xlYW4nKSByZXR1cm4gIXNjaGVtYTtcbiAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkgaWYgKHJ1bGVzW2tleV0pIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRXhjZXB0KHNjaGVtYSwgcnVsZXMsIGV4Y2VwdEtleXdvcmQpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gJ2Jvb2xlYW4nKSByZXR1cm4gIXNjaGVtYSAmJiBleGNlcHRLZXl3b3JkICE9ICdub3QnO1xuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSBpZiAoa2V5ICE9IGV4Y2VwdEtleXdvcmQgJiYgcnVsZXNba2V5XSkgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gc2NoZW1hVW5rbm93blJ1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gJ2Jvb2xlYW4nKSByZXR1cm47XG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIGlmICghcnVsZXNba2V5XSkgcmV0dXJuIGtleTtcbn1cblxuXG5mdW5jdGlvbiB0b1F1b3RlZFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuICdcXCcnICsgZXNjYXBlUXVvdGVzKHN0cikgKyAnXFwnJztcbn1cblxuXG5mdW5jdGlvbiBnZXRQYXRoRXhwcihjdXJyZW50UGF0aCwgZXhwciwganNvblBvaW50ZXJzLCBpc051bWJlcikge1xuICB2YXIgcGF0aCA9IGpzb25Qb2ludGVycyAvLyBmYWxzZSBieSBkZWZhdWx0XG4gICAgICAgICAgICAgID8gJ1xcJy9cXCcgKyAnICsgZXhwciArIChpc051bWJlciA/ICcnIDogJy5yZXBsYWNlKC9+L2csIFxcJ34wXFwnKS5yZXBsYWNlKC9cXFxcLy9nLCBcXCd+MVxcJyknKVxuICAgICAgICAgICAgICA6IChpc051bWJlciA/ICdcXCdbXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXVxcJycgOiAnXFwnW1xcXFxcXCdcXCcgKyAnICsgZXhwciArICcgKyBcXCdcXFxcXFwnXVxcJycpO1xuICByZXR1cm4gam9pblBhdGhzKGN1cnJlbnRQYXRoLCBwYXRoKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRQYXRoKGN1cnJlbnRQYXRoLCBwcm9wLCBqc29uUG9pbnRlcnMpIHtcbiAgdmFyIHBhdGggPSBqc29uUG9pbnRlcnMgLy8gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICA/IHRvUXVvdGVkU3RyaW5nKCcvJyArIGVzY2FwZUpzb25Qb2ludGVyKHByb3ApKVxuICAgICAgICAgICAgICA6IHRvUXVvdGVkU3RyaW5nKGdldFByb3BlcnR5KHByb3ApKTtcbiAgcmV0dXJuIGpvaW5QYXRocyhjdXJyZW50UGF0aCwgcGF0aCk7XG59XG5cblxudmFyIEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG52YXIgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC87XG5mdW5jdGlvbiBnZXREYXRhKCRkYXRhLCBsdmwsIHBhdGhzKSB7XG4gIHZhciB1cCwganNvblBvaW50ZXIsIGRhdGEsIG1hdGNoZXM7XG4gIGlmICgkZGF0YSA9PT0gJycpIHJldHVybiAncm9vdERhdGEnO1xuICBpZiAoJGRhdGFbMF0gPT0gJy8nKSB7XG4gICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OLXBvaW50ZXI6ICcgKyAkZGF0YSk7XG4gICAganNvblBvaW50ZXIgPSAkZGF0YTtcbiAgICBkYXRhID0gJ3Jvb3REYXRhJztcbiAgfSBlbHNlIHtcbiAgICBtYXRjaGVzID0gJGRhdGEubWF0Y2goUkVMQVRJVkVfSlNPTl9QT0lOVEVSKTtcbiAgICBpZiAoIW1hdGNoZXMpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OLXBvaW50ZXI6ICcgKyAkZGF0YSk7XG4gICAgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgaWYgKGpzb25Qb2ludGVyID09ICcjJykge1xuICAgICAgaWYgKHVwID49IGx2bCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWNjZXNzIHByb3BlcnR5L2luZGV4ICcgKyB1cCArICcgbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICcgKyBsdmwpO1xuICAgICAgcmV0dXJuIHBhdGhzW2x2bCAtIHVwXTtcbiAgICB9XG5cbiAgICBpZiAodXAgPiBsdmwpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFjY2VzcyBkYXRhICcgKyB1cCArICcgbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICcgKyBsdmwpO1xuICAgIGRhdGEgPSAnZGF0YScgKyAoKGx2bCAtIHVwKSB8fCAnJyk7XG4gICAgaWYgKCFqc29uUG9pbnRlcikgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgZXhwciA9IGRhdGE7XG4gIHZhciBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgIGRhdGEgKz0gZ2V0UHJvcGVydHkodW5lc2NhcGVKc29uUG9pbnRlcihzZWdtZW50KSk7XG4gICAgICBleHByICs9ICcgJiYgJyArIGRhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHByO1xufVxuXG5cbmZ1bmN0aW9uIGpvaW5QYXRocyAoYSwgYikge1xuICBpZiAoYSA9PSAnXCJcIicpIHJldHVybiBiO1xuICByZXR1cm4gKGEgKyAnICsgJyArIGIpLnJlcGxhY2UoLyhbXlxcXFxdKScgXFwrICcvZywgJyQxJyk7XG59XG5cblxuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpO1xufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuXG5cbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgdmFyIGxlbmd0aCA9IDBcbiAgICAsIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIHBvcyA9IDBcbiAgICAsIHZhbHVlO1xuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKys7XG4gICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodmFsdWUgJiAweEZDMDApID09IDB4REMwMCkgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hT2JqZWN0O1xuXG5mdW5jdGlvbiBTY2hlbWFPYmplY3Qob2JqKSB7XG4gIHV0aWwuY29weShvYmosIHRoaXMpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoJy4vcmVzb2x2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVmFsaWRhdGlvbjogZXJyb3JTdWJjbGFzcyhWYWxpZGF0aW9uRXJyb3IpLFxuICBNaXNzaW5nUmVmOiBlcnJvclN1YmNsYXNzKE1pc3NpbmdSZWZFcnJvcilcbn07XG5cblxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGVycm9ycykge1xuICB0aGlzLm1lc3NhZ2UgPSAndmFsaWRhdGlvbiBmYWlsZWQnO1xuICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xufVxuXG5cbk1pc3NpbmdSZWZFcnJvci5tZXNzYWdlID0gZnVuY3Rpb24gKGJhc2VJZCwgcmVmKSB7XG4gIHJldHVybiAnY2FuXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgcmVmICsgJyBmcm9tIGlkICcgKyBiYXNlSWQ7XG59O1xuXG5cbmZ1bmN0aW9uIE1pc3NpbmdSZWZFcnJvcihiYXNlSWQsIHJlZiwgbWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IE1pc3NpbmdSZWZFcnJvci5tZXNzYWdlKGJhc2VJZCwgcmVmKTtcbiAgdGhpcy5taXNzaW5nUmVmID0gcmVzb2x2ZS51cmwoYmFzZUlkLCByZWYpO1xuICB0aGlzLm1pc3NpbmdTY2hlbWEgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKHJlc29sdmUuZnVsbFBhdGgodGhpcy5taXNzaW5nUmVmKSk7XG59XG5cblxuZnVuY3Rpb24gZXJyb3JTdWJjbGFzcyhTdWJjbGFzcykge1xuICBTdWJjbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFN1YmNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YmNsYXNzO1xuICByZXR1cm4gU3ViY2xhc3M7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09ICdudW1iZXInKSByZXR1cm4gaXNGaW5pdGUobm9kZSkgPyAnJyArIG5vZGUgOiAnbnVsbCc7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBKU09OLnN0cmluZ2lmeShub2RlKTtcblxuICAgICAgICB2YXIgaSwgb3V0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgb3V0ID0gJ1snO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0ICs9ICcsJztcbiAgICAgICAgICAgICAgICBvdXQgKz0gc3RyaW5naWZ5KG5vZGVbaV0pIHx8ICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcblxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLnB1c2gobm9kZSkgLSAxO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgIG91dCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZVtrZXldKTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAob3V0KSBvdXQgKz0gJywnO1xuICAgICAgICAgICAgb3V0ICs9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNwbGljZShzZWVuSW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gJ3snICsgb3V0ICsgJ30nO1xuICAgIH0pKGRhdGEpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdmFsaWRhdGUoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcnO1xuICB2YXIgJGFzeW5jID0gaXQuc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSxcbiAgICAkcmVmS2V5d29yZHMgPSBpdC51dGlsLnNjaGVtYUhhc1J1bGVzRXhjZXB0KGl0LnNjaGVtYSwgaXQuUlVMRVMuYWxsLCAnJHJlZicpLFxuICAgICRpZCA9IGl0LnNlbGYuX2dldElkKGl0LnNjaGVtYSk7XG4gIGlmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzKSB7XG4gICAgdmFyICR1bmtub3duS3dkID0gaXQudXRpbC5zY2hlbWFVbmtub3duUnVsZXMoaXQuc2NoZW1hLCBpdC5SVUxFUy5rZXl3b3Jkcyk7XG4gICAgaWYgKCR1bmtub3duS3dkKSB7XG4gICAgICB2YXIgJGtleXdvcmRzTXNnID0gJ3Vua25vd24ga2V5d29yZDogJyArICR1bmtub3duS3dkO1xuICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPT09ICdsb2cnKSBpdC5sb2dnZXIud2Fybigka2V5d29yZHNNc2cpO1xuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJGtleXdvcmRzTXNnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGl0LmlzVG9wKSB7XG4gICAgb3V0ICs9ICcgdmFyIHZhbGlkYXRlID0gJztcbiAgICBpZiAoJGFzeW5jKSB7XG4gICAgICBpdC5hc3luYyA9IHRydWU7XG4gICAgICBvdXQgKz0gJ2FzeW5jICc7XG4gICAgfVxuICAgIG91dCArPSAnZnVuY3Rpb24oZGF0YSwgZGF0YVBhdGgsIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSwgcm9vdERhdGEpIHsgXFwndXNlIHN0cmljdFxcJzsgJztcbiAgICBpZiAoJGlkICYmIChpdC5vcHRzLnNvdXJjZUNvZGUgfHwgaXQub3B0cy5wcm9jZXNzQ29kZSkpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJy9cXCojIHNvdXJjZVVSTD0nICsgJGlkICsgJyAqLycpICsgJyAnO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGl0LnNjaGVtYSA9PSAnYm9vbGVhbicgfHwgISgkcmVmS2V5d29yZHMgfHwgaXQuc2NoZW1hLiRyZWYpKSB7XG4gICAgdmFyICRrZXl3b3JkID0gJ2ZhbHNlIHNjaGVtYSc7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRlcnJvcktleXdvcmQ7XG4gICAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gICAgaWYgKGl0LnNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChpdC5pc1RvcCkge1xuICAgICAgICAkYnJlYWtPbkVycm9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ2ZhbHNlIHNjaGVtYScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICB9XG4gICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGl0LmlzVG9wKSB7XG4gICAgICAgIGlmICgkYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gJyByZXR1cm4gZGF0YTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsOyByZXR1cm4gdHJ1ZTsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgIG91dCArPSAnIH07IHJldHVybiB2YWxpZGF0ZTsgJztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAoaXQuaXNUb3ApIHtcbiAgICB2YXIgJHRvcCA9IGl0LmlzVG9wLFxuICAgICAgJGx2bCA9IGl0LmxldmVsID0gMCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsID0gMCxcbiAgICAgICRkYXRhID0gJ2RhdGEnO1xuICAgIGl0LnJvb3RJZCA9IGl0LnJlc29sdmUuZnVsbFBhdGgoaXQuc2VsZi5fZ2V0SWQoaXQucm9vdC5zY2hlbWEpKTtcbiAgICBpdC5iYXNlSWQgPSBpdC5iYXNlSWQgfHwgaXQucm9vdElkO1xuICAgIGRlbGV0ZSBpdC5pc1RvcDtcbiAgICBpdC5kYXRhUGF0aEFyciA9IFtcIlwiXTtcbiAgICBpZiAoaXQuc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBpdC5vcHRzLnVzZURlZmF1bHRzICYmIGl0Lm9wdHMuc3RyaWN0RGVmYXVsdHMpIHtcbiAgICAgIHZhciAkZGVmYXVsdE1zZyA9ICdkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290JztcbiAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzID09PSAnbG9nJykgaXQubG9nZ2VyLndhcm4oJGRlZmF1bHRNc2cpO1xuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJGRlZmF1bHRNc2cpO1xuICAgIH1cbiAgICBvdXQgKz0gJyB2YXIgdkVycm9ycyA9IG51bGw7ICc7XG4gICAgb3V0ICs9ICcgdmFyIGVycm9ycyA9IDA7ICAgICAnO1xuICAgIG91dCArPSAnIGlmIChyb290RGF0YSA9PT0gdW5kZWZpbmVkKSByb290RGF0YSA9IGRhdGE7ICc7XG4gIH0gZWxzZSB7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICAgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICAgIGlmICgkaWQpIGl0LmJhc2VJZCA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgJGlkKTtcbiAgICBpZiAoJGFzeW5jICYmICFpdC5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWEnKTtcbiAgICBvdXQgKz0gJyB2YXIgZXJyc18nICsgKCRsdmwpICsgJyA9IGVycm9yczsnO1xuICB9XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzLFxuICAgICRjbG9zaW5nQnJhY2VzMSA9ICcnLFxuICAgICRjbG9zaW5nQnJhY2VzMiA9ICcnO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICR0eXBlU2NoZW1hID0gaXQuc2NoZW1hLnR5cGUsXG4gICAgJHR5cGVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSgkdHlwZVNjaGVtYSk7XG4gIGlmICgkdHlwZVNjaGVtYSAmJiBpdC5vcHRzLm51bGxhYmxlICYmIGl0LnNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSkge1xuICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgIGlmICgkdHlwZVNjaGVtYS5pbmRleE9mKCdudWxsJykgPT0gLTEpICR0eXBlU2NoZW1hID0gJHR5cGVTY2hlbWEuY29uY2F0KCdudWxsJyk7XG4gICAgfSBlbHNlIGlmICgkdHlwZVNjaGVtYSAhPSAnbnVsbCcpIHtcbiAgICAgICR0eXBlU2NoZW1hID0gWyR0eXBlU2NoZW1hLCAnbnVsbCddO1xuICAgICAgJHR5cGVJc0FycmF5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCR0eXBlSXNBcnJheSAmJiAkdHlwZVNjaGVtYS5sZW5ndGggPT0gMSkge1xuICAgICR0eXBlU2NoZW1hID0gJHR5cGVTY2hlbWFbMF07XG4gICAgJHR5cGVJc0FycmF5ID0gZmFsc2U7XG4gIH1cbiAgaWYgKGl0LnNjaGVtYS4kcmVmICYmICRyZWZLZXl3b3Jkcykge1xuICAgIGlmIChpdC5vcHRzLmV4dGVuZFJlZnMgPT0gJ2ZhaWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyRyZWY6IHZhbGlkYXRpb24ga2V5d29yZHMgdXNlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIicgKyBpdC5lcnJTY2hlbWFQYXRoICsgJ1wiIChzZWUgb3B0aW9uIGV4dGVuZFJlZnMpJyk7XG4gICAgfSBlbHNlIGlmIChpdC5vcHRzLmV4dGVuZFJlZnMgIT09IHRydWUpIHtcbiAgICAgICRyZWZLZXl3b3JkcyA9IGZhbHNlO1xuICAgICAgaXQubG9nZ2VyLndhcm4oJyRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgIH1cbiAgfVxuICBpZiAoaXQuc2NoZW1hLiRjb21tZW50ICYmIGl0Lm9wdHMuJGNvbW1lbnQpIHtcbiAgICBvdXQgKz0gJyAnICsgKGl0LlJVTEVTLmFsbC4kY29tbWVudC5jb2RlKGl0LCAnJGNvbW1lbnQnKSk7XG4gIH1cbiAgaWYgKCR0eXBlU2NoZW1hKSB7XG4gICAgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMpIHtcbiAgICAgIHZhciAkY29lcmNlVG9UeXBlcyA9IGl0LnV0aWwuY29lcmNlVG9UeXBlcyhpdC5vcHRzLmNvZXJjZVR5cGVzLCAkdHlwZVNjaGVtYSk7XG4gICAgfVxuICAgIHZhciAkcnVsZXNHcm91cCA9IGl0LlJVTEVTLnR5cGVzWyR0eXBlU2NoZW1hXTtcbiAgICBpZiAoJGNvZXJjZVRvVHlwZXMgfHwgJHR5cGVJc0FycmF5IHx8ICRydWxlc0dyb3VwID09PSB0cnVlIHx8ICgkcnVsZXNHcm91cCAmJiAhJHNob3VsZFVzZUdyb3VwKCRydWxlc0dyb3VwKSkpIHtcbiAgICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnR5cGUnLFxuICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL3R5cGUnO1xuICAgICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcudHlwZScsXG4gICAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvdHlwZScsXG4gICAgICAgICRtZXRob2QgPSAkdHlwZUlzQXJyYXkgPyAnY2hlY2tEYXRhVHlwZXMnIDogJ2NoZWNrRGF0YVR5cGUnO1xuICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoaXQudXRpbFskbWV0aG9kXSgkdHlwZVNjaGVtYSwgJGRhdGEsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgdHJ1ZSkpICsgJykgeyAnO1xuICAgICAgaWYgKCRjb2VyY2VUb1R5cGVzKSB7XG4gICAgICAgIHZhciAkZGF0YVR5cGUgPSAnZGF0YVR5cGUnICsgJGx2bCxcbiAgICAgICAgICAkY29lcmNlZCA9ICdjb2VyY2VkJyArICRsdmw7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRkYXRhVHlwZSkgKyAnID0gdHlwZW9mICcgKyAoJGRhdGEpICsgJzsgdmFyICcgKyAoJGNvZXJjZWQpICsgJyA9IHVuZGVmaW5lZDsgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMgPT0gJ2FycmF5Jykge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ29iamVjdFxcJyAmJiBBcnJheS5pc0FycmF5KCcgKyAoJGRhdGEpICsgJykgJiYgJyArICgkZGF0YSkgKyAnLmxlbmd0aCA9PSAxKSB7ICcgKyAoJGRhdGEpICsgJyA9ICcgKyAoJGRhdGEpICsgJ1swXTsgJyArICgkZGF0YVR5cGUpICsgJyA9IHR5cGVvZiAnICsgKCRkYXRhKSArICc7IGlmICgnICsgKGl0LnV0aWwuY2hlY2tEYXRhVHlwZShpdC5zY2hlbWEudHlwZSwgJGRhdGEsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycykpICsgJykgJyArICgkY29lcmNlZCkgKyAnID0gJyArICgkZGF0YSkgKyAnOyB9ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJGNvZXJjZWQpICsgJyAhPT0gdW5kZWZpbmVkKSA7ICc7XG4gICAgICAgIHZhciBhcnIxID0gJGNvZXJjZVRvVHlwZXM7XG4gICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgdmFyICR0eXBlLCAkaSA9IC0xLFxuICAgICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgICAgICR0eXBlID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkdHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBlbHNlIGlmICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ251bWJlclxcJyB8fCAnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ2Jvb2xlYW5cXCcpICcgKyAoJGNvZXJjZWQpICsgJyA9IFxcJ1xcJyArICcgKyAoJGRhdGEpICsgJzsgZWxzZSBpZiAoJyArICgkZGF0YSkgKyAnID09PSBudWxsKSAnICsgKCRjb2VyY2VkKSArICcgPSBcXCdcXCc7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09ICdudW1iZXInIHx8ICR0eXBlID09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBlbHNlIGlmICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ2Jvb2xlYW5cXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSBudWxsIHx8ICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ3N0cmluZ1xcJyAmJiAnICsgKCRkYXRhKSArICcgJiYgJyArICgkZGF0YSkgKyAnID09ICsnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgaWYgKCR0eXBlID09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICYmICEoJyArICgkZGF0YSkgKyAnICUgMSknO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnKSkgJyArICgkY29lcmNlZCkgKyAnID0gKycgKyAoJGRhdGEpICsgJzsgJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGVsc2UgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gXFwnZmFsc2VcXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSAwIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gbnVsbCkgJyArICgkY29lcmNlZCkgKyAnID0gZmFsc2U7IGVsc2UgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gXFwndHJ1ZVxcJyB8fCAnICsgKCRkYXRhKSArICcgPT09IDEpICcgKyAoJGNvZXJjZWQpICsgJyA9IHRydWU7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09ICdudWxsJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBlbHNlIGlmICgnICsgKCRkYXRhKSArICcgPT09IFxcJ1xcJyB8fCAnICsgKCRkYXRhKSArICcgPT09IDAgfHwgJyArICgkZGF0YSkgKyAnID09PSBmYWxzZSkgJyArICgkY29lcmNlZCkgKyAnID0gbnVsbDsgJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXQub3B0cy5jb2VyY2VUeXBlcyA9PSAnYXJyYXknICYmICR0eXBlID09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdzdHJpbmdcXCcgfHwgJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdudW1iZXJcXCcgfHwgJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdib29sZWFuXFwnIHx8ICcgKyAoJGRhdGEpICsgJyA9PSBudWxsKSAnICsgKCRjb2VyY2VkKSArICcgPSBbJyArICgkZGF0YSkgKyAnXTsgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICAgJztcbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ3R5cGUnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHR5cGU6IFxcJyc7XG4gICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gaWYgKCcgKyAoJGNvZXJjZWQpICsgJyAhPT0gdW5kZWZpbmVkKSB7ICAnO1xuICAgICAgICB2YXIgJHBhcmVudERhdGEgPSAkZGF0YUx2bCA/ICdkYXRhJyArICgoJGRhdGFMdmwgLSAxKSB8fCAnJykgOiAncGFyZW50RGF0YScsXG4gICAgICAgICAgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogJ3BhcmVudERhdGFQcm9wZXJ0eSc7XG4gICAgICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJyA9ICcgKyAoJGNvZXJjZWQpICsgJzsgJztcbiAgICAgICAgaWYgKCEkZGF0YUx2bCkge1xuICAgICAgICAgIG91dCArPSAnaWYgKCcgKyAoJHBhcmVudERhdGEpICsgJyAhPT0gdW5kZWZpbmVkKSc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgJyArICgkcGFyZW50RGF0YSkgKyAnWycgKyAoJHBhcmVudERhdGFQcm9wZXJ0eSkgKyAnXSA9ICcgKyAoJGNvZXJjZWQpICsgJzsgfSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ3R5cGUnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHR5cGU6IFxcJyc7XG4gICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICB9XG4gIGlmIChpdC5zY2hlbWEuJHJlZiAmJiAhJHJlZktleXdvcmRzKSB7XG4gICAgb3V0ICs9ICcgJyArIChpdC5SVUxFUy5hbGwuJHJlZi5jb2RlKGl0LCAnJHJlZicpKSArICcgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgfSBpZiAoZXJyb3JzID09PSAnO1xuICAgICAgaWYgKCR0b3ApIHtcbiAgICAgICAgb3V0ICs9ICcwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnZXJyc18nICsgKCRsdmwpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpIHsgJztcbiAgICAgICRjbG9zaW5nQnJhY2VzMiArPSAnfSc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBhcnIyID0gaXQuUlVMRVM7XG4gICAgaWYgKGFycjIpIHtcbiAgICAgIHZhciAkcnVsZXNHcm91cCwgaTIgPSAtMSxcbiAgICAgICAgbDIgPSBhcnIyLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTIgPCBsMikge1xuICAgICAgICAkcnVsZXNHcm91cCA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgIGlmICgkc2hvdWxkVXNlR3JvdXAoJHJ1bGVzR3JvdXApKSB7XG4gICAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKGl0LnV0aWwuY2hlY2tEYXRhVHlwZSgkcnVsZXNHcm91cC50eXBlLCAkZGF0YSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzKSkgKyAnKSB7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoJHJ1bGVzR3JvdXAudHlwZSA9PSAnb2JqZWN0JyAmJiBpdC5zY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICRzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoJHNjaGVtYSk7XG4gICAgICAgICAgICAgIHZhciBhcnIzID0gJHNjaGVtYUtleXM7XG4gICAgICAgICAgICAgIGlmIChhcnIzKSB7XG4gICAgICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSxcbiAgICAgICAgICAgICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpMyA8IGwzKSB7XG4gICAgICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICAgICAgICAgICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICBpZiAoJHNjaC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQuY29tcG9zaXRlUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGRlZmF1bHRNc2cgPSAnZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJyArICRwYXNzRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzID09PSAnbG9nJykgaXQubG9nZ2VyLndhcm4oJGRlZmF1bHRNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJGRlZmF1bHRNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkcGFzc0RhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgJyArICgkcGFzc0RhdGEpICsgJyA9PT0gbnVsbCB8fCAnICsgKCRwYXNzRGF0YSkgKyAnID09PSBcXCdcXCcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgKSAnICsgKCRwYXNzRGF0YSkgKyAnID0gJztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51c2VEZWZhdWx0cyA9PSAnc2hhcmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51c2VEZWZhdWx0KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyAnICsgKEpTT04uc3RyaW5naWZ5KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJzsgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkcnVsZXNHcm91cC50eXBlID09ICdhcnJheScgJiYgQXJyYXkuaXNBcnJheShpdC5zY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgIHZhciBhcnI0ID0gaXQuc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgICBpZiAoYXJyNCkge1xuICAgICAgICAgICAgICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgICAgICAgICAgICAgbDQgPSBhcnI0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCRpIDwgbDQpIHtcbiAgICAgICAgICAgICAgICAgICRzY2ggPSBhcnI0WyRpICs9IDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKCRzY2guZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQuY29tcG9zaXRlUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGRlZmF1bHRNc2cgPSAnZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJyArICRwYXNzRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzID09PSAnbG9nJykgaXQubG9nZ2VyLndhcm4oJGRlZmF1bHRNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJGRlZmF1bHRNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkcGFzc0RhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgJyArICgkcGFzc0RhdGEpICsgJyA9PT0gbnVsbCB8fCAnICsgKCRwYXNzRGF0YSkgKyAnID09PSBcXCdcXCcgJztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgKSAnICsgKCRwYXNzRGF0YSkgKyAnID0gJztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51c2VEZWZhdWx0cyA9PSAnc2hhcmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51c2VEZWZhdWx0KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyAnICsgKEpTT04uc3RyaW5naWZ5KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJzsgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXJyNSA9ICRydWxlc0dyb3VwLnJ1bGVzO1xuICAgICAgICAgIGlmIChhcnI1KSB7XG4gICAgICAgICAgICB2YXIgJHJ1bGUsIGk1ID0gLTEsXG4gICAgICAgICAgICAgIGw1ID0gYXJyNS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGk1IDwgbDUpIHtcbiAgICAgICAgICAgICAgJHJ1bGUgPSBhcnI1W2k1ICs9IDFdO1xuICAgICAgICAgICAgICBpZiAoJHNob3VsZFVzZVJ1bGUoJHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyICRjb2RlID0gJHJ1bGUuY29kZShpdCwgJHJ1bGUua2V5d29yZCwgJHJ1bGVzR3JvdXAudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCRjb2RlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMSArPSAnfSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMSkgKyAnICc7XG4gICAgICAgICAgICAkY2xvc2luZ0JyYWNlczEgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgIGlmICgkdHlwZVNjaGVtYSAmJiAkdHlwZVNjaGVtYSA9PT0gJHJ1bGVzR3JvdXAudHlwZSAmJiAhJGNvZXJjZVRvVHlwZXMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICAgICAgICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnR5cGUnLFxuICAgICAgICAgICAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvdHlwZSc7XG4gICAgICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICd0eXBlJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnXFwnIH0gJztcbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoZXJyb3JzID09PSAnO1xuICAgICAgICAgICAgaWYgKCR0b3ApIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnZXJyc18nICsgKCRsdmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcpIHsgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMiArPSAnfSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlczIpICsgJyAnO1xuICB9XG4gIGlmICgkdG9wKSB7XG4gICAgaWYgKCRhc3luYykge1xuICAgICAgb3V0ICs9ICcgaWYgKGVycm9ycyA9PT0gMCkgcmV0dXJuIGRhdGE7ICAgICAgICAgICAnO1xuICAgICAgb3V0ICs9ICcgZWxzZSB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZFcnJvcnMpOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyAnO1xuICAgICAgb3V0ICs9ICcgcmV0dXJuIGVycm9ycyA9PT0gMDsgICAgICAgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfTsgcmV0dXJuIHZhbGlkYXRlOyc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSBlcnJvcnMgPT09IGVycnNfJyArICgkbHZsKSArICc7JztcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkge1xuICAgIHZhciBydWxlcyA9ICRydWxlc0dyb3VwLnJ1bGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoJHNob3VsZFVzZVJ1bGUocnVsZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VSdWxlKCRydWxlKSB7XG4gICAgcmV0dXJuIGl0LnNjaGVtYVskcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8ICgkcnVsZS5pbXBsZW1lbnRzICYmICRydWxlSW1wbGVtZW50c1NvbWVLZXl3b3JkKCRydWxlKSk7XG4gIH1cblxuICBmdW5jdGlvbiAkcnVsZUltcGxlbWVudHNTb21lS2V5d29yZCgkcnVsZSkge1xuICAgIHZhciBpbXBsID0gJHJ1bGUuaW1wbGVtZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltcGwubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoaXQuc2NoZW1hW2ltcGxbaV1dICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIENhY2hlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWNoZSgpIHtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG5cblxuQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIENhY2hlX3B1dChrZXksIHZhbHVlKSB7XG4gIHRoaXMuX2NhY2hlW2tleV0gPSB2YWx1ZTtcbn07XG5cblxuQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIENhY2hlX2dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiBDYWNoZV9kZWwoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jYWNoZVtrZXldO1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBDYWNoZV9jbGVhcigpIHtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBEQVRFID0gL14oXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0oXFxkXFxkKSQvO1xudmFyIERBWVMgPSBbMCwzMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07XG52YXIgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoXFwuXFxkKyk/KHp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaTtcbnZhciBIT1NUTkFNRSA9IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2k7XG52YXIgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbnZhciBVUklSRUYgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxudmFyIFVSSVRFTVBMQVRFID0gL14oPzooPzpbXlxceDAwLVxceDIwXCInPD4lXFxcXF5ge3x9XXwlWzAtOWEtZl17Mn0pfFxce1srIy4vOz8mPSwhQHxdPyg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8oPzosKD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPykqXFx9KSokL2k7XG4vLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbi8vIEZvciB0ZXN0IGNhc2VzOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbi8vIEB0b2RvIERlbGV0ZSBjdXJyZW50IFVSTCBpbiBmYXZvdXIgb2YgdGhlIGNvbW1lbnRlZCBvdXQgVVJMIHJ1bGUgd2hlbiB0aGlzIGlzc3VlIGlzIGZpeGVkIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy83OTgzLlxuLy8gdmFyIFVSTCA9IC9eKD86KD86aHR0cHM/fGZ0cCk6XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hMTAoPzpcXC5cXGR7MSwzfSl7M30pKD8hMTI3KD86XFwuXFxkezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlxcZHsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKy0pKlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSspKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKy0pKlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXU7XG52YXIgVVJMID0gL14oPzooPzpodHRwW3NcXHUwMTdGXT98ZnRwKTpcXC9cXC8pKD86KD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKyg/OjooPzpbXFwwLVxceDA4XFx4MEUtXFx4MUYhLVxceDlGXFx4QTEtXFx1MTY3RlxcdTE2ODEtXFx1MUZGRlxcdTIwMEItXFx1MjAyN1xcdTIwMkEtXFx1MjAyRVxcdTIwMzAtXFx1MjA1RVxcdTIwNjAtXFx1MkZGRlxcdTMwMDEtXFx1RDdGRlxcdUUwMDAtXFx1RkVGRVxcdUZGMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkqKT9AKT8oPzooPyExMCg/OlxcLlswLTldezEsM30pezN9KSg/ITEyNyg/OlxcLlswLTldezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlswLTldezEsM30pezJ9KSg/ITE5MlxcLjE2OCg/OlxcLlswLTldezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyWzAtOV18M1swMV0pKD86XFwuWzAtOV17MSwzfSl7Mn0pKD86WzEtOV1bMC05XT98MVswLTldWzAtOV18MlswMV1bMC05XXwyMlswLTNdKSg/OlxcLig/OjE/WzAtOV17MSwyfXwyWzAtNF1bMC05XXwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVswLTldP3wxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTRdKSl8KD86KD86KD86WzAtOWEtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSstKSooPzpbMC05YS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKykoPzpcXC4oPzooPzpbMC05YS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKy0pKig/OlswLTlhLXpcXHhBMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkrKSooPzpcXC4oPzooPzpbYS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pezIsfSkpKSg/OjpbMC05XXsyLDV9KT8oPzpcXC8oPzpbXFwwLVxceDA4XFx4MEUtXFx4MUYhLVxceDlGXFx4QTEtXFx1MTY3RlxcdTE2ODEtXFx1MUZGRlxcdTIwMEItXFx1MjAyN1xcdTIwMkEtXFx1MjAyRVxcdTIwMzAtXFx1MjA1RVxcdTIwNjAtXFx1MkZGRlxcdTMwMDEtXFx1RDdGRlxcdUUwMDAtXFx1RkVGRVxcdUZGMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkqKT8kL2k7XG52YXIgVVVJRCA9IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pO1xudmFyIEpTT05fUE9JTlRFUiA9IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC87XG52YXIgSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCA9IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2k7XG52YXIgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0cztcblxuZnVuY3Rpb24gZm9ybWF0cyhtb2RlKSB7XG4gIG1vZGUgPSBtb2RlID09ICdmdWxsJyA/ICdmdWxsJyA6ICdmYXN0JztcbiAgcmV0dXJuIHV0aWwuY29weShmb3JtYXRzW21vZGVdKTtcbn1cblxuXG5mb3JtYXRzLmZhc3QgPSB7XG4gIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgZGF0ZTogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLyxcbiAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIHRpbWU6IC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLFxuICAnZGF0ZS10aW1lJzogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSxcbiAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICB1cmk6IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyk/W15cXHNdKiQvaSxcbiAgJ3VyaS1yZWZlcmVuY2UnOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgJ3VyaS10ZW1wbGF0ZSc6IFVSSVRFTVBMQVRFLFxuICB1cmw6IFVSTCxcbiAgLy8gZW1haWwgKHNvdXJjZXMgZnJvbSBqc2VuIHZhbGlkYXRvcik6XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsbGZ1bCB2aW9sYXRpb24nKVxuICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbiAgaG9zdG5hbWU6IEhPU1ROQU1FLFxuICAvLyBvcHRpbWl6ZWQgaHR0cHM6Ly93d3cuc2FmYXJpYm9va3NvbmxpbmUuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODA1OTY4MDI4MzcvY2gwN3MxNi5odG1sXG4gIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gIC8vIG9wdGltaXplZCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzNDk3L3JlZ3VsYXItZXhwcmVzc2lvbi10aGF0LW1hdGNoZXMtdmFsaWQtaXB2Ni1hZGRyZXNzZXNcbiAgaXB2NjogL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaSxcbiAgcmVnZXg6IHJlZ2V4LFxuICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gIHV1aWQ6IFVVSUQsXG4gIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICdqc29uLXBvaW50ZXInOiBKU09OX1BPSU5URVIsXG4gICdqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50JzogSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCxcbiAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICAncmVsYXRpdmUtanNvbi1wb2ludGVyJzogUkVMQVRJVkVfSlNPTl9QT0lOVEVSXG59O1xuXG5cbmZvcm1hdHMuZnVsbCA9IHtcbiAgZGF0ZTogZGF0ZSxcbiAgdGltZTogdGltZSxcbiAgJ2RhdGUtdGltZSc6IGRhdGVfdGltZSxcbiAgdXJpOiB1cmksXG4gICd1cmktcmVmZXJlbmNlJzogVVJJUkVGLFxuICAndXJpLXRlbXBsYXRlJzogVVJJVEVNUExBVEUsXG4gIHVybDogVVJMLFxuICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gIGhvc3RuYW1lOiBIT1NUTkFNRSxcbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgaXB2NjogL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaSxcbiAgcmVnZXg6IHJlZ2V4LFxuICB1dWlkOiBVVUlELFxuICAnanNvbi1wb2ludGVyJzogSlNPTl9QT0lOVEVSLFxuICAnanNvbi1wb2ludGVyLXVyaS1mcmFnbWVudCc6IEpTT05fUE9JTlRFUl9VUklfRlJBR01FTlQsXG4gICdyZWxhdGl2ZS1qc29uLXBvaW50ZXInOiBSRUxBVElWRV9KU09OX1BPSU5URVJcbn07XG5cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUNcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuXG5cbmZ1bmN0aW9uIGRhdGUoc3RyKSB7XG4gIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2goREFURSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciB5ZWFyID0gK21hdGNoZXNbMV07XG4gIHZhciBtb250aCA9ICttYXRjaGVzWzJdO1xuICB2YXIgZGF5ID0gK21hdGNoZXNbM107XG5cbiAgcmV0dXJuIG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgJiYgZGF5ID49IDEgJiZcbiAgICAgICAgICBkYXkgPD0gKG1vbnRoID09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pO1xufVxuXG5cbmZ1bmN0aW9uIHRpbWUoc3RyLCBmdWxsKSB7XG4gIHZhciBtYXRjaGVzID0gc3RyLm1hdGNoKFRJTUUpO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZTtcblxuICB2YXIgaG91ciA9IG1hdGNoZXNbMV07XG4gIHZhciBtaW51dGUgPSBtYXRjaGVzWzJdO1xuICB2YXIgc2Vjb25kID0gbWF0Y2hlc1szXTtcbiAgdmFyIHRpbWVab25lID0gbWF0Y2hlc1s1XTtcbiAgcmV0dXJuICgoaG91ciA8PSAyMyAmJiBtaW51dGUgPD0gNTkgJiYgc2Vjb25kIDw9IDU5KSB8fFxuICAgICAgICAgIChob3VyID09IDIzICYmIG1pbnV0ZSA9PSA1OSAmJiBzZWNvbmQgPT0gNjApKSAmJlxuICAgICAgICAgKCFmdWxsIHx8IHRpbWVab25lKTtcbn1cblxuXG52YXIgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIHZhciBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuXG5cbnZhciBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5cblxudmFyIFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBydWxlTW9kdWxlcyA9IHJlcXVpcmUoJy4uL2RvdGpzJylcbiAgLCB0b0hhc2ggPSByZXF1aXJlKCcuL3V0aWwnKS50b0hhc2g7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gIHZhciBSVUxFUyA9IFtcbiAgICB7IHR5cGU6ICdudW1iZXInLFxuICAgICAgcnVsZXM6IFsgeyAnbWF4aW11bSc6IFsnZXhjbHVzaXZlTWF4aW11bSddIH0sXG4gICAgICAgICAgICAgICB7ICdtaW5pbXVtJzogWydleGNsdXNpdmVNaW5pbXVtJ10gfSwgJ211bHRpcGxlT2YnLCAnZm9ybWF0J10gfSxcbiAgICB7IHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcnVsZXM6IFsgJ21heExlbmd0aCcsICdtaW5MZW5ndGgnLCAncGF0dGVybicsICdmb3JtYXQnIF0gfSxcbiAgICB7IHR5cGU6ICdhcnJheScsXG4gICAgICBydWxlczogWyAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLCAnaXRlbXMnLCAnY29udGFpbnMnLCAndW5pcXVlSXRlbXMnIF0gfSxcbiAgICB7IHR5cGU6ICdvYmplY3QnLFxuICAgICAgcnVsZXM6IFsgJ21heFByb3BlcnRpZXMnLCAnbWluUHJvcGVydGllcycsICdyZXF1aXJlZCcsICdkZXBlbmRlbmNpZXMnLCAncHJvcGVydHlOYW1lcycsXG4gICAgICAgICAgICAgICB7ICdwcm9wZXJ0aWVzJzogWydhZGRpdGlvbmFsUHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcyddIH0gXSB9LFxuICAgIHsgcnVsZXM6IFsgJyRyZWYnLCAnY29uc3QnLCAnZW51bScsICdub3QnLCAnYW55T2YnLCAnb25lT2YnLCAnYWxsT2YnLCAnaWYnIF0gfVxuICBdO1xuXG4gIHZhciBBTEwgPSBbICd0eXBlJywgJyRjb21tZW50JyBdO1xuICB2YXIgS0VZV09SRFMgPSBbXG4gICAgJyRzY2hlbWEnLCAnJGlkJywgJ2lkJywgJyRkYXRhJywgJyRhc3luYycsICd0aXRsZScsXG4gICAgJ2Rlc2NyaXB0aW9uJywgJ2RlZmF1bHQnLCAnZGVmaW5pdGlvbnMnLFxuICAgICdleGFtcGxlcycsICdyZWFkT25seScsICd3cml0ZU9ubHknLFxuICAgICdjb250ZW50TWVkaWFUeXBlJywgJ2NvbnRlbnRFbmNvZGluZycsXG4gICAgJ2FkZGl0aW9uYWxJdGVtcycsICd0aGVuJywgJ2Vsc2UnXG4gIF07XG4gIHZhciBUWVBFUyA9IFsgJ251bWJlcicsICdpbnRlZ2VyJywgJ3N0cmluZycsICdhcnJheScsICdvYmplY3QnLCAnYm9vbGVhbicsICdudWxsJyBdO1xuICBSVUxFUy5hbGwgPSB0b0hhc2goQUxMKTtcbiAgUlVMRVMudHlwZXMgPSB0b0hhc2goVFlQRVMpO1xuXG4gIFJVTEVTLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgZ3JvdXAucnVsZXMgPSBncm91cC5ydWxlcy5tYXAoZnVuY3Rpb24gKGtleXdvcmQpIHtcbiAgICAgIHZhciBpbXBsS2V5d29yZHM7XG4gICAgICBpZiAodHlwZW9mIGtleXdvcmQgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKGtleXdvcmQpWzBdO1xuICAgICAgICBpbXBsS2V5d29yZHMgPSBrZXl3b3JkW2tleV07XG4gICAgICAgIGtleXdvcmQgPSBrZXk7XG4gICAgICAgIGltcGxLZXl3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgQUxMLnB1c2goayk7XG4gICAgICAgICAgUlVMRVMuYWxsW2tdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBBTEwucHVzaChrZXl3b3JkKTtcbiAgICAgIHZhciBydWxlID0gUlVMRVMuYWxsW2tleXdvcmRdID0ge1xuICAgICAgICBrZXl3b3JkOiBrZXl3b3JkLFxuICAgICAgICBjb2RlOiBydWxlTW9kdWxlc1trZXl3b3JkXSxcbiAgICAgICAgaW1wbGVtZW50czogaW1wbEtleXdvcmRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfSk7XG5cbiAgICBSVUxFUy5hbGwuJGNvbW1lbnQgPSB7XG4gICAgICBrZXl3b3JkOiAnJGNvbW1lbnQnLFxuICAgICAgY29kZTogcnVsZU1vZHVsZXMuJGNvbW1lbnRcbiAgICB9O1xuXG4gICAgaWYgKGdyb3VwLnR5cGUpIFJVTEVTLnR5cGVzW2dyb3VwLnR5cGVdID0gZ3JvdXA7XG4gIH0pO1xuXG4gIFJVTEVTLmtleXdvcmRzID0gdG9IYXNoKEFMTC5jb25jYXQoS0VZV09SRFMpKTtcbiAgUlVMRVMuY3VzdG9tID0ge307XG5cbiAgcmV0dXJuIFJVTEVTO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9hbGwgcmVxdWlyZXMgbXVzdCBiZSBleHBsaWNpdCBiZWNhdXNlIGJyb3dzZXJpZnkgd29uJ3Qgd29yayB3aXRoIGR5bmFtaWMgcmVxdWlyZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICAnJHJlZic6IHJlcXVpcmUoJy4vcmVmJyksXG4gIGFsbE9mOiByZXF1aXJlKCcuL2FsbE9mJyksXG4gIGFueU9mOiByZXF1aXJlKCcuL2FueU9mJyksXG4gICckY29tbWVudCc6IHJlcXVpcmUoJy4vY29tbWVudCcpLFxuICBjb25zdDogcmVxdWlyZSgnLi9jb25zdCcpLFxuICBjb250YWluczogcmVxdWlyZSgnLi9jb250YWlucycpLFxuICBkZXBlbmRlbmNpZXM6IHJlcXVpcmUoJy4vZGVwZW5kZW5jaWVzJyksXG4gICdlbnVtJzogcmVxdWlyZSgnLi9lbnVtJyksXG4gIGZvcm1hdDogcmVxdWlyZSgnLi9mb3JtYXQnKSxcbiAgJ2lmJzogcmVxdWlyZSgnLi9pZicpLFxuICBpdGVtczogcmVxdWlyZSgnLi9pdGVtcycpLFxuICBtYXhpbXVtOiByZXF1aXJlKCcuL19saW1pdCcpLFxuICBtaW5pbXVtOiByZXF1aXJlKCcuL19saW1pdCcpLFxuICBtYXhJdGVtczogcmVxdWlyZSgnLi9fbGltaXRJdGVtcycpLFxuICBtaW5JdGVtczogcmVxdWlyZSgnLi9fbGltaXRJdGVtcycpLFxuICBtYXhMZW5ndGg6IHJlcXVpcmUoJy4vX2xpbWl0TGVuZ3RoJyksXG4gIG1pbkxlbmd0aDogcmVxdWlyZSgnLi9fbGltaXRMZW5ndGgnKSxcbiAgbWF4UHJvcGVydGllczogcmVxdWlyZSgnLi9fbGltaXRQcm9wZXJ0aWVzJyksXG4gIG1pblByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX2xpbWl0UHJvcGVydGllcycpLFxuICBtdWx0aXBsZU9mOiByZXF1aXJlKCcuL211bHRpcGxlT2YnKSxcbiAgbm90OiByZXF1aXJlKCcuL25vdCcpLFxuICBvbmVPZjogcmVxdWlyZSgnLi9vbmVPZicpLFxuICBwYXR0ZXJuOiByZXF1aXJlKCcuL3BhdHRlcm4nKSxcbiAgcHJvcGVydGllczogcmVxdWlyZSgnLi9wcm9wZXJ0aWVzJyksXG4gIHByb3BlcnR5TmFtZXM6IHJlcXVpcmUoJy4vcHJvcGVydHlOYW1lcycpLFxuICByZXF1aXJlZDogcmVxdWlyZSgnLi9yZXF1aXJlZCcpLFxuICB1bmlxdWVJdGVtczogcmVxdWlyZSgnLi91bmlxdWVJdGVtcycpLFxuICB2YWxpZGF0ZTogcmVxdWlyZSgnLi92YWxpZGF0ZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9yZWYoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRhc3luYywgJHJlZkNvZGU7XG4gIGlmICgkc2NoZW1hID09ICcjJyB8fCAkc2NoZW1hID09ICcjLycpIHtcbiAgICBpZiAoaXQuaXNSb290KSB7XG4gICAgICAkYXN5bmMgPSBpdC5hc3luYztcbiAgICAgICRyZWZDb2RlID0gJ3ZhbGlkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgJGFzeW5jID0gaXQucm9vdC5zY2hlbWEuJGFzeW5jID09PSB0cnVlO1xuICAgICAgJHJlZkNvZGUgPSAncm9vdC5yZWZWYWxbMF0nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJHJlZlZhbCA9IGl0LnJlc29sdmVSZWYoaXQuYmFzZUlkLCAkc2NoZW1hLCBpdC5pc1Jvb3QpO1xuICAgIGlmICgkcmVmVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciAkbWVzc2FnZSA9IGl0Lk1pc3NpbmdSZWZFcnJvci5tZXNzYWdlKGl0LmJhc2VJZCwgJHNjaGVtYSk7XG4gICAgICBpZiAoaXQub3B0cy5taXNzaW5nUmVmcyA9PSAnZmFpbCcpIHtcbiAgICAgICAgaXQubG9nZ2VyLmVycm9yKCRtZXNzYWdlKTtcbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCckcmVmJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyByZWY6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2NhblxcXFxcXCd0IHJlc29sdmUgcmVmZXJlbmNlICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoZmFsc2UpIHsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpdC5vcHRzLm1pc3NpbmdSZWZzID09ICdpZ25vcmUnKSB7XG4gICAgICAgIGl0LmxvZ2dlci53YXJuKCRtZXNzYWdlKTtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgaXQuTWlzc2luZ1JlZkVycm9yKGl0LmJhc2VJZCwgJHNjaGVtYSwgJG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJHJlZlZhbC5pbmxpbmUpIHtcbiAgICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgICAgJGl0LmxldmVsKys7XG4gICAgICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gICAgICAkaXQuc2NoZW1hID0gJHJlZlZhbC5zY2hlbWE7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICcnO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkc2NoZW1hO1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KS5yZXBsYWNlKC92YWxpZGF0ZVxcLnNjaGVtYS9nLCAkcmVmVmFsLmNvZGUpO1xuICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJGFzeW5jID0gJHJlZlZhbC4kYXN5bmMgPT09IHRydWUgfHwgKGl0LmFzeW5jICYmICRyZWZWYWwuJGFzeW5jICE9PSBmYWxzZSk7XG4gICAgICAkcmVmQ29kZSA9ICRyZWZWYWwuY29kZTtcbiAgICB9XG4gIH1cbiAgaWYgKCRyZWZDb2RlKSB7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnO1xuICAgIGlmIChpdC5vcHRzLnBhc3NDb250ZXh0KSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRyZWZDb2RlKSArICcuY2FsbCh0aGlzLCAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRyZWZDb2RlKSArICcoICc7XG4gICAgfVxuICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJywgKGRhdGFQYXRoIHx8IFxcJ1xcJyknO1xuICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICB9XG4gICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyAnZGF0YScgKyAoKCRkYXRhTHZsIC0gMSkgfHwgJycpIDogJ3BhcmVudERhdGEnLFxuICAgICAgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogJ3BhcmVudERhdGFQcm9wZXJ0eSc7XG4gICAgb3V0ICs9ICcgLCAnICsgKCRwYXJlbnREYXRhKSArICcgLCAnICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJywgcm9vdERhdGEpICAnO1xuICAgIHZhciBfX2NhbGxWYWxpZGF0ZSA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICgkYXN5bmMpIHtcbiAgICAgIGlmICghaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWEnKTtcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgdHJ5IHsgYXdhaXQgJyArIChfX2NhbGxWYWxpZGF0ZSkgKyAnOyAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9IHRydWU7ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9IGNhdGNoIChlKSB7IGlmICghKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpKSB0aHJvdyBlOyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IGUuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdChlLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgaWYgKCEnICsgKF9fY2FsbFZhbGlkYXRlKSArICcpIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCRyZWZDb2RlKSArICcuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdCgnICsgKCRyZWZDb2RlKSArICcuZXJyb3JzKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7IH0gJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbGxPZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJGN1cnJlbnRCYXNlSWQgPSAkaXQuYmFzZUlkLFxuICAgICRhbGxTY2hlbWFzRW1wdHkgPSB0cnVlO1xuICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gIGlmIChhcnIxKSB7XG4gICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCkgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAgICRhbGxTY2hlbWFzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIGlmICgkYWxsU2NoZW1hc0VtcHR5KSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzLnNsaWNlKDAsIC0xKSkgKyAnICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2FueU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkbm9FbXB0eVNjaGVtYSA9ICRzY2hlbWEuZXZlcnkoZnVuY3Rpb24oJHNjaCkge1xuICAgIHJldHVybiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaCA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoKS5sZW5ndGggPiAwKSB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSk7XG4gIH0pO1xuICBpZiAoJG5vRW1wdHlTY2hlbWEpIHtcbiAgICB2YXIgJGN1cnJlbnRCYXNlSWQgPSAkaXQuYmFzZUlkO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7IHZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICAnO1xuICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGggKyAnLycgKyAkaTtcbiAgICAgICAgb3V0ICs9ICcgICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJHZhbGlkKSArICcgfHwgJyArICgkbmV4dFZhbGlkKSArICc7IGlmICghJyArICgkdmFsaWQpICsgJykgeyAnO1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICB9XG4gICAgfVxuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnYW55T2YnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHNvbWUgc2NoZW1hIGluIGFueU9mXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSAnIH0gZWxzZSB7ICBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb21tZW50KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRjb21tZW50ID0gaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKTtcbiAgaWYgKGl0Lm9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICBvdXQgKz0gJyBjb25zb2xlLmxvZygnICsgKCRjb21tZW50KSArICcpOyc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGl0Lm9wdHMuJGNvbW1lbnQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG91dCArPSAnIHNlbGYuX29wdHMuJGNvbW1lbnQoJyArICgkY29tbWVudCkgKyAnLCAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcsIHZhbGlkYXRlLnJvb3Quc2NoZW1hKTsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2NvbnN0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICghJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsnO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJHZhbGlkKSArICcgPSBlcXVhbCgnICsgKCRkYXRhKSArICcsIHNjaGVtYScgKyAoJGx2bCkgKyAnKTsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdjb25zdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlOiBzY2hlbWEnICsgKCRsdmwpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBlcXVhbCB0byBjb25zdGFudFxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0nO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2NvbnRhaW5zKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkaWR4ID0gJ2knICsgJGx2bCxcbiAgICAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkLFxuICAgICRub25FbXB0eVNjaGVtYSA9IChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoZW1hID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2hlbWEpLmxlbmd0aCA+IDApIHx8ICRzY2hlbWEgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKTtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciAnICsgKCR2YWxpZCkgKyAnOyc7XG4gIGlmICgkbm9uRW1wdHlTY2hlbWEpIHtcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHRWYWxpZCkgKyAnID0gZmFsc2U7IGZvciAodmFyICcgKyAoJGlkeCkgKyAnID0gMDsgJyArICgkaWR4KSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7ICc7XG4gICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaWR4LCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGlkeCArICddJztcbiAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGlkeDtcbiAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgYnJlYWs7IH0gICc7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgeyc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPT0gMCkgeyc7XG4gIH1cbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdjb250YWlucycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBjb250YWluIGEgdmFsaWQgaXRlbVxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gIGlmICgkbm9uRW1wdHlTY2hlbWEpIHtcbiAgICBvdXQgKz0gJyAgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICB9XG4gIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgIG91dCArPSAnIH0gJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9kZXBlbmRlbmNpZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkc2NoZW1hRGVwcyA9IHt9LFxuICAgICRwcm9wZXJ0eURlcHMgPSB7fSxcbiAgICAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcztcbiAgZm9yICgkcHJvcGVydHkgaW4gJHNjaGVtYSkge1xuICAgIGlmICgkcHJvcGVydHkgPT0gJ19fcHJvdG9fXycpIGNvbnRpbnVlO1xuICAgIHZhciAkc2NoID0gJHNjaGVtYVskcHJvcGVydHldO1xuICAgIHZhciAkZGVwcyA9IEFycmF5LmlzQXJyYXkoJHNjaCkgPyAkcHJvcGVydHlEZXBzIDogJHNjaGVtYURlcHM7XG4gICAgJGRlcHNbJHByb3BlcnR5XSA9ICRzY2g7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyc7XG4gIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgb3V0ICs9ICd2YXIgbWlzc2luZycgKyAoJGx2bCkgKyAnOyc7XG4gIGZvciAodmFyICRwcm9wZXJ0eSBpbiAkcHJvcGVydHlEZXBzKSB7XG4gICAgJGRlcHMgPSAkcHJvcGVydHlEZXBzWyRwcm9wZXJ0eV07XG4gICAgaWYgKCRkZXBzLmxlbmd0aCkge1xuICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCRkYXRhKSArIChpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSkpICsgJyAhPT0gdW5kZWZpbmVkICc7XG4gICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgb3V0ICs9ICcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcpICc7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyAmJiAoICc7XG4gICAgICAgIHZhciBhcnIxID0gJGRlcHM7XG4gICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICR1c2VEYXRhID0gJGRhdGEgKyAkcHJvcDtcbiAgICAgICAgICAgIG91dCArPSAnICggKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgJiYgKG1pc3NpbmcnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eUtleSA6ICRwcm9wKSkgKyAnKSApICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSkgeyAgJztcbiAgICAgICAgdmFyICRwcm9wZXJ0eVBhdGggPSAnbWlzc2luZycgKyAkbHZsLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgJyArICRwcm9wZXJ0eVBhdGggKyAnICsgXFwnJztcbiAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuanNvblBvaW50ZXJzID8gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgdHJ1ZSkgOiAkY3VycmVudEVycm9yUGF0aCArICcgKyAnICsgJHByb3BlcnR5UGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2RlcGVuZGVuY2llcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgcHJvcGVydHk6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnLCBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnLCBkZXBzQ291bnQ6ICcgKyAoJGRlcHMubGVuZ3RoKSArICcsIGRlcHM6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMubGVuZ3RoID09IDEgPyAkZGVwc1swXSA6ICRkZXBzLmpvaW4oXCIsIFwiKSkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBoYXZlICc7XG4gICAgICAgICAgICBpZiAoJGRlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJ3Byb3BlcnRpZXMgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnIHdoZW4gcHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICcgaXMgcHJlc2VudFxcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyApIHsgJztcbiAgICAgICAgdmFyIGFycjIgPSAkZGVwcztcbiAgICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMiA9IC0xLFxuICAgICAgICAgICAgbDIgPSBhcnIyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGkyIDwgbDIpIHtcbiAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoICcgKyAoJHVzZURhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHByb3BlcnR5OiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJ1xcJywgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJywgZGVwc0NvdW50OiAnICsgKCRkZXBzLmxlbmd0aCkgKyAnLCBkZXBzOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmxlbmd0aCA9PSAxID8gJGRlcHNbMF0gOiAkZGVwcy5qb2luKFwiLCBcIikpKSArICdcXCcgfSAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBoYXZlICc7XG4gICAgICAgICAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ3Byb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHNbMF0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0aWVzICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnIHdoZW4gcHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICcgaXMgcHJlc2VudFxcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICB2YXIgJGN1cnJlbnRCYXNlSWQgPSAkaXQuYmFzZUlkO1xuICBmb3IgKHZhciAkcHJvcGVydHkgaW4gJHNjaGVtYURlcHMpIHtcbiAgICB2YXIgJHNjaCA9ICRzY2hlbWFEZXBzWyRwcm9wZXJ0eV07XG4gICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgb3V0ICs9ICcgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyBpZiAoICcgKyAoJGRhdGEpICsgKGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5KSkgKyAnICE9PSB1bmRlZmluZWQgJztcbiAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICBvdXQgKz0gJyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJ1xcJykgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSk7XG4gICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgaXQudXRpbC5lc2NhcGVGcmFnbWVudCgkcHJvcGVydHkpO1xuICAgICAgb3V0ICs9ICcgICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAgICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZW51bShpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICR2U2NoZW1hID0gJ3NjaGVtYScgKyAkbHZsO1xuICBpZiAoISRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkdlNjaGVtYSkgKyAnID0gdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnOyc7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIGlmIChzY2hlbWEnICsgKCRsdmwpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hJyArICgkbHZsKSArICcpKSAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGVsc2Ugeyc7XG4gIH1cbiAgb3V0ICs9ICcnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7Zm9yICh2YXIgJyArICgkaSkgKyAnPTA7ICcgKyAoJGkpICsgJzwnICsgKCR2U2NoZW1hKSArICcubGVuZ3RoOyAnICsgKCRpKSArICcrKykgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJywgJyArICgkdlNjaGVtYSkgKyAnWycgKyAoJGkpICsgJ10pKSB7ICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyBicmVhazsgfSc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgIH0gICc7XG4gIH1cbiAgb3V0ICs9ICcgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdlbnVtJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBhbGxvd2VkVmFsdWVzOiBzY2hlbWEnICsgKCRsdmwpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZm9ybWF0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIGlmIChpdC5vcHRzLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICR1bmtub3duRm9ybWF0cyA9IGl0Lm9wdHMudW5rbm93bkZvcm1hdHMsXG4gICAgJGFsbG93VW5rbm93biA9IEFycmF5LmlzQXJyYXkoJHVua25vd25Gb3JtYXRzKTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICB2YXIgJGZvcm1hdCA9ICdmb3JtYXQnICsgJGx2bCxcbiAgICAgICRpc09iamVjdCA9ICdpc09iamVjdCcgKyAkbHZsLFxuICAgICAgJGZvcm1hdFR5cGUgPSAnZm9ybWF0VHlwZScgKyAkbHZsO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRmb3JtYXQpICsgJyA9IGZvcm1hdHNbJyArICgkc2NoZW1hVmFsdWUpICsgJ107IHZhciAnICsgKCRpc09iamVjdCkgKyAnID0gdHlwZW9mICcgKyAoJGZvcm1hdCkgKyAnID09IFxcJ29iamVjdFxcJyAmJiAhKCcgKyAoJGZvcm1hdCkgKyAnIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAnICsgKCRmb3JtYXQpICsgJy52YWxpZGF0ZTsgdmFyICcgKyAoJGZvcm1hdFR5cGUpICsgJyA9ICcgKyAoJGlzT2JqZWN0KSArICcgJiYgJyArICgkZm9ybWF0KSArICcudHlwZSB8fCBcXCdzdHJpbmdcXCc7IGlmICgnICsgKCRpc09iamVjdCkgKyAnKSB7ICc7XG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgYXN5bmMnICsgKCRsdmwpICsgJyA9ICcgKyAoJGZvcm1hdCkgKyAnLmFzeW5jOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAnICsgKCRmb3JtYXQpICsgJyA9ICcgKyAoJGZvcm1hdCkgKyAnLnZhbGlkYXRlOyB9IGlmICggICc7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnc3RyaW5nXFwnKSB8fCAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAoJztcbiAgICBpZiAoJHVua25vd25Gb3JtYXRzICE9ICdpZ25vcmUnKSB7XG4gICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAmJiAhJyArICgkZm9ybWF0KSArICcgJztcbiAgICAgIGlmICgkYWxsb3dVbmtub3duKSB7XG4gICAgICAgIG91dCArPSAnICYmIHNlbGYuX29wdHMudW5rbm93bkZvcm1hdHMuaW5kZXhPZignICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSA9PSAtMSAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpIHx8ICc7XG4gICAgfVxuICAgIG91dCArPSAnICgnICsgKCRmb3JtYXQpICsgJyAmJiAnICsgKCRmb3JtYXRUeXBlKSArICcgPT0gXFwnJyArICgkcnVsZVR5cGUpICsgJ1xcJyAmJiAhKHR5cGVvZiAnICsgKCRmb3JtYXQpICsgJyA9PSBcXCdmdW5jdGlvblxcJyA/ICc7XG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyAoYXN5bmMnICsgKCRsdmwpICsgJyA/IGF3YWl0ICcgKyAoJGZvcm1hdCkgKyAnKCcgKyAoJGRhdGEpICsgJykgOiAnICsgKCRmb3JtYXQpICsgJygnICsgKCRkYXRhKSArICcpKSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRmb3JtYXQpICsgJygnICsgKCRkYXRhKSArICcpICc7XG4gICAgfVxuICAgIG91dCArPSAnIDogJyArICgkZm9ybWF0KSArICcudGVzdCgnICsgKCRkYXRhKSArICcpKSkpKSB7JztcbiAgfSBlbHNlIHtcbiAgICB2YXIgJGZvcm1hdCA9IGl0LmZvcm1hdHNbJHNjaGVtYV07XG4gICAgaWYgKCEkZm9ybWF0KSB7XG4gICAgICBpZiAoJHVua25vd25Gb3JtYXRzID09ICdpZ25vcmUnKSB7XG4gICAgICAgIGl0LmxvZ2dlci53YXJuKCd1bmtub3duIGZvcm1hdCBcIicgKyAkc2NoZW1hICsgJ1wiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0gZWxzZSBpZiAoJGFsbG93VW5rbm93biAmJiAkdW5rbm93bkZvcm1hdHMuaW5kZXhPZigkc2NoZW1hKSA+PSAwKSB7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZvcm1hdCBcIicgKyAkc2NoZW1hICsgJ1wiIGlzIHVzZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgJGlzT2JqZWN0ID0gdHlwZW9mICRmb3JtYXQgPT0gJ29iamVjdCcgJiYgISgkZm9ybWF0IGluc3RhbmNlb2YgUmVnRXhwKSAmJiAkZm9ybWF0LnZhbGlkYXRlO1xuICAgIHZhciAkZm9ybWF0VHlwZSA9ICRpc09iamVjdCAmJiAkZm9ybWF0LnR5cGUgfHwgJ3N0cmluZyc7XG4gICAgaWYgKCRpc09iamVjdCkge1xuICAgICAgdmFyICRhc3luYyA9ICRmb3JtYXQuYXN5bmMgPT09IHRydWU7XG4gICAgICAkZm9ybWF0ID0gJGZvcm1hdC52YWxpZGF0ZTtcbiAgICB9XG4gICAgaWYgKCRmb3JtYXRUeXBlICE9ICRydWxlVHlwZSkge1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGlmICgkYXN5bmMpIHtcbiAgICAgIGlmICghaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hJyk7XG4gICAgICB2YXIgJGZvcm1hdFJlZiA9ICdmb3JtYXRzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSkgKyAnLnZhbGlkYXRlJztcbiAgICAgIG91dCArPSAnIGlmICghKGF3YWl0ICcgKyAoJGZvcm1hdFJlZikgKyAnKCcgKyAoJGRhdGEpICsgJykpKSB7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGlmICghICc7XG4gICAgICB2YXIgJGZvcm1hdFJlZiA9ICdmb3JtYXRzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSk7XG4gICAgICBpZiAoJGlzT2JqZWN0KSAkZm9ybWF0UmVmICs9ICcudmFsaWRhdGUnO1xuICAgICAgaWYgKHR5cGVvZiAkZm9ybWF0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkZm9ybWF0UmVmKSArICcoJyArICgkZGF0YSkgKyAnKSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkZm9ybWF0UmVmKSArICcudGVzdCgnICsgKCRkYXRhKSArICcpICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgeyAnO1xuICAgIH1cbiAgfVxuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2Zvcm1hdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgZm9ybWF0OiAgJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICB9XG4gICAgb3V0ICs9ICcgIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGZvcm1hdCBcIic7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnXCJcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2lmKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICR0aGVuU2NoID0gaXQuc2NoZW1hWyd0aGVuJ10sXG4gICAgJGVsc2VTY2ggPSBpdC5zY2hlbWFbJ2Vsc2UnXSxcbiAgICAkdGhlblByZXNlbnQgPSAkdGhlblNjaCAhPT0gdW5kZWZpbmVkICYmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkdGhlblNjaCA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkdGhlblNjaCkubGVuZ3RoID4gMCkgfHwgJHRoZW5TY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkdGhlblNjaCwgaXQuUlVMRVMuYWxsKSksXG4gICAgJGVsc2VQcmVzZW50ID0gJGVsc2VTY2ggIT09IHVuZGVmaW5lZCAmJiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJGVsc2VTY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJGVsc2VTY2gpLmxlbmd0aCA+IDApIHx8ICRlbHNlU2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJGVsc2VTY2gsIGl0LlJVTEVTLmFsbCkpLFxuICAgICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZDtcbiAgaWYgKCR0aGVuUHJlc2VudCB8fCAkZWxzZVByZXNlbnQpIHtcbiAgICB2YXIgJGlmQ2xhdXNlO1xuICAgICRpdC5jcmVhdGVFcnJvcnMgPSBmYWxzZTtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAgJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgJGl0LmNyZWF0ZUVycm9ycyA9IHRydWU7XG4gICAgb3V0ICs9ICcgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gICc7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBpZiAoJHRoZW5QcmVzZW50KSB7XG4gICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgICc7XG4gICAgICAkaXQuc2NoZW1hID0gaXQuc2NoZW1hWyd0aGVuJ107XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnRoZW4nO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy90aGVuJztcbiAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJG5leHRWYWxpZCkgKyAnOyAnO1xuICAgICAgaWYgKCR0aGVuUHJlc2VudCAmJiAkZWxzZVByZXNlbnQpIHtcbiAgICAgICAgJGlmQ2xhdXNlID0gJ2lmQ2xhdXNlJyArICRsdmw7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRpZkNsYXVzZSkgKyAnID0gXFwndGhlblxcJzsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpZkNsYXVzZSA9ICdcXCd0aGVuXFwnJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIGlmICgkZWxzZVByZXNlbnQpIHtcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRlbHNlUHJlc2VudCkge1xuICAgICAgJGl0LnNjaGVtYSA9IGl0LnNjaGVtYVsnZWxzZSddO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5lbHNlJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvZWxzZSc7XG4gICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRuZXh0VmFsaWQpICsgJzsgJztcbiAgICAgIGlmICgkdGhlblByZXNlbnQgJiYgJGVsc2VQcmVzZW50KSB7XG4gICAgICAgICRpZkNsYXVzZSA9ICdpZkNsYXVzZScgKyAkbHZsO1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkaWZDbGF1c2UpICsgJyA9IFxcJ2Vsc2VcXCc7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaWZDbGF1c2UgPSAnXFwnZWxzZVxcJyc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICAgIG91dCArPSAnIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnaWYnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGZhaWxpbmdLZXl3b3JkOiAnICsgKCRpZkNsYXVzZSkgKyAnIH0gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBcIlxcJyArICcgKyAoJGlmQ2xhdXNlKSArICcgKyBcXCdcIiBzY2hlbWFcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9ICcgfSAgICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfaXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRpZHggPSAnaScgKyAkbHZsLFxuICAgICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQsXG4gICAgJGN1cnJlbnRCYXNlSWQgPSBpdC5iYXNlSWQ7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoQXJyYXkuaXNBcnJheSgkc2NoZW1hKSkge1xuICAgIHZhciAkYWRkaXRpb25hbEl0ZW1zID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICBpZiAoJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoIDw9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgJztcbiAgICAgIHZhciAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgIG91dCArPSAnICBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICAnO1xuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbEl0ZW1zJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnIH0gJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgIH1cbiAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgJGVyclNjaGVtYVBhdGggPSAkY3VyckVyclNjaGVtYVBhdGg7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgaWYgKGFycjEpIHtcbiAgICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCkgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJGkpICsgJykgeyAnO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpICsgJ10nO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgJGk7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaSwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mICRhZGRpdGlvbmFsSXRlbXMgPT0gJ29iamVjdCcgJiYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRhZGRpdGlvbmFsSXRlbXMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJGFkZGl0aW9uYWxJdGVtcykubGVuZ3RoID4gMCkgfHwgJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRhZGRpdGlvbmFsSXRlbXMsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAkaXQuc2NoZW1hID0gJGFkZGl0aW9uYWxJdGVtcztcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcpIHsgIGZvciAodmFyICcgKyAoJGlkeCkgKyAnID0gJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnOyAnICsgKCRpZHgpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgJztcbiAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGlkeCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGlkeCArICddJztcbiAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSB9ICAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2hlbWEgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaGVtYSkubGVuZ3RoID4gMCkgfHwgJHNjaGVtYSA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIG91dCArPSAnICBmb3IgKHZhciAnICsgKCRpZHgpICsgJyA9ICcgKyAoMCkgKyAnOyAnICsgKCRpZHgpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgJztcbiAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRpZHgsIGl0Lm9wdHMuanNvblBvaW50ZXJzLCB0cnVlKTtcbiAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAkaWR4ICsgJ10nO1xuICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICB9XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9JztcbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfX2xpbWl0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICRpc01heCA9ICRrZXl3b3JkID09ICdtYXhpbXVtJyxcbiAgICAkZXhjbHVzaXZlS2V5d29yZCA9ICRpc01heCA/ICdleGNsdXNpdmVNYXhpbXVtJyA6ICdleGNsdXNpdmVNaW5pbXVtJyxcbiAgICAkc2NoZW1hRXhjbCA9IGl0LnNjaGVtYVskZXhjbHVzaXZlS2V5d29yZF0sXG4gICAgJGlzRGF0YUV4Y2wgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWFFeGNsICYmICRzY2hlbWFFeGNsLiRkYXRhLFxuICAgICRvcCA9ICRpc01heCA/ICc8JyA6ICc+JyxcbiAgICAkbm90T3AgPSAkaXNNYXggPyAnPicgOiAnPCcsXG4gICAgJGVycm9yS2V5d29yZCA9IHVuZGVmaW5lZDtcbiAgaWYgKCEoJGlzRGF0YSB8fCB0eXBlb2YgJHNjaGVtYSA9PSAnbnVtYmVyJyB8fCAkc2NoZW1hID09PSB1bmRlZmluZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgJyBtdXN0IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICghKCRpc0RhdGFFeGNsIHx8ICRzY2hlbWFFeGNsID09PSB1bmRlZmluZWQgfHwgdHlwZW9mICRzY2hlbWFFeGNsID09ICdudW1iZXInIHx8IHR5cGVvZiAkc2NoZW1hRXhjbCA9PSAnYm9vbGVhbicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCRleGNsdXNpdmVLZXl3b3JkICsgJyBtdXN0IGJlIG51bWJlciBvciBib29sZWFuJyk7XG4gIH1cbiAgaWYgKCRpc0RhdGFFeGNsKSB7XG4gICAgdmFyICRzY2hlbWFWYWx1ZUV4Y2wgPSBpdC51dGlsLmdldERhdGEoJHNjaGVtYUV4Y2wuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFyciksXG4gICAgICAkZXhjbHVzaXZlID0gJ2V4Y2x1c2l2ZScgKyAkbHZsLFxuICAgICAgJGV4Y2xUeXBlID0gJ2V4Y2xUeXBlJyArICRsdmwsXG4gICAgICAkZXhjbElzTnVtYmVyID0gJ2V4Y2xJc051bWJlcicgKyAkbHZsLFxuICAgICAgJG9wRXhwciA9ICdvcCcgKyAkbHZsLFxuICAgICAgJG9wU3RyID0gJ1xcJyArICcgKyAkb3BFeHByICsgJyArIFxcJyc7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYUV4Y2wnICsgKCRsdmwpICsgJyA9ICcgKyAoJHNjaGVtYVZhbHVlRXhjbCkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZUV4Y2wgPSAnc2NoZW1hRXhjbCcgKyAkbHZsO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRleGNsdXNpdmUpICsgJzsgdmFyICcgKyAoJGV4Y2xUeXBlKSArICcgPSB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICc7IGlmICgnICsgKCRleGNsVHlwZSkgKyAnICE9IFxcJ2Jvb2xlYW5cXCcgJiYgJyArICgkZXhjbFR5cGUpICsgJyAhPSBcXCd1bmRlZmluZWRcXCcgJiYgJyArICgkZXhjbFR5cGUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHsgJztcbiAgICB2YXIgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ19leGNsdXNpdmVMaW1pdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnICsgKCRleGNsdXNpdmVLZXl3b3JkKSArICcgc2hvdWxkIGJlIGJvb2xlYW5cXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9IGVsc2UgaWYgKCAnO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgJyArICgkZXhjbFR5cGUpICsgJyA9PSBcXCdudW1iZXJcXCcgPyAoICgnICsgKCRleGNsdXNpdmUpICsgJyA9ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgPT09IHVuZGVmaW5lZCB8fCAnICsgKCRzY2hlbWFWYWx1ZUV4Y2wpICsgJyAnICsgKCRvcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSA/ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZUV4Y2wpICsgJyA6ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKSA6ICggKCcgKyAoJGV4Y2x1c2l2ZSkgKyAnID0gJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICcgPT09IHRydWUpID8gJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICc9ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgOiAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICkgfHwgJyArICgkZGF0YSkgKyAnICE9PSAnICsgKCRkYXRhKSArICcpIHsgdmFyIG9wJyArICgkbHZsKSArICcgPSAnICsgKCRleGNsdXNpdmUpICsgJyA/IFxcJycgKyAoJG9wKSArICdcXCcgOiBcXCcnICsgKCRvcCkgKyAnPVxcJzsgJztcbiAgICBpZiAoJHNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAkZXJyb3JLZXl3b3JkID0gJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWFWYWx1ZUV4Y2w7XG4gICAgICAkaXNEYXRhID0gJGlzRGF0YUV4Y2w7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciAkZXhjbElzTnVtYmVyID0gdHlwZW9mICRzY2hlbWFFeGNsID09ICdudW1iZXInLFxuICAgICAgJG9wU3RyID0gJG9wO1xuICAgIGlmICgkZXhjbElzTnVtYmVyICYmICRpc0RhdGEpIHtcbiAgICAgIHZhciAkb3BFeHByID0gJ1xcJycgKyAkb3BTdHIgKyAnXFwnJztcbiAgICAgIG91dCArPSAnIGlmICggJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAnICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnbnVtYmVyXFwnKSB8fCAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgKCAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID09PSB1bmRlZmluZWQgfHwgJyArICgkc2NoZW1hRXhjbCkgKyAnICcgKyAoJG9wKSArICc9ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgPyAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJz0gJyArICgkc2NoZW1hRXhjbCkgKyAnIDogJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hVmFsdWUpICsgJyApIHx8ICcgKyAoJGRhdGEpICsgJyAhPT0gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkZXhjbElzTnVtYmVyICYmICRzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAkZXhjbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYUV4Y2w7XG4gICAgICAgICRub3RPcCArPSAnPSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJGV4Y2xJc051bWJlcikgJHNjaGVtYVZhbHVlID0gTWF0aFskaXNNYXggPyAnbWluJyA6ICdtYXgnXSgkc2NoZW1hRXhjbCwgJHNjaGVtYSk7XG4gICAgICAgIGlmICgkc2NoZW1hRXhjbCA9PT0gKCRleGNsSXNOdW1iZXIgPyAkc2NoZW1hVmFsdWUgOiB0cnVlKSkge1xuICAgICAgICAgICRleGNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgICAkbm90T3AgKz0gJz0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRleGNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAkb3BTdHIgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgJG9wRXhwciA9ICdcXCcnICsgJG9wU3RyICsgJ1xcJyc7XG4gICAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgfHwgJyArICgkZGF0YSkgKyAnICE9PSAnICsgKCRkYXRhKSArICcpIHsgJztcbiAgICB9XG4gIH1cbiAgJGVycm9yS2V5d29yZCA9ICRlcnJvcktleXdvcmQgfHwgJGtleXdvcmQ7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfbGltaXQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGNvbXBhcmlzb246ICcgKyAoJG9wRXhwcikgKyAnLCBsaW1pdDogJyArICgkc2NoZW1hVmFsdWUpICsgJywgZXhjbHVzaXZlOiAnICsgKCRleGNsdXNpdmUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcFN0cikgKyAnICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hVmFsdWUpICsgJ1xcJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9fbGltaXRJdGVtcyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gJ251bWJlcicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgJyBtdXN0IGJlIG51bWJlcicpO1xuICB9XG4gIHZhciAkb3AgPSAka2V5d29yZCA9PSAnbWF4SXRlbXMnID8gJz4nIDogJzwnO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgfVxuICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICcgKyAoJG9wKSArICcgJyArICgkc2NoZW1hVmFsdWUpICsgJykgeyAnO1xuICB2YXIgJGVycm9yS2V5d29yZCA9ICRrZXl3b3JkO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAnX2xpbWl0SXRlbXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGxpbWl0OiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlICc7XG4gICAgICBpZiAoJGtleXdvcmQgPT0gJ21heEl0ZW1zJykge1xuICAgICAgICBvdXQgKz0gJ21vcmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdmZXdlcic7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB0aGFuICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfX2xpbWl0TGVuZ3RoKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgaWYgKCEoJGlzRGF0YSB8fCB0eXBlb2YgJHNjaGVtYSA9PSAnbnVtYmVyJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJGtleXdvcmQgKyAnIG11c3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgdmFyICRvcCA9ICRrZXl3b3JkID09ICdtYXhMZW5ndGgnID8gJz4nIDogJzwnO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgfVxuICBpZiAoaXQub3B0cy51bmljb2RlID09PSBmYWxzZSkge1xuICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJy5sZW5ndGggJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB1Y3MybGVuZ3RoKCcgKyAoJGRhdGEpICsgJykgJztcbiAgfVxuICBvdXQgKz0gJyAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcpIHsgJztcbiAgdmFyICRlcnJvcktleXdvcmQgPSAka2V5d29yZDtcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ19saW1pdExlbmd0aCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbGltaXQ6ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlICc7XG4gICAgICBpZiAoJGtleXdvcmQgPT0gJ21heExlbmd0aCcpIHtcbiAgICAgICAgb3V0ICs9ICdsb25nZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdzaG9ydGVyJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIHRoYW4gJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAnXFwnICsgJyArICgkc2NoZW1hVmFsdWUpICsgJyArIFxcJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyBjaGFyYWN0ZXJzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdFByb3BlcnRpZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRlcnJvcktleXdvcmQ7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoISgkaXNEYXRhIHx8IHR5cGVvZiAkc2NoZW1hID09ICdudW1iZXInKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArICcgbXVzdCBiZSBudW1iZXInKTtcbiAgfVxuICB2YXIgJG9wID0gJGtleXdvcmQgPT0gJ21heFByb3BlcnRpZXMnID8gJz4nIDogJzwnO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgfVxuICBvdXQgKz0gJyBPYmplY3Qua2V5cygnICsgKCRkYXRhKSArICcpLmxlbmd0aCAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcpIHsgJztcbiAgdmFyICRlcnJvcktleXdvcmQgPSAka2V5d29yZDtcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ19saW1pdFByb3BlcnRpZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGxpbWl0OiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlICc7XG4gICAgICBpZiAoJGtleXdvcmQgPT0gJ21heFByb3BlcnRpZXMnKSB7XG4gICAgICAgIG91dCArPSAnbW9yZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJ2Zld2VyJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIHRoYW4gJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAnXFwnICsgJyArICgkc2NoZW1hVmFsdWUpICsgJyArIFxcJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyBwcm9wZXJ0aWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX211bHRpcGxlT2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gJ251bWJlcicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgJyBtdXN0IGJlIG51bWJlcicpO1xuICB9XG4gIG91dCArPSAndmFyIGRpdmlzaW9uJyArICgkbHZsKSArICc7aWYgKCc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmICggdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnbnVtYmVyXFwnIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgKGRpdmlzaW9uJyArICgkbHZsKSArICcgPSAnICsgKCRkYXRhKSArICcgLyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnLCAnO1xuICBpZiAoaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uKSB7XG4gICAgb3V0ICs9ICcgTWF0aC5hYnMoTWF0aC5yb3VuZChkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSAtIGRpdmlzaW9uJyArICgkbHZsKSArICcpID4gMWUtJyArIChpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb24pICsgJyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIGRpdmlzaW9uJyArICgkbHZsKSArICcgIT09IHBhcnNlSW50KGRpdmlzaW9uJyArICgkbHZsKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgKSAnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICApICAnO1xuICB9XG4gIG91dCArPSAnICkgeyAgICc7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnbXVsdGlwbGVPZicpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbXVsdGlwbGVPZjogJyArICgkc2NoZW1hVmFsdWUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBtdWx0aXBsZSBvZiAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYVZhbHVlKSArICdcXCcnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9ub3QoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoZW1hID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2hlbWEpLmxlbmd0aCA+IDApIHx8ICRzY2hlbWEgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICRpdC5zY2hlbWEgPSAkc2NoZW1hO1xuICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGg7XG4gICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyAgJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAkaXQuY3JlYXRlRXJyb3JzID0gZmFsc2U7XG4gICAgdmFyICRhbGxFcnJvcnNPcHRpb247XG4gICAgaWYgKCRpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgJGFsbEVycm9yc09wdGlvbiA9ICRpdC5vcHRzLmFsbEVycm9ycztcbiAgICAgICRpdC5vcHRzLmFsbEVycm9ycyA9IGZhbHNlO1xuICAgIH1cbiAgICBvdXQgKz0gJyAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICRpdC5jcmVhdGVFcnJvcnMgPSB0cnVlO1xuICAgIGlmICgkYWxsRXJyb3JzT3B0aW9uKSAkaXQub3B0cy5hbGxFcnJvcnMgPSAkYWxsRXJyb3JzT3B0aW9uO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICAgJztcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnbm90JykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczoge30gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgdmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9IGVsc2UgeyAgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdub3QnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB7fSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoZmFsc2UpIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfb25lT2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZCxcbiAgICAkcHJldlZhbGlkID0gJ3ByZXZWYWxpZCcgKyAkbHZsLFxuICAgICRwYXNzaW5nU2NoZW1hcyA9ICdwYXNzaW5nU2NoZW1hcycgKyAkbHZsO1xuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnMgLCAnICsgKCRwcmV2VmFsaWQpICsgJyA9IGZhbHNlICwgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlICwgJyArICgkcGFzc2luZ1NjaGVtYXMpICsgJyA9IG51bGw7ICc7XG4gIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICBpZiAoYXJyMSkge1xuICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgaWYgKChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gKHR5cGVvZiAkc2NoID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDApIHx8ICRzY2ggPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICdbJyArICRpICsgJ10nO1xuICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgJGk7XG4gICAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgfVxuICAgICAgaWYgKCRpKSB7XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJyAmJiAnICsgKCRwcmV2VmFsaWQpICsgJykgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICcgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcgPSBbJyArICgkcGFzc2luZ1NjaGVtYXMpICsgJywgJyArICgkaSkgKyAnXTsgfSBlbHNlIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRwcmV2VmFsaWQpICsgJyA9IHRydWU7ICcgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcgPSAnICsgKCRpKSArICc7IH0nO1xuICAgIH1cbiAgfVxuICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICBvdXQgKz0gJycgKyAoJGNsb3NpbmdCcmFjZXMpICsgJ2lmICghJyArICgkdmFsaWQpICsgJykgeyAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdvbmVPZicpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgcGFzc2luZ1NjaGVtYXM6ICcgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZFcnJvcnMpOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9XG4gIG91dCArPSAnfSBlbHNlIHsgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0nO1xuICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICBvdXQgKz0gJyB9ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcGF0dGVybihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICRyZWdleHAgPSAkaXNEYXRhID8gJyhuZXcgUmVnRXhwKCcgKyAkc2NoZW1hVmFsdWUgKyAnKSknIDogaXQudXNlUGF0dGVybigkc2NoZW1hKTtcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdzdHJpbmdcXCcpIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgIScgKyAoJHJlZ2V4cCkgKyAnLnRlc3QoJyArICgkZGF0YSkgKyAnKSApIHsgICAnO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3BhdHRlcm4nKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHBhdHRlcm46ICAnO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSkpO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggcGF0dGVybiBcIic7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnXCJcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcHJvcGVydGllcyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRrZXkgPSAna2V5JyArICRsdmwsXG4gICAgJGlkeCA9ICdpZHgnICsgJGx2bCxcbiAgICAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICRkYXRhUHJvcGVydGllcyA9ICdkYXRhUHJvcGVydGllcycgKyAkbHZsO1xuICB2YXIgJHNjaGVtYUtleXMgPSBPYmplY3Qua2V5cygkc2NoZW1hIHx8IHt9KS5maWx0ZXIobm90UHJvdG8pLFxuICAgICRwUHJvcGVydGllcyA9IGl0LnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyB8fCB7fSxcbiAgICAkcFByb3BlcnR5S2V5cyA9IE9iamVjdC5rZXlzKCRwUHJvcGVydGllcykuZmlsdGVyKG5vdFByb3RvKSxcbiAgICAkYVByb3BlcnRpZXMgPSBpdC5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgJHNvbWVQcm9wZXJ0aWVzID0gJHNjaGVtYUtleXMubGVuZ3RoIHx8ICRwUHJvcGVydHlLZXlzLmxlbmd0aCxcbiAgICAkbm9BZGRpdGlvbmFsID0gJGFQcm9wZXJ0aWVzID09PSBmYWxzZSxcbiAgICAkYWRkaXRpb25hbElzU2NoZW1hID0gdHlwZW9mICRhUHJvcGVydGllcyA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkYVByb3BlcnRpZXMpLmxlbmd0aCxcbiAgICAkcmVtb3ZlQWRkaXRpb25hbCA9IGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCxcbiAgICAkY2hlY2tBZGRpdGlvbmFsID0gJG5vQWRkaXRpb25hbCB8fCAkYWRkaXRpb25hbElzU2NoZW1hIHx8ICRyZW1vdmVBZGRpdGlvbmFsLFxuICAgICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzLFxuICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICB2YXIgJHJlcXVpcmVkID0gaXQuc2NoZW1hLnJlcXVpcmVkO1xuICBpZiAoJHJlcXVpcmVkICYmICEoaXQub3B0cy4kZGF0YSAmJiAkcmVxdWlyZWQuJGRhdGEpICYmICRyZXF1aXJlZC5sZW5ndGggPCBpdC5vcHRzLmxvb3BSZXF1aXJlZCkge1xuICAgIHZhciAkcmVxdWlyZWRIYXNoID0gaXQudXRpbC50b0hhc2goJHJlcXVpcmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFByb3RvKHApIHtcbiAgICByZXR1cm4gcCAhPT0gJ19fcHJvdG9fXyc7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciAnICsgKCRuZXh0VmFsaWQpICsgJyA9IHRydWU7JztcbiAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgPSB1bmRlZmluZWQ7JztcbiAgfVxuICBpZiAoJGNoZWNrQWRkaXRpb25hbCkge1xuICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgfHwgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKTsgZm9yICh2YXIgJyArICgkaWR4KSArICc9MDsgJyArICgkaWR4KSArICc8JyArICgkZGF0YVByb3BlcnRpZXMpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgdmFyICcgKyAoJGtleSkgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJ1snICsgKCRpZHgpICsgJ107ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGtleSkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIH1cbiAgICBpZiAoJHNvbWVQcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgaXNBZGRpdGlvbmFsJyArICgkbHZsKSArICcgPSAhKGZhbHNlICc7XG4gICAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICgkc2NoZW1hS2V5cy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgb3V0ICs9ICcgfHwgdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnLmhhc093blByb3BlcnR5KCcgKyAoJGtleSkgKyAnKSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcnIxID0gJHNjaGVtYUtleXM7XG4gICAgICAgICAgaWYgKGFycjEpIHtcbiAgICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksIGkxID0gLTEsXG4gICAgICAgICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGkxIDwgbDEpIHtcbiAgICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyMVtpMSArPSAxXTtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgJyArICgka2V5KSArICcgPT0gJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRwcm9wZXJ0eUtleSkpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCRwUHJvcGVydHlLZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyMiA9ICRwUHJvcGVydHlLZXlzO1xuICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgIHZhciAkcFByb3BlcnR5LCAkaSA9IC0xLFxuICAgICAgICAgICAgbDIgPSBhcnIyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKCRpIDwgbDIpIHtcbiAgICAgICAgICAgICRwUHJvcGVydHkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgb3V0ICs9ICcgfHwgJyArIChpdC51c2VQYXR0ZXJuKCRwUHJvcGVydHkpKSArICcudGVzdCgnICsgKCRrZXkpICsgJykgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSAnICk7IGlmIChpc0FkZGl0aW9uYWwnICsgKCRsdmwpICsgJykgeyAnO1xuICAgIH1cbiAgICBpZiAoJHJlbW92ZUFkZGl0aW9uYWwgPT0gJ2FsbCcpIHtcbiAgICAgIG91dCArPSAnIGRlbGV0ZSAnICsgKCRkYXRhKSArICdbJyArICgka2V5KSArICddOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgICB2YXIgJGFkZGl0aW9uYWxQcm9wZXJ0eSA9ICdcXCcgKyAnICsgJGtleSArICcgKyBcXCcnO1xuICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgfVxuICAgICAgaWYgKCRub0FkZGl0aW9uYWwpIHtcbiAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsKSB7XG4gICAgICAgICAgb3V0ICs9ICcgZGVsZXRlICcgKyAoJGRhdGEpICsgJ1snICsgKCRrZXkpICsgJ107ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArICgkbmV4dFZhbGlkKSArICcgPSBmYWxzZTsgJztcbiAgICAgICAgICB2YXIgJGN1cnJFcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy9hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBhZGRpdGlvbmFsUHJvcGVydHk6IFxcJycgKyAoJGFkZGl0aW9uYWxQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJyc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGFuIGludmFsaWQgYWRkaXRpb25hbCBwcm9wZXJ0eSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgJGVyclNjaGVtYVBhdGggPSAkY3VyckVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkYWRkaXRpb25hbElzU2NoZW1hKSB7XG4gICAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSAnZmFpbGluZycpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyAgJztcbiAgICAgICAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkgPyBpdC5lcnJvclBhdGggOiBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRrZXkgKyAnXSc7XG4gICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRrZXk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSB7IGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZhbGlkYXRlLmVycm9ycyAhPT0gbnVsbCkgeyBpZiAoZXJyb3JzKSB2YWxpZGF0ZS5lcnJvcnMubGVuZ3RoID0gZXJyb3JzOyBlbHNlIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7IH0gZGVsZXRlICcgKyAoJGRhdGEpICsgJ1snICsgKCRrZXkpICsgJ107IH0gICc7XG4gICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkgPyBpdC5lcnJvclBhdGggOiBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRrZXkgKyAnXSc7XG4gICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRrZXk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgYnJlYWs7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgICB9XG4gICAgaWYgKCRzb21lUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICB9XG4gIH1cbiAgdmFyICR1c2VEZWZhdWx0cyA9IGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGU7XG4gIGlmICgkc2NoZW1hS2V5cy5sZW5ndGgpIHtcbiAgICB2YXIgYXJyMyA9ICRzY2hlbWFLZXlzO1xuICAgIGlmIChhcnIzKSB7XG4gICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMyA9IC0xLFxuICAgICAgICBsMyA9IGFycjMubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpMyA8IGwzKSB7XG4gICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjNbaTMgKz0gMV07XG4gICAgICAgIHZhciAkc2NoID0gJHNjaGVtYVskcHJvcGVydHlLZXldO1xuICAgICAgICBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCkgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgJHBhc3NEYXRhID0gJGRhdGEgKyAkcHJvcCxcbiAgICAgICAgICAgICRoYXNEZWZhdWx0ID0gJHVzZURlZmF1bHRzICYmICRzY2guZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAkcHJvcDtcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgaXQudXRpbC5lc2NhcGVGcmFnbWVudCgkcHJvcGVydHlLZXkpO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoaXQuZXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gaXQudXRpbC50b1F1b3RlZFN0cmluZygkcHJvcGVydHlLZXkpO1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICAkY29kZSA9IGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpO1xuICAgICAgICAgICAgdmFyICR1c2VEYXRhID0gJHBhc3NEYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkbmV4dERhdGE7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkaGFzRGVmYXVsdCkge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgkcmVxdWlyZWRIYXNoICYmICRyZXF1aXJlZEhhc2hbJHByb3BlcnR5S2V5XSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoICcgKyAoJHVzZURhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcpIHsgJyArICgkbmV4dFZhbGlkKSArICcgPSBmYWxzZTsgJztcbiAgICAgICAgICAgICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoLFxuICAgICAgICAgICAgICAgICRjdXJyRXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoLFxuICAgICAgICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL3JlcXVpcmVkJztcbiAgICAgICAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJyc7XG4gICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eSc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ3Nob3VsZCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFxcXFxcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcXFxcXCcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9ICRjdXJyRXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gICAgICAgICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIGlmICggJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnKSB7ICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgfSBlbHNlIHsgJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkdXNlRGF0YSkgKyAnICE9PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICYmICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnICkgeyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgfSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJHBQcm9wZXJ0eUtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGFycjQgPSAkcFByb3BlcnR5S2V5cztcbiAgICBpZiAoYXJyNCkge1xuICAgICAgdmFyICRwUHJvcGVydHksIGk0ID0gLTEsXG4gICAgICAgIGw0ID0gYXJyNC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGk0IDwgbDQpIHtcbiAgICAgICAgJHBQcm9wZXJ0eSA9IGFycjRbaTQgKz0gMV07XG4gICAgICAgIHZhciAkc2NoID0gJHBQcm9wZXJ0aWVzWyRwUHJvcGVydHldO1xuICAgICAgICBpZiAoKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRzY2ggPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCkgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5wYXR0ZXJuUHJvcGVydGllcycgKyBpdC51dGlsLmdldFByb3BlcnR5KCRwUHJvcGVydHkpO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvcGF0dGVyblByb3BlcnRpZXMvJyArIGl0LnV0aWwuZXNjYXBlRnJhZ21lbnQoJHBQcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyB8fCBPYmplY3Qua2V5cygnICsgKCRkYXRhKSArICcpOyBmb3IgKHZhciAnICsgKCRpZHgpICsgJz0wOyAnICsgKCRpZHgpICsgJzwnICsgKCRkYXRhUHJvcGVydGllcykgKyAnLmxlbmd0aDsgJyArICgkaWR4KSArICcrKykgeyB2YXIgJyArICgka2V5KSArICcgPSAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnWycgKyAoJGlkeCkgKyAnXTsgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgka2V5KSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkpICsgJy50ZXN0KCcgKyAoJGtleSkgKyAnKSkgeyAnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRrZXkgKyAnXSc7XG4gICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRrZXk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgYnJlYWs7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgZWxzZSAnICsgKCRuZXh0VmFsaWQpICsgJyA9IHRydWU7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcHJvcGVydHlOYW1lcyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyc7XG4gIGlmICgoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/ICh0eXBlb2YgJHNjaGVtYSA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkc2NoZW1hKS5sZW5ndGggPiAwKSB8fCAkc2NoZW1hID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgdmFyICRrZXkgPSAna2V5JyArICRsdmwsXG4gICAgICAkaWR4ID0gJ2lkeCcgKyAkbHZsLFxuICAgICAgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgJGludmFsaWROYW1lID0gJ1xcJyArICcgKyAka2V5ICsgJyArIFxcJycsXG4gICAgICAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQsXG4gICAgICAkZGF0YVByb3BlcnRpZXMgPSAnZGF0YVByb3BlcnRpZXMnICsgJGx2bCxcbiAgICAgICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzLFxuICAgICAgJGN1cnJlbnRCYXNlSWQgPSBpdC5iYXNlSWQ7XG4gICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9IHVuZGVmaW5lZDsgJztcbiAgICB9XG4gICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyB8fCBPYmplY3Qua2V5cygnICsgKCRkYXRhKSArICcpOyBmb3IgKHZhciAnICsgKCRpZHgpICsgJz0wOyAnICsgKCRpZHgpICsgJzwnICsgKCRkYXRhUHJvcGVydGllcykgKyAnLmxlbmd0aDsgJyArICgkaWR4KSArICcrKykgeyB2YXIgJyArICgka2V5KSArICcgPSAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnWycgKyAoJGlkeCkgKyAnXTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgka2V5KSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIHZhciBzdGFydEVycnMnICsgKCRsdmwpICsgJyA9IGVycm9yczsgJztcbiAgICB2YXIgJHBhc3NEYXRhID0gJGtleTtcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgeyBmb3IgKHZhciAnICsgKCRpKSArICc9c3RhcnRFcnJzJyArICgkbHZsKSArICc7ICcgKyAoJGkpICsgJzxlcnJvcnM7ICcgKyAoJGkpICsgJysrKSB7IHZFcnJvcnNbJyArICgkaSkgKyAnXS5wcm9wZXJ0eU5hbWUgPSAnICsgKCRrZXkpICsgJzsgfSAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncHJvcGVydHlOYW1lcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgcHJvcGVydHlOYW1lOiBcXCcnICsgKCRpbnZhbGlkTmFtZSkgKyAnXFwnIH0gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Byb3BlcnR5IG5hbWUgXFxcXFxcJycgKyAoJGludmFsaWROYW1lKSArICdcXFxcXFwnIGlzIGludmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGJyZWFrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9IH0nO1xuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9yZXF1aXJlZChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJHZTY2hlbWEgPSAnc2NoZW1hJyArICRsdmw7XG4gIGlmICghJGlzRGF0YSkge1xuICAgIGlmICgkc2NoZW1hLmxlbmd0aCA8IGl0Lm9wdHMubG9vcFJlcXVpcmVkICYmIGl0LnNjaGVtYS5wcm9wZXJ0aWVzICYmIE9iamVjdC5rZXlzKGl0LnNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHZhciAkcmVxdWlyZWQgPSBbXTtcbiAgICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgIHZhciAkcHJvcGVydHksIGkxID0gLTEsXG4gICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgJHByb3BlcnR5ID0gYXJyMVtpMSArPSAxXTtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5U2NoID0gaXQuc2NoZW1hLnByb3BlcnRpZXNbJHByb3BlcnR5XTtcbiAgICAgICAgICBpZiAoISgkcHJvcGVydHlTY2ggJiYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyAodHlwZW9mICRwcm9wZXJ0eVNjaCA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkcHJvcGVydHlTY2gpLmxlbmd0aCA+IDApIHx8ICRwcm9wZXJ0eVNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRwcm9wZXJ0eVNjaCwgaXQuUlVMRVMuYWxsKSkpKSB7XG4gICAgICAgICAgICAkcmVxdWlyZWRbJHJlcXVpcmVkLmxlbmd0aF0gPSAkcHJvcGVydHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkcmVxdWlyZWQgPSAkc2NoZW1hO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRGF0YSB8fCAkcmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoLFxuICAgICAgJGxvb3BSZXF1aXJlZCA9ICRpc0RhdGEgfHwgJHJlcXVpcmVkLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BSZXF1aXJlZCxcbiAgICAgICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgbWlzc2luZycgKyAoJGx2bCkgKyAnOyAnO1xuICAgICAgaWYgKCRsb29wUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZTY2hlbWEpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnIGlmIChzY2hlbWEnICsgKCRsdmwpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hJyArICgkbHZsKSArICcpKSAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGVsc2Ugeyc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgkaSkgKyAnID0gMDsgJyArICgkaSkgKyAnIDwgJyArICgkdlNjaGVtYSkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJGRhdGEpICsgJ1snICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXV0gIT09IHVuZGVmaW5lZCAnO1xuICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICBvdXQgKz0gJyAmJiAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsICcgKyAoJHZTY2hlbWEpICsgJ1snICsgKCRpKSArICddKSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnOyBpZiAoIScgKyAoJHZhbGlkKSArICcpIGJyZWFrOyB9ICc7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgIH0gICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgICc7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIGlmICggJztcbiAgICAgICAgdmFyIGFycjIgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICR1c2VEYXRhID0gJGRhdGEgKyAkcHJvcDtcbiAgICAgICAgICAgIG91dCArPSAnICggKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgJiYgKG1pc3NpbmcnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eUtleSA6ICRwcm9wKSkgKyAnKSApICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSB7ICAnO1xuICAgICAgICB2YXIgJHByb3BlcnR5UGF0aCA9ICdtaXNzaW5nJyArICRsdmwsXG4gICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9ICdcXCcgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcXCcnO1xuICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQub3B0cy5qc29uUG9pbnRlcnMgPyBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCB0cnVlKSA6ICRjdXJyZW50RXJyb3JQYXRoICsgJyArICcgKyAkcHJvcGVydHlQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRsb29wUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZTY2hlbWEpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkdlNjaGVtYSkgKyAnICYmICFBcnJheS5pc0FycmF5KCcgKyAoJHZTY2hlbWEpICsgJykpIHsgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9IGVsc2UgaWYgKCcgKyAoJHZTY2hlbWEpICsgJyAhPT0gdW5kZWZpbmVkKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgkaSkgKyAnID0gMDsgJyArICgkaSkgKyAnIDwgJyArICgkdlNjaGVtYSkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgaWYgKCcgKyAoJGRhdGEpICsgJ1snICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXV0gPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsICcgKyAoJHZTY2hlbWEpICsgJ1snICsgKCRpKSArICddKSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gfSAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnICB9ICAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyMyA9ICRyZXF1aXJlZDtcbiAgICAgICAgaWYgKGFycjMpIHtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMyA9IC0xLFxuICAgICAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjNbaTMgKz0gMV07XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoICcgKyAoJHVzZURhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ3Nob3VsZCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFxcXFxcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcXFxcXCcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICB9IGVsc2UgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdW5pcXVlSXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgaWYgKCgkc2NoZW1hIHx8ICRpc0RhdGEpICYmIGl0Lm9wdHMudW5pcXVlSXRlbXMgIT09IGZhbHNlKSB7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnOyBpZiAoJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gZmFsc2UgfHwgJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAodHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnYm9vbGVhblxcJykgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgdmFyIGkgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoICwgJyArICgkdmFsaWQpICsgJyA9IHRydWUgLCBqOyBpZiAoaSA+IDEpIHsgJztcbiAgICB2YXIgJGl0ZW1UeXBlID0gaXQuc2NoZW1hLml0ZW1zICYmIGl0LnNjaGVtYS5pdGVtcy50eXBlLFxuICAgICAgJHR5cGVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSgkaXRlbVR5cGUpO1xuICAgIGlmICghJGl0ZW1UeXBlIHx8ICRpdGVtVHlwZSA9PSAnb2JqZWN0JyB8fCAkaXRlbVR5cGUgPT0gJ2FycmF5JyB8fCAoJHR5cGVJc0FycmF5ICYmICgkaXRlbVR5cGUuaW5kZXhPZignb2JqZWN0JykgPj0gMCB8fCAkaXRlbVR5cGUuaW5kZXhPZignYXJyYXknKSA+PSAwKSkpIHtcbiAgICAgIG91dCArPSAnIG91dGVyOiBmb3IgKDtpLS07KSB7IGZvciAoaiA9IGk7IGotLTspIHsgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJ1tpXSwgJyArICgkZGF0YSkgKyAnW2pdKSkgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGJyZWFrIG91dGVyOyB9IH0gfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgaXRlbUluZGljZXMgPSB7fSwgaXRlbTsgZm9yICg7aS0tOykgeyB2YXIgaXRlbSA9ICcgKyAoJGRhdGEpICsgJ1tpXTsgJztcbiAgICAgIHZhciAkbWV0aG9kID0gJ2NoZWNrRGF0YVR5cGUnICsgKCR0eXBlSXNBcnJheSA/ICdzJyA6ICcnKTtcbiAgICAgIG91dCArPSAnIGlmICgnICsgKGl0LnV0aWxbJG1ldGhvZF0oJGl0ZW1UeXBlLCAnaXRlbScsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgdHJ1ZSkpICsgJykgY29udGludWU7ICc7XG4gICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgIG91dCArPSAnIGlmICh0eXBlb2YgaXRlbSA9PSBcXCdzdHJpbmdcXCcpIGl0ZW0gPSBcXCdcIlxcJyArIGl0ZW07ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyBpZiAodHlwZW9mIGl0ZW1JbmRpY2VzW2l0ZW1dID09IFxcJ251bWJlclxcJykgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGogPSBpdGVtSW5kaWNlc1tpdGVtXTsgYnJlYWs7IH0gaXRlbUluZGljZXNbaXRlbV0gPSBpOyB9ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcgIH0gICc7XG4gICAgfVxuICAgIG91dCArPSAnIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgICc7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3VuaXF1ZUl0ZW1zJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBpOiBpLCBqOiBqIH0gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjIFxcJyArIGogKyBcXCcgYW5kIFxcJyArIGkgKyBcXCcgYXJlIGlkZW50aWNhbClcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBLRVlXT1JEUyA9IFtcbiAgJ211bHRpcGxlT2YnLFxuICAnbWF4aW11bScsXG4gICdleGNsdXNpdmVNYXhpbXVtJyxcbiAgJ21pbmltdW0nLFxuICAnZXhjbHVzaXZlTWluaW11bScsXG4gICdtYXhMZW5ndGgnLFxuICAnbWluTGVuZ3RoJyxcbiAgJ3BhdHRlcm4nLFxuICAnYWRkaXRpb25hbEl0ZW1zJyxcbiAgJ21heEl0ZW1zJyxcbiAgJ21pbkl0ZW1zJyxcbiAgJ3VuaXF1ZUl0ZW1zJyxcbiAgJ21heFByb3BlcnRpZXMnLFxuICAnbWluUHJvcGVydGllcycsXG4gICdyZXF1aXJlZCcsXG4gICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICdlbnVtJyxcbiAgJ2Zvcm1hdCcsXG4gICdjb25zdCdcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gIGZvciAodmFyIGk9MDsgaTxrZXl3b3Jkc0pzb25Qb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICB2YXIgc2VnbWVudHMgPSBrZXl3b3Jkc0pzb25Qb2ludGVyc1tpXS5zcGxpdCgnLycpO1xuICAgIHZhciBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgdmFyIGo7XG4gICAgZm9yIChqPTE7IGo8c2VnbWVudHMubGVuZ3RoOyBqKyspXG4gICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ21lbnRzW2pdXTtcblxuICAgIGZvciAoaj0wOyBqPEtFWVdPUkRTLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gS0VZV09SRFNbal07XG4gICAgICB2YXIgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAga2V5d29yZHNba2V5XSA9IHtcbiAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgeyAkcmVmOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jJyB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRhU2NoZW1hO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1pc3NpbmdSZWZFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JfY2xhc3NlcycpLk1pc3NpbmdSZWY7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUFzeW5jO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hIHdpdGggYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgbWlzc2luZyBzY2hlbWFzLlxuICogYGxvYWRTY2hlbWFgIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgc2NoZW1hIHVyaSBhbmQgcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2NoZW1hLlxuICogQHRoaXMgIEFqdlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1hIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIG1ldGEgb3B0aW9uYWwgdHJ1ZSB0byBjb21waWxlIG1ldGEtc2NoZW1hOyB0aGlzIHBhcmFtZXRlciBjYW4gYmUgc2tpcHBlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFjaywgaXQgaXMgY2FsbGVkIHdpdGggMiBwYXJhbWV0ZXJzOiBlcnJvciAob3IgbnVsbCkgYW5kIHZhbGlkYXRpbmcgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHZhbGlkYXRpbmcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEsIGNhbGxiYWNrKSB7XG4gIC8qIGVzbGludCBuby1zaGFkb3c6IDAgKi9cbiAgLyogZ2xvYmFsIFByb21pc2UgKi9cbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0eXBlb2YgdGhpcy5fb3B0cy5sb2FkU2NoZW1hICE9ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAodHlwZW9mIG1ldGEgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbWV0YTtcbiAgICBtZXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHAgPSBsb2FkTWV0YVNjaGVtYU9mKHNjaGVtYSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjaGVtYU9iaiA9IHNlbGYuX2FkZFNjaGVtYShzY2hlbWEsIHVuZGVmaW5lZCwgbWV0YSk7XG4gICAgcmV0dXJuIHNjaGVtYU9iai52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jKHNjaGVtYU9iaik7XG4gIH0pO1xuXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHAudGhlbihcbiAgICAgIGZ1bmN0aW9uKHYpIHsgY2FsbGJhY2sobnVsbCwgdik7IH0sXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gcDtcblxuXG4gIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hT2Yoc2NoKSB7XG4gICAgdmFyICRzY2hlbWEgPSBzY2guJHNjaGVtYTtcbiAgICByZXR1cm4gJHNjaGVtYSAmJiAhc2VsZi5nZXRTY2hlbWEoJHNjaGVtYSlcbiAgICAgICAgICAgID8gY29tcGlsZUFzeW5jLmNhbGwoc2VsZiwgeyAkcmVmOiAkc2NoZW1hIH0sIHRydWUpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaGVtYU9iaikge1xuICAgIHRyeSB7IHJldHVybiBzZWxmLl9jb21waWxlKHNjaGVtYU9iaik7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIE1pc3NpbmdSZWZFcnJvcikgcmV0dXJuIGxvYWRNaXNzaW5nU2NoZW1hKGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKGUpIHtcbiAgICAgIHZhciByZWYgPSBlLm1pc3NpbmdTY2hlbWE7XG4gICAgICBpZiAoYWRkZWQocmVmKSkgdGhyb3cgbmV3IEVycm9yKCdTY2hlbWEgJyArIHJlZiArICcgaXMgbG9hZGVkIGJ1dCAnICsgZS5taXNzaW5nUmVmICsgJyBjYW5ub3QgYmUgcmVzb2x2ZWQnKTtcblxuICAgICAgdmFyIHNjaGVtYVByb21pc2UgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgaWYgKCFzY2hlbWFQcm9taXNlKSB7XG4gICAgICAgIHNjaGVtYVByb21pc2UgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdID0gc2VsZi5fb3B0cy5sb2FkU2NoZW1hKHJlZik7XG4gICAgICAgIHNjaGVtYVByb21pc2UudGhlbihyZW1vdmVQcm9taXNlLCByZW1vdmVQcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjaGVtYVByb21pc2UudGhlbihmdW5jdGlvbiAoc2NoKSB7XG4gICAgICAgIGlmICghYWRkZWQocmVmKSkge1xuICAgICAgICAgIHJldHVybiBsb2FkTWV0YVNjaGVtYU9mKHNjaCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWFkZGVkKHJlZikpIHNlbGYuYWRkU2NoZW1hKHNjaCwgcmVmLCB1bmRlZmluZWQsIG1ldGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVByb21pc2UoKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRlZChyZWYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3JlZnNbcmVmXSB8fCBzZWxmLl9zY2hlbWFzW3JlZl07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJREVOVElGSUVSID0gL15bYS16XyRdW2EtejAtOV8kLV0qJC9pO1xudmFyIGN1c3RvbVJ1bGVDb2RlID0gcmVxdWlyZSgnLi9kb3Rqcy9jdXN0b20nKTtcbnZhciBkZWZpbml0aW9uU2NoZW1hID0gcmVxdWlyZSgnLi9kZWZpbml0aW9uX3NjaGVtYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGRLZXl3b3JkLFxuICBnZXQ6IGdldEtleXdvcmQsXG4gIHJlbW92ZTogcmVtb3ZlS2V5d29yZCxcbiAgdmFsaWRhdGU6IHZhbGlkYXRlS2V5d29yZFxufTtcblxuXG4vKipcbiAqIERlZmluZSBjdXN0b20ga2V5d29yZFxuICogQHRoaXMgIEFqdlxuICogQHBhcmFtIHtTdHJpbmd9IGtleXdvcmQgY3VzdG9tIGtleXdvcmQsIHNob3VsZCBiZSB1bmlxdWUgKGluY2x1ZGluZyBkaWZmZXJlbnQgZnJvbSBhbGwgc3RhbmRhcmQsIGN1c3RvbSBhbmQgbWFjcm8ga2V5d29yZHMpLlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24ga2V5d29yZCBkZWZpbml0aW9uIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYHR5cGVgICh0eXBlKHMpIHdoaWNoIHRoZSBrZXl3b3JkIGFwcGxpZXMgdG8pLCBgdmFsaWRhdGVgIG9yIGBjb21waWxlYC5cbiAqIEByZXR1cm4ge0Fqdn0gdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gKi9cbmZ1bmN0aW9uIGFkZEtleXdvcmQoa2V5d29yZCwgZGVmaW5pdGlvbikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIC8qIGVzbGludCBuby1zaGFkb3c6IDAgKi9cbiAgdmFyIFJVTEVTID0gdGhpcy5SVUxFUztcbiAgaWYgKFJVTEVTLmtleXdvcmRzW2tleXdvcmRdKVxuICAgIHRocm93IG5ldyBFcnJvcignS2V5d29yZCAnICsga2V5d29yZCArICcgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG5cbiAgaWYgKCFJREVOVElGSUVSLnRlc3Qoa2V5d29yZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXl3b3JkICcgKyBrZXl3b3JkICsgJyBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyJyk7XG5cbiAgaWYgKGRlZmluaXRpb24pIHtcbiAgICB0aGlzLnZhbGlkYXRlS2V5d29yZChkZWZpbml0aW9uLCB0cnVlKTtcblxuICAgIHZhciBkYXRhVHlwZSA9IGRlZmluaXRpb24udHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhVHlwZSkpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhVHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgX2FkZFJ1bGUoa2V5d29yZCwgZGF0YVR5cGVbaV0sIGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYWRkUnVsZShrZXl3b3JkLCBkYXRhVHlwZSwgZGVmaW5pdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIG1ldGFTY2hlbWEgPSBkZWZpbml0aW9uLm1ldGFTY2hlbWE7XG4gICAgaWYgKG1ldGFTY2hlbWEpIHtcbiAgICAgIGlmIChkZWZpbml0aW9uLiRkYXRhICYmIHRoaXMuX29wdHMuJGRhdGEpIHtcbiAgICAgICAgbWV0YVNjaGVtYSA9IHtcbiAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgbWV0YVNjaGVtYSxcbiAgICAgICAgICAgIHsgJyRyZWYnOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jJyB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZGVmaW5pdGlvbi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IFJVTEVTLmFsbFtrZXl3b3JkXSA9IHRydWU7XG5cblxuICBmdW5jdGlvbiBfYWRkUnVsZShrZXl3b3JkLCBkYXRhVHlwZSwgZGVmaW5pdGlvbikge1xuICAgIHZhciBydWxlR3JvdXA7XG4gICAgZm9yICh2YXIgaT0wOyBpPFJVTEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmcgPSBSVUxFU1tpXTtcbiAgICAgIGlmIChyZy50eXBlID09IGRhdGFUeXBlKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHJnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdIH07XG4gICAgICBSVUxFUy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSB7XG4gICAgICBrZXl3b3JkOiBrZXl3b3JkLFxuICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvbixcbiAgICAgIGN1c3RvbTogdHJ1ZSxcbiAgICAgIGNvZGU6IGN1c3RvbVJ1bGVDb2RlLFxuICAgICAgaW1wbGVtZW50czogZGVmaW5pdGlvbi5pbXBsZW1lbnRzXG4gICAgfTtcbiAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5jdXN0b21ba2V5d29yZF0gPSBydWxlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQga2V5d29yZFxuICogQHRoaXMgIEFqdlxuICogQHBhcmFtIHtTdHJpbmd9IGtleXdvcmQgcHJlLWRlZmluZWQgb3IgY3VzdG9tIGtleXdvcmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8Qm9vbGVhbn0gY3VzdG9tIGtleXdvcmQgZGVmaW5pdGlvbiwgYHRydWVgIGlmIGl0IGlzIGEgcHJlZGVmaW5lZCBrZXl3b3JkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHJ1bGUgPSB0aGlzLlJVTEVTLmN1c3RvbVtrZXl3b3JkXTtcbiAgcmV0dXJuIHJ1bGUgPyBydWxlLmRlZmluaXRpb24gOiB0aGlzLlJVTEVTLmtleXdvcmRzW2tleXdvcmRdIHx8IGZhbHNlO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlIGtleXdvcmRcbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXl3b3JkIHByZS1kZWZpbmVkIG9yIGN1c3RvbSBrZXl3b3JkLlxuICogQHJldHVybiB7QWp2fSB0aGlzIGZvciBtZXRob2QgY2hhaW5pbmdcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIFJVTEVTID0gdGhpcy5SVUxFUztcbiAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdO1xuICBkZWxldGUgUlVMRVMuYWxsW2tleXdvcmRdO1xuICBkZWxldGUgUlVMRVMuY3VzdG9tW2tleXdvcmRdO1xuICBmb3IgKHZhciBpPTA7IGk8UlVMRVMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcnVsZXMgPSBSVUxFU1tpXS5ydWxlcztcbiAgICBmb3IgKHZhciBqPTA7IGo8cnVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChydWxlc1tqXS5rZXl3b3JkID09IGtleXdvcmQpIHtcbiAgICAgICAgcnVsZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBWYWxpZGF0ZSBrZXl3b3JkIGRlZmluaXRpb25cbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGtleXdvcmQgZGVmaW5pdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRocm93RXJyb3IgdHJ1ZSB0byB0aHJvdyBleGNlcHRpb24gaWYgZGVmaW5pdGlvbiBpcyBpbnZhbGlkXG4gKiBAcmV0dXJuIHtib29sZWFufSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoZGVmaW5pdGlvbiwgdGhyb3dFcnJvcikge1xuICB2YWxpZGF0ZUtleXdvcmQuZXJyb3JzID0gbnVsbDtcbiAgdmFyIHYgPSB0aGlzLl92YWxpZGF0ZUtleXdvcmQgPSB0aGlzLl92YWxpZGF0ZUtleXdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLmNvbXBpbGUoZGVmaW5pdGlvblNjaGVtYSwgdHJ1ZSk7XG5cbiAgaWYgKHYoZGVmaW5pdGlvbikpIHJldHVybiB0cnVlO1xuICB2YWxpZGF0ZUtleXdvcmQuZXJyb3JzID0gdi5lcnJvcnM7XG4gIGlmICh0aHJvd0Vycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcignY3VzdG9tIGtleXdvcmQgZGVmaW5pdGlvbiBpcyBpbnZhbGlkOiAnICArIHRoaXMuZXJyb3JzVGV4dCh2LmVycm9ycykpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jdXN0b20oaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRlcnJvcktleXdvcmQ7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICRydWxlID0gdGhpcyxcbiAgICAkZGVmaW5pdGlvbiA9ICdkZWZpbml0aW9uJyArICRsdmwsXG4gICAgJHJEZWYgPSAkcnVsZS5kZWZpbml0aW9uLFxuICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gIHZhciAkY29tcGlsZSwgJGlubGluZSwgJG1hY3JvLCAkcnVsZVZhbGlkYXRlLCAkdmFsaWRhdGVDb2RlO1xuICBpZiAoJGlzRGF0YSAmJiAkckRlZi4kZGF0YSkge1xuICAgICR2YWxpZGF0ZUNvZGUgPSAna2V5d29yZFZhbGlkYXRlJyArICRsdmw7XG4gICAgdmFyICR2YWxpZGF0ZVNjaGVtYSA9ICRyRGVmLnZhbGlkYXRlU2NoZW1hO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRkZWZpbml0aW9uKSArICcgPSBSVUxFUy5jdXN0b21bXFwnJyArICgka2V5d29yZCkgKyAnXFwnXS5kZWZpbml0aW9uOyB2YXIgJyArICgkdmFsaWRhdGVDb2RlKSArICcgPSAnICsgKCRkZWZpbml0aW9uKSArICcudmFsaWRhdGU7JztcbiAgfSBlbHNlIHtcbiAgICAkcnVsZVZhbGlkYXRlID0gaXQudXNlQ3VzdG9tUnVsZSgkcnVsZSwgJHNjaGVtYSwgaXQuc2NoZW1hLCBpdCk7XG4gICAgaWYgKCEkcnVsZVZhbGlkYXRlKSByZXR1cm47XG4gICAgJHNjaGVtYVZhbHVlID0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAkc2NoZW1hUGF0aDtcbiAgICAkdmFsaWRhdGVDb2RlID0gJHJ1bGVWYWxpZGF0ZS5jb2RlO1xuICAgICRjb21waWxlID0gJHJEZWYuY29tcGlsZTtcbiAgICAkaW5saW5lID0gJHJEZWYuaW5saW5lO1xuICAgICRtYWNybyA9ICRyRGVmLm1hY3JvO1xuICB9XG4gIHZhciAkcnVsZUVycnMgPSAkdmFsaWRhdGVDb2RlICsgJy5lcnJvcnMnLFxuICAgICRpID0gJ2knICsgJGx2bCxcbiAgICAkcnVsZUVyciA9ICdydWxlRXJyJyArICRsdmwsXG4gICAgJGFzeW5jS2V5d29yZCA9ICRyRGVmLmFzeW5jO1xuICBpZiAoJGFzeW5jS2V5d29yZCAmJiAhaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYScpO1xuICBpZiAoISgkaW5saW5lIHx8ICRtYWNybykpIHtcbiAgICBvdXQgKz0gJycgKyAoJHJ1bGVFcnJzKSArICcgPSBudWxsOyc7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciAnICsgKCR2YWxpZCkgKyAnOyc7XG4gIGlmICgkaXNEYXRhICYmICRyRGVmLiRkYXRhKSB7XG4gICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgIG91dCArPSAnIGlmICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID09PSB1bmRlZmluZWQpIHsgJyArICgkdmFsaWQpICsgJyA9IHRydWU7IH0gZWxzZSB7ICc7XG4gICAgaWYgKCR2YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJGRlZmluaXRpb24pICsgJy52YWxpZGF0ZVNjaGVtYSgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKTsgaWYgKCcgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICB9XG4gIH1cbiAgaWYgKCRpbmxpbmUpIHtcbiAgICBpZiAoJHJEZWYuc3RhdGVtZW50cykge1xuICAgICAgb3V0ICs9ICcgJyArICgkcnVsZVZhbGlkYXRlLnZhbGlkYXRlKSArICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJHJ1bGVWYWxpZGF0ZS52YWxpZGF0ZSkgKyAnOyAnO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkbWFjcm8pIHtcbiAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgICAkaXQubGV2ZWwrKztcbiAgICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gICAgJGl0LnNjaGVtYSA9ICRydWxlVmFsaWRhdGUudmFsaWRhdGU7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAnJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpLnJlcGxhY2UoL3ZhbGlkYXRlXFwuc2NoZW1hL2csICR2YWxpZGF0ZUNvZGUpO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgJyArICgkY29kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnO1xuICAgIG91dCArPSAnICAnICsgKCR2YWxpZGF0ZUNvZGUpICsgJy5jYWxsKCAnO1xuICAgIGlmIChpdC5vcHRzLnBhc3NDb250ZXh0KSB7XG4gICAgICBvdXQgKz0gJ3RoaXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJ3NlbGYnO1xuICAgIH1cbiAgICBpZiAoJGNvbXBpbGUgfHwgJHJEZWYuc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCAnICsgKCRkYXRhKSArICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgLCAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICwgJyArICgkZGF0YSkgKyAnICwgdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgaWYgKGl0LmVycm9yUGF0aCAhPSAnXCJcIicpIHtcbiAgICAgIG91dCArPSAnICsgJyArIChpdC5lcnJvclBhdGgpO1xuICAgIH1cbiAgICB2YXIgJHBhcmVudERhdGEgPSAkZGF0YUx2bCA/ICdkYXRhJyArICgoJGRhdGFMdmwgLSAxKSB8fCAnJykgOiAncGFyZW50RGF0YScsXG4gICAgICAkcGFyZW50RGF0YVByb3BlcnR5ID0gJGRhdGFMdmwgPyBpdC5kYXRhUGF0aEFyclskZGF0YUx2bF0gOiAncGFyZW50RGF0YVByb3BlcnR5JztcbiAgICBvdXQgKz0gJyAsICcgKyAoJHBhcmVudERhdGEpICsgJyAsICcgKyAoJHBhcmVudERhdGFQcm9wZXJ0eSkgKyAnICwgcm9vdERhdGEgKSAgJztcbiAgICB2YXIgZGVmX2NhbGxSdWxlVmFsaWRhdGUgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoJHJEZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICc7XG4gICAgICBpZiAoJGFzeW5jS2V5d29yZCkge1xuICAgICAgICBvdXQgKz0gJ2F3YWl0ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJycgKyAoZGVmX2NhbGxSdWxlVmFsaWRhdGUpICsgJzsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRhc3luY0tleXdvcmQpIHtcbiAgICAgICAgJHJ1bGVFcnJzID0gJ2N1c3RvbUVycm9ycycgKyAkbHZsO1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkcnVsZUVycnMpICsgJyA9IG51bGw7IHRyeSB7ICcgKyAoJHZhbGlkKSArICcgPSBhd2FpdCAnICsgKGRlZl9jYWxsUnVsZVZhbGlkYXRlKSArICc7IH0gY2F0Y2ggKGUpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBpZiAoZSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikgJyArICgkcnVsZUVycnMpICsgJyA9IGUuZXJyb3JzOyBlbHNlIHRocm93IGU7IH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGVFcnJzKSArICcgPSBudWxsOyAnICsgKCR2YWxpZCkgKyAnID0gJyArIChkZWZfY2FsbFJ1bGVWYWxpZGF0ZSkgKyAnOyAnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJHJEZWYubW9kaWZ5aW5nKSB7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJHBhcmVudERhdGEpICsgJykgJyArICgkZGF0YSkgKyAnID0gJyArICgkcGFyZW50RGF0YSkgKyAnWycgKyAoJHBhcmVudERhdGFQcm9wZXJ0eSkgKyAnXTsnO1xuICB9XG4gIG91dCArPSAnJyArICgkY2xvc2luZ0JyYWNlcyk7XG4gIGlmICgkckRlZi52YWxpZCkge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgaWYgKCRyRGVmLnZhbGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG91dCArPSAnICEnO1xuICAgICAgaWYgKCRtYWNybykge1xuICAgICAgICBvdXQgKz0gJycgKyAoJG5leHRWYWxpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHZhbGlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgJyArICghJHJEZWYudmFsaWQpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJykgeyAnO1xuICAgICRlcnJvcktleXdvcmQgPSAkcnVsZS5rZXl3b3JkO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJztcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdjdXN0b20nKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGtleXdvcmQ6IFxcJycgKyAoJHJ1bGUua2V5d29yZCkgKyAnXFwnIH0gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBwYXNzIFwiJyArICgkcnVsZS5rZXl3b3JkKSArICdcIiBrZXl3b3JkIHZhbGlkYXRpb25cXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICB2YXIgZGVmX2N1c3RvbUVycm9yID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCRpbmxpbmUpIHtcbiAgICAgIGlmICgkckRlZi5lcnJvcnMpIHtcbiAgICAgICAgaWYgKCRyRGVmLmVycm9ycyAhPSAnZnVsbCcpIHtcbiAgICAgICAgICBvdXQgKz0gJyAgZm9yICh2YXIgJyArICgkaSkgKyAnPScgKyAoJGVycnMpICsgJzsgJyArICgkaSkgKyAnPGVycm9yczsgJyArICgkaSkgKyAnKyspIHsgdmFyICcgKyAoJHJ1bGVFcnIpICsgJyA9IHZFcnJvcnNbJyArICgkaSkgKyAnXTsgaWYgKCcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9PT0gdW5kZWZpbmVkKSAnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPSAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICc7IGlmICgnICsgKCRydWxlRXJyKSArICcuc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkKSB7ICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWFQYXRoID0gXCInICsgKCRlcnJTY2hlbWFQYXRoKSArICdcIjsgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWEgPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnOyAnICsgKCRydWxlRXJyKSArICcuZGF0YSA9ICcgKyAoJGRhdGEpICsgJzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJHJEZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoZGVmX2N1c3RvbUVycm9yKSArICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyAnICsgKGRlZl9jdXN0b21FcnJvcikgKyAnIH0gZWxzZSB7ICBmb3IgKHZhciAnICsgKCRpKSArICc9JyArICgkZXJycykgKyAnOyAnICsgKCRpKSArICc8ZXJyb3JzOyAnICsgKCRpKSArICcrKykgeyB2YXIgJyArICgkcnVsZUVycikgKyAnID0gdkVycm9yc1snICsgKCRpKSArICddOyBpZiAoJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID09PSB1bmRlZmluZWQpICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJzsgaWYgKCcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWFQYXRoID09PSB1bmRlZmluZWQpIHsgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYVBhdGggPSBcIicgKyAoJGVyclNjaGVtYVBhdGgpICsgJ1wiOyB9ICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYSA9ICcgKyAoJHNjaGVtYVZhbHVlKSArICc7ICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhID0gJyArICgkZGF0YSkgKyAnOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9IH0gJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJG1hY3JvKSB7XG4gICAgICBvdXQgKz0gJyAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAnY3VzdG9tJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBrZXl3b3JkOiBcXCcnICsgKCRydWxlLmtleXdvcmQpICsgJ1xcJyB9ICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIHBhc3MgXCInICsgKCRydWxlLmtleXdvcmQpICsgJ1wiIGtleXdvcmQgdmFsaWRhdGlvblxcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkckRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoZGVmX2N1c3RvbUVycm9yKSArICcgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIGlmIChBcnJheS5pc0FycmF5KCcgKyAoJHJ1bGVFcnJzKSArICcpKSB7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gJyArICgkcnVsZUVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoJyArICgkcnVsZUVycnMpICsgJyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyAgZm9yICh2YXIgJyArICgkaSkgKyAnPScgKyAoJGVycnMpICsgJzsgJyArICgkaSkgKyAnPGVycm9yczsgJyArICgkaSkgKyAnKyspIHsgdmFyICcgKyAoJHJ1bGVFcnIpICsgJyA9IHZFcnJvcnNbJyArICgkaSkgKyAnXTsgaWYgKCcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9PT0gdW5kZWZpbmVkKSAnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPSAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICc7ICAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hUGF0aCA9IFwiJyArICgkZXJyU2NoZW1hUGF0aCkgKyAnXCI7ICAnO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYSA9ICcgKyAoJHNjaGVtYVZhbHVlKSArICc7ICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhID0gJyArICgkZGF0YSkgKyAnOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gfSBlbHNlIHsgJyArIChkZWZfY3VzdG9tRXJyb3IpICsgJyB9ICc7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtZXRhU2NoZW1hID0gcmVxdWlyZSgnLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICRpZDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9ibG9iL21hc3Rlci9saWIvZGVmaW5pdGlvbl9zY2hlbWEuanMnLFxuICBkZWZpbml0aW9uczoge1xuICAgIHNpbXBsZVR5cGVzOiBtZXRhU2NoZW1hLmRlZmluaXRpb25zLnNpbXBsZVR5cGVzXG4gIH0sXG4gIHR5cGU6ICdvYmplY3QnLFxuICBkZXBlbmRlbmNpZXM6IHtcbiAgICBzY2hlbWE6IFsndmFsaWRhdGUnXSxcbiAgICAkZGF0YTogWyd2YWxpZGF0ZSddLFxuICAgIHN0YXRlbWVudHM6IFsnaW5saW5lJ10sXG4gICAgdmFsaWQ6IHtub3Q6IHtyZXF1aXJlZDogWydtYWNybyddfX1cbiAgfSxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IG1ldGFTY2hlbWEucHJvcGVydGllcy50eXBlLFxuICAgIHNjaGVtYToge3R5cGU6ICdib29sZWFuJ30sXG4gICAgc3RhdGVtZW50czoge3R5cGU6ICdib29sZWFuJ30sXG4gICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ31cbiAgICB9LFxuICAgIG1ldGFTY2hlbWE6IHt0eXBlOiAnb2JqZWN0J30sXG4gICAgbW9kaWZ5aW5nOiB7dHlwZTogJ2Jvb2xlYW4nfSxcbiAgICB2YWxpZDoge3R5cGU6ICdib29sZWFuJ30sXG4gICAgJGRhdGE6IHt0eXBlOiAnYm9vbGVhbid9LFxuICAgIGFzeW5jOiB7dHlwZTogJ2Jvb2xlYW4nfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIGFueU9mOiBbXG4gICAgICAgIHt0eXBlOiAnYm9vbGVhbid9LFxuICAgICAgICB7Y29uc3Q6ICdmdWxsJ31cbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG4iLCJ7XG4gICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgXCIkaWRcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICBcInRpdGxlXCI6IFwiQ29yZSBzY2hlbWEgbWV0YS1zY2hlbWFcIixcbiAgICBcImRlZmluaXRpb25zXCI6IHtcbiAgICAgICAgXCJzY2hlbWFBcnJheVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgICAgICAgIFwibWluaW11bVwiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIjoge1xuICAgICAgICAgICAgXCJhbGxPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgICAgICAgICAgeyBcImRlZmF1bHRcIjogMCB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic2ltcGxlVHlwZXNcIjoge1xuICAgICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgICAgICBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgXCJudWxsXCIsXG4gICAgICAgICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCJcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogW11cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCIkaWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgICAgICB9LFxuICAgICAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJHJlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJGNvbW1lbnRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0aXRsZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgICBcInJlYWRPbmx5XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImV4YW1wbGVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1pbmltdW1cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4TGVuZ3RoXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICBcIm1pbkxlbmd0aFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInJlZ2V4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRpdGlvbmFsSXRlbXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcIm1heEl0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICBcIm1pbkl0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiIH0sXG4gICAgICAgIFwidW5pcXVlSXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29udGFpbnNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICBcIm1pblByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCIgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIiB9LFxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5TmFtZXNcIjogeyBcImZvcm1hdFwiOiBcInJlZ2V4XCIgfSxcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgICAgICB9LFxuICAgICAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIiB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInByb3BlcnR5TmFtZXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgXCJjb25zdFwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCIgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaXRlbXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9ybWF0XCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXCJjb250ZW50RW5jb2RpbmdcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxuICAgICAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgICBcInRoZW5cIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICAgIFwiZWxzZVwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgICAgXCJhbGxPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgICBcImFueU9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICAgIFwib25lT2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgICAgXCJub3RcIjogeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsIntcbiAgICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICBcIiRpZFwiOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJNZXRhLXNjaGVtYSBmb3IgJGRhdGEgcmVmZXJlbmNlIChKU09OIFNjaGVtYSBleHRlbnNpb24gcHJvcG9zYWwpXCIsXG4gICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgXCJyZXF1aXJlZFwiOiBbIFwiJGRhdGFcIiBdLFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiJGRhdGFcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwiZm9ybWF0XCI6IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCIgfSwgXG4gICAgICAgICAgICAgICAgeyBcImZvcm1hdFwiOiBcImpzb24tcG9pbnRlclwiIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNTRUNsaWVudFRyYW5zcG9ydCA9IGV4cG9ydHMuU3NlRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBldmVudHNvdXJjZV8xID0gcmVxdWlyZShcImV2ZW50c291cmNlXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguanNcIik7XG5jbGFzcyBTc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBldmVudCkge1xuICAgICAgICBzdXBlcihgU1NFIGVycm9yOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB9XG59XG5leHBvcnRzLlNzZUVycm9yID0gU3NlRXJyb3I7XG4vKipcbiAqIENsaWVudCB0cmFuc3BvcnQgZm9yIFNTRTogdGhpcyB3aWxsIGNvbm5lY3QgdG8gYSBzZXJ2ZXIgdXNpbmcgU2VydmVyLVNlbnQgRXZlbnRzIGZvciByZWNlaXZpbmdcbiAqIG1lc3NhZ2VzIGFuZCBtYWtlIHNlcGFyYXRlIFBPU1QgcmVxdWVzdHMgZm9yIHNlbmRpbmcgbWVzc2FnZXMuXG4gKi9cbmNsYXNzIFNTRUNsaWVudFRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VNZXRhZGF0YVVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2VJbml0ID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV2ZW50U291cmNlSW5pdDtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEluaXQgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdEluaXQ7XG4gICAgICAgIHRoaXMuX2F1dGhQcm92aWRlciA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5hdXRoUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX2ZldGNoID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZldGNoO1xuICAgIH1cbiAgICBhc3luYyBfYXV0aFRoZW5TdGFydCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuX2F1dGhQcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGF1dGhfanNfMS5VbmF1dGhvcml6ZWRFcnJvcignTm8gYXV0aCBwcm92aWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCAoMCwgYXV0aF9qc18xLmF1dGgpKHRoaXMuX2F1dGhQcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHNlcnZlclVybDogdGhpcy5fdXJsLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTWV0YWRhdGFVcmw6IHRoaXMuX3Jlc291cmNlTWV0YWRhdGFVcmwsXG4gICAgICAgICAgICAgICAgZmV0Y2hGbjogdGhpcy5fZmV0Y2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICE9PSAnQVVUSE9SSVpFRCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhdXRoX2pzXzEuVW5hdXRob3JpemVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc3RhcnRPckF1dGgoKTtcbiAgICB9XG4gICAgYXN5bmMgX2NvbW1vbkhlYWRlcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5fYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCB0aGlzLl9hdXRoUHJvdmlkZXIudG9rZW5zKCk7XG4gICAgICAgICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2Vucy5hY2Nlc3NfdG9rZW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydtY3AtcHJvdG9jb2wtdmVyc2lvbiddID0gdGhpcy5fcHJvdG9jb2xWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVhZGVycyh7IC4uLmhlYWRlcnMsIC4uLihfYSA9IHRoaXMuX3JlcXVlc3RJbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycyB9KTtcbiAgICB9XG4gICAgX3N0YXJ0T3JBdXRoKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZmV0Y2hJbXBsID0gKChfYyA9IChfYiA9IChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5fZXZlbnRTb3VyY2VJbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmV0Y2gpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX2ZldGNoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmZXRjaCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudFNvdXJjZSA9IG5ldyBldmVudHNvdXJjZV8xLkV2ZW50U291cmNlKHRoaXMuX3VybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZXZlbnRTb3VyY2VJbml0LFxuICAgICAgICAgICAgICAgIGZldGNoOiBhc3luYyAodXJsLCBpbml0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLl9jb21tb25IZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAndGV4dC9ldmVudC1zdHJlYW0nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIHJlc3BvbnNlLmhlYWRlcnMuaGFzKCd3d3ctYXV0aGVudGljYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTWV0YWRhdGFVcmwgPSAoMCwgYXV0aF9qc18xLmV4dHJhY3RSZXNvdXJjZU1ldGFkYXRhVXJsKShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uub25lcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IDQwMSAmJiB0aGlzLl9hdXRoUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aFRoZW5TdGFydCgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTc2VFcnJvcihldmVudC5jb2RlLCBldmVudC5tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiwgYnV0IHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGVuZHBvaW50IHRvIGJlIHJlY2VpdmVkLlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZHBvaW50JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZHBvaW50ID0gbmV3IFVSTChtZXNzYWdlRXZlbnQuZGF0YSwgdGhpcy5fdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuZHBvaW50Lm9yaWdpbiAhPT0gdGhpcy5fdXJsLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbmRwb2ludCBvcmlnaW4gZG9lcyBub3QgbWF0Y2ggY29ubmVjdGlvbiBvcmlnaW46ICR7dGhpcy5fZW5kcG9pbnQub3JpZ2lufWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0eXBlc19qc18xLkpTT05SUENNZXNzYWdlU2NoZW1hLnBhcnNlKEpTT04ucGFyc2UobWVzc2FnZUV2ZW50LmRhdGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMub25lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub25tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50U291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NTRUNsaWVudFRyYW5zcG9ydCBhbHJlYWR5IHN0YXJ0ZWQhIElmIHVzaW5nIENsaWVudCBjbGFzcywgbm90ZSB0aGF0IGNvbm5lY3QoKSBjYWxscyBzdGFydCgpIGF1dG9tYXRpY2FsbHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3N0YXJ0T3JBdXRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyBtZXRob2QgYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIGF1dGhvcml6aW5nIHZpYSB0aGVpciB1c2VyIGFnZW50IGFuZCBpcyByZWRpcmVjdGVkIGJhY2sgdG8gdGhlIE1DUCBjbGllbnQgYXBwbGljYXRpb24uIFRoaXMgd2lsbCBleGNoYW5nZSB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIGZvciBhbiBhY2Nlc3MgdG9rZW4sIGVuYWJsaW5nIHRoZSBuZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdCB0byBzdWNjZXNzZnVsbHkgYXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5pc2hBdXRoKGF1dGhvcml6YXRpb25Db2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYXV0aF9qc18xLlVuYXV0aG9yaXplZEVycm9yKCdObyBhdXRoIHByb3ZpZGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIGF1dGhfanNfMS5hdXRoKSh0aGlzLl9hdXRoUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHNlcnZlclVybDogdGhpcy5fdXJsLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbkNvZGUsXG4gICAgICAgICAgICByZXNvdXJjZU1ldGFkYXRhVXJsOiB0aGlzLl9yZXNvdXJjZU1ldGFkYXRhVXJsLFxuICAgICAgICAgICAgZmV0Y2hGbjogdGhpcy5fZmV0Y2hcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09ICdBVVRIT1JJWkVEJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGF1dGhfanNfMS5VbmF1dGhvcml6ZWRFcnJvcignRmFpbGVkIHRvIGF1dGhvcml6ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgKF9hID0gdGhpcy5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgKF9iID0gdGhpcy5fZXZlbnRTb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbG9zZSgpO1xuICAgICAgICAoX2MgPSB0aGlzLm9uY2xvc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghdGhpcy5fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5fY29tbW9uSGVhZGVycygpO1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICBjb25zdCBpbml0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX3JlcXVlc3RJbml0LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiAoX2EgPSB0aGlzLl9hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgoX2IgPSB0aGlzLl9mZXRjaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmV0Y2gpKHRoaXMuX2VuZHBvaW50LCBpbml0KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgJiYgdGhpcy5fYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTWV0YWRhdGFVcmwgPSAoMCwgYXV0aF9qc18xLmV4dHJhY3RSZXNvdXJjZU1ldGFkYXRhVXJsKShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBhdXRoX2pzXzEuYXV0aCkodGhpcy5fYXV0aFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJVcmw6IHRoaXMuX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlTWV0YWRhdGFVcmw6IHRoaXMuX3Jlc291cmNlTWV0YWRhdGFVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaEZuOiB0aGlzLl9mZXRjaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gJ0FVVEhPUklaRUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXV0aF9qc18xLlVuYXV0aG9yaXplZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHVycG9zZWx5IF9ub3RfIGF3YWl0ZWQsIHNvIHdlIGRvbid0IGNhbGwgb25lcnJvciB0d2ljZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgUE9TVGluZyB0byBlbmRwb2ludCAoSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30pOiAke3RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLm9uZXJyb3IpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByb3RvY29sVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sVmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxufVxuZXhwb3J0cy5TU0VDbGllbnRUcmFuc3BvcnQgPSBTU0VDbGllbnRUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zc2UuanMubWFwIixudWxsLCJpbXBvcnQgeyBjcmVhdGVQYXJzZXIgfSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRXJyb3JFdmVudGAgaW5zdGFuY2UuIFRoaXMgaXMgdHlwaWNhbGx5IG5vdCBjYWxsZWQgZGlyZWN0bHksXG4gICAqIGJ1dCByYXRoZXIgZW1pdHRlZCBieSB0aGUgYEV2ZW50U291cmNlYCBvYmplY3Qgd2hlbiBhbiBlcnJvciBvY2N1cnMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IChzaG91bGQgYmUgXCJlcnJvclwiKVxuICAgKiBAcGFyYW0gZXJyb3JFdmVudEluaXREaWN0IC0gT3B0aW9uYWwgcHJvcGVydGllcyB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgZXJyb3JFdmVudEluaXREaWN0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdXBlcih0eXBlKSwgdGhpcy5jb2RlID0gKF9hID0gZXJyb3JFdmVudEluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckV2ZW50SW5pdERpY3QuY29kZSkgIT0gbnVsbCA/IF9hIDogdm9pZCAwLCB0aGlzLm1lc3NhZ2UgPSAoX2IgPSBlcnJvckV2ZW50SW5pdERpY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yRXZlbnRJbml0RGljdC5tZXNzYWdlKSAhPSBudWxsID8gX2IgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIE5vZGUuanMgXCJoaWRlc1wiIHRoZSBgbWVzc2FnZWAgYW5kIGBjb2RlYCBwcm9wZXJ0aWVzIG9mIHRoZSBgRXJyb3JFdmVudGAgaW5zdGFuY2UsXG4gICAqIHdoZW4gaXQgaXMgYGNvbnNvbGUubG9nYCdlZC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gZGVidWcgZXJyb3JzLiBUbyBlYXNlIGRlYnVnZ2luZyxcbiAgICogd2UgZXhwbGljaXRseSBpbmNsdWRlIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBgaW5zcGVjdGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IE5vZGUuanMgd2hlbiB5b3UgYGNvbnNvbGUubG9nYCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gX2RlcHRoIC0gVGhlIGN1cnJlbnQgZGVwdGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gYHV0aWwuaW5zcGVjdGBcbiAgICogQHBhcmFtIGluc3BlY3QgLSBUaGUgaW5zcGVjdCBmdW5jdGlvbiB0byB1c2UgKHByZXZlbnRzIGhhdmluZyB0byBpbXBvcnQgaXQgZnJvbSBgdXRpbGApXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oX2RlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgcmV0dXJuIGluc3BlY3QoaW5zcGVjdGFibGVFcnJvcih0aGlzKSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIERlbm8gXCJoaWRlc1wiIHRoZSBgbWVzc2FnZWAgYW5kIGBjb2RlYCBwcm9wZXJ0aWVzIG9mIHRoZSBgRXJyb3JFdmVudGAgaW5zdGFuY2UsXG4gICAqIHdoZW4gaXQgaXMgYGNvbnNvbGUubG9nYCdlZC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gZGVidWcgZXJyb3JzLiBUbyBlYXNlIGRlYnVnZ2luZyxcbiAgICogd2UgZXhwbGljaXRseSBpbmNsdWRlIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBgaW5zcGVjdGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IERlbm8gd2hlbiB5b3UgYGNvbnNvbGUubG9nYCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5zcGVjdCAtIFRoZSBpbnNwZWN0IGZ1bmN0aW9uIHRvIHVzZSAocHJldmVudHMgaGF2aW5nIHRvIGltcG9ydCBpdCBmcm9tIGB1dGlsYClcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gYERlbm8uaW5zcGVjdGBcbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yXG4gICAqL1xuICBbU3ltYm9sLmZvcihcIkRlbm8uY3VzdG9tSW5zcGVjdFwiKV0oaW5zcGVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnNwZWN0KGluc3BlY3RhYmxlRXJyb3IodGhpcyksIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBzeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIGNvbnN0IERvbUV4Y2VwdGlvbiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uO1xuICByZXR1cm4gdHlwZW9mIERvbUV4Y2VwdGlvbiA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgRG9tRXhjZXB0aW9uKG1lc3NhZ2UsIFwiU3ludGF4RXJyb3JcIikgOiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuRXJyb3IoZXJyKSB7XG4gIHJldHVybiBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IFwiZXJyb3JzXCIgaW4gZXJyICYmIEFycmF5LmlzQXJyYXkoZXJyLmVycm9ycykgPyBlcnIuZXJyb3JzLm1hcChmbGF0dGVuRXJyb3IpLmpvaW4oXCIsIFwiKSA6IFwiY2F1c2VcIiBpbiBlcnIgJiYgZXJyLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlcnJ9OiAke2ZsYXR0ZW5FcnJvcihlcnIuY2F1c2UpfWAgOiBlcnIubWVzc2FnZSA6IGAke2Vycn1gO1xufVxuZnVuY3Rpb24gaW5zcGVjdGFibGVFcnJvcihlcnIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlcnIudHlwZSxcbiAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICBjb2RlOiBlcnIuY29kZSxcbiAgICBkZWZhdWx0UHJldmVudGVkOiBlcnIuZGVmYXVsdFByZXZlbnRlZCxcbiAgICBjYW5jZWxhYmxlOiBlcnIuY2FuY2VsYWJsZSxcbiAgICB0aW1lU3RhbXA6IGVyci50aW1lU3RhbXBcbiAgfTtcbn1cbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59LCBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyksIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSksIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IG1lbWJlci5oYXMob2JqKSA/IF9fdHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKSwgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbWV0aG9kKSwgX3JlYWR5U3RhdGUsIF91cmwsIF9yZWRpcmVjdFVybCwgX3dpdGhDcmVkZW50aWFscywgX2ZldGNoLCBfcmVjb25uZWN0SW50ZXJ2YWwsIF9yZWNvbm5lY3RUaW1lciwgX2xhc3RFdmVudElkLCBfY29udHJvbGxlciwgX3BhcnNlciwgX29uRXJyb3IsIF9vbk1lc3NhZ2UsIF9vbk9wZW4sIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGNvbm5lY3RfZm4sIF9vbkZldGNoUmVzcG9uc2UsIF9vbkZldGNoRXJyb3IsIGdldFJlcXVlc3RPcHRpb25zX2ZuLCBfb25FdmVudCwgX29uUmV0cnlDaGFuZ2UsIGZhaWxDb25uZWN0aW9uX2ZuLCBzY2hlZHVsZVJlY29ubmVjdF9mbiwgX3JlY29ubmVjdDtcbmNsYXNzIEV2ZW50U291cmNlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGV2ZW50U291cmNlSW5pdERpY3QpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN1cGVyKCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzKSwgdGhpcy5DT05ORUNUSU5HID0gMCwgdGhpcy5PUEVOID0gMSwgdGhpcy5DTE9TRUQgPSAyLCBfX3ByaXZhdGVBZGQodGhpcywgX3JlYWR5U3RhdGUpLCBfX3ByaXZhdGVBZGQodGhpcywgX3VybCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmVkaXJlY3RVcmwpLCBfX3ByaXZhdGVBZGQodGhpcywgX3dpdGhDcmVkZW50aWFscyksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZmV0Y2gpLCBfX3ByaXZhdGVBZGQodGhpcywgX3JlY29ubmVjdEludGVydmFsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWNvbm5lY3RUaW1lciksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGFzdEV2ZW50SWQsIG51bGwpLCBfX3ByaXZhdGVBZGQodGhpcywgX2NvbnRyb2xsZXIpLCBfX3ByaXZhdGVBZGQodGhpcywgX3BhcnNlciksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25FcnJvciwgbnVsbCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25NZXNzYWdlLCBudWxsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9vbk9wZW4sIG51bGwpLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRmV0Y2hSZXNwb25zZSwgYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJzZXIpLnJlc2V0KCk7XG4gICAgICBjb25zdCB7IGJvZHksIHJlZGlyZWN0ZWQsIHN0YXR1cywgaGVhZGVycyB9ID0gcmVzcG9uc2U7XG4gICAgICBpZiAoc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGZhaWxDb25uZWN0aW9uX2ZuKS5jYWxsKHRoaXMsIFwiU2VydmVyIHNlbnQgSFRUUCAyMDQsIG5vdCByZWNvbm5lY3RpbmdcIiwgMjA0KSwgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVkaXJlY3RlZCA/IF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVkaXJlY3RVcmwsIG5ldyBVUkwocmVzcG9uc2UudXJsKSkgOiBfX3ByaXZhdGVTZXQodGhpcywgX3JlZGlyZWN0VXJsLCB2b2lkIDApLCBzdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgZmFpbENvbm5lY3Rpb25fZm4pLmNhbGwodGhpcywgYE5vbi0yMDAgc3RhdHVzIGNvZGUgKCR7c3RhdHVzfSlgLCBzdGF0dXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiKS5zdGFydHNXaXRoKFwidGV4dC9ldmVudC1zdHJlYW1cIikpIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGZhaWxDb25uZWN0aW9uX2ZuKS5jYWxsKHRoaXMsICdJbnZhbGlkIGNvbnRlbnQgdHlwZSwgZXhwZWN0ZWQgXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiJywgc3RhdHVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVhZHlTdGF0ZSkgPT09IHRoaXMuQ0xPU0VEKVxuICAgICAgICByZXR1cm47XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuT1BFTik7XG4gICAgICBjb25zdCBvcGVuRXZlbnQgPSBuZXcgRXZlbnQoXCJvcGVuXCIpO1xuICAgICAgaWYgKChfYTIgPSBfX3ByaXZhdGVHZXQodGhpcywgX29uT3BlbikpID09IG51bGwgfHwgX2EyLmNhbGwodGhpcywgb3BlbkV2ZW50KSwgdGhpcy5kaXNwYXRjaEV2ZW50KG9wZW5FdmVudCksIHR5cGVvZiBib2R5ICE9IFwib2JqZWN0XCIgfHwgIWJvZHkgfHwgIShcImdldFJlYWRlclwiIGluIGJvZHkpKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBmYWlsQ29ubmVjdGlvbl9mbikuY2FsbCh0aGlzLCBcIkludmFsaWQgcmVzcG9uc2UgYm9keSwgZXhwZWN0ZWQgYSB3ZWIgUmVhZGFibGVTdHJlYW1cIiwgc3RhdHVzKSwgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCksIHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICBsZXQgb3BlbiA9ICEwO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICB2YWx1ZSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX3BhcnNlcikuZmVlZChkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06ICFkb25lIH0pKSwgZG9uZSAmJiAob3BlbiA9ICExLCBfX3ByaXZhdGVHZXQodGhpcywgX3BhcnNlcikucmVzZXQoKSwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIHNjaGVkdWxlUmVjb25uZWN0X2ZuKS5jYWxsKHRoaXMpKTtcbiAgICAgIH0gd2hpbGUgKG9wZW4pO1xuICAgIH0pLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRmV0Y2hFcnJvciwgKGVycikgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb250cm9sbGVyLCB2b2lkIDApLCAhKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnIudHlwZSA9PT0gXCJhYm9ydGVkXCIpICYmIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBzY2hlZHVsZVJlY29ubmVjdF9mbikuY2FsbCh0aGlzLCBmbGF0dGVuRXJyb3IoZXJyKSk7XG4gICAgfSksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25FdmVudCwgKGV2ZW50KSA9PiB7XG4gICAgICB0eXBlb2YgZXZlbnQuaWQgPT0gXCJzdHJpbmdcIiAmJiBfX3ByaXZhdGVTZXQodGhpcywgX2xhc3RFdmVudElkLCBldmVudC5pZCk7XG4gICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KGV2ZW50LmV2ZW50IHx8IFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgIG9yaWdpbjogX19wcml2YXRlR2V0KHRoaXMsIF9yZWRpcmVjdFVybCkgPyBfX3ByaXZhdGVHZXQodGhpcywgX3JlZGlyZWN0VXJsKS5vcmlnaW4gOiBfX3ByaXZhdGVHZXQodGhpcywgX3VybCkub3JpZ2luLFxuICAgICAgICBsYXN0RXZlbnRJZDogZXZlbnQuaWQgfHwgXCJcIlxuICAgICAgfSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX29uTWVzc2FnZSkgJiYgKCFldmVudC5ldmVudCB8fCBldmVudC5ldmVudCA9PT0gXCJtZXNzYWdlXCIpICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25NZXNzYWdlKS5jYWxsKHRoaXMsIG1lc3NhZ2VFdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChtZXNzYWdlRXZlbnQpO1xuICAgIH0pLCBfX3ByaXZhdGVBZGQodGhpcywgX29uUmV0cnlDaGFuZ2UsICh2YWx1ZSkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWNvbm5lY3RJbnRlcnZhbCwgdmFsdWUpO1xuICAgIH0pLCBfX3ByaXZhdGVBZGQodGhpcywgX3JlY29ubmVjdCwgKCkgPT4ge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWNvbm5lY3RUaW1lciwgdm9pZCAwKSwgX19wcml2YXRlR2V0KHRoaXMsIF9yZWFkeVN0YXRlKSA9PT0gdGhpcy5DT05ORUNUSU5HICYmIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBjb25uZWN0X2ZuKS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBpZiAodXJsIGluc3RhbmNlb2YgVVJMKVxuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3VybCwgdXJsKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB1cmwgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIG5ldyBVUkwodXJsLCBnZXRCYXNlVVJMKCkpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVUkxcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBzeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wYXJzZXIsIGNyZWF0ZVBhcnNlcih7XG4gICAgICBvbkV2ZW50OiBfX3ByaXZhdGVHZXQodGhpcywgX29uRXZlbnQpLFxuICAgICAgb25SZXRyeTogX19wcml2YXRlR2V0KHRoaXMsIF9vblJldHJ5Q2hhbmdlKVxuICAgIH0pKSwgX19wcml2YXRlU2V0KHRoaXMsIF9yZWFkeVN0YXRlLCB0aGlzLkNPTk5FQ1RJTkcpLCBfX3ByaXZhdGVTZXQodGhpcywgX3JlY29ubmVjdEludGVydmFsLCAzZTMpLCBfX3ByaXZhdGVTZXQodGhpcywgX2ZldGNoLCAoX2EgPSBldmVudFNvdXJjZUluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudFNvdXJjZUluaXREaWN0LmZldGNoKSAhPSBudWxsID8gX2EgOiBnbG9iYWxUaGlzLmZldGNoKSwgX19wcml2YXRlU2V0KHRoaXMsIF93aXRoQ3JlZGVudGlhbHMsIChfYiA9IGV2ZW50U291cmNlSW5pdERpY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzKSAhPSBudWxsID8gX2IgOiAhMSksIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBjb25uZWN0X2ZuKS5jYWxsKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGlzIEV2ZW50U291cmNlIG9iamVjdCdzIGNvbm5lY3Rpb24uIEl0IGNhbiBoYXZlIHRoZSB2YWx1ZXMgZGVzY3JpYmVkIGJlbG93LlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL3JlYWR5U3RhdGUpXG4gICAqXG4gICAqIE5vdGU6IHR5cGVkIGFzIGBudW1iZXJgIGluc3RlYWQgb2YgYDAgfCAxIHwgMmAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYEV2ZW50U291cmNlYCBpbnRlcmZhY2UsXG4gICAqIGRlZmluZWQgaW4gdGhlIFR5cGVTY3JpcHQgYGRvbWAgbGlicmFyeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVhZHlTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVSTCBwcm92aWRpbmcgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS91cmwpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXJsKS5ocmVmO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNyZWRlbnRpYWxzIG1vZGUgZm9yIGNvbm5lY3Rpb24gcmVxdWVzdHMgdG8gdGhlIFVSTCBwcm92aWRpbmcgdGhlIGV2ZW50IHN0cmVhbSBpcyBzZXQgdG8gXCJpbmNsdWRlXCIsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2Uvd2l0aENyZWRlbnRpYWxzKVxuICAgKi9cbiAgZ2V0IHdpdGhDcmVkZW50aWFscygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF93aXRoQ3JlZGVudGlhbHMpO1xuICB9XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL2Vycm9yX2V2ZW50KSAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9vbkVycm9yKTtcbiAgfVxuICBzZXQgb25lcnJvcih2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb25FcnJvciwgdmFsdWUpO1xuICB9XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL21lc3NhZ2VfZXZlbnQpICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25NZXNzYWdlKTtcbiAgfVxuICBzZXQgb25tZXNzYWdlKHZhbHVlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9vbk1lc3NhZ2UsIHZhbHVlKTtcbiAgfVxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9vcGVuX2V2ZW50KSAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29uT3Blbik7XG4gIH1cbiAgc2V0IG9ub3Blbih2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb25PcGVuLCB2YWx1ZSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpc3RlbiA9IGxpc3RlbmVyO1xuICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuLCBvcHRpb25zKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGlzdGVuID0gbGlzdGVuZXI7XG4gICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW4sIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBBYm9ydHMgYW55IGluc3RhbmNlcyBvZiB0aGUgZmV0Y2ggYWxnb3JpdGhtIHN0YXJ0ZWQgZm9yIHRoaXMgRXZlbnRTb3VyY2Ugb2JqZWN0LCBhbmQgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ0xPU0VELlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL2Nsb3NlKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3JlY29ubmVjdFRpbWVyKSAmJiBjbGVhclRpbWVvdXQoX19wcml2YXRlR2V0KHRoaXMsIF9yZWNvbm5lY3RUaW1lcikpLCBfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpICE9PSB0aGlzLkNMT1NFRCAmJiAoX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRyb2xsZXIpLmFib3J0KCksIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVhZHlTdGF0ZSwgdGhpcy5DTE9TRUQpLCBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIHZvaWQgMCkpO1xuICB9XG59XG5fcmVhZHlTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfdXJsID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9yZWRpcmVjdFVybCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfd2l0aENyZWRlbnRpYWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9mZXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfcmVjb25uZWN0SW50ZXJ2YWwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3JlY29ubmVjdFRpbWVyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9sYXN0RXZlbnRJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfY29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfcGFyc2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9vbkVycm9yID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9vbk1lc3NhZ2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX29uT3BlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCksIC8qKlxuKiBDb25uZWN0IHRvIHRoZSBnaXZlbiBVUkwgYW5kIHN0YXJ0IHJlY2VpdmluZyBldmVudHNcbipcbiogQGludGVybmFsXG4qL1xuY29ubmVjdF9mbiA9IGZ1bmN0aW9uKCkge1xuICBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ09OTkVDVElORyksIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29udHJvbGxlciwgbmV3IEFib3J0Q29udHJvbGxlcigpKSwgX19wcml2YXRlR2V0KHRoaXMsIF9mZXRjaCkoX19wcml2YXRlR2V0KHRoaXMsIF91cmwpLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgZ2V0UmVxdWVzdE9wdGlvbnNfZm4pLmNhbGwodGhpcykpLnRoZW4oX19wcml2YXRlR2V0KHRoaXMsIF9vbkZldGNoUmVzcG9uc2UpKS5jYXRjaChfX3ByaXZhdGVHZXQodGhpcywgX29uRmV0Y2hFcnJvcikpO1xufSwgX29uRmV0Y2hSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25GZXRjaEVycm9yID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIC8qKlxuKiBHZXQgcmVxdWVzdCBvcHRpb25zIGZvciB0aGUgYGZldGNoKClgIHJlcXVlc3RcbipcbiogQHJldHVybnMgVGhlIHJlcXVlc3Qgb3B0aW9uc1xuKiBAaW50ZXJuYWxcbiovXG5nZXRSZXF1ZXN0T3B0aW9uc19mbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGluaXQgPSB7XG4gICAgLy8gW3NwZWNdIExldCBgY29yc0F0dHJpYnV0ZVN0YXRlYCBiZSBgQW5vbnltb3VzYOKAplxuICAgIC8vIFtzcGVjXSDigKZ3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCLigKZcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLCAuLi5fX3ByaXZhdGVHZXQodGhpcywgX2xhc3RFdmVudElkKSA/IHsgXCJMYXN0LUV2ZW50LUlEXCI6IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGFzdEV2ZW50SWQpIH0gOiB2b2lkIDAgfSxcbiAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxuICAgIHNpZ25hbDogKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpZ25hbFxuICB9O1xuICByZXR1cm4gXCJ3aW5kb3dcIiBpbiBnbG9iYWxUaGlzICYmIChpbml0LmNyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIiksIGluaXQ7XG59LCBfb25FdmVudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25SZXRyeUNoYW5nZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAvKipcbiogSGFuZGxlcyB0aGUgcHJvY2VzcyByZWZlcnJlZCB0byBpbiB0aGUgRXZlbnRTb3VyY2Ugc3BlY2lmaWNhdGlvbiBhcyBcImZhaWxpbmcgYSBjb25uZWN0aW9uXCIuXG4qXG4qIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBjYXVzaW5nIHRoZSBjb25uZWN0aW9uIHRvIGZhaWxcbiogQHBhcmFtIGNvZGUgLSBUaGUgSFRUUCBzdGF0dXMgY29kZSwgaWYgYXZhaWxhYmxlXG4qIEBpbnRlcm5hbFxuKi9cbmZhaWxDb25uZWN0aW9uX2ZuID0gZnVuY3Rpb24obWVzc2FnZSwgY29kZSkge1xuICB2YXIgX2E7XG4gIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVhZHlTdGF0ZSkgIT09IHRoaXMuQ0xPU0VEICYmIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVhZHlTdGF0ZSwgdGhpcy5DTE9TRUQpO1xuICBjb25zdCBlcnJvckV2ZW50ID0gbmV3IEVycm9yRXZlbnQoXCJlcnJvclwiLCB7IGNvZGUsIG1lc3NhZ2UgfSk7XG4gIChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfb25FcnJvcikpID09IG51bGwgfHwgX2EuY2FsbCh0aGlzLCBlcnJvckV2ZW50KSwgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yRXZlbnQpO1xufSwgLyoqXG4qIFNjaGVkdWxlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGFnYWluc3QgdGhlIEV2ZW50U291cmNlIGVuZHBvaW50LlxuKlxuKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBjYXVzaW5nIHRoZSBjb25uZWN0aW9uIHRvIGZhaWxcbiogQHBhcmFtIGNvZGUgLSBUaGUgSFRUUCBzdGF0dXMgY29kZSwgaWYgYXZhaWxhYmxlXG4qIEBpbnRlcm5hbFxuKi9cbnNjaGVkdWxlUmVjb25uZWN0X2ZuID0gZnVuY3Rpb24obWVzc2FnZSwgY29kZSkge1xuICB2YXIgX2E7XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpID09PSB0aGlzLkNMT1NFRClcbiAgICByZXR1cm47XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVhZHlTdGF0ZSwgdGhpcy5DT05ORUNUSU5HKTtcbiAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBjb2RlLCBtZXNzYWdlIH0pO1xuICAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX29uRXJyb3IpKSA9PSBudWxsIHx8IF9hLmNhbGwodGhpcywgZXJyb3JFdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KSwgX19wcml2YXRlU2V0KHRoaXMsIF9yZWNvbm5lY3RUaW1lciwgc2V0VGltZW91dChfX3ByaXZhdGVHZXQodGhpcywgX3JlY29ubmVjdCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVjb25uZWN0SW50ZXJ2YWwpKSk7XG59LCBfcmVjb25uZWN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIC8qKlxuKiBSZWFkeVN0YXRlIHJlcHJlc2VudGluZyBhbiBFdmVudFNvdXJjZSBjdXJyZW50bHkgdHJ5aW5nIHRvIGNvbm5lY3RcbipcbiogQHB1YmxpY1xuKi9cbkV2ZW50U291cmNlLkNPTk5FQ1RJTkcgPSAwLCAvKipcbiogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIG9wZW4gKGVnIGNvbm5lY3RlZClcbipcbiogQHB1YmxpY1xuKi9cbkV2ZW50U291cmNlLk9QRU4gPSAxLCAvKipcbiogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIGNsb3NlZCAoZWcgZGlzY29ubmVjdGVkKVxuKlxuKiBAcHVibGljXG4qL1xuRXZlbnRTb3VyY2UuQ0xPU0VEID0gMjtcbmZ1bmN0aW9uIGdldEJhc2VVUkwoKSB7XG4gIGNvbnN0IGRvYyA9IFwiZG9jdW1lbnRcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5kb2N1bWVudCA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvYyAmJiB0eXBlb2YgZG9jID09IFwib2JqZWN0XCIgJiYgXCJiYXNlVVJJXCIgaW4gZG9jICYmIHR5cGVvZiBkb2MuYmFzZVVSSSA9PSBcInN0cmluZ1wiID8gZG9jLmJhc2VVUkkgOiB2b2lkIDA7XG59XG5leHBvcnQge1xuICBFcnJvckV2ZW50LFxuICBFdmVudFNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyoqXG4gKiBBbiBleHRlbmRlZCB2ZXJzaW9uIG9mIHRoZSBgRXZlbnRgIGVtaXR0ZWQgYnkgdGhlIGBFdmVudFNvdXJjZWAgb2JqZWN0IHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuICogV2hpbGUgdGhlIHNwZWMgZG9lcyBub3QgaW5jbHVkZSBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCB3ZSBpbnRlbnRpb25hbGx5IGdvIGJleW9uZCB0aGUgc3BlY1xuICogYW5kIHByb3ZpZGUgc29tZSAobWluaW1hbCkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBhaWQgaW4gZGVidWdnaW5nLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBIVFRQIHN0YXR1cyBjb2RlLCBpZiB0aGlzIHdhcyB0cmlnZ2VyZWQgYnkgYW4gSFRUUCBlcnJvclxuICAgKiBOb3RlOiB0aGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjLCBidXQgaXMgaW5jbHVkZWQgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcHVibGljIGNvZGU/OiBudW1iZXIgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogT3B0aW9uYWwgbWVzc2FnZSBhdHRhY2hlZCB0byB0aGUgZXJyb3IuXG4gICAqIE5vdGU6IHRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMsIGJ1dCBpcyBpbmNsdWRlZCBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwdWJsaWMgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBFcnJvckV2ZW50YCBpbnN0YW5jZS4gVGhpcyBpcyB0eXBpY2FsbHkgbm90IGNhbGxlZCBkaXJlY3RseSxcbiAgICogYnV0IHJhdGhlciBlbWl0dGVkIGJ5IHRoZSBgRXZlbnRTb3VyY2VgIG9iamVjdCB3aGVuIGFuIGVycm9yIG9jY3Vycy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKHNob3VsZCBiZSBcImVycm9yXCIpXG4gICAqIEBwYXJhbSBlcnJvckV2ZW50SW5pdERpY3QgLSBPcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZXJyb3JFdmVudEluaXREaWN0Pzoge21lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7IGNvZGU/OiBudW1iZXIgfCB1bmRlZmluZWR9LFxuICApIHtcbiAgICBzdXBlcih0eXBlKVxuICAgIHRoaXMuY29kZSA9IGVycm9yRXZlbnRJbml0RGljdD8uY29kZSA/PyB1bmRlZmluZWRcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvckV2ZW50SW5pdERpY3Q/Lm1lc3NhZ2UgPz8gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogTm9kZS5qcyBcImhpZGVzXCIgdGhlIGBtZXNzYWdlYCBhbmQgYGNvZGVgIHByb3BlcnRpZXMgb2YgdGhlIGBFcnJvckV2ZW50YCBpbnN0YW5jZSxcbiAgICogd2hlbiBpdCBpcyBgY29uc29sZS5sb2dgJ2VkLiBUaGlzIG1ha2VzIGl0IGhhcmRlciB0byBkZWJ1ZyBlcnJvcnMuIFRvIGVhc2UgZGVidWdnaW5nLFxuICAgKiB3ZSBleHBsaWNpdGx5IGluY2x1ZGUgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGBpbnNwZWN0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgTm9kZS5qcyB3aGVuIHlvdSBgY29uc29sZS5sb2dgIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBfZGVwdGggLSBUaGUgY3VycmVudCBkZXB0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBgdXRpbC5pbnNwZWN0YFxuICAgKiBAcGFyYW0gaW5zcGVjdCAtIFRoZSBpbnNwZWN0IGZ1bmN0aW9uIHRvIHVzZSAocHJldmVudHMgaGF2aW5nIHRvIGltcG9ydCBpdCBmcm9tIGB1dGlsYClcbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yXG4gICAqL1xuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oXG4gICAgX2RlcHRoOiBudW1iZXIsXG4gICAgb3B0aW9uczoge2NvbG9yczogYm9vbGVhbn0sXG4gICAgaW5zcGVjdDogKG9iajogdW5rbm93biwgaW5zcGVjdE9wdGlvbnM6IHtjb2xvcnM6IGJvb2xlYW59KSA9PiBzdHJpbmcsXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGluc3BlY3QoaW5zcGVjdGFibGVFcnJvcih0aGlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZW5vIFwiaGlkZXNcIiB0aGUgYG1lc3NhZ2VgIGFuZCBgY29kZWAgcHJvcGVydGllcyBvZiB0aGUgYEVycm9yRXZlbnRgIGluc3RhbmNlLFxuICAgKiB3aGVuIGl0IGlzIGBjb25zb2xlLmxvZ2AnZWQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGRlYnVnIGVycm9ycy4gVG8gZWFzZSBkZWJ1Z2dpbmcsXG4gICAqIHdlIGV4cGxpY2l0bHkgaW5jbHVkZSB0aGUgcHJvcGVydGllcyBpbiB0aGUgYGluc3BlY3RgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBEZW5vIHdoZW4geW91IGBjb25zb2xlLmxvZ2AgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIGluc3BlY3QgLSBUaGUgaW5zcGVjdCBmdW5jdGlvbiB0byB1c2UgKHByZXZlbnRzIGhhdmluZyB0byBpbXBvcnQgaXQgZnJvbSBgdXRpbGApXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGBEZW5vLmluc3BlY3RgXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICAgKi9cbiAgW1N5bWJvbC5mb3IoJ0Rlbm8uY3VzdG9tSW5zcGVjdCcpXShcbiAgICBpbnNwZWN0OiAob2JqOiB1bmtub3duLCBpbnNwZWN0T3B0aW9uczoge2NvbG9yczogYm9vbGVhbn0pID0+IHN0cmluZyxcbiAgICBvcHRpb25zOiB7Y29sb3JzOiBib29sZWFufSxcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaW5zcGVjdChpbnNwZWN0YWJsZUVycm9yKHRoaXMpLCBvcHRpb25zKVxuICB9XG59XG5cbi8qKlxuICogRm9yIGVudmlyb25tZW50cyB3aGVyZSBET01FeGNlcHRpb24gbWF5IG5vdCBleGlzdCwgd2Ugd2lsbCB1c2UgYSBTeW50YXhFcnJvciBpbnN0ZWFkLlxuICogV2hpbGUgdGhpcyBpc24ndCBzdHJpY3RseSBhY2NvcmRpbmcgdG8gc3BlYywgaXQgaXMgdmVyeSBjbG9zZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yXG4gKiBAcmV0dXJucyBBIGBET01FeGNlcHRpb25gIG9yIGBTeW50YXhFcnJvcmAgaW5zdGFuY2VcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ludGF4RXJyb3IobWVzc2FnZTogc3RyaW5nKTogU3ludGF4RXJyb3Ige1xuICAvLyBJZiBzb21lb25lIGNhbiBmaWd1cmUgb3V0IGEgd2F5IHRvIG1ha2UgdGhpcyB3b3JrIHdpdGhvdXQgZGVwZW5kaW5nIG9uIERPTS9Ob2RlLmpzIHR5cGluZ3MsXG4gIC8vIGFuZCB3aXRob3V0IGNhc3RpbmcgdG8gYGFueWAsIHBsZWFzZSBzZW5kIGEgUFIg8J+Zj1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IERvbUV4Y2VwdGlvbiA9IChnbG9iYWxUaGlzIGFzIGFueSkuRE9NRXhjZXB0aW9uXG4gIGlmICh0eXBlb2YgRG9tRXhjZXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5ldyBEb21FeGNlcHRpb24obWVzc2FnZSwgJ1N5bnRheEVycm9yJylcbiAgfVxuXG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSlcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGFuIGVycm9yIGludG8gYSBzaW5nbGUgZXJyb3IgbWVzc2FnZSBzdHJpbmcuXG4gKiBVbndyYXBzIG5lc3RlZCBlcnJvcnMgYW5kIGpvaW5zIHRoZW0gd2l0aCBhIGNvbW1hLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBUaGUgZXJyb3IgdG8gZmxhdHRlblxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5FcnJvcihlcnI6IHVua25vd24pOiBzdHJpbmcge1xuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICByZXR1cm4gYCR7ZXJyfWBcbiAgfVxuXG4gIGlmICgnZXJyb3JzJyBpbiBlcnIgJiYgQXJyYXkuaXNBcnJheShlcnIuZXJyb3JzKSkge1xuICAgIHJldHVybiBlcnIuZXJyb3JzLm1hcChmbGF0dGVuRXJyb3IpLmpvaW4oJywgJylcbiAgfVxuXG4gIGlmICgnY2F1c2UnIGluIGVyciAmJiBlcnIuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBgJHtlcnJ9OiAke2ZsYXR0ZW5FcnJvcihlcnIuY2F1c2UpfWBcbiAgfVxuXG4gIHJldHVybiBlcnIubWVzc2FnZVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYEVycm9yRXZlbnRgIGluc3RhbmNlIGludG8gYSBwbGFpbiBvYmplY3QgZm9yIGluc3BlY3Rpb24uXG4gKlxuICogQHBhcmFtIGVyciAtIFRoZSBgRXJyb3JFdmVudGAgaW5zdGFuY2UgdG8gaW5zcGVjdFxuICogQHJldHVybnMgQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdGFibGVFcnJvcihlcnI6IEVycm9yRXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlcnIudHlwZSxcbiAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICBjb2RlOiBlcnIuY29kZSxcbiAgICBkZWZhdWx0UHJldmVudGVkOiBlcnIuZGVmYXVsdFByZXZlbnRlZCxcbiAgICBjYW5jZWxhYmxlOiBlcnIuY2FuY2VsYWJsZSxcbiAgICB0aW1lU3RhbXA6IGVyci50aW1lU3RhbXAsXG4gIH1cbn1cbiIsImltcG9ydCB7Y3JlYXRlUGFyc2VyLCB0eXBlIEV2ZW50U291cmNlTWVzc2FnZSwgdHlwZSBFdmVudFNvdXJjZVBhcnNlcn0gZnJvbSAnZXZlbnRzb3VyY2UtcGFyc2VyJ1xuXG5pbXBvcnQge0Vycm9yRXZlbnQsIGZsYXR0ZW5FcnJvciwgc3ludGF4RXJyb3J9IGZyb20gJy4vZXJyb3JzLmpzJ1xuaW1wb3J0IHR5cGUge1xuICBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QsXG4gIEV2ZW50U291cmNlRXZlbnRNYXAsXG4gIEV2ZW50U291cmNlRmV0Y2hJbml0LFxuICBFdmVudFNvdXJjZUluaXQsXG4gIEZldGNoTGlrZSxcbiAgRmV0Y2hMaWtlUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbi8qKlxuICogQW4gYEV2ZW50U291cmNlYCBpbnN0YW5jZSBvcGVucyBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0byBhbiBIVFRQIHNlcnZlciwgd2hpY2ggc2VuZHMgZXZlbnRzXG4gKiBpbiBgdGV4dC9ldmVudC1zdHJlYW1gIGZvcm1hdC4gVGhlIGNvbm5lY3Rpb24gcmVtYWlucyBvcGVuIHVudGlsIGNsb3NlZCBieSBjYWxsaW5nIGAuY2xvc2UoKWAuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnaHR0cHM6Ly9leGFtcGxlLmNvbS9zdHJlYW0nKVxuICogZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAqICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAqIH0pXG4gKiBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gKiAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2U6JywgZXZlbnQuZGF0YSlcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50U291cmNlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBDT05ORUNUSU5HID0gMCBhcyBjb25zdFxuXG4gIC8qKlxuICAgKiBSZWFkeVN0YXRlIHJlcHJlc2VudGluZyBhbiBFdmVudFNvdXJjZSBjb25uZWN0aW9uIHRoYXQgaXMgb3BlbiAoZWcgY29ubmVjdGVkKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgT1BFTiA9IDEgYXMgY29uc3RcblxuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIGNsb3NlZCAoZWcgZGlzY29ubmVjdGVkKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgQ0xPU0VEID0gMiBhcyBjb25zdFxuXG4gIC8qKlxuICAgKiBSZWFkeVN0YXRlIHJlcHJlc2VudGluZyBhbiBFdmVudFNvdXJjZSBjdXJyZW50bHkgdHJ5aW5nIHRvIGNvbm5lY3RcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVhZG9ubHkgQ09OTkVDVElORyA9IDAgYXMgY29uc3RcblxuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIG9wZW4gKGVnIGNvbm5lY3RlZClcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVhZG9ubHkgT1BFTiA9IDEgYXMgY29uc3RcblxuICAvKipcbiAgICogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY29ubmVjdGlvbiB0aGF0IGlzIGNsb3NlZCAoZWcgZGlzY29ubmVjdGVkKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZWFkb25seSBDTE9TRUQgPSAyIGFzIGNvbnN0XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIG9mIHRoaXMgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgY29ubmVjdGlvbi4gSXQgY2FuIGhhdmUgdGhlIHZhbHVlcyBkZXNjcmliZWQgYmVsb3cuXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvcmVhZHlTdGF0ZSlcbiAgICpcbiAgICogTm90ZTogdHlwZWQgYXMgYG51bWJlcmAgaW5zdGVhZCBvZiBgMCB8IDEgfCAyYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBgRXZlbnRTb3VyY2VgIGludGVyZmFjZSxcbiAgICogZGVmaW5lZCBpbiB0aGUgVHlwZVNjcmlwdCBgZG9tYCBsaWJyYXJ5LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJlYWR5U3RhdGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZHlTdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVSTCBwcm92aWRpbmcgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS91cmwpXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHB1YmxpYyBnZXQgdXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuI3VybC5ocmVmXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjcmVkZW50aWFscyBtb2RlIGZvciBjb25uZWN0aW9uIHJlcXVlc3RzIHRvIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0gaXMgc2V0IHRvIFwiaW5jbHVkZVwiLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL3dpdGhDcmVkZW50aWFscylcbiAgICovXG4gIHB1YmxpYyBnZXQgd2l0aENyZWRlbnRpYWxzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiN3aXRoQ3JlZGVudGlhbHNcbiAgfVxuXG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL2Vycm9yX2V2ZW50KSAqL1xuICBwdWJsaWMgZ2V0IG9uZXJyb3IoKTogKChldjogRXJyb3JFdmVudCkgPT4gdW5rbm93bikgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4jb25FcnJvclxuICB9XG4gIHB1YmxpYyBzZXQgb25lcnJvcih2YWx1ZTogKChldjogRXJyb3JFdmVudCkgPT4gdW5rbm93bikgfCBudWxsKSB7XG4gICAgdGhpcy4jb25FcnJvciA9IHZhbHVlXG4gIH1cblxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9tZXNzYWdlX2V2ZW50KSAqL1xuICBwdWJsaWMgZ2V0IG9ubWVzc2FnZSgpOiAoKGV2OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuI29uTWVzc2FnZVxuICB9XG4gIHB1YmxpYyBzZXQgb25tZXNzYWdlKHZhbHVlOiAoKGV2OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCkge1xuICAgIHRoaXMuI29uTWVzc2FnZSA9IHZhbHVlXG4gIH1cblxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9vcGVuX2V2ZW50KSAqL1xuICBwdWJsaWMgZ2V0IG9ub3BlbigpOiAoKGV2OiBFdmVudCkgPT4gdW5rbm93bikgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4jb25PcGVuXG4gIH1cbiAgcHVibGljIHNldCBvbm9wZW4odmFsdWU6ICgoZXY6IEV2ZW50KSA9PiB1bmtub3duKSB8IG51bGwpIHtcbiAgICB0aGlzLiNvbk9wZW4gPSB2YWx1ZVxuICB9XG5cbiAgb3ZlcnJpZGUgYWRkRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgRXZlbnRTb3VyY2VFdmVudE1hcD4oXG4gICAgdHlwZTogSyxcbiAgICBsaXN0ZW5lcjogKHRoaXM6IEV2ZW50U291cmNlLCBldjogRXZlbnRTb3VyY2VFdmVudE1hcFtLXSkgPT4gdW5rbm93bixcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkXG4gIG92ZXJyaWRlIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiAodGhpczogRXZlbnRTb3VyY2UsIGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24sXG4gICAgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgKTogdm9pZFxuICBvdmVycmlkZSBhZGRFdmVudExpc3RlbmVyKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCxcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkXG4gIG92ZXJyaWRlIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOlxuICAgICAgfCAoKHRoaXM6IEV2ZW50U291cmNlLCBldmVudDogTWVzc2FnZUV2ZW50KSA9PiB1bmtub3duKVxuICAgICAgfCBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbiA9IGxpc3RlbmVyIGFzICh0aGlzOiBFdmVudFNvdXJjZSwgZXZlbnQ6IEV2ZW50KSA9PiB1bmtub3duXG4gICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW4sIG9wdGlvbnMpXG4gIH1cblxuICBvdmVycmlkZSByZW1vdmVFdmVudExpc3RlbmVyPEsgZXh0ZW5kcyBrZXlvZiBFdmVudFNvdXJjZUV2ZW50TWFwPihcbiAgICB0eXBlOiBLLFxuICAgIGxpc3RlbmVyOiAodGhpczogRXZlbnRTb3VyY2UsIGV2OiBFdmVudFNvdXJjZUV2ZW50TWFwW0tdKSA9PiB1bmtub3duLFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICk6IHZvaWRcbiAgb3ZlcnJpZGUgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6ICh0aGlzOiBFdmVudFNvdXJjZSwgZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdW5rbm93bixcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEV2ZW50TGlzdGVuZXJPcHRpb25zLFxuICApOiB2b2lkXG4gIG92ZXJyaWRlIHJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICk6IHZvaWRcbiAgb3ZlcnJpZGUgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6XG4gICAgICB8ICgodGhpczogRXZlbnRTb3VyY2UsIGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24pXG4gICAgICB8IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QsXG4gICAgb3B0aW9ucz86IGJvb2xlYW4gfCBFdmVudExpc3RlbmVyT3B0aW9ucyxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgbGlzdGVuID0gbGlzdGVuZXIgYXMgKHRoaXM6IEV2ZW50U291cmNlLCBldmVudDogRXZlbnQpID0+IHVua25vd25cbiAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3Rlbiwgb3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nIHwgVVJMLCBldmVudFNvdXJjZUluaXREaWN0PzogRXZlbnRTb3VyY2VJbml0KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IG5ldyBVUkwodXJsLCBnZXRCYXNlVVJMKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVJMJylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IHN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQnKVxuICAgIH1cblxuICAgIHRoaXMuI3BhcnNlciA9IGNyZWF0ZVBhcnNlcih7XG4gICAgICBvbkV2ZW50OiB0aGlzLiNvbkV2ZW50LFxuICAgICAgb25SZXRyeTogdGhpcy4jb25SZXRyeUNoYW5nZSxcbiAgICB9KVxuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuQ09OTkVDVElOR1xuICAgIHRoaXMuI3JlY29ubmVjdEludGVydmFsID0gMzAwMFxuICAgIHRoaXMuI2ZldGNoID0gZXZlbnRTb3VyY2VJbml0RGljdD8uZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaFxuICAgIHRoaXMuI3dpdGhDcmVkZW50aWFscyA9IGV2ZW50U291cmNlSW5pdERpY3Q/LndpdGhDcmVkZW50aWFscyA/PyBmYWxzZVxuXG4gICAgdGhpcy4jY29ubmVjdCgpXG4gIH1cblxuICAvKipcbiAgICogQWJvcnRzIGFueSBpbnN0YW5jZXMgb2YgdGhlIGZldGNoIGFsZ29yaXRobSBzdGFydGVkIGZvciB0aGlzIEV2ZW50U291cmNlIG9iamVjdCwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFRC5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9jbG9zZSlcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuI3JlY29ubmVjdFRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy4jcmVjb25uZWN0VGltZXIpXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0VEKSByZXR1cm5cbiAgICBpZiAodGhpcy4jY29udHJvbGxlcikgdGhpcy4jY29udHJvbGxlci5hYm9ydCgpXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuQ0xPU0VEXG4gICAgdGhpcy4jY29udHJvbGxlciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gUFJJVkFURVMgRk9MTE9XXG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNyZWFkeVN0YXRlOiBudW1iZXJcblxuICAvKipcbiAgICogT3JpZ2luYWwgVVJMIHVzZWQgdG8gY29ubmVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBzdGF5IHRoZSBzYW1lIGV2ZW4gYWZ0ZXIgYSByZWRpcmVjdC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjdXJsOiBVUkxcblxuICAvKipcbiAgICogVGhlIGRlc3RpbmF0aW9uIFVSTCBhZnRlciBhIHJlZGlyZWN0LiBJcyByZXNldCBvbiByZWNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3JlZGlyZWN0VXJsOiBVUkwgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogV2hldGhlciB0byBpbmNsdWRlIGNyZWRlbnRpYWxzIGluIHRoZSByZXF1ZXN0XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3dpdGhDcmVkZW50aWFsczogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI2ZldGNoOiBGZXRjaExpa2VcblxuICAvKipcbiAgICogVGhlIHJlY29ubmVjdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNyZWNvbm5lY3RJbnRlcnZhbDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byBhbiBvbmdvaW5nIHJlY29ubmVjdCBhdHRlbXB0LCBpZiBhbnlcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjcmVjb25uZWN0VGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IGV2ZW50IElEIHNlZW4gYnkgdGhlIEV2ZW50U291cmNlLCB3aGljaCB3aWxsIGJlIHNlbnQgYXMgYExhc3QtRXZlbnQtSURgIGluIHRoZVxuICAgKiByZXF1ZXN0IGhlYWRlcnMgb24gYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjbGFzdEV2ZW50SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBBYm9ydENvbnRyb2xsZXIgaW5zdGFuY2UgdXNlZCB0byBhYm9ydCB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgYW4gRXZlbnRTb3VyY2UgcGFyc2VyIChgZXZlbnRzb3VyY2UtcGFyc2VyYCBucG0gbW9kdWxlKVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICNwYXJzZXI6IEV2ZW50U291cmNlUGFyc2VyXG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBjdXJyZW50IGVycm9yIGhhbmRsZXIsIGF0dGFjaGVkIHRocm91Z2ggYG9uZXJyb3JgIHByb3BlcnR5IGRpcmVjdGx5LlxuICAgKiBOb3RlIHRoYXQgYGFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywg4oCmKWAgd2lsbCBub3QgYmUgc3RvcmVkIGhlcmUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uRXJyb3I6ICgoZXY6IEVycm9yRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogSG9sZHMgdGhlIGN1cnJlbnQgbWVzc2FnZSBoYW5kbGVyLCBhdHRhY2hlZCB0aHJvdWdoIGBvbm1lc3NhZ2VgIHByb3BlcnR5IGRpcmVjdGx5LlxuICAgKiBOb3RlIHRoYXQgYGFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCDigKYpYCB3aWxsIG5vdCBiZSBzdG9yZWQgaGVyZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjb25NZXNzYWdlOiAoKGV2OiBNZXNzYWdlRXZlbnQpID0+IHVua25vd24pIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogSG9sZHMgdGhlIGN1cnJlbnQgb3BlbiBoYW5kbGVyLCBhdHRhY2hlZCB0aHJvdWdoIGBvbm9wZW5gIHByb3BlcnR5IGRpcmVjdGx5LlxuICAgKiBOb3RlIHRoYXQgYGFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCDigKYpYCB3aWxsIG5vdCBiZSBzdG9yZWQgaGVyZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjb25PcGVuOiAoKGV2OiBFdmVudCkgPT4gdW5rbm93bikgfCBudWxsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHRoZSBnaXZlbiBVUkwgYW5kIHN0YXJ0IHJlY2VpdmluZyBldmVudHNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjY29ubmVjdCgpIHtcbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gdGhpcy5DT05ORUNUSU5HXG4gICAgdGhpcy4jY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgLy8gQnJvd3NlciB0ZXN0cyBhcmUgZmFpbGluZyBpZiB3ZSBkaXJlY3RseSBjYWxsIGB0aGlzLiNmZXRjaCgpYCwgdGh1cyB0aGUgaW5kaXJlY3Rpb24uXG4gICAgY29uc3QgZmV0Y2ggPSB0aGlzLiNmZXRjaFxuICAgIGZldGNoKHRoaXMuI3VybCwgdGhpcy4jZ2V0UmVxdWVzdE9wdGlvbnMoKSlcbiAgICAgIC50aGVuKHRoaXMuI29uRmV0Y2hSZXNwb25zZSlcbiAgICAgIC5jYXRjaCh0aGlzLiNvbkZldGNoRXJyb3IpXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZmV0Y2ggcmVzcG9uc2VcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEZldGNoKGlzaCkgcmVzcG9uc2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjb25GZXRjaFJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlOiBGZXRjaExpa2VSZXNwb25zZSkgPT4ge1xuICAgIHRoaXMuI3BhcnNlci5yZXNldCgpXG5cbiAgICBjb25zdCB7Ym9keSwgcmVkaXJlY3RlZCwgc3RhdHVzLCBoZWFkZXJzfSA9IHJlc3BvbnNlXG5cbiAgICAvLyBbc3BlY10gYSBjbGllbnQgY2FuIGJlIHRvbGQgdG8gc3RvcCByZWNvbm5lY3RpbmcgdXNpbmcgdGhlIEhUVFAgMjA0IE5vIENvbnRlbnQgcmVzcG9uc2UgY29kZS5cbiAgICBpZiAoc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gZW1pdCBhbiBlcnJvciBldmVudCAtIHRoaXMgbWlycm9ycyB0aGUgYnJvd3NlciBiZWhhdmlvcixcbiAgICAgIC8vIGFuZCB3aXRob3V0IGl0IHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIHRoZSB1c2VyIHRoYXQgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZC5cbiAgICAgIHRoaXMuI2ZhaWxDb25uZWN0aW9uKCdTZXJ2ZXIgc2VudCBIVFRQIDIwNCwgbm90IHJlY29ubmVjdGluZycsIDIwNClcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gW3NwZWNdIOKApkV2ZW50IHN0cmVhbSByZXF1ZXN0cyBjYW4gYmUgcmVkaXJlY3RlZCB1c2luZyBIVFRQIDMwMSBhbmQgMzA3IHJlZGlyZWN0cyBhcyB3aXRoXG4gICAgLy8gW3NwZWNdIG5vcm1hbCBIVFRQIHJlcXVlc3RzLlxuICAgIC8vIFNwZWMgZG9lcyBub3Qgc2F5IGFueXRoaW5nIGFib3V0IG90aGVyIHJlZGlyZWN0IGNvZGVzICgzMDIsIDMwOCksIGJ1dCB0aGlzIHNlZW1zIGFuXG4gICAgLy8gdW5pbnRlbmRlZCBvbWlzc2lvbiwgcmF0aGVyIHRoYW4gYSBmZWF0dXJlLiBCcm93c2VycyB3aWxsIGhhcHBpbHkgcmVkaXJlY3Qgb24gb3RoZXIgM3h4cydzLlxuICAgIGlmIChyZWRpcmVjdGVkKSB7XG4gICAgICB0aGlzLiNyZWRpcmVjdFVybCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZWRpcmVjdFVybCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8vIFtzcGVjXSBpZiByZXMncyBzdGF0dXMgaXMgbm90IDIwMCwg4oCmLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aGlzLiNmYWlsQ29ubmVjdGlvbihgTm9uLTIwMCBzdGF0dXMgY29kZSAoJHtzdGF0dXN9KWAsIHN0YXR1cylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFtzcGVjXSDigKZvciBpZiByZXMncyBgQ29udGVudC1UeXBlYCBpcyBub3QgYHRleHQvZXZlbnQtc3RyZWFtYCwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gICAgaWYgKCFjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0L2V2ZW50LXN0cmVhbScpKSB7XG4gICAgICB0aGlzLiNmYWlsQ29ubmVjdGlvbignSW52YWxpZCBjb250ZW50IHR5cGUsIGV4cGVjdGVkIFwidGV4dC9ldmVudC1zdHJlYW1cIicsIHN0YXR1cylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFtzcGVjXSDigKZpZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGEgdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUTigKZcbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gdGhpcy5DTE9TRUQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFtzcGVjXSDigKZzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBPUEVOIGFuZCBmaXJlcyBhbiBldmVudFxuICAgIC8vIFtzcGVjXSDigKZuYW1lZCBvcGVuIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuT1BFTlxuXG4gICAgY29uc3Qgb3BlbkV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJylcbiAgICB0aGlzLiNvbk9wZW4/LihvcGVuRXZlbnQpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG9wZW5FdmVudClcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSByZXNwb25zZSBzdHJlYW0gaXMgYSB3ZWIgc3RyZWFtXG4gICAgaWYgKHR5cGVvZiBib2R5ICE9PSAnb2JqZWN0JyB8fCAhYm9keSB8fCAhKCdnZXRSZWFkZXInIGluIGJvZHkpKSB7XG4gICAgICB0aGlzLiNmYWlsQ29ubmVjdGlvbignSW52YWxpZCByZXNwb25zZSBib2R5LCBleHBlY3RlZCBhIHdlYiBSZWFkYWJsZVN0cmVhbScsIHN0YXR1cylcbiAgICAgIHRoaXMuY2xvc2UoKSAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBgZmV0Y2hgIHByb3ZpZGVkIGlzIFwiZmF1bHR5XCIgLSBkb24ndCByZWNvbm5lY3RcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4gICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKVxuICAgIGxldCBvcGVuID0gdHJ1ZVxuXG4gICAgZG8ge1xuICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNwYXJzZXIuZmVlZChkZWNvZGVyLmRlY29kZSh2YWx1ZSwge3N0cmVhbTogIWRvbmV9KSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIG9wZW4gPSBmYWxzZVxuICAgICAgdGhpcy4jcGFyc2VyLnJlc2V0KClcblxuICAgICAgdGhpcy4jc2NoZWR1bGVSZWNvbm5lY3QoKVxuICAgIH0gd2hpbGUgKG9wZW4pXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyByZWplY3RlZCByZXF1ZXN0cyBmb3IgdGhlIEV2ZW50U291cmNlIGVuZHBvaW50XG4gICAqXG4gICAqIEBwYXJhbSBlcnIgLSBUaGUgZXJyb3IgZnJvbSBgZmV0Y2goKWBcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjb25GZXRjaEVycm9yID0gKGVycjogRXJyb3IgJiB7dHlwZT86IHN0cmluZ30pID0+IHtcbiAgICB0aGlzLiNjb250cm9sbGVyID0gdW5kZWZpbmVkXG5cbiAgICAvLyBXZSBleHBlY3QgYWJvcnQgZXJyb3JzIHdoZW4gdGhlIHVzZXIgbWFudWFsbHkgY2FsbHMgYGNsb3NlKClgIC0gaWdub3JlIHRob3NlXG4gICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyLnR5cGUgPT09ICdhYm9ydGVkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jc2NoZWR1bGVSZWNvbm5lY3QoZmxhdHRlbkVycm9yKGVycikpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIGBmZXRjaCgpYCByZXF1ZXN0XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjZ2V0UmVxdWVzdE9wdGlvbnMoKTogRXZlbnRTb3VyY2VGZXRjaEluaXQge1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IHRoaXMuI2xhc3RFdmVudElkID8geydMYXN0LUV2ZW50LUlEJzogdGhpcy4jbGFzdEV2ZW50SWR9IDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBpbml0OiBFdmVudFNvdXJjZUZldGNoSW5pdCA9IHtcbiAgICAgIC8vIFtzcGVjXSBMZXQgYGNvcnNBdHRyaWJ1dGVTdGF0ZWAgYmUgYEFub255bW91c2DigKZcbiAgICAgIC8vIFtzcGVjXSDigKZ3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCLigKZcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIGhlYWRlcnM6IHtBY2NlcHQ6ICd0ZXh0L2V2ZW50LXN0cmVhbScsIC4uLmxhc3RFdmVudH0sXG4gICAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICAgIHNpZ25hbDogdGhpcy4jY29udHJvbGxlcj8uc2lnbmFsLFxuICAgIH1cblxuICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIGNyYXNoIGlmIGF0dGVtcHRpbmcgdG8gc2V0IGBjcmVkZW50aWFsc2Agd2hlcmUgaXQgaXMgbm90IHN1cHBvcnRlZCxcbiAgICAvLyBlZyBvbiBDbG91ZGZsYXJlIFdvcmtlcnMuIFRvIGF2b2lkIHRoaXMsIHdlIG9ubHkgc2V0IGl0IGluIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKCd3aW5kb3cnIGluIGdsb2JhbFRoaXMpIHtcbiAgICAgIC8vIFtzcGVjXSDigKZhbmQgdGhlaXIgY3JlZGVudGlhbHMgbW9kZSBzZXQgdG8gXCJzYW1lLW9yaWdpblwiXG4gICAgICAvLyBbc3BlY10g4oCmaWYgdGhlIGB3aXRoQ3JlZGVudGlhbHNgIGF0dHJpYnV0ZSBpcyBgdHJ1ZWAsIHNldCB0aGUgY3JlZGVudGlhbHMgbW9kZSB0byBcImluY2x1ZGVcIuKAplxuICAgICAgaW5pdC5jcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJ1xuICAgIH1cblxuICAgIHJldHVybiBpbml0XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGJ5IEV2ZW50U291cmNlUGFyc2VyIGluc3RhbmNlIHdoZW4gYW4gZXZlbnQgaGFzIHN1Y2Nlc3NmdWxseSBiZWVuIHBhcnNlZFxuICAgKiBhbmQgaXMgcmVhZHkgdG8gYmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcGFyc2VkIGV2ZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uRXZlbnQgPSAoZXZlbnQ6IEV2ZW50U291cmNlTWVzc2FnZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLiNsYXN0RXZlbnRJZCA9IGV2ZW50LmlkXG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChldmVudC5ldmVudCB8fCAnbWVzc2FnZScsIHtcbiAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICBvcmlnaW46IHRoaXMuI3JlZGlyZWN0VXJsID8gdGhpcy4jcmVkaXJlY3RVcmwub3JpZ2luIDogdGhpcy4jdXJsLm9yaWdpbixcbiAgICAgIGxhc3RFdmVudElkOiBldmVudC5pZCB8fCAnJyxcbiAgICB9KVxuXG4gICAgLy8gVGhlIGBvbm1lc3NhZ2VgIHByb3BlcnR5IG9mIHRoZSBFdmVudFNvdXJjZSBpbnN0YW5jZSBvbmx5IHRyaWdnZXJzIG9uIG1lc3NhZ2VzIHdpdGhvdXQgYW5cbiAgICAvLyBgZXZlbnRgIGZpZWxkLCBvciBvbmVzIHRoYXQgZXhwbGljaXRseSBzZXQgYG1lc3NhZ2VgLlxuICAgIGlmICh0aGlzLiNvbk1lc3NhZ2UgJiYgKCFldmVudC5ldmVudCB8fCBldmVudC5ldmVudCA9PT0gJ21lc3NhZ2UnKSkge1xuICAgICAgdGhpcy4jb25NZXNzYWdlKG1lc3NhZ2VFdmVudClcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobWVzc2FnZUV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBFdmVudFNvdXJjZVBhcnNlciBpbnN0YW5jZSB3aGVuIGEgbmV3IHJlY29ubmVjdGlvbiBpbnRlcnZhbCBpcyByZWNlaXZlZFxuICAgKiBmcm9tIHRoZSBFdmVudFNvdXJjZSBlbmRwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG5ldyByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI29uUmV0cnlDaGFuZ2UgPSAodmFsdWU6IG51bWJlcikgPT4ge1xuICAgIHRoaXMuI3JlY29ubmVjdEludGVydmFsID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBwcm9jZXNzIHJlZmVycmVkIHRvIGluIHRoZSBFdmVudFNvdXJjZSBzcGVjaWZpY2F0aW9uIGFzIFwiZmFpbGluZyBhIGNvbm5lY3Rpb25cIi5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGNhdXNpbmcgdGhlIGNvbm5lY3Rpb24gdG8gZmFpbFxuICAgKiBAcGFyYW0gY29kZSAtIFRoZSBIVFRQIHN0YXR1cyBjb2RlLCBpZiBhdmFpbGFibGVcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjZmFpbENvbm5lY3Rpb24obWVzc2FnZT86IHN0cmluZywgY29kZT86IG51bWJlcikge1xuICAgIC8vIFtzcGVjXSDigKZpZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGEgdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUQsXG4gICAgLy8gW3NwZWNdIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFROKAplxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlICE9PSB0aGlzLkNMT1NFRCkge1xuICAgICAgdGhpcy4jcmVhZHlTdGF0ZSA9IHRoaXMuQ0xPU0VEXG4gICAgfVxuXG4gICAgLy8gW3NwZWNdIOKApmFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBgZXJyb3JgIGF0IHRoZSBgRXZlbnRTb3VyY2VgIG9iamVjdC5cbiAgICAvLyBbc3BlY10gT25jZSB0aGUgdXNlciBhZ2VudCBoYXMgZmFpbGVkIHRoZSBjb25uZWN0aW9uLCBpdCBkb2VzIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdC5cbiAgICAvLyBbc3BlY10gPiBJbXBsZW1lbnRhdGlvbnMgYXJlIGVzcGVjaWFsbHkgZW5jb3VyYWdlZCB0byByZXBvcnQgZGV0YWlsZWQgaW5mb3JtYXRpb25cbiAgICAvLyBbc3BlY10gPiB0byB0aGVpciBkZXZlbG9wbWVudCBjb25zb2xlcyB3aGVuZXZlciBhbiBlcnJvciBldmVudCBpcyBmaXJlZCwgc2luY2UgbGl0dGxlXG4gICAgLy8gW3NwZWNdID4gdG8gbm8gaW5mb3JtYXRpb24gY2FuIGJlIG1hZGUgYXZhaWxhYmxlIGluIHRoZSBldmVudHMgdGhlbXNlbHZlcy5cbiAgICAvLyBQcmludGluZyB0byBjb25zb2xlIGlzIG5vdCB2ZXJ5IHByb2dyYW1hdGljYWxseSBoZWxwZnVsLCB0aG91Z2gsIHNvIHdlIGVtaXQgYSBjdXN0b20gZXZlbnQuXG4gICAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtjb2RlLCBtZXNzYWdlfSlcblxuICAgIHRoaXMuI29uRXJyb3I/LihlcnJvckV2ZW50KVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGFnYWluc3QgdGhlIEV2ZW50U291cmNlIGVuZHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBjYXVzaW5nIHRoZSBjb25uZWN0aW9uIHRvIGZhaWxcbiAgICogQHBhcmFtIGNvZGUgLSBUaGUgSFRUUCBzdGF0dXMgY29kZSwgaWYgYXZhaWxhYmxlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgI3NjaGVkdWxlUmVjb25uZWN0KG1lc3NhZ2U/OiBzdHJpbmcsIGNvZGU/OiBudW1iZXIpIHtcbiAgICAvLyBbc3BlY10gSWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBDTE9TRUQsIGFib3J0IHRoZSB0YXNrLlxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSB0aGlzLkNMT1NFRCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gW3NwZWNdIFNldCB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ09OTkVDVElORy5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gdGhpcy5DT05ORUNUSU5HXG5cbiAgICAvLyBbc3BlY10gRmlyZSBhbiBldmVudCBuYW1lZCBgZXJyb3JgIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtjb2RlLCBtZXNzYWdlfSlcbiAgICB0aGlzLiNvbkVycm9yPy4oZXJyb3JFdmVudClcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudClcblxuICAgIC8vIFtzcGVjXSBXYWl0IGEgZGVsYXkgZXF1YWwgdG8gdGhlIHJlY29ubmVjdGlvbiB0aW1lIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gICAgdGhpcy4jcmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuI3JlY29ubmVjdCwgdGhpcy4jcmVjb25uZWN0SW50ZXJ2YWwpXG4gIH1cblxuICAvKipcbiAgICogUmVjb25uZWN0cyB0byB0aGUgRXZlbnRTb3VyY2UgZW5kcG9pbnQgYWZ0ZXIgYSBkaXNjb25uZWN0L2ZhaWx1cmVcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICAjcmVjb25uZWN0ID0gKCkgPT4ge1xuICAgIHRoaXMuI3JlY29ubmVjdFRpbWVyID0gdW5kZWZpbmVkXG5cbiAgICAvLyBbc3BlY10gSWYgdGhlIEV2ZW50U291cmNlJ3MgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgbm90IHNldCB0byBDT05ORUNUSU5HLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSAhPT0gdGhpcy5DT05ORUNUSU5HKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxufVxuXG4vKipcbiAqIEFjY29yZGluZyB0byBzcGVjLCB3aGVuIGNvbnN0cnVjdGluZyBhIFVSTDpcbiAqID4gMS4gTGV0IGJhc2VVUkwgYmUgZW52aXJvbm1lbnQncyBiYXNlIFVSTCwgaWYgZW52aXJvbm1lbnQgaXMgYSBEb2N1bWVudCBvYmplY3RcbiAqID4gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFVSTCBwYXJzZXIgdG8gdXJsLCB3aXRoIGJhc2VVUkwuXG4gKlxuICogVGh1cyB3ZSBzaG91bGQgdXNlIGBkb2N1bWVudC5iYXNlVVJJYCBpZiBhdmFpbGFibGUsIHNpbmNlIGl0IGNhbiBiZSBzZXQgdGhyb3VnaCBhIGJhc2UgdGFnLlxuICpcbiAqIEByZXR1cm5zIFRoZSBiYXNlIFVSTCwgaWYgYXZhaWxhYmxlIC0gb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVSTCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBkb2MgPSAnZG9jdW1lbnQnIGluIGdsb2JhbFRoaXMgPyAoZ2xvYmFsVGhpcyBhcyBhbnkpLmRvY3VtZW50IDogdW5kZWZpbmVkXG4gIHJldHVybiBkb2MgJiYgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCcgJiYgJ2Jhc2VVUkknIGluIGRvYyAmJiB0eXBlb2YgZG9jLmJhc2VVUkkgPT09ICdzdHJpbmcnXG4gICAgPyBkb2MuYmFzZVVSSVxuICAgIDogdW5kZWZpbmVkXG59XG4iLCJjbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSksIHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiLCB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUsIHRoaXMuZmllbGQgPSBvcHRpb25zLmZpZWxkLCB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZSwgdGhpcy5saW5lID0gb3B0aW9ucy5saW5lO1xuICB9XG59XG5mdW5jdGlvbiBub29wKF9hcmcpIHtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihjYWxsYmFja3MpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcImBjYWxsYmFja3NgIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgYSBmdW5jdGlvbiBpbnN0ZWFkLiBEaWQgeW91IG1lYW4gYHtvbkV2ZW50OiBmbn1gP1wiXG4gICAgKTtcbiAgY29uc3QgeyBvbkV2ZW50ID0gbm9vcCwgb25FcnJvciA9IG5vb3AsIG9uUmV0cnkgPSBub29wLCBvbkNvbW1lbnQgfSA9IGNhbGxiYWNrcztcbiAgbGV0IGluY29tcGxldGVMaW5lID0gXCJcIiwgaXNGaXJzdENodW5rID0gITAsIGlkLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIjtcbiAgZnVuY3Rpb24gZmVlZChuZXdDaHVuaykge1xuICAgIGNvbnN0IGNodW5rID0gaXNGaXJzdENodW5rID8gbmV3Q2h1bmsucmVwbGFjZSgvXlxceEVGXFx4QkJcXHhCRi8sIFwiXCIpIDogbmV3Q2h1bmssIFtjb21wbGV0ZSwgaW5jb21wbGV0ZV0gPSBzcGxpdExpbmVzKGAke2luY29tcGxldGVMaW5lfSR7Y2h1bmt9YCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbXBsZXRlKVxuICAgICAgcGFyc2VMaW5lKGxpbmUpO1xuICAgIGluY29tcGxldGVMaW5lID0gaW5jb21wbGV0ZSwgaXNGaXJzdENodW5rID0gITE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmUpIHtcbiAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgZGlzcGF0Y2hFdmVudCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgICAgb25Db21tZW50ICYmIG9uQ29tbWVudChsaW5lLnNsaWNlKGxpbmUuc3RhcnRzV2l0aChcIjogXCIpID8gMiA6IDEpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmllbGRTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGZpZWxkU2VwYXJhdG9ySW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgZmllbGRTZXBhcmF0b3JJbmRleCksIG9mZnNldCA9IGxpbmVbZmllbGRTZXBhcmF0b3JJbmRleCArIDFdID09PSBcIiBcIiA/IDIgOiAxLCB2YWx1ZSA9IGxpbmUuc2xpY2UoZmllbGRTZXBhcmF0b3JJbmRleCArIG9mZnNldCk7XG4gICAgICBwcm9jZXNzRmllbGQoZmllbGQsIHZhbHVlLCBsaW5lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzc0ZpZWxkKGxpbmUsIFwiXCIsIGxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChmaWVsZCwgdmFsdWUsIGxpbmUpIHtcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgZXZlbnRUeXBlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgZGF0YSA9IGAke2RhdGF9JHt2YWx1ZX1cbmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGlkID0gdmFsdWUuaW5jbHVkZXMoXCJcXDBcIikgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmV0cnlcIjpcbiAgICAgICAgL15cXGQrJC8udGVzdCh2YWx1ZSkgPyBvblJldHJ5KHBhcnNlSW50KHZhbHVlLCAxMCkpIDogb25FcnJvcihcbiAgICAgICAgICBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBcXGByZXRyeVxcYCB2YWx1ZTogXCIke3ZhbHVlfVwiYCwge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkLXJldHJ5XCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBmaWVsZCBcIiR7ZmllbGQubGVuZ3RoID4gMjAgPyBgJHtmaWVsZC5zbGljZSgwLCAyMCl9XFx1MjAyNmAgOiBmaWVsZH1cImAsXG4gICAgICAgICAgICB7IHR5cGU6IFwidW5rbm93bi1maWVsZFwiLCBmaWVsZCwgdmFsdWUsIGxpbmUgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgZGF0YS5sZW5ndGggPiAwICYmIG9uRXZlbnQoe1xuICAgICAgaWQsXG4gICAgICBldmVudDogZXZlbnRUeXBlIHx8IHZvaWQgMCxcbiAgICAgIC8vIElmIHRoZSBkYXRhIGJ1ZmZlcidzIGxhc3QgY2hhcmFjdGVyIGlzIGEgVSswMDBBIExJTkUgRkVFRCAoTEYpIGNoYXJhY3RlcixcbiAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBmcm9tIHRoZSBkYXRhIGJ1ZmZlci5cbiAgICAgIGRhdGE6IGRhdGEuZW5kc1dpdGgoYFxuYCkgPyBkYXRhLnNsaWNlKDAsIC0xKSA6IGRhdGFcbiAgICB9KSwgaWQgPSB2b2lkIDAsIGRhdGEgPSBcIlwiLCBldmVudFR5cGUgPSBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KG9wdGlvbnMgPSB7fSkge1xuICAgIGluY29tcGxldGVMaW5lICYmIG9wdGlvbnMuY29uc3VtZSAmJiBwYXJzZUxpbmUoaW5jb21wbGV0ZUxpbmUpLCBpc0ZpcnN0Q2h1bmsgPSAhMCwgaWQgPSB2b2lkIDAsIGRhdGEgPSBcIlwiLCBldmVudFR5cGUgPSBcIlwiLCBpbmNvbXBsZXRlTGluZSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHsgZmVlZCwgcmVzZXQgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGluY29tcGxldGVMaW5lID0gXCJcIiwgc2VhcmNoSW5kZXggPSAwO1xuICBmb3IgKDsgc2VhcmNoSW5kZXggPCBjaHVuay5sZW5ndGg7ICkge1xuICAgIGNvbnN0IGNySW5kZXggPSBjaHVuay5pbmRleE9mKFwiXFxyXCIsIHNlYXJjaEluZGV4KSwgbGZJbmRleCA9IGNodW5rLmluZGV4T2YoYFxuYCwgc2VhcmNoSW5kZXgpO1xuICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgaWYgKGNySW5kZXggIT09IC0xICYmIGxmSW5kZXggIT09IC0xID8gbGluZUVuZCA9IE1hdGgubWluKGNySW5kZXgsIGxmSW5kZXgpIDogY3JJbmRleCAhPT0gLTEgPyBjckluZGV4ID09PSBjaHVuay5sZW5ndGggLSAxID8gbGluZUVuZCA9IC0xIDogbGluZUVuZCA9IGNySW5kZXggOiBsZkluZGV4ICE9PSAtMSAmJiAobGluZUVuZCA9IGxmSW5kZXgpLCBsaW5lRW5kID09PSAtMSkge1xuICAgICAgaW5jb21wbGV0ZUxpbmUgPSBjaHVuay5zbGljZShzZWFyY2hJbmRleCk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGluZSA9IGNodW5rLnNsaWNlKHNlYXJjaEluZGV4LCBsaW5lRW5kKTtcbiAgICAgIGxpbmVzLnB1c2gobGluZSksIHNlYXJjaEluZGV4ID0gbGluZUVuZCArIDEsIGNodW5rW3NlYXJjaEluZGV4IC0gMV0gPT09IFwiXFxyXCIgJiYgY2h1bmtbc2VhcmNoSW5kZXhdID09PSBgXG5gICYmIHNlYXJjaEluZGV4Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbGluZXMsIGluY29tcGxldGVMaW5lXTtcbn1cbmV4cG9ydCB7XG4gIFBhcnNlRXJyb3IsXG4gIGNyZWF0ZVBhcnNlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyoqXG4gKiBUaGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBFcnJvclR5cGUgPSAnaW52YWxpZC1yZXRyeScgfCAndW5rbm93bi1maWVsZCdcblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBlbmNvdW50ZXJpbmcgYW4gaXNzdWUgZHVyaW5nIHBhcnNpbmcuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gICAqL1xuICB0eXBlOiBFcnJvclR5cGVcblxuICAvKipcbiAgICogSW4gdGhlIGNhc2Ugb2YgYW4gdW5rbm93biBmaWVsZCBlbmNvdW50ZXJlZCBpbiB0aGUgc3RyZWFtLCB0aGlzIHdpbGwgYmUgdGhlIGZpZWxkIG5hbWUuXG4gICAqL1xuICBmaWVsZD86IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBJbiB0aGUgY2FzZSBvZiBhbiB1bmtub3duIGZpZWxkIGVuY291bnRlcmVkIGluIHRoZSBzdHJlYW0sIHRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLlxuICAgKi9cbiAgdmFsdWU/OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogVGhlIGxpbmUgdGhhdCBjYXVzZWQgdGhlIGVycm9yLCBpZiBhdmFpbGFibGUuXG4gICAqL1xuICBsaW5lPzogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHt0eXBlOiBFcnJvclR5cGU7IGZpZWxkPzogc3RyaW5nOyB2YWx1ZT86IHN0cmluZzsgbGluZT86IHN0cmluZ30sXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InXG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlXG4gICAgdGhpcy5maWVsZCA9IG9wdGlvbnMuZmllbGRcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZVxuICAgIHRoaXMubGluZSA9IG9wdGlvbnMubGluZVxuICB9XG59XG4iLCIvKipcbiAqIEV2ZW50U291cmNlL1NlcnZlci1TZW50IEV2ZW50cyBwYXJzZXJcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWxcbiAqL1xuaW1wb3J0IHtQYXJzZUVycm9yfSBmcm9tICcuL2Vycm9ycy50cydcbmltcG9ydCB0eXBlIHtFdmVudFNvdXJjZVBhcnNlciwgUGFyc2VyQ2FsbGJhY2tzfSBmcm9tICcuL3R5cGVzLnRzJ1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiBub29wKF9hcmc6IHVua25vd24pIHtcbiAgLy8gaW50ZW50aW9uYWwgbm9vcFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2UgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFja3MgLSBDYWxsYmFja3MgdG8gaW52b2tlIG9uIGRpZmZlcmVudCBwYXJzaW5nIGV2ZW50czpcbiAqICAgLSBgb25FdmVudGAgd2hlbiBhIG5ldyBldmVudCBpcyBwYXJzZWRcbiAqICAgLSBgb25FcnJvcmAgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAqICAgLSBgb25SZXRyeWAgd2hlbiBhIG5ldyByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaGFzIGJlZW4gc2VudCBmcm9tIHRoZSBzZXJ2ZXJcbiAqICAgLSBgb25Db21tZW50YCB3aGVuIGEgY29tbWVudCBpcyBlbmNvdW50ZXJlZCBpbiB0aGUgc3RyZWFtXG4gKlxuICogQHJldHVybnMgQSBuZXcgRXZlbnRTb3VyY2UgcGFyc2VyLCB3aXRoIGBwYXJzZWAgYW5kIGByZXNldGAgbWV0aG9kcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihjYWxsYmFja3M6IFBhcnNlckNhbGxiYWNrcyk6IEV2ZW50U291cmNlUGFyc2VyIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ2BjYWxsYmFja3NgIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgYSBmdW5jdGlvbiBpbnN0ZWFkLiBEaWQgeW91IG1lYW4gYHtvbkV2ZW50OiBmbn1gPycsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qge29uRXZlbnQgPSBub29wLCBvbkVycm9yID0gbm9vcCwgb25SZXRyeSA9IG5vb3AsIG9uQ29tbWVudH0gPSBjYWxsYmFja3NcblxuICBsZXQgaW5jb21wbGV0ZUxpbmUgPSAnJ1xuXG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlXG4gIGxldCBpZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGxldCBkYXRhID0gJydcbiAgbGV0IGV2ZW50VHlwZSA9ICcnXG5cbiAgZnVuY3Rpb24gZmVlZChuZXdDaHVuazogc3RyaW5nKSB7XG4gICAgLy8gU3RyaXAgYW55IFVURjggYnl0ZSBvcmRlciBtYXJrIChCT00pIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyZWFtXG4gICAgY29uc3QgY2h1bmsgPSBpc0ZpcnN0Q2h1bmsgPyBuZXdDaHVuay5yZXBsYWNlKC9eXFx4RUZcXHhCQlxceEJGLywgJycpIDogbmV3Q2h1bmtcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGluY29tcGxldGUgbGluZSwgYXBwZW5kIGl0IHRvIHRoZSBuZXcgY2h1bmssXG4gICAgLy8gc28gd2UgbWF5IHByb2Nlc3MgaXQgdG9nZXRoZXIgYXMgYSBuZXcgKGhvcGVmdWxseSBjb21wbGV0ZSkgY2h1bmsuXG4gICAgY29uc3QgW2NvbXBsZXRlLCBpbmNvbXBsZXRlXSA9IHNwbGl0TGluZXMoYCR7aW5jb21wbGV0ZUxpbmV9JHtjaHVua31gKVxuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbXBsZXRlKSB7XG4gICAgICBwYXJzZUxpbmUobGluZSlcbiAgICB9XG5cbiAgICBpbmNvbXBsZXRlTGluZSA9IGluY29tcGxldGVcbiAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmU6IHN0cmluZykge1xuICAgIC8vIElmIHRoZSBsaW5lIGlzIGVtcHR5IChhIGJsYW5rIGxpbmUpLCBkaXNwYXRjaCB0aGUgZXZlbnRcbiAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KSwgaWdub3JlIHRoZSBsaW5lLlxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgaWYgKG9uQ29tbWVudCkge1xuICAgICAgICBvbkNvbW1lbnQobGluZS5zbGljZShsaW5lLnN0YXJ0c1dpdGgoJzogJykgPyAyIDogMSkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbGluZSBjb250YWlucyBhIFUrMDAzQSBDT0xPTiBjaGFyYWN0ZXIgKDopXG4gICAgY29uc3QgZmllbGRTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZignOicpXG4gICAgaWYgKGZpZWxkU2VwYXJhdG9ySW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBDb2xsZWN0IHRoZSBjaGFyYWN0ZXJzIG9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgZmlyc3QgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOiksXG4gICAgICAvLyBhbmQgbGV0IGBmaWVsZGAgYmUgdGhhdCBzdHJpbmcuXG4gICAgICBjb25zdCBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgZmllbGRTZXBhcmF0b3JJbmRleClcblxuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBhZnRlciB0aGUgZmlyc3QgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOiksXG4gICAgICAvLyBhbmQgbGV0IGB2YWx1ZWAgYmUgdGhhdCBzdHJpbmcuIElmIHZhbHVlIHN0YXJ0cyB3aXRoIGEgVSswMDIwIFNQQUNFIGNoYXJhY3RlcixcbiAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHZhbHVlLlxuICAgICAgY29uc3Qgb2Zmc2V0ID0gbGluZVtmaWVsZFNlcGFyYXRvckluZGV4ICsgMV0gPT09ICcgJyA/IDIgOiAxXG4gICAgICBjb25zdCB2YWx1ZSA9IGxpbmUuc2xpY2UoZmllbGRTZXBhcmF0b3JJbmRleCArIG9mZnNldClcblxuICAgICAgcHJvY2Vzc0ZpZWxkKGZpZWxkLCB2YWx1ZSwgbGluZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdGhlIHN0cmluZyBpcyBub3QgZW1wdHkgYnV0IGRvZXMgbm90IGNvbnRhaW4gYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIC8vIFByb2Nlc3MgdGhlIGZpZWxkIHVzaW5nIHRoZSB3aG9sZSBsaW5lIGFzIHRoZSBmaWVsZCBuYW1lLCBhbmQgYW4gZW1wdHkgc3RyaW5nIGFzIHRoZSBmaWVsZCB2YWx1ZS5cbiAgICAvLyDwn5GGIFRoaXMgaXMgYWNjb3JkaW5nIHRvIHNwZWMuIFRoYXQgbWVhbnMgdGhhdCBhIGxpbmUgdGhhdCBoYXMgdGhlIHZhbHVlIGBkYXRhYCB3aWxsIHJlc3VsdCBpblxuICAgIC8vIGEgbmV3bGluZSBiZWluZyBhZGRlZCB0byB0aGUgY3VycmVudCBgZGF0YWAgYnVmZmVyLCBmb3IgaW5zdGFuY2UuXG4gICAgcHJvY2Vzc0ZpZWxkKGxpbmUsICcnLCBsaW5lKVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZpZWxkKGZpZWxkOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGxpbmU6IHN0cmluZykge1xuICAgIC8vIEZpZWxkIG5hbWVzIG11c3QgYmUgY29tcGFyZWQgbGl0ZXJhbGx5LCB3aXRoIG5vIGNhc2UgZm9sZGluZyBwZXJmb3JtZWQuXG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAvLyBTZXQgdGhlIGBldmVudCB0eXBlYCBidWZmZXIgdG8gZmllbGQgdmFsdWVcbiAgICAgICAgZXZlbnRUeXBlID0gdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAvLyBBcHBlbmQgdGhlIGZpZWxkIHZhbHVlIHRvIHRoZSBgZGF0YWAgYnVmZmVyLCB0aGVuIGFwcGVuZCBhIHNpbmdsZSBVKzAwMEEgTElORSBGRUVEKExGKVxuICAgICAgICAvLyBjaGFyYWN0ZXIgdG8gdGhlIGBkYXRhYCBidWZmZXIuXG4gICAgICAgIGRhdGEgPSBgJHtkYXRhfSR7dmFsdWV9XFxuYFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAvLyBJZiB0aGUgZmllbGQgdmFsdWUgZG9lcyBub3QgY29udGFpbiBVKzAwMDAgTlVMTCwgdGhlbiBzZXQgdGhlIGBJRGAgYnVmZmVyIHRvXG4gICAgICAgIC8vIHRoZSBmaWVsZCB2YWx1ZS4gT3RoZXJ3aXNlLCBpZ25vcmUgdGhlIGZpZWxkLlxuICAgICAgICBpZCA9IHZhbHVlLmluY2x1ZGVzKCdcXDAnKSA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB2YWx1ZSBjb25zaXN0cyBvZiBvbmx5IEFTQ0lJIGRpZ2l0cywgdGhlbiBpbnRlcnByZXQgdGhlIGZpZWxkIHZhbHVlIGFzIGFuXG4gICAgICAgIC8vIGludGVnZXIgaW4gYmFzZSB0ZW4sIGFuZCBzZXQgdGhlIGV2ZW50IHN0cmVhbSdzIHJlY29ubmVjdGlvbiB0aW1lIHRvIHRoYXQgaW50ZWdlci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZ25vcmUgdGhlIGZpZWxkLlxuICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBvblJldHJ5KHBhcnNlSW50KHZhbHVlLCAxMCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25FcnJvcihcbiAgICAgICAgICAgIG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIFxcYHJldHJ5XFxgIHZhbHVlOiBcIiR7dmFsdWV9XCJgLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdpbnZhbGlkLXJldHJ5JyxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGZpZWxkIGlzIGlnbm9yZWQuXG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBmaWVsZCBcIiR7ZmllbGQubGVuZ3RoID4gMjAgPyBgJHtmaWVsZC5zbGljZSgwLCAyMCl94oCmYCA6IGZpZWxkfVwiYCxcbiAgICAgICAgICAgIHt0eXBlOiAndW5rbm93bi1maWVsZCcsIGZpZWxkLCB2YWx1ZSwgbGluZX0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgY29uc3Qgc2hvdWxkRGlzcGF0Y2ggPSBkYXRhLmxlbmd0aCA+IDBcbiAgICBpZiAoc2hvdWxkRGlzcGF0Y2gpIHtcbiAgICAgIG9uRXZlbnQoe1xuICAgICAgICBpZCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50VHlwZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIC8vIElmIHRoZSBkYXRhIGJ1ZmZlcidzIGxhc3QgY2hhcmFjdGVyIGlzIGEgVSswMDBBIExJTkUgRkVFRCAoTEYpIGNoYXJhY3RlcixcbiAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGZyb20gdGhlIGRhdGEgYnVmZmVyLlxuICAgICAgICBkYXRhOiBkYXRhLmVuZHNXaXRoKCdcXG4nKSA/IGRhdGEuc2xpY2UoMCwgLTEpIDogZGF0YSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGV2ZW50XG4gICAgaWQgPSB1bmRlZmluZWRcbiAgICBkYXRhID0gJydcbiAgICBldmVudFR5cGUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQob3B0aW9uczoge2NvbnN1bWU/OiBib29sZWFufSA9IHt9KSB7XG4gICAgaWYgKGluY29tcGxldGVMaW5lICYmIG9wdGlvbnMuY29uc3VtZSkge1xuICAgICAgcGFyc2VMaW5lKGluY29tcGxldGVMaW5lKVxuICAgIH1cblxuICAgIGlzRmlyc3RDaHVuayA9IHRydWVcbiAgICBpZCA9IHVuZGVmaW5lZFxuICAgIGRhdGEgPSAnJ1xuICAgIGV2ZW50VHlwZSA9ICcnXG4gICAgaW5jb21wbGV0ZUxpbmUgPSAnJ1xuICB9XG5cbiAgcmV0dXJuIHtmZWVkLCByZXNldH1cbn1cblxuLyoqXG4gKiBGb3IgdGhlIGdpdmVuIGBjaHVua2AsIHNwbGl0IGl0IGludG8gbGluZXMgYWNjb3JkaW5nIHRvIHNwZWMsIGFuZCByZXR1cm4gYW55IHJlbWFpbmluZyBpbmNvbXBsZXRlIGxpbmUuXG4gKlxuICogQHBhcmFtIGNodW5rIC0gVGhlIGNodW5rIHRvIHNwbGl0IGludG8gbGluZXNcbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyBhbiBhcnJheSBvZiBjb21wbGV0ZSBsaW5lcywgYW5kIGFueSByZW1haW5pbmcgaW5jb21wbGV0ZSBsaW5lXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhjaHVuazogc3RyaW5nKTogW2NvbXBsZXRlOiBBcnJheTxzdHJpbmc+LCBpbmNvbXBsZXRlOiBzdHJpbmddIHtcbiAgLyoqXG4gICAqIEFjY29yZGluZyB0byB0aGUgc3BlYywgYSBsaW5lIGlzIHRlcm1pbmF0ZWQgYnkgZWl0aGVyOlxuICAgKiAtIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gVSswMDBBIExJTkUgRkVFRCAoQ1JMRikgY2hhcmFjdGVyIHBhaXJcbiAgICogLSBhIHNpbmdsZSBVKzAwMEEgTElORSBGRUVEKExGKSBjaGFyYWN0ZXIgbm90IHByZWNlZGVkIGJ5IGEgVSswMDBEIENBUlJJQUdFIFJFVFVSTihDUikgY2hhcmFjdGVyXG4gICAqIC0gYSBzaW5nbGUgVSswMDBEIENBUlJJQUdFIFJFVFVSTihDUikgY2hhcmFjdGVyIG5vdCBmb2xsb3dlZCBieSBhIFUrMDAwQSBMSU5FIEZFRUQoTEYpIGNoYXJhY3RlclxuICAgKi9cbiAgY29uc3QgbGluZXM6IEFycmF5PHN0cmluZz4gPSBbXVxuICBsZXQgaW5jb21wbGV0ZUxpbmUgPSAnJ1xuICBsZXQgc2VhcmNoSW5kZXggPSAwXG5cbiAgd2hpbGUgKHNlYXJjaEluZGV4IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgLy8gRmluZCBuZXh0IGxpbmUgdGVybWluYXRvclxuICAgIGNvbnN0IGNySW5kZXggPSBjaHVuay5pbmRleE9mKCdcXHInLCBzZWFyY2hJbmRleClcbiAgICBjb25zdCBsZkluZGV4ID0gY2h1bmsuaW5kZXhPZignXFxuJywgc2VhcmNoSW5kZXgpXG5cbiAgICAvLyBEZXRlcm1pbmUgbGluZSBlbmRcbiAgICBsZXQgbGluZUVuZCA9IC0xXG4gICAgaWYgKGNySW5kZXggIT09IC0xICYmIGxmSW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBDUkxGIGNhc2VcbiAgICAgIGxpbmVFbmQgPSBNYXRoLm1pbihjckluZGV4LCBsZkluZGV4KVxuICAgIH0gZWxzZSBpZiAoY3JJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIENSIGF0IHRoZSBlbmQgb2YgYSBjaHVuayBtaWdodCBiZSBwYXJ0IG9mIGEgQ1JMRiBzZXF1ZW5jZSB0aGF0IHNwYW5zIGNodW5rcyxcbiAgICAgIC8vIHNvIHdlIHNob3VsZG4ndCB0cmVhdCBpdCBhcyBhIGxpbmUgdGVybWluYXRvciAoeWV0KVxuICAgICAgaWYgKGNySW5kZXggPT09IGNodW5rLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGluZUVuZCA9IC0xXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lRW5kID0gY3JJbmRleFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGZJbmRleCAhPT0gLTEpIHtcbiAgICAgIGxpbmVFbmQgPSBsZkluZGV4XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBsaW5lIGlmIHRlcm1pbmF0b3IgZm91bmRcbiAgICBpZiAobGluZUVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIE5vIHRlcm1pbmF0b3IgZm91bmQsIHJlc3QgaXMgaW5jb21wbGV0ZVxuICAgICAgaW5jb21wbGV0ZUxpbmUgPSBjaHVuay5zbGljZShzZWFyY2hJbmRleClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjaHVuay5zbGljZShzZWFyY2hJbmRleCwgbGluZUVuZClcbiAgICAgIGxpbmVzLnB1c2gobGluZSlcblxuICAgICAgLy8gTW92ZSBwYXN0IGxpbmUgdGVybWluYXRvclxuICAgICAgc2VhcmNoSW5kZXggPSBsaW5lRW5kICsgMVxuICAgICAgaWYgKGNodW5rW3NlYXJjaEluZGV4IC0gMV0gPT09ICdcXHInICYmIGNodW5rW3NlYXJjaEluZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgc2VhcmNoSW5kZXgrK1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbGluZXMsIGluY29tcGxldGVMaW5lXVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuYXV0aG9yaXplZEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZUVycm9yUmVzcG9uc2UgPSBwYXJzZUVycm9yUmVzcG9uc2U7XG5leHBvcnRzLmF1dGggPSBhdXRoO1xuZXhwb3J0cy5zZWxlY3RSZXNvdXJjZVVSTCA9IHNlbGVjdFJlc291cmNlVVJMO1xuZXhwb3J0cy5leHRyYWN0UmVzb3VyY2VNZXRhZGF0YVVybCA9IGV4dHJhY3RSZXNvdXJjZU1ldGFkYXRhVXJsO1xuZXhwb3J0cy5kaXNjb3Zlck9BdXRoUHJvdGVjdGVkUmVzb3VyY2VNZXRhZGF0YSA9IGRpc2NvdmVyT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhO1xuZXhwb3J0cy5kaXNjb3Zlck9BdXRoTWV0YWRhdGEgPSBkaXNjb3Zlck9BdXRoTWV0YWRhdGE7XG5leHBvcnRzLmJ1aWxkRGlzY292ZXJ5VXJscyA9IGJ1aWxkRGlzY292ZXJ5VXJscztcbmV4cG9ydHMuZGlzY292ZXJBdXRob3JpemF0aW9uU2VydmVyTWV0YWRhdGEgPSBkaXNjb3ZlckF1dGhvcml6YXRpb25TZXJ2ZXJNZXRhZGF0YTtcbmV4cG9ydHMuc3RhcnRBdXRob3JpemF0aW9uID0gc3RhcnRBdXRob3JpemF0aW9uO1xuZXhwb3J0cy5leGNoYW5nZUF1dGhvcml6YXRpb24gPSBleGNoYW5nZUF1dGhvcml6YXRpb247XG5leHBvcnRzLnJlZnJlc2hBdXRob3JpemF0aW9uID0gcmVmcmVzaEF1dGhvcml6YXRpb247XG5leHBvcnRzLnJlZ2lzdGVyQ2xpZW50ID0gcmVnaXN0ZXJDbGllbnQ7XG5jb25zdCBwa2NlX2NoYWxsZW5nZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwa2NlLWNoYWxsZW5nZVwiKSk7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hdXRoLmpzXCIpO1xuY29uc3QgYXV0aF9qc18yID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hdXRoLmpzXCIpO1xuY29uc3QgYXV0aF91dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hdXRoLXV0aWxzLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vc2VydmVyL2F1dGgvZXJyb3JzLmpzXCIpO1xuY2xhc3MgVW5hdXRob3JpemVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnVW5hdXRob3JpemVkJyk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmF1dGhvcml6ZWRFcnJvciA9IFVuYXV0aG9yaXplZEVycm9yO1xuY29uc3QgQVVUSE9SSVpBVElPTl9DT0RFX1JFU1BPTlNFX1RZUEUgPSAnY29kZSc7XG5jb25zdCBBVVRIT1JJWkFUSU9OX0NPREVfQ0hBTExFTkdFX01FVEhPRCA9ICdTMjU2Jztcbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIHRvIHVzZSBiYXNlZCBvbiBzZXJ2ZXIgc3VwcG9ydCBhbmQgY2xpZW50IGNvbmZpZ3VyYXRpb24uXG4gKlxuICogUHJpb3JpdHkgb3JkZXIgKGhpZ2hlc3QgdG8gbG93ZXN0KTpcbiAqIDEuIGNsaWVudF9zZWNyZXRfYmFzaWMgKGlmIGNsaWVudCBzZWNyZXQgaXMgYXZhaWxhYmxlKVxuICogMi4gY2xpZW50X3NlY3JldF9wb3N0IChpZiBjbGllbnQgc2VjcmV0IGlzIGF2YWlsYWJsZSlcbiAqIDMuIG5vbmUgKGZvciBwdWJsaWMgY2xpZW50cylcbiAqXG4gKiBAcGFyYW0gY2xpZW50SW5mb3JtYXRpb24gLSBPQXV0aCBjbGllbnQgaW5mb3JtYXRpb24gY29udGFpbmluZyBjcmVkZW50aWFsc1xuICogQHBhcmFtIHN1cHBvcnRlZE1ldGhvZHMgLSBBdXRoZW50aWNhdGlvbiBtZXRob2RzIHN1cHBvcnRlZCBieSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXJcbiAqIEByZXR1cm5zIFRoZSBzZWxlY3RlZCBhdXRoZW50aWNhdGlvbiBtZXRob2RcbiAqL1xuZnVuY3Rpb24gc2VsZWN0Q2xpZW50QXV0aE1ldGhvZChjbGllbnRJbmZvcm1hdGlvbiwgc3VwcG9ydGVkTWV0aG9kcykge1xuICAgIGNvbnN0IGhhc0NsaWVudFNlY3JldCA9IGNsaWVudEluZm9ybWF0aW9uLmNsaWVudF9zZWNyZXQgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBJZiBzZXJ2ZXIgZG9lc24ndCBzcGVjaWZ5IHN1cHBvcnRlZCBtZXRob2RzLCB1c2UgUkZDIDY3NDkgZGVmYXVsdHNcbiAgICBpZiAoc3VwcG9ydGVkTWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhhc0NsaWVudFNlY3JldCA/ICdjbGllbnRfc2VjcmV0X3Bvc3QnIDogJ25vbmUnO1xuICAgIH1cbiAgICAvLyBUcnkgbWV0aG9kcyBpbiBwcmlvcml0eSBvcmRlciAobW9zdCBzZWN1cmUgZmlyc3QpXG4gICAgaWYgKGhhc0NsaWVudFNlY3JldCAmJiBzdXBwb3J0ZWRNZXRob2RzLmluY2x1ZGVzKCdjbGllbnRfc2VjcmV0X2Jhc2ljJykpIHtcbiAgICAgICAgcmV0dXJuICdjbGllbnRfc2VjcmV0X2Jhc2ljJztcbiAgICB9XG4gICAgaWYgKGhhc0NsaWVudFNlY3JldCAmJiBzdXBwb3J0ZWRNZXRob2RzLmluY2x1ZGVzKCdjbGllbnRfc2VjcmV0X3Bvc3QnKSkge1xuICAgICAgICByZXR1cm4gJ2NsaWVudF9zZWNyZXRfcG9zdCc7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0ZWRNZXRob2RzLmluY2x1ZGVzKCdub25lJykpIHtcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgLy8gRmFsbGJhY2s6IHVzZSB3aGF0IHdlIGhhdmVcbiAgICByZXR1cm4gaGFzQ2xpZW50U2VjcmV0ID8gJ2NsaWVudF9zZWNyZXRfcG9zdCcgOiAnbm9uZSc7XG59XG4vKipcbiAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIHRvIHRoZSByZXF1ZXN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgbWV0aG9kLlxuICpcbiAqIEltcGxlbWVudHMgT0F1dGggMi4xIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RzOlxuICogLSBjbGllbnRfc2VjcmV0X2Jhc2ljOiBIVFRQIEJhc2ljIGF1dGhlbnRpY2F0aW9uIChSRkMgNjc0OSBTZWN0aW9uIDIuMy4xKVxuICogLSBjbGllbnRfc2VjcmV0X3Bvc3Q6IENyZWRlbnRpYWxzIGluIHJlcXVlc3QgYm9keSAoUkZDIDY3NDkgU2VjdGlvbiAyLjMuMSlcbiAqIC0gbm9uZTogUHVibGljIGNsaWVudCBhdXRoZW50aWNhdGlvbiAoUkZDIDY3NDkgU2VjdGlvbiAyLjEpXG4gKlxuICogQHBhcmFtIG1ldGhvZCAtIFRoZSBhdXRoZW50aWNhdGlvbiBtZXRob2QgdG8gdXNlXG4gKiBAcGFyYW0gY2xpZW50SW5mb3JtYXRpb24gLSBPQXV0aCBjbGllbnQgaW5mb3JtYXRpb24gY29udGFpbmluZyBjcmVkZW50aWFsc1xuICogQHBhcmFtIGhlYWRlcnMgLSBIVFRQIGhlYWRlcnMgb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHBhcmFtcyAtIFVSTCBzZWFyY2ggcGFyYW1ldGVycyB0byBtb2RpZnlcbiAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHJlcXVpcmVkIGNyZWRlbnRpYWxzIGFyZSBtaXNzaW5nXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q2xpZW50QXV0aGVudGljYXRpb24obWV0aG9kLCBjbGllbnRJbmZvcm1hdGlvbiwgaGVhZGVycywgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQgfSA9IGNsaWVudEluZm9ybWF0aW9uO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOlxuICAgICAgICAgICAgYXBwbHlCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0LCBoZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnY2xpZW50X3NlY3JldF9wb3N0JzpcbiAgICAgICAgICAgIGFwcGx5UG9zdEF1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0LCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIGFwcGx5UHVibGljQXV0aChjbGllbnRfaWQsIHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2Q6ICR7bWV0aG9kfWApO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBIVFRQIEJhc2ljIGF1dGhlbnRpY2F0aW9uIChSRkMgNjc0OSBTZWN0aW9uIDIuMy4xKVxuICovXG5mdW5jdGlvbiBhcHBseUJhc2ljQXV0aChjbGllbnRJZCwgY2xpZW50U2VjcmV0LCBoZWFkZXJzKSB7XG4gICAgaWYgKCFjbGllbnRTZWNyZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGllbnRfc2VjcmV0X2Jhc2ljIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIGEgY2xpZW50X3NlY3JldCcpO1xuICAgIH1cbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7Y2xpZW50SWR9OiR7Y2xpZW50U2VjcmV0fWApO1xuICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJhc2ljICR7Y3JlZGVudGlhbHN9YCk7XG59XG4vKipcbiAqIEFwcGxpZXMgUE9TVCBib2R5IGF1dGhlbnRpY2F0aW9uIChSRkMgNjc0OSBTZWN0aW9uIDIuMy4xKVxuICovXG5mdW5jdGlvbiBhcHBseVBvc3RBdXRoKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIHBhcmFtcykge1xuICAgIHBhcmFtcy5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudElkKTtcbiAgICBpZiAoY2xpZW50U2VjcmV0KSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ2NsaWVudF9zZWNyZXQnLCBjbGllbnRTZWNyZXQpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBwdWJsaWMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIChSRkMgNjc0OSBTZWN0aW9uIDIuMSlcbiAqL1xuZnVuY3Rpb24gYXBwbHlQdWJsaWNBdXRoKGNsaWVudElkLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnRJZCk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBPQXV0aCBlcnJvciByZXNwb25zZSBmcm9tIGEgc3RyaW5nIG9yIFJlc3BvbnNlIG9iamVjdC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgaXMgYSBzdGFuZGFyZCBPQXV0aDIuMCBlcnJvciByZXNwb25zZSwgaXQgd2lsbCBiZSBwYXJzZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gKiBhbmQgYW4gaW5zdGFuY2Ugb2YgdGhlIGFwcHJvcHJpYXRlIE9BdXRoRXJyb3Igc3ViY2xhc3Mgd2lsbCBiZSByZXR1cm5lZC5cbiAqIElmIHBhcnNpbmcgZmFpbHMsIGl0IGZhbGxzIGJhY2sgdG8gYSBnZW5lcmljIFNlcnZlckVycm9yIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSByZXNwb25zZSBzdGF0dXMgKGlmIGF2YWlsYWJsZSkgYW5kIG9yaWdpbmFsIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gQSBSZXNwb25zZSBvYmplY3Qgb3Igc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVycm9yIHJlc3BvbnNlXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBPQXV0aEVycm9yIGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlRXJyb3JSZXNwb25zZShpbnB1dCkge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBpbnB1dCBpbnN0YW5jZW9mIFJlc3BvbnNlID8gaW5wdXQuc3RhdHVzIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGJvZHkgPSBpbnB1dCBpbnN0YW5jZW9mIFJlc3BvbnNlID8gYXdhaXQgaW5wdXQudGV4dCgpIDogaW5wdXQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXV0aF9qc18xLk9BdXRoRXJyb3JSZXNwb25zZVNjaGVtYS5wYXJzZShKU09OLnBhcnNlKGJvZHkpKTtcbiAgICAgICAgY29uc3QgeyBlcnJvciwgZXJyb3JfZGVzY3JpcHRpb24sIGVycm9yX3VyaSB9ID0gcmVzdWx0O1xuICAgICAgICBjb25zdCBlcnJvckNsYXNzID0gZXJyb3JzX2pzXzEuT0FVVEhfRVJST1JTW2Vycm9yXSB8fCBlcnJvcnNfanNfMS5TZXJ2ZXJFcnJvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvckNsYXNzKGVycm9yX2Rlc2NyaXB0aW9uIHx8ICcnLCBlcnJvcl91cmkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gTm90IGEgdmFsaWQgT0F1dGggZXJyb3IgcmVzcG9uc2UsIGJ1dCB0cnkgdG8gaW5mb3JtIHRoZSB1c2VyIG9mIHRoZSByYXcgZGF0YSBhbnl3YXlcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7c3RhdHVzQ29kZSA/IGBIVFRQICR7c3RhdHVzQ29kZX06IGAgOiAnJ31JbnZhbGlkIE9BdXRoIGVycm9yIHJlc3BvbnNlOiAke2Vycm9yfS4gUmF3IGJvZHk6ICR7Ym9keX1gO1xuICAgICAgICByZXR1cm4gbmV3IGVycm9yc19qc18xLlNlcnZlckVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBPcmNoZXN0cmF0ZXMgdGhlIGZ1bGwgYXV0aCBmbG93IHdpdGggYSBzZXJ2ZXIuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCBhcyBhIHNpbmdsZSBlbnRyeSBwb2ludCBmb3IgYWxsIGF1dGhvcml6YXRpb24gZnVuY3Rpb25hbGl0eSxcbiAqIGluc3RlYWQgb2YgbGlua2luZyB0b2dldGhlciB0aGUgb3RoZXIgbG93ZXItbGV2ZWwgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlLlxuICovXG5hc3luYyBmdW5jdGlvbiBhdXRoKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXV0aEludGVybmFsKHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEhhbmRsZSByZWNvdmVyYWJsZSBlcnJvciB0eXBlcyBieSBpbnZhbGlkYXRpbmcgY3JlZGVudGlhbHMgYW5kIHJldHJ5aW5nXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc19qc18xLkludmFsaWRDbGllbnRFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIGVycm9yc19qc18xLlVuYXV0aG9yaXplZENsaWVudEVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9hID0gcHJvdmlkZXIuaW52YWxpZGF0ZUNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm92aWRlciwgJ2FsbCcpKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhdXRoSW50ZXJuYWwocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuSW52YWxpZEdyYW50RXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSBwcm92aWRlci5pbnZhbGlkYXRlQ3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHByb3ZpZGVyLCAndG9rZW5zJykpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGF1dGhJbnRlcm5hbChwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyb3cgb3RoZXJ3aXNlXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGF1dGhJbnRlcm5hbChwcm92aWRlciwgeyBzZXJ2ZXJVcmwsIGF1dGhvcml6YXRpb25Db2RlLCBzY29wZSwgcmVzb3VyY2VNZXRhZGF0YVVybCwgZmV0Y2hGbiB9KSB7XG4gICAgbGV0IHJlc291cmNlTWV0YWRhdGE7XG4gICAgbGV0IGF1dGhvcml6YXRpb25TZXJ2ZXJVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb3VyY2VNZXRhZGF0YSA9IGF3YWl0IGRpc2NvdmVyT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhKHNlcnZlclVybCwgeyByZXNvdXJjZU1ldGFkYXRhVXJsIH0sIGZldGNoRm4pO1xuICAgICAgICBpZiAocmVzb3VyY2VNZXRhZGF0YS5hdXRob3JpemF0aW9uX3NlcnZlcnMgJiYgcmVzb3VyY2VNZXRhZGF0YS5hdXRob3JpemF0aW9uX3NlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvblNlcnZlclVybCA9IHJlc291cmNlTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9zZXJ2ZXJzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGFuZCBmYWxsIGJhY2sgdG8gLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyXG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGdldCBhIHZhbGlkIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIGZyb20gcHJvdGVjdGVkIHJlc291cmNlIG1ldGFkYXRhLFxuICAgICAqIGZhbGxiYWNrIHRvIHRoZSBsZWdhY3kgTUNQIHNwZWMncyBpbXBsZW1lbnRhdGlvbiAodmVyc2lvbiAyMDI1LTAzLTI2KTogTUNQIHNlcnZlciBhY3RzIGFzIHRoZSBBdXRob3JpemF0aW9uIHNlcnZlci5cbiAgICAgKi9cbiAgICBpZiAoIWF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblNlcnZlclVybCA9IHNlcnZlclVybDtcbiAgICB9XG4gICAgY29uc3QgcmVzb3VyY2UgPSBhd2FpdCBzZWxlY3RSZXNvdXJjZVVSTChzZXJ2ZXJVcmwsIHByb3ZpZGVyLCByZXNvdXJjZU1ldGFkYXRhKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGRpc2NvdmVyQXV0aG9yaXphdGlvblNlcnZlck1ldGFkYXRhKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHtcbiAgICAgICAgZmV0Y2hGblxuICAgIH0pO1xuICAgIC8vIEhhbmRsZSBjbGllbnQgcmVnaXN0cmF0aW9uIGlmIG5lZWRlZFxuICAgIGxldCBjbGllbnRJbmZvcm1hdGlvbiA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShwcm92aWRlci5jbGllbnRJbmZvcm1hdGlvbigpKTtcbiAgICBpZiAoIWNsaWVudEluZm9ybWF0aW9uKSB7XG4gICAgICAgIGlmIChhdXRob3JpemF0aW9uQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4aXN0aW5nIE9BdXRoIGNsaWVudCBpbmZvcm1hdGlvbiBpcyByZXF1aXJlZCB3aGVuIGV4Y2hhbmdpbmcgYW4gYXV0aG9yaXphdGlvbiBjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm92aWRlci5zYXZlQ2xpZW50SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT0F1dGggY2xpZW50IGluZm9ybWF0aW9uIG11c3QgYmUgc2F2ZWFibGUgZm9yIGR5bmFtaWMgcmVnaXN0cmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbEluZm9ybWF0aW9uID0gYXdhaXQgcmVnaXN0ZXJDbGllbnQoYXV0aG9yaXphdGlvblNlcnZlclVybCwge1xuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBjbGllbnRNZXRhZGF0YTogcHJvdmlkZXIuY2xpZW50TWV0YWRhdGEsXG4gICAgICAgICAgICBmZXRjaEZuXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwcm92aWRlci5zYXZlQ2xpZW50SW5mb3JtYXRpb24oZnVsbEluZm9ybWF0aW9uKTtcbiAgICAgICAgY2xpZW50SW5mb3JtYXRpb24gPSBmdWxsSW5mb3JtYXRpb247XG4gICAgfVxuICAgIC8vIEV4Y2hhbmdlIGF1dGhvcml6YXRpb24gY29kZSBmb3IgdG9rZW5zXG4gICAgaWYgKGF1dGhvcml6YXRpb25Db2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gYXdhaXQgcHJvdmlkZXIuY29kZVZlcmlmaWVyKCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IGV4Y2hhbmdlQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uU2VydmVyVXJsLCB7XG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIGNsaWVudEluZm9ybWF0aW9uLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbkNvZGUsXG4gICAgICAgICAgICBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICByZWRpcmVjdFVyaTogcHJvdmlkZXIucmVkaXJlY3RVcmwsXG4gICAgICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgICAgIGFkZENsaWVudEF1dGhlbnRpY2F0aW9uOiBwcm92aWRlci5hZGRDbGllbnRBdXRoZW50aWNhdGlvbixcbiAgICAgICAgICAgIGZldGNoRm46IGZldGNoRm5cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLnNhdmVUb2tlbnModG9rZW5zKTtcbiAgICAgICAgcmV0dXJuICdBVVRIT1JJWkVEJztcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gYXdhaXQgcHJvdmlkZXIudG9rZW5zKCk7XG4gICAgLy8gSGFuZGxlIHRva2VuIHJlZnJlc2ggb3IgbmV3IGF1dGhvcml6YXRpb25cbiAgICBpZiAodG9rZW5zID09PSBudWxsIHx8IHRva2VucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Rva2VucyA9IGF3YWl0IHJlZnJlc2hBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBjbGllbnRJbmZvcm1hdGlvbixcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IHRva2Vucy5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHJlc291cmNlLFxuICAgICAgICAgICAgICAgIGFkZENsaWVudEF1dGhlbnRpY2F0aW9uOiBwcm92aWRlci5hZGRDbGllbnRBdXRoZW50aWNhdGlvbixcbiAgICAgICAgICAgICAgICBmZXRjaEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLnNhdmVUb2tlbnMobmV3VG9rZW5zKTtcbiAgICAgICAgICAgIHJldHVybiAnQVVUSE9SSVpFRCc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgU2VydmVyRXJyb3IsIG9yIGFuIHVua25vd24gdHlwZSwgbG9nIGl0IG91dCBhbmQgdHJ5IHRvIGNvbnRpbnVlLiBPdGhlcndpc2UsIGVzY2FsYXRlIHNvIHdlIGNhbiBmaXggdGhpbmdzIGFuZCByZXRyeS5cbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuT0F1dGhFcnJvcikgfHwgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfanNfMS5TZXJ2ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIG5vdCByZWZyZXNoIE9BdXRoIHRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVmcmVzaCBmYWlsZWQgZm9yIGFub3RoZXIgcmVhc29uLCByZS10aHJvd1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gcHJvdmlkZXIuc3RhdGUgPyBhd2FpdCBwcm92aWRlci5zdGF0ZSgpIDogdW5kZWZpbmVkO1xuICAgIC8vIFN0YXJ0IG5ldyBhdXRob3JpemF0aW9uIGZsb3dcbiAgICBjb25zdCB7IGF1dGhvcml6YXRpb25VcmwsIGNvZGVWZXJpZmllciB9ID0gYXdhaXQgc3RhcnRBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHtcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGNsaWVudEluZm9ybWF0aW9uLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVkaXJlY3RVcmw6IHByb3ZpZGVyLnJlZGlyZWN0VXJsLFxuICAgICAgICBzY29wZTogc2NvcGUgfHwgcHJvdmlkZXIuY2xpZW50TWV0YWRhdGEuc2NvcGUsXG4gICAgICAgIHJlc291cmNlXG4gICAgfSk7XG4gICAgYXdhaXQgcHJvdmlkZXIuc2F2ZUNvZGVWZXJpZmllcihjb2RlVmVyaWZpZXIpO1xuICAgIGF3YWl0IHByb3ZpZGVyLnJlZGlyZWN0VG9BdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25VcmwpO1xuICAgIHJldHVybiAnUkVESVJFQ1QnO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VsZWN0UmVzb3VyY2VVUkwoc2VydmVyVXJsLCBwcm92aWRlciwgcmVzb3VyY2VNZXRhZGF0YSkge1xuICAgIGNvbnN0IGRlZmF1bHRSZXNvdXJjZSA9ICgwLCBhdXRoX3V0aWxzX2pzXzEucmVzb3VyY2VVcmxGcm9tU2VydmVyVXJsKShzZXJ2ZXJVcmwpO1xuICAgIC8vIElmIHByb3ZpZGVyIGhhcyBjdXN0b20gdmFsaWRhdGlvbiwgZGVsZWdhdGUgdG8gaXRcbiAgICBpZiAocHJvdmlkZXIudmFsaWRhdGVSZXNvdXJjZVVSTCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIudmFsaWRhdGVSZXNvdXJjZVVSTChkZWZhdWx0UmVzb3VyY2UsIHJlc291cmNlTWV0YWRhdGEgPT09IG51bGwgfHwgcmVzb3VyY2VNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzb3VyY2VNZXRhZGF0YS5yZXNvdXJjZSk7XG4gICAgfVxuICAgIC8vIE9ubHkgaW5jbHVkZSByZXNvdXJjZSBwYXJhbWV0ZXIgd2hlbiBQcm90ZWN0ZWQgUmVzb3VyY2UgTWV0YWRhdGEgaXMgcHJlc2VudFxuICAgIGlmICghcmVzb3VyY2VNZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBtZXRhZGF0YSdzIHJlc291cmNlIGlzIGNvbXBhdGlibGUgd2l0aCBvdXIgcmVxdWVzdFxuICAgIGlmICghKDAsIGF1dGhfdXRpbHNfanNfMS5jaGVja1Jlc291cmNlQWxsb3dlZCkoeyByZXF1ZXN0ZWRSZXNvdXJjZTogZGVmYXVsdFJlc291cmNlLCBjb25maWd1cmVkUmVzb3VyY2U6IHJlc291cmNlTWV0YWRhdGEucmVzb3VyY2UgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm90ZWN0ZWQgcmVzb3VyY2UgJHtyZXNvdXJjZU1ldGFkYXRhLnJlc291cmNlfSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCAke2RlZmF1bHRSZXNvdXJjZX0gKG9yIG9yaWdpbilgKTtcbiAgICB9XG4gICAgLy8gUHJlZmVyIHRoZSByZXNvdXJjZSBmcm9tIG1ldGFkYXRhIHNpbmNlIGl0J3Mgd2hhdCB0aGUgc2VydmVyIGlzIHRlbGxpbmcgdXMgdG8gcmVxdWVzdFxuICAgIHJldHVybiBuZXcgVVJMKHJlc291cmNlTWV0YWRhdGEucmVzb3VyY2UpO1xufVxuLyoqXG4gKiBFeHRyYWN0IHJlc291cmNlX21ldGFkYXRhIGZyb20gcmVzcG9uc2UgaGVhZGVyLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UmVzb3VyY2VNZXRhZGF0YVVybChyZXMpIHtcbiAgICBjb25zdCBhdXRoZW50aWNhdGVIZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoJ1dXVy1BdXRoZW50aWNhdGUnKTtcbiAgICBpZiAoIWF1dGhlbnRpY2F0ZUhlYWRlcikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBbdHlwZSwgc2NoZW1lXSA9IGF1dGhlbnRpY2F0ZUhlYWRlci5zcGxpdCgnICcpO1xuICAgIGlmICh0eXBlLnRvTG93ZXJDYXNlKCkgIT09ICdiZWFyZXInIHx8ICFzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcmVnZXggPSAvcmVzb3VyY2VfbWV0YWRhdGE9XCIoW15cIl0qKVwiLztcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXV0aGVudGljYXRlSGVhZGVyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKG1hdGNoWzFdKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBMb29rcyB1cCBSRkMgOTcyOCBPQXV0aCAyLjAgUHJvdGVjdGVkIFJlc291cmNlIE1ldGFkYXRhLlxuICpcbiAqIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhIDQwNCBmb3IgdGhlIHdlbGwta25vd24gZW5kcG9pbnQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogcmV0dXJuIGB1bmRlZmluZWRgLiBBbnkgb3RoZXIgZXJyb3JzIHdpbGwgYmUgdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhKHNlcnZlclVybCwgb3B0cywgZmV0Y2hGbiA9IGZldGNoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkaXNjb3Zlck1ldGFkYXRhV2l0aEZhbGxiYWNrKHNlcnZlclVybCwgJ29hdXRoLXByb3RlY3RlZC1yZXNvdXJjZScsIGZldGNoRm4sIHtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICAgICBtZXRhZGF0YVVybDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJlc291cmNlTWV0YWRhdGFVcmxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugc2VydmVyIGRvZXMgbm90IGltcGxlbWVudCBPQXV0aCAyLjAgUHJvdGVjdGVkIFJlc291cmNlIE1ldGFkYXRhLmApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gdHJ5aW5nIHRvIGxvYWQgd2VsbC1rbm93biBPQXV0aCBwcm90ZWN0ZWQgcmVzb3VyY2UgbWV0YWRhdGEuYCk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoX2pzXzIuT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhU2NoZW1hLnBhcnNlKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgZmV0Y2ggd2l0aCBDT1JTIHJldHJ5IGxvZ2ljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aENvcnNSZXRyeSh1cmwsIGhlYWRlcnMsIGZldGNoRm4gPSBmZXRjaCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZXRjaEZuKHVybCwgeyBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIENPUlMgZXJyb3JzIGNvbWUgYmFjayBhcyBUeXBlRXJyb3IsIHJldHJ5IHdpdGhvdXQgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFdpdGhDb3JzUmV0cnkodXJsLCB1bmRlZmluZWQsIGZldGNoRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgZ2V0dGluZyBDT1JTIGVycm9ycyBvbiByZXRyeSB0b28sIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgd2VsbC1rbm93biBwYXRoIGZvciBhdXRoLXJlbGF0ZWQgbWV0YWRhdGEgZGlzY292ZXJ5XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkV2VsbEtub3duUGF0aCh3ZWxsS25vd25QcmVmaXgsIHBhdGhuYW1lID0gJycsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFN0cmlwIHRyYWlsaW5nIHNsYXNoIGZyb20gcGF0aG5hbWUgdG8gYXZvaWQgZG91YmxlIHNsYXNoZXNcbiAgICBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJlcGVuZFBhdGhuYW1lID8gYCR7cGF0aG5hbWV9Ly53ZWxsLWtub3duLyR7d2VsbEtub3duUHJlZml4fWAgOiBgLy53ZWxsLWtub3duLyR7d2VsbEtub3duUHJlZml4fSR7cGF0aG5hbWV9YDtcbn1cbi8qKlxuICogVHJpZXMgdG8gZGlzY292ZXIgT0F1dGggbWV0YWRhdGEgYXQgYSBzcGVjaWZpYyBVUkxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJ5TWV0YWRhdGFEaXNjb3ZlcnkodXJsLCBwcm90b2NvbFZlcnNpb24sIGZldGNoRm4gPSBmZXRjaCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdNQ1AtUHJvdG9jb2wtVmVyc2lvbic6IHByb3RvY29sVmVyc2lvblxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoV2l0aENvcnNSZXRyeSh1cmwsIGhlYWRlcnMsIGZldGNoRm4pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGZhbGxiYWNrIHRvIHJvb3QgZGlzY292ZXJ5IHNob3VsZCBiZSBhdHRlbXB0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXR0ZW1wdEZhbGxiYWNrKHJlc3BvbnNlLCBwYXRobmFtZSkge1xuICAgIHJldHVybiAhcmVzcG9uc2UgfHwgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwICYmIHBhdGhuYW1lICE9PSAnLycpO1xufVxuLyoqXG4gKiBHZW5lcmljIGZ1bmN0aW9uIGZvciBkaXNjb3ZlcmluZyBPQXV0aCBtZXRhZGF0YSB3aXRoIGZhbGxiYWNrIHN1cHBvcnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJNZXRhZGF0YVdpdGhGYWxsYmFjayhzZXJ2ZXJVcmwsIHdlbGxLbm93blR5cGUsIGZldGNoRm4sIG9wdHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGlzc3VlciA9IG5ldyBVUkwoc2VydmVyVXJsKTtcbiAgICBjb25zdCBwcm90b2NvbFZlcnNpb24gPSAoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMucHJvdG9jb2xWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlc19qc18xLkxBVEVTVF9QUk9UT0NPTF9WRVJTSU9OO1xuICAgIGxldCB1cmw7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5tZXRhZGF0YVVybCkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKG9wdHMubWV0YWRhdGFVcmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHBhdGgtYXdhcmUgZGlzY292ZXJ5IGZpcnN0XG4gICAgICAgIGNvbnN0IHdlbGxLbm93blBhdGggPSBidWlsZFdlbGxLbm93blBhdGgod2VsbEtub3duVHlwZSwgaXNzdWVyLnBhdGhuYW1lKTtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh3ZWxsS25vd25QYXRoLCAoX2IgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWV0YWRhdGFTZXJ2ZXJVcmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzc3Vlcik7XG4gICAgICAgIHVybC5zZWFyY2ggPSBpc3N1ZXIuc2VhcmNoO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0cnlNZXRhZGF0YURpc2NvdmVyeSh1cmwsIHByb3RvY29sVmVyc2lvbiwgZmV0Y2hGbik7XG4gICAgLy8gSWYgcGF0aC1hd2FyZSBkaXNjb3ZlcnkgZmFpbHMgd2l0aCA0MDQgYW5kIHdlJ3JlIG5vdCBhbHJlYWR5IGF0IHJvb3QsIHRyeSBmYWxsYmFjayB0byByb290IGRpc2NvdmVyeVxuICAgIGlmICghKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5tZXRhZGF0YVVybCkgJiYgc2hvdWxkQXR0ZW1wdEZhbGxiYWNrKHJlc3BvbnNlLCBpc3N1ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHJvb3RVcmwgPSBuZXcgVVJMKGAvLndlbGwta25vd24vJHt3ZWxsS25vd25UeXBlfWAsIGlzc3Vlcik7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdHJ5TWV0YWRhdGFEaXNjb3Zlcnkocm9vdFVybCwgcHJvdG9jb2xWZXJzaW9uLCBmZXRjaEZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuLyoqXG4gKiBMb29rcyB1cCBSRkMgODQxNCBPQXV0aCAyLjAgQXV0aG9yaXphdGlvbiBTZXJ2ZXIgTWV0YWRhdGEuXG4gKlxuICogSWYgdGhlIHNlcnZlciByZXR1cm5zIGEgNDA0IGZvciB0aGUgd2VsbC1rbm93biBlbmRwb2ludCwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiByZXR1cm4gYHVuZGVmaW5lZGAuIEFueSBvdGhlciBlcnJvcnMgd2lsbCBiZSB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYGRpc2NvdmVyQXV0aG9yaXphdGlvblNlcnZlck1ldGFkYXRhYC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJPQXV0aE1ldGFkYXRhKGlzc3VlciwgeyBhdXRob3JpemF0aW9uU2VydmVyVXJsLCBwcm90b2NvbFZlcnNpb24gfSA9IHt9LCBmZXRjaEZuID0gZmV0Y2gpIHtcbiAgICBpZiAodHlwZW9mIGlzc3VlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXNzdWVyID0gbmV3IFVSTChpc3N1ZXIpO1xuICAgIH1cbiAgICBpZiAoIWF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblNlcnZlclVybCA9IGlzc3VlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uU2VydmVyVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICBhdXRob3JpemF0aW9uU2VydmVyVXJsID0gbmV3IFVSTChhdXRob3JpemF0aW9uU2VydmVyVXJsKTtcbiAgICB9XG4gICAgcHJvdG9jb2xWZXJzaW9uICE9PSBudWxsICYmIHByb3RvY29sVmVyc2lvbiAhPT0gdm9pZCAwID8gcHJvdG9jb2xWZXJzaW9uIDogKHByb3RvY29sVmVyc2lvbiA9IHR5cGVzX2pzXzEuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGlzY292ZXJNZXRhZGF0YVdpdGhGYWxsYmFjayhhdXRob3JpemF0aW9uU2VydmVyVXJsLCAnb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXInLCBmZXRjaEZuLCB7XG4gICAgICAgIHByb3RvY29sVmVyc2lvbixcbiAgICAgICAgbWV0YWRhdGFTZXJ2ZXJVcmw6IGF1dGhvcml6YXRpb25TZXJ2ZXJVcmxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSB0cnlpbmcgdG8gbG9hZCB3ZWxsLWtub3duIE9BdXRoIG1ldGFkYXRhYCk7XG4gICAgfVxuICAgIHJldHVybiBhdXRoX2pzXzIuT0F1dGhNZXRhZGF0YVNjaGVtYS5wYXJzZShhd2FpdCByZXNwb25zZS5qc29uKCkpO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBsaXN0IG9mIGRpc2NvdmVyeSBVUkxzIHRvIHRyeSBmb3IgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGEuXG4gKiBVUkxzIGFyZSByZXR1cm5lZCBpbiBwcmlvcml0eSBvcmRlcjpcbiAqIDEuIE9BdXRoIG1ldGFkYXRhIGF0IHRoZSBnaXZlbiBVUkxcbiAqIDIuIE9BdXRoIG1ldGFkYXRhIGF0IHJvb3QgKGlmIFVSTCBoYXMgcGF0aClcbiAqIDMuIE9JREMgbWV0YWRhdGEgZW5kcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRGlzY292ZXJ5VXJscyhhdXRob3JpemF0aW9uU2VydmVyVXJsKSB7XG4gICAgY29uc3QgdXJsID0gdHlwZW9mIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgPT09ICdzdHJpbmcnID8gbmV3IFVSTChhdXRob3JpemF0aW9uU2VydmVyVXJsKSA6IGF1dGhvcml6YXRpb25TZXJ2ZXJVcmw7XG4gICAgY29uc3QgaGFzUGF0aCA9IHVybC5wYXRobmFtZSAhPT0gJy8nO1xuICAgIGNvbnN0IHVybHNUb1RyeSA9IFtdO1xuICAgIGlmICghaGFzUGF0aCkge1xuICAgICAgICAvLyBSb290IHBhdGg6IGh0dHBzOi8vZXhhbXBsZS5jb20vLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXJcbiAgICAgICAgdXJsc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgdXJsOiBuZXcgVVJMKCcvLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXInLCB1cmwub3JpZ2luKSxcbiAgICAgICAgICAgIHR5cGU6ICdvYXV0aCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9JREM6IGh0dHBzOi8vZXhhbXBsZS5jb20vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25cbiAgICAgICAgdXJsc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgdXJsOiBuZXcgVVJMKGAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gLCB1cmwub3JpZ2luKSxcbiAgICAgICAgICAgIHR5cGU6ICdvaWRjJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybHNUb1RyeTtcbiAgICB9XG4gICAgLy8gU3RyaXAgdHJhaWxpbmcgc2xhc2ggZnJvbSBwYXRobmFtZSB0byBhdm9pZCBkb3VibGUgc2xhc2hlc1xuICAgIGxldCBwYXRobmFtZSA9IHVybC5wYXRobmFtZTtcbiAgICBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgLy8gMS4gT0F1dGggbWV0YWRhdGEgYXQgdGhlIGdpdmVuIFVSTFxuICAgIC8vIEluc2VydCB3ZWxsLWtub3duIGJlZm9yZSB0aGUgcGF0aDogaHR0cHM6Ly9leGFtcGxlLmNvbS8ud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlci90ZW5hbnQxXG4gICAgdXJsc1RvVHJ5LnB1c2goe1xuICAgICAgICB1cmw6IG5ldyBVUkwoYC8ud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlciR7cGF0aG5hbWV9YCwgdXJsLm9yaWdpbiksXG4gICAgICAgIHR5cGU6ICdvYXV0aCdcbiAgICB9KTtcbiAgICAvLyBSb290IHBhdGg6IGh0dHBzOi8vZXhhbXBsZS5jb20vLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXJcbiAgICB1cmxzVG9UcnkucHVzaCh7XG4gICAgICAgIHVybDogbmV3IFVSTCgnLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyJywgdXJsLm9yaWdpbiksXG4gICAgICAgIHR5cGU6ICdvYXV0aCdcbiAgICB9KTtcbiAgICAvLyAzLiBPSURDIG1ldGFkYXRhIGVuZHBvaW50c1xuICAgIC8vIFJGQyA4NDE0IHN0eWxlOiBJbnNlcnQgLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uIGJlZm9yZSB0aGUgcGF0aFxuICAgIHVybHNUb1RyeS5wdXNoKHtcbiAgICAgICAgdXJsOiBuZXcgVVJMKGAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24ke3BhdGhuYW1lfWAsIHVybC5vcmlnaW4pLFxuICAgICAgICB0eXBlOiAnb2lkYydcbiAgICB9KTtcbiAgICAvLyBPSURDIERpc2NvdmVyeSAxLjAgc3R5bGU6IEFwcGVuZCAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24gYWZ0ZXIgdGhlIHBhdGhcbiAgICB1cmxzVG9UcnkucHVzaCh7XG4gICAgICAgIHVybDogbmV3IFVSTChgJHtwYXRobmFtZX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gLCB1cmwub3JpZ2luKSxcbiAgICAgICAgdHlwZTogJ29pZGMnXG4gICAgfSk7XG4gICAgcmV0dXJuIHVybHNUb1RyeTtcbn1cbi8qKlxuICogRGlzY292ZXJzIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIHdpdGggc3VwcG9ydCBmb3IgUkZDIDg0MTQgT0F1dGggMi4wIEF1dGhvcml6YXRpb24gU2VydmVyIE1ldGFkYXRhXG4gKiBhbmQgT3BlbklEIENvbm5lY3QgRGlzY292ZXJ5IDEuMCBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgYSBmYWxsYmFjayBzdHJhdGVneSBmb3IgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgZGlzY292ZXJ5OlxuICogMS4gQXR0ZW1wdHMgUkZDIDg0MTQgT0F1dGggbWV0YWRhdGEgZGlzY292ZXJ5IGZpcnN0XG4gKiAyLiBJZiBPQXV0aCBkaXNjb3ZlcnkgZmFpbHMsIGZhbGxzIGJhY2sgdG8gT3BlbklEIENvbm5lY3QgRGlzY292ZXJ5XG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwgLSBUaGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgVVJMIG9idGFpbmVkIGZyb20gdGhlIE1DUCBTZXJ2ZXInc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcmVzb3VyY2UgbWV0YWRhdGEsIG9yIHRoZSBNQ1Agc2VydmVyJ3MgVVJMIGlmIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSB3YXMgbm90IGZvdW5kLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLmZldGNoRm4gLSBPcHRpb25hbCBmZXRjaCBmdW5jdGlvbiBmb3IgbWFraW5nIEhUVFAgcmVxdWVzdHMsIGRlZmF1bHRzIHRvIGdsb2JhbCBmZXRjaFxuICogQHBhcmFtIG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uIC0gTUNQIHByb3RvY29sIHZlcnNpb24gdG8gdXNlLCBkZWZhdWx0cyB0byBMQVRFU1RfUFJPVE9DT0xfVkVSU0lPTlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGEsIG9yIHVuZGVmaW5lZCBpZiBkaXNjb3ZlcnkgZmFpbHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJBdXRob3JpemF0aW9uU2VydmVyTWV0YWRhdGEoYXV0aG9yaXphdGlvblNlcnZlclVybCwgeyBmZXRjaEZuID0gZmV0Y2gsIHByb3RvY29sVmVyc2lvbiA9IHR5cGVzX2pzXzEuTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gfSA9IHt9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHsgJ01DUC1Qcm90b2NvbC1WZXJzaW9uJzogcHJvdG9jb2xWZXJzaW9uIH07XG4gICAgLy8gR2V0IHRoZSBsaXN0IG9mIFVSTHMgdG8gdHJ5XG4gICAgY29uc3QgdXJsc1RvVHJ5ID0gYnVpbGREaXNjb3ZlcnlVcmxzKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpO1xuICAgIC8vIFRyeSBlYWNoIFVSTCBpbiBvcmRlclxuICAgIGZvciAoY29uc3QgeyB1cmw6IGVuZHBvaW50VXJsLCB0eXBlIH0gb2YgdXJsc1RvVHJ5KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ29yc1JldHJ5KGVuZHBvaW50VXJsLCBoZWFkZXJzLCBmZXRjaEZuKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDT1JTIGVycm9yIG9jY3VycmVkIC0gZG9uJ3QgdGhyb3cgYXMgdGhlIGVuZHBvaW50IG1heSBub3QgYWxsb3cgQ09SUyxcbiAgICAgICAgICAgICAqIGNvbnRpbnVlIHRyeWluZyBvdGhlciBwb3NzaWJsZSBlbmRwb2ludHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gQ29udGludWUgbG9va2luZyBmb3IgYW55IDR4eCByZXNwb25zZSBjb2RlLlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFRyeSBuZXh0IFVSTFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSB0cnlpbmcgdG8gbG9hZCAke3R5cGUgPT09ICdvYXV0aCcgPyAnT0F1dGgnIDogJ09wZW5JRCBwcm92aWRlcid9IG1ldGFkYXRhIGZyb20gJHtlbmRwb2ludFVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBhbmQgdmFsaWRhdGUgYmFzZWQgb24gdHlwZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ29hdXRoJykge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhfanNfMi5PQXV0aE1ldGFkYXRhU2NoZW1hLnBhcnNlKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXV0aF9qc18xLk9wZW5JZFByb3ZpZGVyRGlzY292ZXJ5TWV0YWRhdGFTY2hlbWEucGFyc2UoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBCZWdpbnMgdGhlIGF1dGhvcml6YXRpb24gZmxvdyB3aXRoIHRoZSBnaXZlbiBzZXJ2ZXIsIGJ5IGdlbmVyYXRpbmcgYSBQS0NFIGNoYWxsZW5nZSBhbmQgY29uc3RydWN0aW5nIHRoZSBhdXRob3JpemF0aW9uIFVSTC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhcnRBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHsgbWV0YWRhdGEsIGNsaWVudEluZm9ybWF0aW9uLCByZWRpcmVjdFVybCwgc2NvcGUsIHN0YXRlLCByZXNvdXJjZSB9KSB7XG4gICAgbGV0IGF1dGhvcml6YXRpb25Vcmw7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25VcmwgPSBuZXcgVVJMKG1ldGFkYXRhLmF1dGhvcml6YXRpb25fZW5kcG9pbnQpO1xuICAgICAgICBpZiAoIW1ldGFkYXRhLnJlc3BvbnNlX3R5cGVzX3N1cHBvcnRlZC5pbmNsdWRlcyhBVVRIT1JJWkFUSU9OX0NPREVfUkVTUE9OU0VfVFlQRSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGF1dGggc2VydmVyOiBkb2VzIG5vdCBzdXBwb3J0IHJlc3BvbnNlIHR5cGUgJHtBVVRIT1JJWkFUSU9OX0NPREVfUkVTUE9OU0VfVFlQRX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWQgJiZcbiAgICAgICAgICAgICFtZXRhZGF0YS5jb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZC5pbmNsdWRlcyhBVVRIT1JJWkFUSU9OX0NPREVfQ0hBTExFTkdFX01FVEhPRCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGF1dGggc2VydmVyOiBkb2VzIG5vdCBzdXBwb3J0IGNvZGUgY2hhbGxlbmdlIG1ldGhvZCAke0FVVEhPUklaQVRJT05fQ09ERV9DSEFMTEVOR0VfTUVUSE9EfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsID0gbmV3IFVSTCgnL2F1dGhvcml6ZScsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBQS0NFIGNoYWxsZW5nZVxuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGF3YWl0ICgwLCBwa2NlX2NoYWxsZW5nZV8xLmRlZmF1bHQpKCk7XG4gICAgY29uc3QgY29kZVZlcmlmaWVyID0gY2hhbGxlbmdlLmNvZGVfdmVyaWZpZXI7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGNoYWxsZW5nZS5jb2RlX2NoYWxsZW5nZTtcbiAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Jlc3BvbnNlX3R5cGUnLCBBVVRIT1JJWkFUSU9OX0NPREVfUkVTUE9OU0VfVFlQRSk7XG4gICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnRJbmZvcm1hdGlvbi5jbGllbnRfaWQpO1xuICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnY29kZV9jaGFsbGVuZ2UnLCBjb2RlQ2hhbGxlbmdlKTtcbiAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvZGVfY2hhbGxlbmdlX21ldGhvZCcsIEFVVEhPUklaQVRJT05fQ09ERV9DSEFMTEVOR0VfTUVUSE9EKTtcbiAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3JlZGlyZWN0X3VyaScsIFN0cmluZyhyZWRpcmVjdFVybCkpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3N0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgYXV0aG9yaXphdGlvblVybC5zZWFyY2hQYXJhbXMuc2V0KCdzY29wZScsIHNjb3BlKTtcbiAgICB9XG4gICAgaWYgKHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5pbmNsdWRlcygnb2ZmbGluZV9hY2Nlc3MnKSkge1xuICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCBpbmNsdWRlcyB0aGUgT0lEQy1vbmx5IFwib2ZmbGluZV9hY2Nlc3NcIiBzY29wZSxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgdGhlIHByb21wdCB0byBcImNvbnNlbnRcIiB0byBlbnN1cmUgdGhlIHVzZXIgaXMgcHJvbXB0ZWQgdG8gZ3JhbnQgb2ZmbGluZSBhY2Nlc3NcbiAgICAgICAgLy8gaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjT2ZmbGluZUFjY2Vzc1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3Byb21wdCcsICdjb25zZW50Jyk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Jlc291cmNlJywgcmVzb3VyY2UuaHJlZik7XG4gICAgfVxuICAgIHJldHVybiB7IGF1dGhvcml6YXRpb25VcmwsIGNvZGVWZXJpZmllciB9O1xufVxuLyoqXG4gKiBFeGNoYW5nZXMgYW4gYXV0aG9yaXphdGlvbiBjb2RlIGZvciBhbiBhY2Nlc3MgdG9rZW4gd2l0aCB0aGUgZ2l2ZW4gc2VydmVyLlxuICpcbiAqIFN1cHBvcnRzIG11bHRpcGxlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGFzIHNwZWNpZmllZCBpbiBPQXV0aCAyLjE6XG4gKiAtIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCBhdXRoZW50aWNhdGlvbiBtZXRob2QgYmFzZWQgb24gc2VydmVyIHN1cHBvcnRcbiAqIC0gRmFsbHMgYmFjayB0byBhcHByb3ByaWF0ZSBkZWZhdWx0cyB3aGVuIHNlcnZlciBtZXRhZGF0YSBpcyB1bmF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uU2VydmVyVXJsIC0gVGhlIGF1dGhvcml6YXRpb24gc2VydmVyJ3MgYmFzZSBVUkxcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBjbGllbnQgaW5mbywgYXV0aCBjb2RlLCBldGMuXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBPQXV0aCB0b2tlbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHRva2VuIGV4Y2hhbmdlIGZhaWxzIG9yIGF1dGhlbnRpY2F0aW9uIGlzIGludmFsaWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhjaGFuZ2VBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHsgbWV0YWRhdGEsIGNsaWVudEluZm9ybWF0aW9uLCBhdXRob3JpemF0aW9uQ29kZSwgY29kZVZlcmlmaWVyLCByZWRpcmVjdFVyaSwgcmVzb3VyY2UsIGFkZENsaWVudEF1dGhlbnRpY2F0aW9uLCBmZXRjaEZuIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZ3JhbnRUeXBlID0gJ2F1dGhvcml6YXRpb25fY29kZSc7XG4gICAgY29uc3QgdG9rZW5VcmwgPSAobWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLnRva2VuX2VuZHBvaW50KSA/IG5ldyBVUkwobWV0YWRhdGEudG9rZW5fZW5kcG9pbnQpIDogbmV3IFVSTCgnL3Rva2VuJywgYXV0aG9yaXphdGlvblNlcnZlclVybCk7XG4gICAgaWYgKChtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEuZ3JhbnRfdHlwZXNfc3VwcG9ydGVkKSAmJiAhbWV0YWRhdGEuZ3JhbnRfdHlwZXNfc3VwcG9ydGVkLmluY2x1ZGVzKGdyYW50VHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgYXV0aCBzZXJ2ZXI6IGRvZXMgbm90IHN1cHBvcnQgZ3JhbnQgdHlwZSAke2dyYW50VHlwZX1gKTtcbiAgICB9XG4gICAgLy8gRXhjaGFuZ2UgY29kZSBmb3IgdG9rZW5zXG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBncmFudF90eXBlOiBncmFudFR5cGUsXG4gICAgICAgIGNvZGU6IGF1dGhvcml6YXRpb25Db2RlLFxuICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogU3RyaW5nKHJlZGlyZWN0VXJpKVxuICAgIH0pO1xuICAgIGlmIChhZGRDbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBhZGRDbGllbnRBdXRoZW50aWNhdGlvbihoZWFkZXJzLCBwYXJhbXMsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERldGVybWluZSBhbmQgYXBwbHkgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZFxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRNZXRob2RzID0gKF9hID0gbWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gc2VsZWN0Q2xpZW50QXV0aE1ldGhvZChjbGllbnRJbmZvcm1hdGlvbiwgc3VwcG9ydGVkTWV0aG9kcyk7XG4gICAgICAgIGFwcGx5Q2xpZW50QXV0aGVudGljYXRpb24oYXV0aE1ldGhvZCwgY2xpZW50SW5mb3JtYXRpb24sIGhlYWRlcnMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICBwYXJhbXMuc2V0KCdyZXNvdXJjZScsIHJlc291cmNlLmhyZWYpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChmZXRjaEZuICE9PSBudWxsICYmIGZldGNoRm4gIT09IHZvaWQgMCA/IGZldGNoRm4gOiBmZXRjaCkodG9rZW5VcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHBhcmFtc1xuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgcGFyc2VFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhfanNfMi5PQXV0aFRva2Vuc1NjaGVtYS5wYXJzZShhd2FpdCByZXNwb25zZS5qc29uKCkpO1xufVxuLyoqXG4gKiBFeGNoYW5nZSBhIHJlZnJlc2ggdG9rZW4gZm9yIGFuIHVwZGF0ZWQgYWNjZXNzIHRva2VuLlxuICpcbiAqIFN1cHBvcnRzIG11bHRpcGxlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGFzIHNwZWNpZmllZCBpbiBPQXV0aCAyLjE6XG4gKiAtIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCBhdXRoZW50aWNhdGlvbiBtZXRob2QgYmFzZWQgb24gc2VydmVyIHN1cHBvcnRcbiAqIC0gUHJlc2VydmVzIHRoZSBvcmlnaW5hbCByZWZyZXNoIHRva2VuIGlmIGEgbmV3IG9uZSBpcyBub3QgcmV0dXJuZWRcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvblNlcnZlclVybCAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlcidzIGJhc2UgVVJMXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgY2xpZW50IGluZm8sIHJlZnJlc2ggdG9rZW4sIGV0Yy5cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIE9BdXRoIHRva2VucyAocHJlc2VydmVzIG9yaWdpbmFsIHJlZnJlc2hfdG9rZW4gaWYgbm90IHJlcGxhY2VkKVxuICogQHRocm93cyB7RXJyb3J9IFdoZW4gdG9rZW4gcmVmcmVzaCBmYWlscyBvciBhdXRoZW50aWNhdGlvbiBpcyBpbnZhbGlkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHsgbWV0YWRhdGEsIGNsaWVudEluZm9ybWF0aW9uLCByZWZyZXNoVG9rZW4sIHJlc291cmNlLCBhZGRDbGllbnRBdXRoZW50aWNhdGlvbiwgZmV0Y2hGbiB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGdyYW50VHlwZSA9ICdyZWZyZXNoX3Rva2VuJztcbiAgICBsZXQgdG9rZW5Vcmw7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIHRva2VuVXJsID0gbmV3IFVSTChtZXRhZGF0YS50b2tlbl9lbmRwb2ludCk7XG4gICAgICAgIGlmIChtZXRhZGF0YS5ncmFudF90eXBlc19zdXBwb3J0ZWQgJiYgIW1ldGFkYXRhLmdyYW50X3R5cGVzX3N1cHBvcnRlZC5pbmNsdWRlcyhncmFudFR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBhdXRoIHNlcnZlcjogZG9lcyBub3Qgc3VwcG9ydCBncmFudCB0eXBlICR7Z3JhbnRUeXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b2tlblVybCA9IG5ldyBVUkwoJy90b2tlbicsIGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwpO1xuICAgIH1cbiAgICAvLyBFeGNoYW5nZSByZWZyZXNoIHRva2VuXG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGdyYW50X3R5cGU6IGdyYW50VHlwZSxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuXG4gICAgfSk7XG4gICAgaWYgKGFkZENsaWVudEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIGFkZENsaWVudEF1dGhlbnRpY2F0aW9uKGhlYWRlcnMsIHBhcmFtcywgYXV0aG9yaXphdGlvblNlcnZlclVybCwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGFuZCBhcHBseSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZE1ldGhvZHMgPSAoX2EgPSBtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGNvbnN0IGF1dGhNZXRob2QgPSBzZWxlY3RDbGllbnRBdXRoTWV0aG9kKGNsaWVudEluZm9ybWF0aW9uLCBzdXBwb3J0ZWRNZXRob2RzKTtcbiAgICAgICAgYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbihhdXRoTWV0aG9kLCBjbGllbnRJbmZvcm1hdGlvbiwgaGVhZGVycywgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ3Jlc291cmNlJywgcmVzb3VyY2UuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGZldGNoRm4gIT09IG51bGwgJiYgZmV0Y2hGbiAhPT0gdm9pZCAwID8gZmV0Y2hGbiA6IGZldGNoKSh0b2tlblVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogcGFyYW1zXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBhd2FpdCBwYXJzZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aF9qc18yLk9BdXRoVG9rZW5zU2NoZW1hLnBhcnNlKHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLCAuLi4oYXdhaXQgcmVzcG9uc2UuanNvbigpKSB9KTtcbn1cbi8qKlxuICogUGVyZm9ybXMgT0F1dGggMi4wIER5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBhY2NvcmRpbmcgdG8gUkZDIDc1OTEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyQ2xpZW50KGF1dGhvcml6YXRpb25TZXJ2ZXJVcmwsIHsgbWV0YWRhdGEsIGNsaWVudE1ldGFkYXRhLCBmZXRjaEZuIH0pIHtcbiAgICBsZXQgcmVnaXN0cmF0aW9uVXJsO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBpZiAoIW1ldGFkYXRhLnJlZ2lzdHJhdGlvbl9lbmRwb2ludCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgYXV0aCBzZXJ2ZXI6IGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0cmF0aW9uVXJsID0gbmV3IFVSTChtZXRhZGF0YS5yZWdpc3RyYXRpb25fZW5kcG9pbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uVXJsID0gbmV3IFVSTCgnL3JlZ2lzdGVyJywgYXV0aG9yaXphdGlvblNlcnZlclVybCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGZldGNoRm4gIT09IG51bGwgJiYgZmV0Y2hGbiAhPT0gdm9pZCAwID8gZmV0Y2hGbiA6IGZldGNoKShyZWdpc3RyYXRpb25VcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2xpZW50TWV0YWRhdGEpXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBhd2FpdCBwYXJzZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aF9qc18yLk9BdXRoQ2xpZW50SW5mb3JtYXRpb25GdWxsU2NoZW1hLnBhcnNlKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoLmpzLm1hcCIsbnVsbCwibGV0IGNyeXB0bztcbmNyeXB0byA9IGdsb2JhbFRoaXMuY3J5cHRvOyAvLyB3ZWIgYnJvd3NlcnNcbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBsZW5ndGggYHNpemVgIG9mIHJhbmRvbSBieXRlc1xuICogQHBhcmFtIHNpemVcbiAqIEByZXR1cm5zIEFycmF5IG9mIHJhbmRvbSBpbnRzICgwIHRvIDI1NSlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKHNpemUpIHtcbiAgICByZXR1cm4gKGF3YWl0IGNyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbn1cbi8qKiBHZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgcmFuZG9tIHN0cmluZ1xuICogQHBhcmFtIHNpemUgVGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqIEByZXR1cm5zIFRoZSByYW5kb20gc3RyaW5nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJhbmRvbShzaXplKSB7XG4gICAgY29uc3QgbWFzayA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODktLl9+XCI7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgY29uc3QgcmFuZG9tVWludHMgPSBhd2FpdCBnZXRSYW5kb21WYWx1ZXMoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgLy8gY2FwIHRoZSB2YWx1ZSBvZiB0aGUgcmFuZG9tSW5kZXggdG8gbWFzay5sZW5ndGggLSAxXG4gICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gcmFuZG9tVWludHNbaV0gJSBtYXNrLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ICs9IG1hc2tbcmFuZG9tSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEdlbmVyYXRlIGEgUEtDRSBjaGFsbGVuZ2UgdmVyaWZpZXJcbiAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIG9mIHRoZSB2ZXJpZmllclxuICogQHJldHVybnMgQSByYW5kb20gdmVyaWZpZXIgYGxlbmd0aGAgY2hhcmFjdGVycyBsb25nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVmVyaWZpZXIobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJhbmRvbShsZW5ndGgpO1xufVxuLyoqIEdlbmVyYXRlIGEgUEtDRSBjb2RlIGNoYWxsZW5nZSBmcm9tIGEgY29kZSB2ZXJpZmllclxuICogQHBhcmFtIGNvZGVfdmVyaWZpZXJcbiAqIEByZXR1cm5zIFRoZSBiYXNlNjQgdXJsIGVuY29kZWQgY29kZSBjaGFsbGVuZ2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCAoYXdhaXQgY3J5cHRvKS5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoY29kZV92ZXJpZmllcikpO1xuICAgIC8vIEdlbmVyYXRlIGJhc2U2NHVybCBzdHJpbmdcbiAgICAvLyBidG9hIGlzIGRlcHJlY2F0ZWQgaW4gTm9kZS5qcyBidXQgaXMgdXNlZCBoZXJlIGZvciB3ZWIgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gICAgLy8gKHdoaWNoIGhhcyBubyBnb29kIHJlcGxhY2VtZW50IHlldCwgc2VlIGFsc28gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy82ODExKVxuICAgIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpO1xufVxuLyoqIEdlbmVyYXRlIGEgUEtDRSBjaGFsbGVuZ2UgcGFpclxuICogQHBhcmFtIGxlbmd0aCBMZW5ndGggb2YgdGhlIHZlcmlmZXIgKGJldHdlZW4gNDMtMTI4KS4gRGVmYXVsdHMgdG8gNDMuXG4gKiBAcmV0dXJucyBQS0NFIGNoYWxsZW5nZSBwYWlyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBrY2VDaGFsbGVuZ2UobGVuZ3RoKSB7XG4gICAgaWYgKCFsZW5ndGgpXG4gICAgICAgIGxlbmd0aCA9IDQzO1xuICAgIGlmIChsZW5ndGggPCA0MyB8fCBsZW5ndGggPiAxMjgpIHtcbiAgICAgICAgdGhyb3cgYEV4cGVjdGVkIGEgbGVuZ3RoIGJldHdlZW4gNDMgYW5kIDEyOC4gUmVjZWl2ZWQgJHtsZW5ndGh9LmA7XG4gICAgfVxuICAgIGNvbnN0IHZlcmlmaWVyID0gYXdhaXQgZ2VuZXJhdGVWZXJpZmllcihsZW5ndGgpO1xuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlQ2hhbGxlbmdlKHZlcmlmaWVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlX3ZlcmlmaWVyOiB2ZXJpZmllcixcbiAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNoYWxsZW5nZSxcbiAgICB9O1xufVxuLyoqIFZlcmlmeSB0aGF0IGEgY29kZV92ZXJpZmllciBwcm9kdWNlcyB0aGUgZXhwZWN0ZWQgY29kZSBjaGFsbGVuZ2VcbiAqIEBwYXJhbSBjb2RlX3ZlcmlmaWVyXG4gKiBAcGFyYW0gZXhwZWN0ZWRDaGFsbGVuZ2UgVGhlIGNvZGUgY2hhbGxlbmdlIHRvIHZlcmlmeVxuICogQHJldHVybnMgVHJ1ZSBpZiBjaGFsbGVuZ2VzIGFyZSBlcXVhbC4gRmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIsIGV4cGVjdGVkQ2hhbGxlbmdlKSB7XG4gICAgY29uc3QgYWN0dWFsQ2hhbGxlbmdlID0gYXdhaXQgZ2VuZXJhdGVDaGFsbGVuZ2UoY29kZV92ZXJpZmllcik7XG4gICAgcmV0dXJuIGFjdHVhbENoYWxsZW5nZSA9PT0gZXhwZWN0ZWRDaGFsbGVuZ2U7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0F1dGhUb2tlblJldm9jYXRpb25SZXF1ZXN0U2NoZW1hID0gZXhwb3J0cy5PQXV0aENsaWVudFJlZ2lzdHJhdGlvbkVycm9yU2NoZW1hID0gZXhwb3J0cy5PQXV0aENsaWVudEluZm9ybWF0aW9uRnVsbFNjaGVtYSA9IGV4cG9ydHMuT0F1dGhDbGllbnRJbmZvcm1hdGlvblNjaGVtYSA9IGV4cG9ydHMuT0F1dGhDbGllbnRNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuT0F1dGhFcnJvclJlc3BvbnNlU2NoZW1hID0gZXhwb3J0cy5PQXV0aFRva2Vuc1NjaGVtYSA9IGV4cG9ydHMuT3BlbklkUHJvdmlkZXJEaXNjb3ZlcnlNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuT3BlbklkUHJvdmlkZXJNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuT0F1dGhNZXRhZGF0YVNjaGVtYSA9IGV4cG9ydHMuT0F1dGhQcm90ZWN0ZWRSZXNvdXJjZU1ldGFkYXRhU2NoZW1hID0gZXhwb3J0cy5TYWZlVXJsU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBSZXVzYWJsZSBVUkwgdmFsaWRhdGlvbiB0aGF0IGRpc2FsbG93cyBqYXZhc2NyaXB0OiBzY2hlbWVcbiAqL1xuZXhwb3J0cy5TYWZlVXJsU2NoZW1hID0gem9kXzEuelxuICAgIC5zdHJpbmcoKVxuICAgIC51cmwoKVxuICAgIC5zdXBlclJlZmluZSgodmFsLCBjdHgpID0+IHtcbiAgICBpZiAoIVVSTC5jYW5QYXJzZSh2YWwpKSB7XG4gICAgICAgIGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICBjb2RlOiB6b2RfMS56LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICBtZXNzYWdlOiAnVVJMIG11c3QgYmUgcGFyc2VhYmxlJyxcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gem9kXzEuei5ORVZFUjtcbiAgICB9XG59KVxuICAgIC5yZWZpbmUodXJsID0+IHtcbiAgICBjb25zdCB1ID0gbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiB1LnByb3RvY29sICE9PSAnamF2YXNjcmlwdDonICYmIHUucHJvdG9jb2wgIT09ICdkYXRhOicgJiYgdS5wcm90b2NvbCAhPT0gJ3Zic2NyaXB0Oic7XG59LCB7IG1lc3NhZ2U6ICdVUkwgY2Fubm90IHVzZSBqYXZhc2NyaXB0OiwgZGF0YTosIG9yIHZic2NyaXB0OiBzY2hlbWUnIH0pO1xuLyoqXG4gKiBSRkMgOTcyOCBPQXV0aCBQcm90ZWN0ZWQgUmVzb3VyY2UgTWV0YWRhdGFcbiAqL1xuZXhwb3J0cy5PQXV0aFByb3RlY3RlZFJlc291cmNlTWV0YWRhdGFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgcmVzb3VyY2U6IHpvZF8xLnouc3RyaW5nKCkudXJsKCksXG4gICAgYXV0aG9yaXphdGlvbl9zZXJ2ZXJzOiB6b2RfMS56LmFycmF5KGV4cG9ydHMuU2FmZVVybFNjaGVtYSkub3B0aW9uYWwoKSxcbiAgICBqd2tzX3VyaTogem9kXzEuei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpLFxuICAgIHNjb3Blc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBiZWFyZXJfbWV0aG9kc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXNvdXJjZV9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVzb3VyY2VfbmFtZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHJlc291cmNlX2RvY3VtZW50YXRpb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICByZXNvdXJjZV9wb2xpY3lfdXJpOiB6b2RfMS56LnN0cmluZygpLnVybCgpLm9wdGlvbmFsKCksXG4gICAgcmVzb3VyY2VfdG9zX3VyaTogem9kXzEuei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpLFxuICAgIHRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2Vuczogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBhdXRob3JpemF0aW9uX2RldGFpbHNfdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZHBvcF9ib3VuZF9hY2Nlc3NfdG9rZW5zX3JlcXVpcmVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBSRkMgODQxNCBPQXV0aCAyLjAgQXV0aG9yaXphdGlvbiBTZXJ2ZXIgTWV0YWRhdGFcbiAqL1xuZXhwb3J0cy5PQXV0aE1ldGFkYXRhU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGlzc3Vlcjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiBleHBvcnRzLlNhZmVVcmxTY2hlbWEsXG4gICAgdG9rZW5fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYSxcbiAgICByZWdpc3RyYXRpb25fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIHNjb3Blc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXNwb25zZV90eXBlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSksXG4gICAgcmVzcG9uc2VfbW9kZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZ3JhbnRfdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHNlcnZpY2VfZG9jdW1lbnRhdGlvbjogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgcmV2b2NhdGlvbl9lbmRwb2ludDogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgcmV2b2NhdGlvbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmV2b2NhdGlvbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBpbnRyb3NwZWN0aW9uX2VuZHBvaW50OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgaW50cm9zcGVjdGlvbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgaW50cm9zcGVjdGlvbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpO1xuLyoqXG4gKiBPcGVuSUQgQ29ubmVjdCBEaXNjb3ZlcnkgMS4wIFByb3ZpZGVyIE1ldGFkYXRhXG4gKiBzZWU6IGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1kaXNjb3ZlcnktMV8wLmh0bWwjUHJvdmlkZXJNZXRhZGF0YVxuICovXG5leHBvcnRzLk9wZW5JZFByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgaXNzdWVyOiB6b2RfMS56LnN0cmluZygpLFxuICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IGV4cG9ydHMuU2FmZVVybFNjaGVtYSxcbiAgICB0b2tlbl9lbmRwb2ludDogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLFxuICAgIHVzZXJpbmZvX2VuZHBvaW50OiBleHBvcnRzLlNhZmVVcmxTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBqd2tzX3VyaTogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLFxuICAgIHJlZ2lzdHJhdGlvbl9lbmRwb2ludDogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgc2NvcGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHJlc3BvbnNlX3R5cGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKSxcbiAgICByZXNwb25zZV9tb2Rlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBncmFudF90eXBlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBhY3JfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHN1YmplY3RfdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLFxuICAgIGlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSksXG4gICAgaWRfdG9rZW5fZW5jcnlwdGlvbl9hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGlkX3Rva2VuX2VuY3J5cHRpb25fZW5jX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB1c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdXNlcmluZm9fZW5jcnlwdGlvbl9hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHVzZXJpbmZvX2VuY3J5cHRpb25fZW5jX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXF1ZXN0X29iamVjdF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9hbGdfdmFsdWVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fZW5jX3ZhbHVlc19zdXBwb3J0ZWQ6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZGlzcGxheV92YWx1ZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgY2xhaW1fdHlwZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgY2xhaW1zX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHNlcnZpY2VfZG9jdW1lbnRhdGlvbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNsYWltc19sb2NhbGVzX3N1cHBvcnRlZDogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHVpX2xvY2FsZXNfc3VwcG9ydGVkOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgY2xhaW1zX3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgcmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHJlcXVlc3RfdXJpX3BhcmFtZXRlcl9zdXBwb3J0ZWQ6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgcmVxdWlyZV9yZXF1ZXN0X3VyaV9yZWdpc3RyYXRpb246IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgb3BfcG9saWN5X3VyaTogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgb3BfdG9zX3VyaTogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKClcbn0pXG4gICAgLnBhc3N0aHJvdWdoKCk7XG4vKipcbiAqIE9wZW5JRCBDb25uZWN0IERpc2NvdmVyeSBtZXRhZGF0YSB0aGF0IG1heSBpbmNsdWRlIE9BdXRoIDIuMCBmaWVsZHNcbiAqIFRoaXMgc2NoZW1hIHJlcHJlc2VudHMgdGhlIHJlYWwtd29ybGQgc2NlbmFyaW8gd2hlcmUgT0lEQyBwcm92aWRlcnNcbiAqIHJldHVybiBhIG1peCBvZiBPcGVuSUQgQ29ubmVjdCBhbmQgT0F1dGggMi4wIG1ldGFkYXRhIGZpZWxkc1xuICovXG5leHBvcnRzLk9wZW5JZFByb3ZpZGVyRGlzY292ZXJ5TWV0YWRhdGFTY2hlbWEgPSBleHBvcnRzLk9wZW5JZFByb3ZpZGVyTWV0YWRhdGFTY2hlbWEubWVyZ2UoZXhwb3J0cy5PQXV0aE1ldGFkYXRhU2NoZW1hLnBpY2soe1xuICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkOiB0cnVlXG59KSk7XG4vKipcbiAqIE9BdXRoIDIuMSB0b2tlbiByZXNwb25zZVxuICovXG5leHBvcnRzLk9BdXRoVG9rZW5zU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGFjY2Vzc190b2tlbjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBpZF90b2tlbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLCAvLyBPcHRpb25hbCBmb3IgT0F1dGggMi4xLCBidXQgbmVjZXNzYXJ5IGluIE9wZW5JRCBDb25uZWN0XG4gICAgdG9rZW5fdHlwZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICBleHBpcmVzX2luOiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgc2NvcGU6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICByZWZyZXNoX3Rva2VuOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pXG4gICAgLnN0cmlwKCk7XG4vKipcbiAqIE9BdXRoIDIuMSBlcnJvciByZXNwb25zZVxuICovXG5leHBvcnRzLk9BdXRoRXJyb3JSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBlcnJvcjogem9kXzEuei5zdHJpbmcoKSxcbiAgICBlcnJvcl9kZXNjcmlwdGlvbjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yX3VyaTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcbi8qKlxuICogUkZDIDc1OTEgT0F1dGggMi4wIER5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBtZXRhZGF0YVxuICovXG5leHBvcnRzLk9BdXRoQ2xpZW50TWV0YWRhdGFTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgcmVkaXJlY3RfdXJpczogem9kXzEuei5hcnJheShleHBvcnRzLlNhZmVVcmxTY2hlbWEpLFxuICAgIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZ3JhbnRfdHlwZXM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICByZXNwb25zZV90eXBlczogem9kXzEuei5hcnJheSh6b2RfMS56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGNsaWVudF9uYW1lOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY2xpZW50X3VyaTogZXhwb3J0cy5TYWZlVXJsU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgbG9nb191cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIHNjb3BlOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29udGFjdHM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB0b3NfdXJpOiBleHBvcnRzLlNhZmVVcmxTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBwb2xpY3lfdXJpOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgandrc191cmk6IGV4cG9ydHMuU2FmZVVybFNjaGVtYS5vcHRpb25hbCgpLFxuICAgIGp3a3M6IHpvZF8xLnouYW55KCkub3B0aW9uYWwoKSxcbiAgICBzb2Z0d2FyZV9pZDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHNvZnR3YXJlX3ZlcnNpb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBzb2Z0d2FyZV9zdGF0ZW1lbnQ6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKVxufSlcbiAgICAuc3RyaXAoKTtcbi8qKlxuICogUkZDIDc1OTEgT0F1dGggMi4wIER5bmFtaWMgQ2xpZW50IFJlZ2lzdHJhdGlvbiBjbGllbnQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0cy5PQXV0aENsaWVudEluZm9ybWF0aW9uU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGNsaWVudF9pZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICBjbGllbnRfc2VjcmV0OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY2xpZW50X2lkX2lzc3VlZF9hdDogem9kXzEuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGNsaWVudF9zZWNyZXRfZXhwaXJlc19hdDogem9kXzEuei5udW1iZXIoKS5vcHRpb25hbCgpXG59KVxuICAgIC5zdHJpcCgpO1xuLyoqXG4gKiBSRkMgNzU5MSBPQXV0aCAyLjAgRHluYW1pYyBDbGllbnQgUmVnaXN0cmF0aW9uIGZ1bGwgcmVzcG9uc2UgKGNsaWVudCBpbmZvcm1hdGlvbiBwbHVzIG1ldGFkYXRhKVxuICovXG5leHBvcnRzLk9BdXRoQ2xpZW50SW5mb3JtYXRpb25GdWxsU2NoZW1hID0gZXhwb3J0cy5PQXV0aENsaWVudE1ldGFkYXRhU2NoZW1hLm1lcmdlKGV4cG9ydHMuT0F1dGhDbGllbnRJbmZvcm1hdGlvblNjaGVtYSk7XG4vKipcbiAqIFJGQyA3NTkxIE9BdXRoIDIuMCBEeW5hbWljIENsaWVudCBSZWdpc3RyYXRpb24gZXJyb3IgcmVzcG9uc2VcbiAqL1xuZXhwb3J0cy5PQXV0aENsaWVudFJlZ2lzdHJhdGlvbkVycm9yU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLFxuICAgIGVycm9yX2Rlc2NyaXB0aW9uOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pXG4gICAgLnN0cmlwKCk7XG4vKipcbiAqIFJGQyA3MDA5IE9BdXRoIDIuMCBUb2tlbiBSZXZvY2F0aW9uIHJlcXVlc3RcbiAqL1xuZXhwb3J0cy5PQXV0aFRva2VuUmV2b2NhdGlvblJlcXVlc3RTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdG9rZW46IHpvZF8xLnouc3RyaW5nKCksXG4gICAgdG9rZW5fdHlwZV9oaW50OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKClcbn0pXG4gICAgLnN0cmlwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoLmpzLm1hcCIsbnVsbCwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgaGFuZGxpbmcgT0F1dGggcmVzb3VyY2UgVVJJcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvdXJjZVVybEZyb21TZXJ2ZXJVcmwgPSByZXNvdXJjZVVybEZyb21TZXJ2ZXJVcmw7XG5leHBvcnRzLmNoZWNrUmVzb3VyY2VBbGxvd2VkID0gY2hlY2tSZXNvdXJjZUFsbG93ZWQ7XG4vKipcbiAqIENvbnZlcnRzIGEgc2VydmVyIFVSTCB0byBhIHJlc291cmNlIFVSTCBieSByZW1vdmluZyB0aGUgZnJhZ21lbnQuXG4gKiBSRkMgODcwNyBzZWN0aW9uIDIgc3RhdGVzIHRoYXQgcmVzb3VyY2UgVVJJcyBcIk1VU1QgTk9UIGluY2x1ZGUgYSBmcmFnbWVudCBjb21wb25lbnRcIi5cbiAqIEtlZXBzIGV2ZXJ5dGhpbmcgZWxzZSB1bmNoYW5nZWQgKHNjaGVtZSwgZG9tYWluLCBwb3J0LCBwYXRoLCBxdWVyeSkuXG4gKi9cbmZ1bmN0aW9uIHJlc291cmNlVXJsRnJvbVNlcnZlclVybCh1cmwpIHtcbiAgICBjb25zdCByZXNvdXJjZVVSTCA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gbmV3IFVSTCh1cmwpIDogbmV3IFVSTCh1cmwuaHJlZik7XG4gICAgcmVzb3VyY2VVUkwuaGFzaCA9ICcnOyAvLyBSZW1vdmUgZnJhZ21lbnRcbiAgICByZXR1cm4gcmVzb3VyY2VVUkw7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHJlcXVlc3RlZCByZXNvdXJjZSBVUkwgbWF0Y2hlcyBhIGNvbmZpZ3VyZWQgcmVzb3VyY2UgVVJMLlxuICogQSByZXF1ZXN0ZWQgcmVzb3VyY2UgbWF0Y2hlcyBpZiBpdCBoYXMgdGhlIHNhbWUgc2NoZW1lLCBkb21haW4sIHBvcnQsXG4gKiBhbmQgaXRzIHBhdGggc3RhcnRzIHdpdGggdGhlIGNvbmZpZ3VyZWQgcmVzb3VyY2UncyBwYXRoLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0ZWRSZXNvdXJjZSBUaGUgcmVzb3VyY2UgVVJMIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIGNvbmZpZ3VyZWRSZXNvdXJjZSBUaGUgcmVzb3VyY2UgVVJMIHRoYXQgaGFzIGJlZW4gY29uZmlndXJlZFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdGVkIHJlc291cmNlIG1hdGNoZXMgdGhlIGNvbmZpZ3VyZWQgcmVzb3VyY2UsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjaGVja1Jlc291cmNlQWxsb3dlZCh7IHJlcXVlc3RlZFJlc291cmNlLCBjb25maWd1cmVkUmVzb3VyY2UgfSkge1xuICAgIGNvbnN0IHJlcXVlc3RlZCA9IHR5cGVvZiByZXF1ZXN0ZWRSZXNvdXJjZSA9PT0gJ3N0cmluZycgPyBuZXcgVVJMKHJlcXVlc3RlZFJlc291cmNlKSA6IG5ldyBVUkwocmVxdWVzdGVkUmVzb3VyY2UuaHJlZik7XG4gICAgY29uc3QgY29uZmlndXJlZCA9IHR5cGVvZiBjb25maWd1cmVkUmVzb3VyY2UgPT09ICdzdHJpbmcnID8gbmV3IFVSTChjb25maWd1cmVkUmVzb3VyY2UpIDogbmV3IFVSTChjb25maWd1cmVkUmVzb3VyY2UuaHJlZik7XG4gICAgLy8gQ29tcGFyZSB0aGUgb3JpZ2luIChzY2hlbWUsIGRvbWFpbiwgYW5kIHBvcnQpXG4gICAgaWYgKHJlcXVlc3RlZC5vcmlnaW4gIT09IGNvbmZpZ3VyZWQub3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNhc2VzIGxpa2UgcmVxdWVzdGVkPS9mb28gYW5kIGNvbmZpZ3VyZWQ9L2Zvby9cbiAgICBpZiAocmVxdWVzdGVkLnBhdGhuYW1lLmxlbmd0aCA8IGNvbmZpZ3VyZWQucGF0aG5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCBwYXRoIHN0YXJ0cyB3aXRoIHRoZSBjb25maWd1cmVkIHBhdGhcbiAgICAvLyBFbnN1cmUgYm90aCBwYXRocyBlbmQgd2l0aCAvIGZvciBwcm9wZXIgY29tcGFyaXNvblxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHdlIGhhdmUgcGF0aHMgbGlrZSBcIi9hcGlcIiBhbmQgXCIvYXBpL3VzZXJzXCIsXG4gICAgLy8gd2UgcHJvcGVybHkgZGV0ZWN0IHRoYXQgXCIvYXBpL3VzZXJzXCIgaXMgYSBzdWJwYXRoIG9mIFwiL2FwaVwiXG4gICAgLy8gQnkgYWRkaW5nIGEgdHJhaWxpbmcgc2xhc2ggaWYgbWlzc2luZywgd2UgYXZvaWQgZmFsc2UgcG9zaXRpdmVzXG4gICAgLy8gd2hlcmUgcGF0aHMgbGlrZSBcIi9hcGkxMjNcIiB3b3VsZCBpbmNvcnJlY3RseSBtYXRjaCBcIi9hcGlcIlxuICAgIGNvbnN0IHJlcXVlc3RlZFBhdGggPSByZXF1ZXN0ZWQucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSA/IHJlcXVlc3RlZC5wYXRobmFtZSA6IHJlcXVlc3RlZC5wYXRobmFtZSArICcvJztcbiAgICBjb25zdCBjb25maWd1cmVkUGF0aCA9IGNvbmZpZ3VyZWQucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSA/IGNvbmZpZ3VyZWQucGF0aG5hbWUgOiBjb25maWd1cmVkLnBhdGhuYW1lICsgJy8nO1xuICAgIHJldHVybiByZXF1ZXN0ZWRQYXRoLnN0YXJ0c1dpdGgoY29uZmlndXJlZFBhdGgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC11dGlscy5qcy5tYXAiLG51bGwsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PQVVUSF9FUlJPUlMgPSBleHBvcnRzLkN1c3RvbU9BdXRoRXJyb3IgPSBleHBvcnRzLkluc3VmZmljaWVudFNjb3BlRXJyb3IgPSBleHBvcnRzLkludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yID0gZXhwb3J0cy5Ub29NYW55UmVxdWVzdHNFcnJvciA9IGV4cG9ydHMuTWV0aG9kTm90QWxsb3dlZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVG9rZW5FcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRUb2tlblR5cGVFcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRSZXNwb25zZVR5cGVFcnJvciA9IGV4cG9ydHMuVGVtcG9yYXJpbHlVbmF2YWlsYWJsZUVycm9yID0gZXhwb3J0cy5TZXJ2ZXJFcnJvciA9IGV4cG9ydHMuQWNjZXNzRGVuaWVkRXJyb3IgPSBleHBvcnRzLkludmFsaWRTY29wZUVycm9yID0gZXhwb3J0cy5VbnN1cHBvcnRlZEdyYW50VHlwZUVycm9yID0gZXhwb3J0cy5VbmF1dGhvcml6ZWRDbGllbnRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEdyYW50RXJyb3IgPSBleHBvcnRzLkludmFsaWRDbGllbnRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFJlcXVlc3RFcnJvciA9IGV4cG9ydHMuT0F1dGhFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIE9BdXRoIGVycm9yc1xuICovXG5jbGFzcyBPQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yVXJpKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVycm9yVXJpID0gZXJyb3JVcmk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGVycm9yIHRvIGEgc3RhbmRhcmQgT0F1dGggZXJyb3IgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICovXG4gICAgdG9SZXNwb25zZU9iamVjdCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvckNvZGUsXG4gICAgICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmVycm9yVXJpKSB7XG4gICAgICAgICAgICByZXNwb25zZS5lcnJvcl91cmkgPSB0aGlzLmVycm9yVXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgZ2V0IGVycm9yQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZXJyb3JDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuT0F1dGhFcnJvciA9IE9BdXRoRXJyb3I7XG4vKipcbiAqIEludmFsaWQgcmVxdWVzdCBlcnJvciAtIFRoZSByZXF1ZXN0IGlzIG1pc3NpbmcgYSByZXF1aXJlZCBwYXJhbWV0ZXIsXG4gKiBpbmNsdWRlcyBhbiBpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZSwgaW5jbHVkZXMgYSBwYXJhbWV0ZXIgbW9yZSB0aGFuIG9uY2UsXG4gKiBvciBpcyBvdGhlcndpc2UgbWFsZm9ybWVkLlxuICovXG5jbGFzcyBJbnZhbGlkUmVxdWVzdEVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRSZXF1ZXN0RXJyb3IgPSBJbnZhbGlkUmVxdWVzdEVycm9yO1xuSW52YWxpZFJlcXVlc3RFcnJvci5lcnJvckNvZGUgPSAnaW52YWxpZF9yZXF1ZXN0Jztcbi8qKlxuICogSW52YWxpZCBjbGllbnQgZXJyb3IgLSBDbGllbnQgYXV0aGVudGljYXRpb24gZmFpbGVkIChlLmcuLCB1bmtub3duIGNsaWVudCwgbm8gY2xpZW50XG4gKiBhdXRoZW50aWNhdGlvbiBpbmNsdWRlZCwgb3IgdW5zdXBwb3J0ZWQgYXV0aGVudGljYXRpb24gbWV0aG9kKS5cbiAqL1xuY2xhc3MgSW52YWxpZENsaWVudEVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRDbGllbnRFcnJvciA9IEludmFsaWRDbGllbnRFcnJvcjtcbkludmFsaWRDbGllbnRFcnJvci5lcnJvckNvZGUgPSAnaW52YWxpZF9jbGllbnQnO1xuLyoqXG4gKiBJbnZhbGlkIGdyYW50IGVycm9yIC0gVGhlIHByb3ZpZGVkIGF1dGhvcml6YXRpb24gZ3JhbnQgb3IgcmVmcmVzaCB0b2tlbiBpc1xuICogaW52YWxpZCwgZXhwaXJlZCwgcmV2b2tlZCwgZG9lcyBub3QgbWF0Y2ggdGhlIHJlZGlyZWN0aW9uIFVSSSB1c2VkIGluIHRoZVxuICogYXV0aG9yaXphdGlvbiByZXF1ZXN0LCBvciB3YXMgaXNzdWVkIHRvIGFub3RoZXIgY2xpZW50LlxuICovXG5jbGFzcyBJbnZhbGlkR3JhbnRFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkR3JhbnRFcnJvciA9IEludmFsaWRHcmFudEVycm9yO1xuSW52YWxpZEdyYW50RXJyb3IuZXJyb3JDb2RlID0gJ2ludmFsaWRfZ3JhbnQnO1xuLyoqXG4gKiBVbmF1dGhvcml6ZWQgY2xpZW50IGVycm9yIC0gVGhlIGF1dGhlbnRpY2F0ZWQgY2xpZW50IGlzIG5vdCBhdXRob3JpemVkIHRvIHVzZVxuICogdGhpcyBhdXRob3JpemF0aW9uIGdyYW50IHR5cGUuXG4gKi9cbmNsYXNzIFVuYXV0aG9yaXplZENsaWVudEVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLlVuYXV0aG9yaXplZENsaWVudEVycm9yID0gVW5hdXRob3JpemVkQ2xpZW50RXJyb3I7XG5VbmF1dGhvcml6ZWRDbGllbnRFcnJvci5lcnJvckNvZGUgPSAndW5hdXRob3JpemVkX2NsaWVudCc7XG4vKipcbiAqIFVuc3VwcG9ydGVkIGdyYW50IHR5cGUgZXJyb3IgLSBUaGUgYXV0aG9yaXphdGlvbiBncmFudCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqIGJ5IHRoZSBhdXRob3JpemF0aW9uIHNlcnZlci5cbiAqL1xuY2xhc3MgVW5zdXBwb3J0ZWRHcmFudFR5cGVFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5VbnN1cHBvcnRlZEdyYW50VHlwZUVycm9yID0gVW5zdXBwb3J0ZWRHcmFudFR5cGVFcnJvcjtcblVuc3VwcG9ydGVkR3JhbnRUeXBlRXJyb3IuZXJyb3JDb2RlID0gJ3Vuc3VwcG9ydGVkX2dyYW50X3R5cGUnO1xuLyoqXG4gKiBJbnZhbGlkIHNjb3BlIGVycm9yIC0gVGhlIHJlcXVlc3RlZCBzY29wZSBpcyBpbnZhbGlkLCB1bmtub3duLCBtYWxmb3JtZWQsIG9yXG4gKiBleGNlZWRzIHRoZSBzY29wZSBncmFudGVkIGJ5IHRoZSByZXNvdXJjZSBvd25lci5cbiAqL1xuY2xhc3MgSW52YWxpZFNjb3BlRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFNjb3BlRXJyb3IgPSBJbnZhbGlkU2NvcGVFcnJvcjtcbkludmFsaWRTY29wZUVycm9yLmVycm9yQ29kZSA9ICdpbnZhbGlkX3Njb3BlJztcbi8qKlxuICogQWNjZXNzIGRlbmllZCBlcnJvciAtIFRoZSByZXNvdXJjZSBvd25lciBvciBhdXRob3JpemF0aW9uIHNlcnZlciBkZW5pZWQgdGhlIHJlcXVlc3QuXG4gKi9cbmNsYXNzIEFjY2Vzc0RlbmllZEVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkFjY2Vzc0RlbmllZEVycm9yID0gQWNjZXNzRGVuaWVkRXJyb3I7XG5BY2Nlc3NEZW5pZWRFcnJvci5lcnJvckNvZGUgPSAnYWNjZXNzX2RlbmllZCc7XG4vKipcbiAqIFNlcnZlciBlcnJvciAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlciBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGNvbmRpdGlvblxuICogdGhhdCBwcmV2ZW50ZWQgaXQgZnJvbSBmdWxmaWxsaW5nIHRoZSByZXF1ZXN0LlxuICovXG5jbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5TZXJ2ZXJFcnJvciA9IFNlcnZlckVycm9yO1xuU2VydmVyRXJyb3IuZXJyb3JDb2RlID0gJ3NlcnZlcl9lcnJvcic7XG4vKipcbiAqIFRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlIGVycm9yIC0gVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIGlzIGN1cnJlbnRseSB1bmFibGUgdG9cbiAqIGhhbmRsZSB0aGUgcmVxdWVzdCBkdWUgdG8gYSB0ZW1wb3Jhcnkgb3ZlcmxvYWRpbmcgb3IgbWFpbnRlbmFuY2Ugb2YgdGhlIHNlcnZlci5cbiAqL1xuY2xhc3MgVGVtcG9yYXJpbHlVbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLlRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvciA9IFRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvcjtcblRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvci5lcnJvckNvZGUgPSAndGVtcG9yYXJpbHlfdW5hdmFpbGFibGUnO1xuLyoqXG4gKiBVbnN1cHBvcnRlZCByZXNwb25zZSB0eXBlIGVycm9yIC0gVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIGRvZXMgbm90IHN1cHBvcnRcbiAqIG9idGFpbmluZyBhbiBhdXRob3JpemF0aW9uIGNvZGUgdXNpbmcgdGhpcyBtZXRob2QuXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkUmVzcG9uc2VUeXBlRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRSZXNwb25zZVR5cGVFcnJvciA9IFVuc3VwcG9ydGVkUmVzcG9uc2VUeXBlRXJyb3I7XG5VbnN1cHBvcnRlZFJlc3BvbnNlVHlwZUVycm9yLmVycm9yQ29kZSA9ICd1bnN1cHBvcnRlZF9yZXNwb25zZV90eXBlJztcbi8qKlxuICogVW5zdXBwb3J0ZWQgdG9rZW4gdHlwZSBlcnJvciAtIFRoZSBhdXRob3JpemF0aW9uIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgcmVxdWVzdGVkIHRva2VuIHR5cGUuXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkVG9rZW5UeXBlRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRUb2tlblR5cGVFcnJvciA9IFVuc3VwcG9ydGVkVG9rZW5UeXBlRXJyb3I7XG5VbnN1cHBvcnRlZFRva2VuVHlwZUVycm9yLmVycm9yQ29kZSA9ICd1bnN1cHBvcnRlZF90b2tlbl90eXBlJztcbi8qKlxuICogSW52YWxpZCB0b2tlbiBlcnJvciAtIFRoZSBhY2Nlc3MgdG9rZW4gcHJvdmlkZWQgaXMgZXhwaXJlZCwgcmV2b2tlZCwgbWFsZm9ybWVkLFxuICogb3IgaW52YWxpZCBmb3Igb3RoZXIgcmVhc29ucy5cbiAqL1xuY2xhc3MgSW52YWxpZFRva2VuRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFRva2VuRXJyb3IgPSBJbnZhbGlkVG9rZW5FcnJvcjtcbkludmFsaWRUb2tlbkVycm9yLmVycm9yQ29kZSA9ICdpbnZhbGlkX3Rva2VuJztcbi8qKlxuICogTWV0aG9kIG5vdCBhbGxvd2VkIGVycm9yIC0gVGhlIEhUVFAgbWV0aG9kIHVzZWQgaXMgbm90IGFsbG93ZWQgZm9yIHRoaXMgZW5kcG9pbnQuXG4gKiAoQ3VzdG9tLCBub24tc3RhbmRhcmQgZXJyb3IpXG4gKi9cbmNsYXNzIE1ldGhvZE5vdEFsbG93ZWRFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xufVxuZXhwb3J0cy5NZXRob2ROb3RBbGxvd2VkRXJyb3IgPSBNZXRob2ROb3RBbGxvd2VkRXJyb3I7XG5NZXRob2ROb3RBbGxvd2VkRXJyb3IuZXJyb3JDb2RlID0gJ21ldGhvZF9ub3RfYWxsb3dlZCc7XG4vKipcbiAqIFRvbyBtYW55IHJlcXVlc3RzIGVycm9yIC0gUmF0ZSBsaW1pdCBleGNlZWRlZC5cbiAqIChDdXN0b20sIG5vbi1zdGFuZGFyZCBlcnJvciBiYXNlZCBvbiBSRkMgNjU4NSlcbiAqL1xuY2xhc3MgVG9vTWFueVJlcXVlc3RzRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuVG9vTWFueVJlcXVlc3RzRXJyb3IgPSBUb29NYW55UmVxdWVzdHNFcnJvcjtcblRvb01hbnlSZXF1ZXN0c0Vycm9yLmVycm9yQ29kZSA9ICd0b29fbWFueV9yZXF1ZXN0cyc7XG4vKipcbiAqIEludmFsaWQgY2xpZW50IG1ldGFkYXRhIGVycm9yIC0gVGhlIGNsaWVudCBtZXRhZGF0YSBpcyBpbnZhbGlkLlxuICogKEN1c3RvbSBlcnJvciBmb3IgZHluYW1pYyBjbGllbnQgcmVnaXN0cmF0aW9uIC0gUkZDIDc1OTEpXG4gKi9cbmNsYXNzIEludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yIGV4dGVuZHMgT0F1dGhFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRDbGllbnRNZXRhZGF0YUVycm9yID0gSW52YWxpZENsaWVudE1ldGFkYXRhRXJyb3I7XG5JbnZhbGlkQ2xpZW50TWV0YWRhdGFFcnJvci5lcnJvckNvZGUgPSAnaW52YWxpZF9jbGllbnRfbWV0YWRhdGEnO1xuLyoqXG4gKiBJbnN1ZmZpY2llbnQgc2NvcGUgZXJyb3IgLSBUaGUgcmVxdWVzdCByZXF1aXJlcyBoaWdoZXIgcHJpdmlsZWdlcyB0aGFuIHByb3ZpZGVkIGJ5IHRoZSBhY2Nlc3MgdG9rZW4uXG4gKi9cbmNsYXNzIEluc3VmZmljaWVudFNjb3BlRXJyb3IgZXh0ZW5kcyBPQXV0aEVycm9yIHtcbn1cbmV4cG9ydHMuSW5zdWZmaWNpZW50U2NvcGVFcnJvciA9IEluc3VmZmljaWVudFNjb3BlRXJyb3I7XG5JbnN1ZmZpY2llbnRTY29wZUVycm9yLmVycm9yQ29kZSA9ICdpbnN1ZmZpY2llbnRfc2NvcGUnO1xuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIGRlZmluaW5nIG9uZS1vZmYgZXJyb3IgY29kZXNcbiAqL1xuY2xhc3MgQ3VzdG9tT0F1dGhFcnJvciBleHRlbmRzIE9BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGN1c3RvbUVycm9yQ29kZSwgbWVzc2FnZSwgZXJyb3JVcmkpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgZXJyb3JVcmkpO1xuICAgICAgICB0aGlzLmN1c3RvbUVycm9yQ29kZSA9IGN1c3RvbUVycm9yQ29kZTtcbiAgICB9XG4gICAgZ2V0IGVycm9yQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRXJyb3JDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VzdG9tT0F1dGhFcnJvciA9IEN1c3RvbU9BdXRoRXJyb3I7XG4vKipcbiAqIEEgZnVsbCBsaXN0IG9mIGFsbCBPQXV0aEVycm9ycywgZW5hYmxpbmcgcGFyc2luZyBmcm9tIGVycm9yIHJlc3BvbnNlc1xuICovXG5leHBvcnRzLk9BVVRIX0VSUk9SUyA9IHtcbiAgICBbSW52YWxpZFJlcXVlc3RFcnJvci5lcnJvckNvZGVdOiBJbnZhbGlkUmVxdWVzdEVycm9yLFxuICAgIFtJbnZhbGlkQ2xpZW50RXJyb3IuZXJyb3JDb2RlXTogSW52YWxpZENsaWVudEVycm9yLFxuICAgIFtJbnZhbGlkR3JhbnRFcnJvci5lcnJvckNvZGVdOiBJbnZhbGlkR3JhbnRFcnJvcixcbiAgICBbVW5hdXRob3JpemVkQ2xpZW50RXJyb3IuZXJyb3JDb2RlXTogVW5hdXRob3JpemVkQ2xpZW50RXJyb3IsXG4gICAgW1Vuc3VwcG9ydGVkR3JhbnRUeXBlRXJyb3IuZXJyb3JDb2RlXTogVW5zdXBwb3J0ZWRHcmFudFR5cGVFcnJvcixcbiAgICBbSW52YWxpZFNjb3BlRXJyb3IuZXJyb3JDb2RlXTogSW52YWxpZFNjb3BlRXJyb3IsXG4gICAgW0FjY2Vzc0RlbmllZEVycm9yLmVycm9yQ29kZV06IEFjY2Vzc0RlbmllZEVycm9yLFxuICAgIFtTZXJ2ZXJFcnJvci5lcnJvckNvZGVdOiBTZXJ2ZXJFcnJvcixcbiAgICBbVGVtcG9yYXJpbHlVbmF2YWlsYWJsZUVycm9yLmVycm9yQ29kZV06IFRlbXBvcmFyaWx5VW5hdmFpbGFibGVFcnJvcixcbiAgICBbVW5zdXBwb3J0ZWRSZXNwb25zZVR5cGVFcnJvci5lcnJvckNvZGVdOiBVbnN1cHBvcnRlZFJlc3BvbnNlVHlwZUVycm9yLFxuICAgIFtVbnN1cHBvcnRlZFRva2VuVHlwZUVycm9yLmVycm9yQ29kZV06IFVuc3VwcG9ydGVkVG9rZW5UeXBlRXJyb3IsXG4gICAgW0ludmFsaWRUb2tlbkVycm9yLmVycm9yQ29kZV06IEludmFsaWRUb2tlbkVycm9yLFxuICAgIFtNZXRob2ROb3RBbGxvd2VkRXJyb3IuZXJyb3JDb2RlXTogTWV0aG9kTm90QWxsb3dlZEVycm9yLFxuICAgIFtUb29NYW55UmVxdWVzdHNFcnJvci5lcnJvckNvZGVdOiBUb29NYW55UmVxdWVzdHNFcnJvcixcbiAgICBbSW52YWxpZENsaWVudE1ldGFkYXRhRXJyb3IuZXJyb3JDb2RlXTogSW52YWxpZENsaWVudE1ldGFkYXRhRXJyb3IsXG4gICAgW0luc3VmZmljaWVudFNjb3BlRXJyb3IuZXJyb3JDb2RlXTogSW5zdWZmaWNpZW50U2NvcGVFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLG51bGwsIi8qKlxyXG4gKiBOb3Rpb24gTUNQIFNTRSBDbGllbnRcclxuICogSGFuZGxlcyBTZXJ2ZXItU2VudCBFdmVudHMgY29ubmVjdGlvbiB0byBOb3Rpb24ncyBob3N0ZWQgTUNQIHNlcnZlclxyXG4gKi9cclxuXHJcbmltcG9ydCB7IE5PVElPTl9DT05GSUcgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgICBNY3BNZXNzYWdlLFxyXG4gICAgTWNwSW5pdGlhbGl6ZVJlcXVlc3QsXHJcbiAgICBNY3BUb29sc0xpc3RSZXNwb25zZSxcclxuICAgIE1jcFRvb2xDYWxsUmVxdWVzdCxcclxuICAgIE5vdGlvbk1jcFN0YXR1cyxcclxuICAgIE1jcENvbm5lY3Rpb25TdGF0ZVxyXG59IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIEV2ZW50U291cmNlLWxpa2UgaW50ZXJmYWNlIGZvciBTU0UgaW4gZXh0ZW5zaW9uIGNvbnRleHRcclxuICogQ2hyb21lIGV4dGVuc2lvbnMgbmVlZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBTU0VcclxuICovXHJcbmNsYXNzIE1jcFNTRUNsaWVudCB7XHJcbiAgICBwcml2YXRlIHNzZVVybDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBhY2Nlc3NUb2tlbjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBzZXNzaW9uSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBNQ1Agc2Vzc2lvbiBJRCBmcm9tIGluaXRpYWxpemF0aW9uXHJcbiAgICBwcml2YXRlIHNzZVNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7IC8vIFNTRSBzdHJlYW0gc2Vzc2lvbiBJRCBmb3IgcmVzdW1hYmlsaXR5XHJcbiAgICBwcml2YXRlIG1lc3NhZ2VFbmRwb2ludDogc3RyaW5nIHwgbnVsbCA9IG51bGw7IC8vIFBPU1QgZW5kcG9pbnQgZnJvbSBTU0UgJ2VuZHBvaW50JyBldmVudFxyXG4gICAgcHJpdmF0ZSBldmVudFNvdXJjZTogRXZlbnRTb3VyY2UgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgcHJpdmF0ZSByZWNvbm5lY3RUaW1lb3V0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgbWVzc2FnZUlkID0gMDtcclxuICAgIHByaXZhdGUgcGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcDxzdHJpbmcgfCBudW1iZXIsIHtcclxuICAgICAgICByZXNvbHZlOiAodmFsdWU6IGFueSkgPT4gdm9pZDtcclxuICAgICAgICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkO1xyXG4gICAgfT4oKTtcclxuXHJcbiAgICBwcml2YXRlIG9uU3RhdHVzQ2hhbmdlOiAoc3RhdHVzOiBOb3Rpb25NY3BTdGF0dXMpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIG9uTWVzc2FnZTogKG1lc3NhZ2U6IE1jcE1lc3NhZ2UpID0+IHZvaWQ7XHJcblxyXG4gICAgcHJpdmF0ZSBjdXJyZW50U3RhdHVzOiBOb3Rpb25NY3BTdGF0dXMgPSB7XHJcbiAgICAgICAgc3RhdGU6ICdkaXNjb25uZWN0ZWQnXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHNzZVVybDogc3RyaW5nLFxyXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmcsXHJcbiAgICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgICAgIG9uU3RhdHVzQ2hhbmdlOiAoc3RhdHVzOiBOb3Rpb25NY3BTdGF0dXMpID0+IHZvaWQ7XHJcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2U6IE1jcE1lc3NhZ2UpID0+IHZvaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5zc2VVcmwgPSBzc2VVcmw7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIHRoaXMub25TdGF0dXNDaGFuZ2UgPSBjYWxsYmFja3Mub25TdGF0dXNDaGFuZ2U7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBjYWxsYmFja3Mub25NZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdCB0byB0aGUgU1NFIGVuZHBvaW50XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2Nvbm5lY3RpbmcnKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRm9yIE1WMyBleHRlbnNpb25zLCB3ZSBuZWVkIHRvIHVzZSBmZXRjaCB3aXRoIFJlYWRhYmxlU3RyZWFtXHJcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgRXZlbnRTb3VyY2UgZHVlIHRvIENTUCByZXN0cmljdGlvbnNcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0V2l0aEZldGNoKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdlcnJvcicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Nvbm5lY3Rpb24gZmFpbGVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHVzaW5nIGZldGNoIGFuZCBSZWFkYWJsZVN0cmVhbSAoTVYzIGNvbXBhdGlibGUpXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgY29ubmVjdFdpdGhGZXRjaCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gQ29ubmVjdGluZyB0byBTU0UgZW5kcG9pbnQ6JywgdGhpcy5zc2VVcmwpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBVc2luZyBhY2Nlc3MgdG9rZW4gKGZpcnN0IDIwIGNoYXJzKTonLCB0aGlzLmFjY2Vzc1Rva2VuLnN1YnN0cmluZygwLCAyMCkgKyAnLi4uJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnNzZVVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFjY2Vzc1Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtLCBhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcclxuICAgICAgICAgICAgICAgICdNQ1AtUHJvdG9jb2wtVmVyc2lvbic6ICcyMDI1LTA2LTE4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTU0UgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNTRSByZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gU1NFIGNvbm5lY3Rpb24gZmFpbGVkOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgZXJyb3IgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBmb3JtYXQgYW5kIGV4cGlyeSBpc3N1ZXNcclxuICAgICAgICAgICAgICAgIGxldCBlcnJvckRhdGE7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGF0YSA9IHsgZXJyb3I6ICd1bmtub3duJywgZXJyb3JfZGVzY3JpcHRpb246IGVycm9yVGV4dCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JEYXRhLmVycm9yID09PSAnaW52YWxpZF90b2tlbicgJiYgZXJyb3JEYXRhLmVycm9yX2Rlc2NyaXB0aW9uPy5pbmNsdWRlcygnSW52YWxpZCB0b2tlbiBmb3JtYXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRva2VuIGZvcm1hdCBpcyB3cm9uZyAtIGRvbid0IHRyeSB0byByZWZyZXNoLCBuZWVkIHJlLWF1dGhcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnaW52YWxpZC10b2tlbicsICdJbnZhbGlkIHRva2VuIGZvcm1hdCAtIHBsZWFzZSByZS1hdXRoZW50aWNhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9rZW4gZm9ybWF0OiAke2Vycm9yRGF0YS5lcnJvcl9kZXNjcmlwdGlvbn1gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9rZW4gZXhwaXJlZCBvciBvdGhlciBhdXRoIGlzc3VlIC0gbWlnaHQgYmUgcmVmcmVzaGFibGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnbmVlZHMtYXV0aCcsICdUb2tlbiBleHBpcmVkIG9yIGludmFsaWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkOiAke2Vycm9yVGV4dH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgbnVsbCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2Nvbm5lY3RlZCcpO1xyXG5cclxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBzdHJlYW0gaW4gdGhlIGJhY2tncm91bmQgKGRvbid0IGF3YWl0KVxyXG4gICAgICAgIHRoaXMucHJvY2Vzc1N0cmVhbShyZXNwb25zZS5ib2R5KTtcclxuXHJcbiAgICAgICAgLy8gTm90ZTogTUNQIHNlc3Npb24gSUQgY29tZXMgZnJvbSBpbml0aWFsaXphdGlvbiByZXNwb25zZSBoZWFkZXJzLFxyXG4gICAgICAgIC8vIG5vdCBmcm9tIHRoZSBTU0Ugc3RyZWFtLiBUaGUgU1NFIGVuZHBvaW50IGV2ZW50IHByb3ZpZGVzIGEgc2VwYXJhdGVcclxuICAgICAgICAvLyBzZXNzaW9uIElEIGZvciBzdHJlYW0gcmVzdW1hYmlsaXR5LlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgU1NFIHN0cmVhbSBpbiB0aGUgYmFja2dyb3VuZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHByb2Nlc3NTdHJlYW0oYm9keTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuICAgICAgICBsZXQgYnVmZmVyID0gJyc7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRFdmVudDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFN0cmVhbSBlbmRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdldmVudDogJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIFNTRSBldmVudCB0eXBlcyAoZS5nLiwgXCJldmVudDogZW5kcG9pbnRcIiwgXCJldmVudDogbWVzc2FnZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXZlbnQgPSBsaW5lLnNsaWNlKDcpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNTRSBldmVudCB0eXBlOicsIGN1cnJlbnRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNikudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGVuZHBvaW50IGV2ZW50IC0gZXh0cmFjdCBtZXNzYWdlIGVuZHBvaW50IGZvciBQT1NUIHJlcXVlc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RXZlbnQgPT09ICdlbmRwb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlciBNQ1Agc3BlYzogc2VydmVyIHNlbmRzIGVuZHBvaW50IFVSSSBmb3IgY2xpZW50IHRvIHVzZSBmb3IgUE9TVCByZXF1ZXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBmb3JtYXQ6IC9zc2UvbWVzc2FnZT9zZXNzaW9uSWQ9Li4uIChyZWxhdGl2ZSBVUkkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VFbmRwb2ludCA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2Vzc2lvbiBJRCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGRhdGEubWF0Y2goL3Nlc3Npb25JZD0oW2EtZjAtOS1dKykvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3NlU2Vzc2lvbklkID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBNZXNzYWdlIGVuZHBvaW50IHJlY2VpdmVkOicsIHRoaXMubWVzc2FnZUVuZHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBTU0UgU2Vzc2lvbiBJRDonLCB0aGlzLnNzZVNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgZGF0YSBvciBub24tSlNPTiBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSB8fCAoIWRhdGEuc3RhcnRzV2l0aCgneycpICYmICFkYXRhLnN0YXJ0c1dpdGgoJ1snKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBOb24tSlNPTiBTU0UgZGF0YTonLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE1jcE1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIEZhaWxlZCB0byBwYXJzZSBtZXNzYWdlOicsIGVyciwgJ0RhdGE6JywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gU3RyZWFtIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcclxuICAgICAgICAgICAgLy8gQ29ubmVjdGlvbiBjbG9zZWQsIGF0dGVtcHQgcmVjb25uZWN0XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgaW5jb21pbmcgU1NFIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVNZXNzYWdlKG1lc3NhZ2U6IE1jcE1lc3NhZ2UpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHJlc3BvbnNlcyB0byBvdXIgcmVxdWVzdHNcclxuICAgICAgICBpZiAobWVzc2FnZS5pZCAmJiB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5oYXMobWVzc2FnZS5pZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChtZXNzYWdlLmlkKSE7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShtZXNzYWdlLmlkKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nLnJlamVjdChuZXcgRXJyb3IobWVzc2FnZS5lcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nLnJlc29sdmUobWVzc2FnZS5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBmdWxsIFBPU1QgZW5kcG9pbnQgVVJMXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UG9zdFVybCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlRW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGVuZHBvaW50IG5vdCBhdmFpbGFibGUuIFNTRSBjb25uZWN0aW9uIG1heSBub3QgYmUgZXN0YWJsaXNoZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIGVuZHBvaW50IGlzIHJlbGF0aXZlLCBjb25zdHJ1Y3QgZnVsbCBVUkxcclxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlRW5kcG9pbnQuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5zc2VVcmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7dXJsLm9yaWdpbn0ke3RoaXMubWVzc2FnZUVuZHBvaW50fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIGVuZHBvaW50IGlzIGFscmVhZHkgYWJzb2x1dGUsIHVzZSBpdCBhcy1pc1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VFbmRwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBub3RpZmljYXRpb24gKG5vIHJlc3BvbnNlIGV4cGVjdGVkKVxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kTm90aWZpY2F0aW9uKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM/OiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlOiBNY3BNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICBwYXJhbXNcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBCdWlsZCBoZWFkZXJzXHJcbiAgICAgICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvZXZlbnQtc3RyZWFtJyxcclxuICAgICAgICAgICAgJ01DUC1Qcm90b2NvbC1WZXJzaW9uJzogJzIwMjUtMDYtMTgnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW5jbHVkZSBzZXNzaW9uIElEIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzWydNY3AtU2Vzc2lvbi1JZCddID0gdGhpcy5zZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQZXIgTUNQIHNwZWM6IHVzZSB0aGUgZW5kcG9pbnQgZnJvbSBTU0UgJ2VuZHBvaW50JyBldmVudCBmb3IgUE9TVCByZXF1ZXN0c1xyXG4gICAgICAgIGNvbnN0IHBvc3RVcmwgPSB0aGlzLmdldFBvc3RVcmwoKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gU2VuZGluZyBub3RpZmljYXRpb24gdG86JywgcG9zdFVybCk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgbm90aWZpY2F0aW9uIC0gbm8gcmVzcG9uc2UgZXhwZWN0ZWQgKHNob3VsZCByZXR1cm4gMjAyIEFjY2VwdGVkKVxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocG9zdFVybCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOb3Rpb25NQ1BdIE5vdGlmaWNhdGlvbiBmYWlsZWQ6JywgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBOb3RpZmljYXRpb24gc2VudDonLCBtZXRob2QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIHJlcXVlc3Qgb3ZlciBTU0UgKHZpYSBQT1NUIHRvIGVuZHBvaW50IGZyb20gU1NFICdlbmRwb2ludCcgZXZlbnQpXHJcbiAgICAgKiBQZXIgTUNQIHNwZWM6IFNTRSBmb3IgcmVjZWl2aW5nLCBQT1NUIHRvIGVuZHBvaW50IHByb3ZpZGVkIGJ5IHNlcnZlciBmb3Igc2VuZGluZ1xyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kUmVxdWVzdChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55LCBvcHRpb25zPzogeyBza2lwU2Vzc2lvbklkPzogYm9vbGVhbiB9KTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICBjb25zdCBpZCA9ICsrdGhpcy5tZXNzYWdlSWQ7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZTogTWNwTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtc1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBoZWFkZXJzXHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFjY2Vzc1Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2V2ZW50LXN0cmVhbScsXHJcbiAgICAgICAgICAgICAgICAnTUNQLVByb3RvY29sLVZlcnNpb24nOiAnMjAyNS0wNi0xOCdcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgc2Vzc2lvbiBJRCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsaXplID0gbWV0aG9kID09PSAnaW5pdGlhbGl6ZSc7XHJcbiAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXplICYmIHRoaXMuc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydNY3AtU2Vzc2lvbi1JZCddID0gdGhpcy5zZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlciBNQ1Agc3BlYzogdXNlIHRoZSBlbmRwb2ludCBmcm9tIFNTRSAnZW5kcG9pbnQnIGV2ZW50IGZvciBQT1NUIHJlcXVlc3RzXHJcbiAgICAgICAgICAgIGNvbnN0IHBvc3RVcmwgPSB0aGlzLmdldFBvc3RVcmwoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNlbmRpbmcgcmVxdWVzdCB0bzonLCBwb3N0VXJsLCAnTWV0aG9kOicsIG1ldGhvZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIHZpYSBQT1NUIHRvIHRoZSBtZXNzYWdlIGVuZHBvaW50IChmcm9tIFNTRSBlbmRwb2ludCBldmVudClcclxuICAgICAgICAgICAgZmV0Y2gocG9zdFVybCwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gUmVxdWVzdCBmYWlsZWQ6JywgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2Vzc2lvbiBJRCBmcm9tIHJlc3BvbnNlIGhlYWRlcnMgaWYgdGhpcyBpcyBpbml0aWFsaXphdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ01jcC1TZXNzaW9uLUlkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uSWRIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkSGVhZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNlc3Npb24gSUQgZnJvbSBpbml0IHJlc3BvbnNlOicsIHRoaXMuc2Vzc2lvbklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgY29udGVudCB0eXBlIHRvIGRldGVybWluZSBob3cgdG8gcGFyc2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKCd0ZXh0L2V2ZW50LXN0cmVhbScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGlzIFNTRSBmb3JtYXQgLSBwYXJzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAoZGF0YS5zdGFydHNXaXRoKCd7JykgfHwgZGF0YS5zdGFydHNXaXRoKCdbJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gRmFpbGVkIHRvIHBhcnNlIFNTRSBkYXRhOicsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzcG9uc2UgaXMgSlNPTiAtIHBhcnNlIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZTogJHtjb250ZW50VHlwZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRpbWVvdXQgYWZ0ZXIgMzAgc2Vjb25kc1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZXF1ZXN0cy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDMwMDAwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdhaXQgZm9yIG1lc3NhZ2UgZW5kcG9pbnQgdG8gYmUgYXZhaWxhYmxlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgd2FpdEZvckVuZHBvaW50KHRpbWVvdXRNczogbnVtYmVyID0gMTAwMDApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHdoaWxlICghdGhpcy5tZXNzYWdlRW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0TXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZW91dCB3YWl0aW5nIGZvciBtZXNzYWdlIGVuZHBvaW50IGZyb20gU1NFJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIE1DUCBjb25uZWN0aW9uXHJcbiAgICAgKiBNdXN0IGJlIGNhbGxlZCBBRlRFUiBTU0UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCBhbmQgZW5kcG9pbnQgZXZlbnQgaXMgcmVjZWl2ZWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBQZXIgTUNQIHNwZWM6IFdhaXQgZm9yIFNTRSAnZW5kcG9pbnQnIGV2ZW50IGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFdhaXRpbmcgZm9yIG1lc3NhZ2UgZW5kcG9pbnQgZnJvbSBTU0UuLi4nKTtcclxuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JFbmRwb2ludCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBNZXNzYWdlIGVuZHBvaW50IHJlYWR5LCBzZW5kaW5nIGluaXRpYWxpemUgcmVxdWVzdCcpO1xyXG5cclxuICAgICAgICBjb25zdCBwYXJhbXM6IE1jcEluaXRpYWxpemVSZXF1ZXN0WydwYXJhbXMnXSA9IHtcclxuICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiAnMjAyNS0wNi0xOCcsXHJcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczoge1xyXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7fSxcclxuICAgICAgICAgICAgICAgIHJvb3RzOiB7IGxpc3RDaGFuZ2VkOiB0cnVlIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xpZW50SW5mbzoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nocm9tZS1haS1leHRlbnNpb24nLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzAuMC4xJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBpbml0aWFsaXplIHJlcXVlc3RcclxuICAgICAgICAvLyBTZXNzaW9uIElEIHdpbGwgYmUgZXh0cmFjdGVkIGZyb20gcmVzcG9uc2UgaGVhZGVyc1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ2luaXRpYWxpemUnLCBwYXJhbXMpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTm90aW9uTUNQXSBJbml0aWFsaXplZDonLCByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLyBWZXJpZnkgc2Vzc2lvbiBJRCB3YXMgcmVjZWl2ZWQgKGlmIHNlcnZlciB1c2VzIHNlc3Npb25zKVxyXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW05vdGlvbk1DUF0gU2Vzc2lvbiBlc3RhYmxpc2hlZDonLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFNlcnZlciBkb2VzIG5vdCB1c2Ugc2Vzc2lvbiBtYW5hZ2VtZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZnRlciBpbml0aWFsaXphdGlvbiwgc2VuZCBpbml0aWFsaXplZCBub3RpZmljYXRpb24gKG5vIHJlc3BvbnNlIGV4cGVjdGVkKVxyXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZE5vdGlmaWNhdGlvbignbm90aWZpY2F0aW9ucy9pbml0aWFsaXplZCcpO1xyXG5cclxuICAgICAgICAvLyBGZXRjaCBhdmFpbGFibGUgdG9vbHNcclxuICAgICAgICBhd2FpdCB0aGlzLmZldGNoVG9vbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGF2YWlsYWJsZSB0b29scyBmcm9tIE1DUCBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmV0Y2hUb29scygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IE1jcFRvb2xzTGlzdFJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCgndG9vbHMvbGlzdCcpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0dXMudG9vbHMgPSByZXN1bHQudG9vbHM7XHJcbiAgICAgICAgICAgIHRoaXMub25TdGF0dXNDaGFuZ2UodGhpcy5jdXJyZW50U3RhdHVzKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tOb3Rpb25NQ1BdIFRvb2xzOicsIHJlc3VsdC50b29scyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05vdGlvbk1DUF0gRmFpbGVkIHRvIGZldGNoIHRvb2xzOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIGEgdG9vbFxyXG4gICAgICovXHJcbiAgICBhc3luYyBjYWxsVG9vbChuYW1lOiBzdHJpbmcsIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCgndG9vbHMvY2FsbCcsIHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlU3RhdHVzKHN0YXRlOiBNY3BDb25uZWN0aW9uU3RhdGUsIGVycm9yPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLmN1cnJlbnRTdGF0dXMsXHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgbGFzdENvbm5lY3RlZDogc3RhdGUgPT09ICdjb25uZWN0ZWQnID8gRGF0ZS5ub3coKSA6IHRoaXMuY3VycmVudFN0YXR1cy5sYXN0Q29ubmVjdGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uU3RhdHVzQ2hhbmdlKHRoaXMuY3VycmVudFN0YXR1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZSByZWNvbm5lY3Rpb24gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBOT1RJT05fQ09ORklHLlJFQ09OTkVDVF9NSU5fREVMQVkgKiBNYXRoLnBvdyhOT1RJT05fQ09ORklHLlJFQ09OTkVDVF9NVUxUSVBMSUVSLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSxcclxuICAgICAgICAgICAgTk9USU9OX0NPTkZJRy5SRUNPTk5FQ1RfTUFYX0RFTEFZXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdjb25uZWN0aW5nJywgYFJlY29ubmVjdGluZyBpbiAke01hdGgucm91bmQoZGVsYXkgLyAxMDAwKX1zLi4uYCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdCBhbmQgY2xlYW51cFxyXG4gICAgICovXHJcbiAgICBkaXNjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVqZWN0IGFsbCBwZW5kaW5nIHJlcXVlc3RzXHJcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHBlbmRpbmddIG9mIHRoaXMucGVuZGluZ1JlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmcucmVqZWN0KG5ldyBFcnJvcignRGlzY29ubmVjdGVkJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnZGlzY29ubmVjdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY3VycmVudCBzdGF0dXNcclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdHVzKCk6IE5vdGlvbk1jcFN0YXR1cyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXR1cztcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgTWNwU1NFQ2xpZW50IH07XHJcbiIsIi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIGNvbnN0YW50cyBmb3IgdGhlIGV4dGVuc2lvblxyXG4gKi9cclxuXHJcbi8vIENocm9tZSBCdWlsdC1pbiBBSSAoR2VtaW5pIE5hbm8pIGxpbWl0c1xyXG4vLyBCYXNlZCBvbiBDaHJvbWUgQUkgZG9jdW1lbnRhdGlvbiBhbmQgY29tbXVuaXR5IHJlcG9ydHNcclxuZXhwb3J0IGNvbnN0IENIUk9NRV9BSV9MSU1JVFMgPSB7XHJcbiAgICAvKiogTWF4aW11bSB0b2tlbnMgcGVyIHNpbmdsZSBwcm9tcHQgdG8gR2VtaW5pIE5hbm8gKG9uLWRldmljZSBtb2RlbCkgKi9cclxuICAgIE1BWF9UT0tFTlNfUEVSX1BST01QVDogMTAyNCxcclxuXHJcbiAgICAvKiogTWF4aW11bSB0b2tlbnMgZm9yIHNlc3Npb24gcmV0ZW50aW9uIChzbGlkaW5nIHdpbmRvdykgKi9cclxuICAgIE1BWF9UT0tFTlNfUEVSX1NFU1NJT046IDQwOTYsXHJcblxyXG4gICAgLyoqIFJlY29tbWVuZGVkIGNodW5rIHNpemUgZm9yIHRleHQgcHJvY2Vzc2luZyB0byBzdGF5IHdlbGwgdW5kZXIgcHJvbXB0IGxpbWl0ICovXHJcbiAgICBSRUNPTU1FTkRFRF9DSFVOS19UT0tFTlM6IDgwMCxcclxuXHJcbiAgICAvKiogTWF4aW11bSBvdXRwdXQgdG9rZW5zIHBlciByZXNwb25zZSAqL1xyXG4gICAgTUFYX09VVFBVVF9UT0tFTlM6IDEwMjQsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG4vKipcclxuICogQ29waWxvdEtpdCBDb25maWd1cmF0aW9uXHJcbiAqIEVkaXQgdGhpcyBVUkwgdG8gcG9pbnQgdG8geW91ciBob3N0ZWQgQ29waWxvdCBSdW50aW1lIGVuZHBvaW50XHJcbiAqIEV4YW1wbGU6IFwiaHR0cHM6Ly95b3VyLXJ1bnRpbWUuZXhhbXBsZS5jb20vYXBpL2NvcGlsb3RraXRcIlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENPUElMT1RfUlVOVElNRV9VUkwgPSBcIiBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpXCIgYXMgc3RyaW5nOyAvLyBUT0RPOiBFZGl0IHRoaXMgVVJMXHJcbmV4cG9ydCBjb25zdCBDT1BJTE9UX1JVTlRJTUVfVVJMX0RFRkFVTFQgPSBcIiBodHRwOi8vbG9jYWxob3N0OjMwMDAvXCI7XHJcblxyXG4vKipcclxuICogTm90aW9uIE1DUCBDb25maWd1cmF0aW9uXHJcbiAqIE9BdXRoIHdpdGggRHluYW1pYyBDbGllbnQgUmVnaXN0cmF0aW9uIGZvciBOb3Rpb24gaG9zdGVkIE1DUCBzZXJ2ZXJcclxuICogXHJcbiAqIElNUE9SVEFOVDogVGhpcyB1c2VzIGR5bmFtaWMgY2xpZW50IHJlZ2lzdHJhdGlvbiAoUkZDIDc1OTEpXHJcbiAqIENsaWVudCBjcmVkZW50aWFscyBhcmUgb2J0YWluZWQgYXQgcnVudGltZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbm5lY3RcIlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5PVElPTl9DT05GSUcgPSB7XHJcbiAgICAvKiogT0F1dGggcmVkaXJlY3QgVVJJIC0gQ2hyb21lIGV4dGVuc2lvbiBpZGVudGl0eSByZWRpcmVjdCAqL1xyXG4gICAgT0FVVEhfUkVESVJFQ1RfVVJJOiBcImh0dHBzOi8vZmluZm5raGNoZWxmb2Zsb29jaWRwZXBhY2ZiYWptbGguY2hyb21pdW1hcHAub3JnL1wiLFxyXG5cclxuICAgIC8qKiBPQXV0aCBkeW5hbWljIGNsaWVudCByZWdpc3RyYXRpb24gZW5kcG9pbnQgKi9cclxuICAgIE9BVVRIX1JFR0lTVEVSX1VSTDogXCJodHRwczovL21jcC5ub3Rpb24uY29tL3JlZ2lzdGVyXCIsXHJcblxyXG4gICAgLyoqIE9BdXRoIGF1dGhvcml6YXRpb24gZW5kcG9pbnQgLSBTdGFuZGFyZCBOb3Rpb24gT0F1dGggKi9cclxuICAgIE9BVVRIX0FVVEhfVVJMOiBcImh0dHBzOi8vbWNwLm5vdGlvbi5jb20vYXV0aG9yaXplXCIsXHJcblxyXG4gICAgLyoqIE9BdXRoIHRva2VuIGVuZHBvaW50IC0gU3RhbmRhcmQgTm90aW9uIE9BdXRoICovXHJcbiAgICBPQVVUSF9UT0tFTl9VUkw6IFwiaHR0cHM6Ly9tY3Aubm90aW9uLmNvbS90b2tlblwiLFxyXG5cclxuICAgIC8qKiBPQXV0aCB0b2tlbiBpbnRyb3NwZWN0aW9uIGVuZHBvaW50ICovXHJcbiAgICBPQVVUSF9JTlRST1NQRUNUX1VSTDogXCJodHRwczovL2FwaS5ub3Rpb24uY29tL3YxL29hdXRoL2ludHJvc3BlY3RcIixcclxuXHJcbiAgICAvKiogTUNQIHJlc291cmNlIGlkZW50aWZpZXIgZm9yIE9BdXRoIHNjb3BlICovXHJcbiAgICBNQ1BfUkVTT1VSQ0U6IFwiaHR0cHM6Ly9tY3Aubm90aW9uLmNvbS9cIixcclxuXHJcbiAgICAvKiogTm90aW9uIE1DUCBTU0UgZW5kcG9pbnQgKGZvciBlc3RhYmxpc2hpbmcgU1NFIGNvbm5lY3Rpb24gYW5kIHJlY2VpdmluZyBldmVudHMpICovXHJcbiAgICBNQ1BfU1NFX1VSTDogXCJodHRwczovL21jcC5ub3Rpb24uY29tL3NzZVwiLFxyXG5cclxuICAgIC8qKiBUb2tlbiBzdG9yYWdlIGtleSBwcmVmaXggKi9cclxuICAgIFNUT1JBR0VfS0VZX1BSRUZJWDogXCJvYXV0aC5ub3Rpb24ubWNwXCIsXHJcblxyXG4gICAgLyoqIFJlY29ubmVjdGlvbiBzZXR0aW5ncyAqL1xyXG4gICAgUkVDT05ORUNUX01JTl9ERUxBWTogNTAwLCAvLyAwLjVzXHJcbiAgICBSRUNPTk5FQ1RfTUFYX0RFTEFZOiAzMDAwMCwgLy8gMzBzXHJcbiAgICBSRUNPTk5FQ1RfTVVMVElQTElFUjogMixcclxufSBhcyBjb25zdDtcclxuIiwiLyoqXHJcbiAqIE9BdXRoIHV0aWxpdGllcyBmb3IgTm90aW9uIE1DUCBhdXRoZW50aWNhdGlvblxyXG4gKiBJbXBsZW1lbnRzIE9BdXRoIDIuMCBQS0NFIChQcm9vZiBLZXkgZm9yIENvZGUgRXhjaGFuZ2UpIGZsb3dcclxuICogZm9yIE5vdGlvbidzIGhvc3RlZCBNQ1Agc2VydmVyIChubyBjbGllbnQgc2VjcmV0KVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGJ1ZmZlciB9IGZyb20gJ25vZGU6c3RyZWFtL2NvbnN1bWVycyc7XHJcbmltcG9ydCB7IE5PVElPTl9DT05GSUcgfSBmcm9tICcuLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgdHlwZSB7IE5vdGlvbk9BdXRoVG9rZW5zIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG4vKipcclxuICogRHluYW1pYyBjbGllbnQgY3JlZGVudGlhbHMgZnJvbSByZWdpc3RyYXRpb25cclxuICovXHJcbmludGVyZmFjZSBEeW5hbWljQ2xpZW50Q3JlZGVudGlhbHMge1xyXG4gICAgY2xpZW50X2lkOiBzdHJpbmc7XHJcbiAgICBjbGllbnRfc2VjcmV0OiBzdHJpbmc7XHJcbiAgICByZWRpcmVjdF91cmlzOiBzdHJpbmdbXTtcclxuICAgIGNsaWVudF9uYW1lOiBzdHJpbmc7XHJcbiAgICBncmFudF90eXBlczogc3RyaW5nW107XHJcbiAgICByZXNwb25zZV90eXBlczogc3RyaW5nW107XHJcbiAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogc3RyaW5nO1xyXG4gICAgcmVnaXN0cmF0aW9uX2NsaWVudF91cmk/OiBzdHJpbmc7XHJcbiAgICBjbGllbnRfaWRfaXNzdWVkX2F0PzogbnVtYmVyO1xyXG4gICAgY3JlYXRlZF9hdDogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXIgYSBkeW5hbWljIGNsaWVudCB3aXRoIE5vdGlvbiBNQ1AgT0F1dGggc2VydmVyXHJcbiAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSBzdGFydGluZyB0aGUgT0F1dGggZmxvd1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJEeW5hbWljQ2xpZW50KHJlZGlyZWN0VXJpOiBzdHJpbmcpOiBQcm9taXNlPER5bmFtaWNDbGllbnRDcmVkZW50aWFscz4ge1xyXG4gICAgY29uc3QgcmVnaXN0cmF0aW9uUGF5bG9hZCA9IHtcclxuICAgICAgICBjbGllbnRfbmFtZTogXCJDaHJvbWUgQUkgRXh0ZW5zaW9uIC0gTm90aW9uIE1DUFwiLFxyXG4gICAgICAgIHJlZGlyZWN0X3VyaXM6IFtyZWRpcmVjdFVyaV0sXHJcbiAgICAgICAgZ3JhbnRfdHlwZXM6IFtcImF1dGhvcml6YXRpb25fY29kZVwiLCBcInJlZnJlc2hfdG9rZW5cIl0sXHJcbiAgICAgICAgcmVzcG9uc2VfdHlwZXM6IFtcImNvZGVcIl0sXHJcbiAgICAgICAgc2NvcGU6IFwicmVhZCB3cml0ZVwiLFxyXG4gICAgICAgIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kOiBcImNsaWVudF9zZWNyZXRfYmFzaWNcIlxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnW09BdXRoXSBSZWdpc3RlcmluZyBkeW5hbWljIGNsaWVudCB3aXRoIHBheWxvYWQ6JywgcmVnaXN0cmF0aW9uUGF5bG9hZCk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChOT1RJT05fQ09ORklHLk9BVVRIX1JFR0lTVEVSX1VSTCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVnaXN0cmF0aW9uUGF5bG9hZClcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCByZWdpc3RyYXRpb24gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdbT0F1dGhdIENsaWVudCByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseTonLCB7XHJcbiAgICAgICAgY2xpZW50X2lkOiBkYXRhLmNsaWVudF9pZCxcclxuICAgICAgICByZWRpcmVjdF91cmlzOiBkYXRhLnJlZGlyZWN0X3VyaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xpZW50X2lkOiBkYXRhLmNsaWVudF9pZCxcclxuICAgICAgICBjbGllbnRfc2VjcmV0OiBkYXRhLmNsaWVudF9zZWNyZXQsXHJcbiAgICAgICAgcmVkaXJlY3RfdXJpczogZGF0YS5yZWRpcmVjdF91cmlzLFxyXG4gICAgICAgIGNsaWVudF9uYW1lOiBkYXRhLmNsaWVudF9uYW1lLFxyXG4gICAgICAgIGdyYW50X3R5cGVzOiBkYXRhLmdyYW50X3R5cGVzLFxyXG4gICAgICAgIHJlc3BvbnNlX3R5cGVzOiBkYXRhLnJlc3BvbnNlX3R5cGVzLFxyXG4gICAgICAgIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kOiBkYXRhLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kLFxyXG4gICAgICAgIHJlZ2lzdHJhdGlvbl9jbGllbnRfdXJpOiBkYXRhLnJlZ2lzdHJhdGlvbl9jbGllbnRfdXJpLFxyXG4gICAgICAgIGNsaWVudF9pZF9pc3N1ZWRfYXQ6IGRhdGEuY2xpZW50X2lkX2lzc3VlZF9hdCxcclxuICAgICAgICBjcmVhdGVkX2F0OiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSByYW5kb20gc3RyaW5nIGZvciBzdGF0ZSBwYXJhbWV0ZXIgKENTUkYgcHJvdGVjdGlvbilcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tU3RyaW5nKGxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcclxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBzdGF0ZSBwYXJhbWV0ZXIgZm9yIENTUkYgcHJvdGVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdGF0ZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tU3RyaW5nKDE2KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNvZGUgdmVyaWZpZXIgZm9yIFBLQ0UgKDQzLTEyOCBjaGFyYWN0ZXJzLCBiYXNlNjR1cmwpXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb2RlVmVyaWZpZXIoKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyAvLyAzMiBieXRlcyA9IDQzIGNoYXJzIGluIGJhc2U2NHVybFxyXG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XHJcbiAgICByZXR1cm4gYmFzZTY0VXJsRW5jb2RlKGFycmF5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNvZGUgY2hhbGxlbmdlIGZyb20gYSB2ZXJpZmllciAoU0hBLTI1NiBoYXNoLCBiYXNlNjR1cmwgZW5jb2RlZClcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvZGVDaGFsbGVuZ2UodmVyaWZpZXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmVyaWZpZXIpO1xyXG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XHJcbiAgICByZXR1cm4gYmFzZTY0VXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KGhhc2gpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2U2NFVSTCBlbmNvZGUgKHdpdGhvdXQgcGFkZGluZylcclxuICovXHJcbmZ1bmN0aW9uIGJhc2U2NFVybEVuY29kZShidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgYmFzZTY0ID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ1ZmZlcikpO1xyXG4gICAgcmV0dXJuIGJhc2U2NFxyXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxyXG4gICAgICAgIC5yZXBsYWNlKC89L2csICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIE5vdGlvbiBNQ1AgT0F1dGggYXV0aG9yaXphdGlvbiBVUkwgKHN0YW5kYXJkIE9BdXRoLCBubyBQS0NFKVxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRBdXRoVXJsKGNsaWVudElkOiBzdHJpbmcsIHJlZGlyZWN0VXJpOiBzdHJpbmcsIHN0YXRlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgICAgcmVzcG9uc2VfdHlwZTogJ2NvZGUnLFxyXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXHJcbiAgICAgICAgcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaSxcclxuICAgICAgICBvd25lcjogJ3VzZXInLFxyXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGAke05PVElPTl9DT05GSUcuT0FVVEhfQVVUSF9VUkx9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4Y2hhbmdlIGF1dGhvcml6YXRpb24gY29kZSBmb3IgdG9rZW5zIHVzaW5nIGR5bmFtaWMgY2xpZW50IGNyZWRlbnRpYWxzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBleGNoYW5nZUNvZGVGb3JUb2tlbnMoXHJcbiAgICBjb2RlOiBzdHJpbmcsXHJcbiAgICBjbGllbnRJZDogc3RyaW5nLFxyXG4gICAgY2xpZW50U2VjcmV0OiBzdHJpbmcsXHJcbiAgICByZWRpcmVjdFVyaTogc3RyaW5nXHJcbik6IFByb21pc2U8Tm90aW9uT0F1dGhUb2tlbnM+IHtcclxuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gQnVmZmVyLmZyb20oYCR7Y2xpZW50SWR9OiR7Y2xpZW50U2VjcmV0fWApLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1tPQXV0aF0gRXhjaGFuZ2UgY29kZSBmb3IgdG9rZW5zIHdpdGggY2xpZW50OicsIGNsaWVudElkKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBib2R5IGZvciBPQXV0aCB0b2tlbiBleGNoYW5nZVxyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXHJcbiAgICAgICAgY29kZTogY29kZSxcclxuICAgICAgICByZWRpcmVjdF91cmk6IHJlZGlyZWN0VXJpXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnW09BdXRoXSBFeGNoYW5nZSBjb2RlIGZvciB0b2tlbnMgYm9keSAodXJsZW5jb2RlZCk6JywgcGFyYW1zLnRvU3RyaW5nKCkpO1xyXG4gICAgY29uc29sZS5sb2coJ1tPQXV0aF0gRXhjaGFuZ2UgY29kZSBmb3IgdG9rZW5zIFVSTDonLCBOT1RJT05fQ09ORklHLk9BVVRIX1RPS0VOX1VSTCk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChOT1RJT05fQ09ORklHLk9BVVRIX1RPS0VOX1VSTCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmFzaWMgJHtjcmVkZW50aWFsc31gLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXHJcbiAgICAgICAgICAgICdOb3Rpb24tVmVyc2lvbic6ICcyMDIyLTA2LTI4J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogcGFyYW1zLnRvU3RyaW5nKClcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuIGV4Y2hhbmdlIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZXhwaXJhdGlvbiB0aW1lc3RhbXBcclxuICAgIGNvbnN0IGV4cGlyZXNJbiA9IGRhdGEuZXhwaXJlc19pbiB8fCAzNjAwOyAvLyBEZWZhdWx0IDEgaG91ciBpZiBub3QgcHJvdmlkZWRcclxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IERhdGUubm93KCkgKyAoZXhwaXJlc0luICogMTAwMCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhY2Nlc3NfdG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IGRhdGEucmVmcmVzaF90b2tlbixcclxuICAgICAgICB0b2tlbl90eXBlOiBkYXRhLnRva2VuX3R5cGUgfHwgJ0JlYXJlcicsXHJcbiAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxyXG4gICAgICAgIHdvcmtzcGFjZV9pZDogZGF0YS53b3Jrc3BhY2VfaWQsXHJcbiAgICAgICAgd29ya3NwYWNlX25hbWU6IGRhdGEud29ya3NwYWNlX25hbWUsXHJcbiAgICAgICAgd29ya3NwYWNlX2ljb246IGRhdGEud29ya3NwYWNlX2ljb24sXHJcbiAgICAgICAgb3duZXI6IGRhdGEub3duZXIsXHJcbiAgICAgICAgYm90X2lkOiBkYXRhLmJvdF9pZCxcclxuICAgICAgICBkdXBsaWNhdGVkX3RlbXBsYXRlX2lkOiBkYXRhLmR1cGxpY2F0ZWRfdGVtcGxhdGVfaWQsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogRGF0ZS5ub3coKVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZnJlc2ggYWNjZXNzIHRva2VuIHVzaW5nIHJlZnJlc2ggdG9rZW4gYW5kIGR5bmFtaWMgY2xpZW50IGNyZWRlbnRpYWxzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoQWNjZXNzVG9rZW4oXHJcbiAgICByZWZyZXNoVG9rZW46IHN0cmluZyxcclxuICAgIGNsaWVudElkOiBzdHJpbmcsXHJcbiAgICBjbGllbnRTZWNyZXQ6IHN0cmluZ1xyXG4pOiBQcm9taXNlPE5vdGlvbk9BdXRoVG9rZW5zPiB7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IEJ1ZmZlci5mcm9tKGAke2NsaWVudElkfToke2NsaWVudFNlY3JldH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgICBcclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcclxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW5cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTk9USU9OX0NPTkZJRy5PQVVUSF9UT0tFTl9VUkwsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJhc2ljICR7Y3JlZGVudGlhbHN9YCxcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgICAgICAnTm90aW9uLVZlcnNpb24nOiAnMjAyMi0wNi0yOCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IHBhcmFtcy50b1N0cmluZygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbiByZWZyZXNoIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3J9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICBjb25zdCBleHBpcmVzSW4gPSBkYXRhLmV4cGlyZXNfaW4gfHwgMzYwMDtcclxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IERhdGUubm93KCkgKyAoZXhwaXJlc0luICogMTAwMCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhY2Nlc3NfdG9rZW46IGRhdGEuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IGRhdGEucmVmcmVzaF90b2tlbiB8fCByZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgdG9rZW5fdHlwZTogZGF0YS50b2tlbl90eXBlIHx8ICdCZWFyZXInLFxyXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcclxuICAgICAgICB3b3Jrc3BhY2VfaWQ6IGRhdGEud29ya3NwYWNlX2lkLFxyXG4gICAgICAgIHdvcmtzcGFjZV9uYW1lOiBkYXRhLndvcmtzcGFjZV9uYW1lLFxyXG4gICAgICAgIHdvcmtzcGFjZV9pY29uOiBkYXRhLndvcmtzcGFjZV9pY29uLFxyXG4gICAgICAgIG93bmVyOiBkYXRhLm93bmVyLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IERhdGUubm93KClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0b2tlbiBpcyBleHBpcmVkIG9yIGFib3V0IHRvIGV4cGlyZSAod2l0aGluIDUgbWludXRlcylcclxuICovXHJcbmZ1bmN0aW9uIGlzVG9rZW5FeHBpcmVkKHRva2VuczogTm90aW9uT0F1dGhUb2tlbnMpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBidWZmZXJUaW1lID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXHJcbiAgICByZXR1cm4gdG9rZW5zLmV4cGlyZXNfYXQgPD0gKG5vdyArIGJ1ZmZlclRpbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RvcmUgdG9rZW5zIGluIGNocm9tZS5zdG9yYWdlLmxvY2FsXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzdG9yZVRva2Vucyh0b2tlbnM6IE5vdGlvbk9BdXRoVG9rZW5zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xyXG4gICAgICAgIFtgJHtOT1RJT05fQ09ORklHLlNUT1JBR0VfS0VZX1BSRUZJWH0udG9rZW5zYF06IHRva2Vuc1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSB0b2tlbnMgZnJvbSBjaHJvbWUuc3RvcmFnZS5sb2NhbFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVkVG9rZW5zKCk6IFByb21pc2U8Tm90aW9uT0F1dGhUb2tlbnMgfCBudWxsPiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LnRva2Vuc2ApO1xyXG4gICAgcmV0dXJuIHJlc3VsdFtgJHtOT1RJT05fQ09ORklHLlNUT1JBR0VfS0VZX1BSRUZJWH0udG9rZW5zYF0gfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHN0b3JlZCB0b2tlbnNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFyVG9rZW5zKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGAke05PVElPTl9DT05GSUcuU1RPUkFHRV9LRVlfUFJFRklYfS50b2tlbnNgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0b3JlIGR5bmFtaWMgY2xpZW50IGNyZWRlbnRpYWxzIGluIGNocm9tZS5zdG9yYWdlLmxvY2FsXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzdG9yZUNsaWVudENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzOiBEeW5hbWljQ2xpZW50Q3JlZGVudGlhbHMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XHJcbiAgICAgICAgW2Ake05PVElPTl9DT05GSUcuU1RPUkFHRV9LRVlfUFJFRklYfS5jbGllbnRgXTogY3JlZGVudGlhbHNcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgZHluYW1pYyBjbGllbnQgY3JlZGVudGlhbHMgZnJvbSBjaHJvbWUuc3RvcmFnZS5sb2NhbFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVkQ2xpZW50Q3JlZGVudGlhbHMoKTogUHJvbWlzZTxEeW5hbWljQ2xpZW50Q3JlZGVudGlhbHMgfCBudWxsPiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LmNsaWVudGApO1xyXG4gICAgcmV0dXJuIHJlc3VsdFtgJHtOT1RJT05fQ09ORklHLlNUT1JBR0VfS0VZX1BSRUZJWH0uY2xpZW50YF0gfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHN0b3JlZCBjbGllbnQgY3JlZGVudGlhbHNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFyQ2xpZW50Q3JlZGVudGlhbHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5yZW1vdmUoYCR7Tk9USU9OX0NPTkZJRy5TVE9SQUdFX0tFWV9QUkVGSVh9LmNsaWVudGApO1xyXG59XHJcblxyXG5leHBvcnQge1xyXG4gICAgcmVnaXN0ZXJEeW5hbWljQ2xpZW50LFxyXG4gICAgZ2VuZXJhdGVTdGF0ZSxcclxuICAgIGNyZWF0ZUNvZGVWZXJpZmllcixcclxuICAgIGNyZWF0ZUNvZGVDaGFsbGVuZ2UsXHJcbiAgICBidWlsZEF1dGhVcmwsXHJcbiAgICBleGNoYW5nZUNvZGVGb3JUb2tlbnMsXHJcbiAgICByZWZyZXNoQWNjZXNzVG9rZW4sXHJcbiAgICBpc1Rva2VuRXhwaXJlZCxcclxuICAgIHN0b3JlVG9rZW5zLFxyXG4gICAgZ2V0U3RvcmVkVG9rZW5zLFxyXG4gICAgY2xlYXJUb2tlbnMsXHJcbiAgICBzdG9yZUNsaWVudENyZWRlbnRpYWxzLFxyXG4gICAgZ2V0U3RvcmVkQ2xpZW50Q3JlZGVudGlhbHMsXHJcbiAgICBjbGVhckNsaWVudENyZWRlbnRpYWxzLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgeyBEeW5hbWljQ2xpZW50Q3JlZGVudGlhbHMgfTtcclxuIiwidmFyIEVyPU9iamVjdC5jcmVhdGU7dmFyIE49T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBkcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBncj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgbXI9T2JqZWN0LmdldFByb3RvdHlwZU9mLElyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyICQ9KGkscik9PigpPT4ocnx8aSgocj17ZXhwb3J0czp7fX0pLmV4cG9ydHMsciksci5leHBvcnRzKSxGcj0oaSxyKT0+e2Zvcih2YXIgdCBpbiByKU4oaSx0LHtnZXQ6clt0XSxlbnVtZXJhYmxlOiEwfSl9LEw9KGkscix0LG4pPT57aWYociYmdHlwZW9mIHI9PVwib2JqZWN0XCJ8fHR5cGVvZiByPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBlIG9mIGdyKHIpKSFJci5jYWxsKGksZSkmJmUhPT10JiZOKGksZSx7Z2V0OigpPT5yW2VdLGVudW1lcmFibGU6IShuPWRyKHIsZSkpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gaX0sUz0oaSxyLHQpPT4oTChpLHIsXCJkZWZhdWx0XCIpLHQmJkwodCxyLFwiZGVmYXVsdFwiKSksSj0oaSxyLHQpPT4odD1pIT1udWxsP0VyKG1yKGkpKTp7fSxMKHJ8fCFpfHwhaS5fX2VzTW9kdWxlP04odCxcImRlZmF1bHRcIix7dmFsdWU6aSxlbnVtZXJhYmxlOiEwfSk6dCxpKSksQXI9aT0+TChOKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGkpO3ZhciBRPSQoTT0+e1widXNlIHN0cmljdFwiO00uYnl0ZUxlbmd0aD1ScjtNLnRvQnl0ZUFycmF5PUNyO00uZnJvbUJ5dGVBcnJheT1Mcjt2YXIgQj1bXSx3PVtdLFVyPXR5cGVvZiBVaW50OEFycmF5PFwidVwiP1VpbnQ4QXJyYXk6QXJyYXksUD1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IobT0wLEs9UC5sZW5ndGg7bTxLOysrbSlCW21dPVBbbV0sd1tQLmNoYXJDb2RlQXQobSldPW07dmFyIG0sSzt3W1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO3dbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gWihpKXt2YXIgcj1pLmxlbmd0aDtpZihyJTQ+MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciB0PWkuaW5kZXhPZihcIj1cIik7dD09PS0xJiYodD1yKTt2YXIgbj10PT09cj8wOjQtdCU0O3JldHVyblt0LG5dfWZ1bmN0aW9uIFJyKGkpe3ZhciByPVooaSksdD1yWzBdLG49clsxXTtyZXR1cm4odCtuKSozLzQtbn1mdW5jdGlvbiBUcihpLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gQ3IoaSl7dmFyIHIsdD1aKGkpLG49dFswXSxlPXRbMV0sbz1uZXcgVXIoVHIoaSxuLGUpKSx1PTAsZj1lPjA/bi00Om4sYztmb3IoYz0wO2M8ZjtjKz00KXI9d1tpLmNoYXJDb2RlQXQoYyldPDwxOHx3W2kuY2hhckNvZGVBdChjKzEpXTw8MTJ8d1tpLmNoYXJDb2RlQXQoYysyKV08PDZ8d1tpLmNoYXJDb2RlQXQoYyszKV0sb1t1KytdPXI+PjE2JjI1NSxvW3UrK109cj4+OCYyNTUsb1t1KytdPXImMjU1O3JldHVybiBlPT09MiYmKHI9d1tpLmNoYXJDb2RlQXQoYyldPDwyfHdbaS5jaGFyQ29kZUF0KGMrMSldPj40LG9bdSsrXT1yJjI1NSksZT09PTEmJihyPXdbaS5jaGFyQ29kZUF0KGMpXTw8MTB8d1tpLmNoYXJDb2RlQXQoYysxKV08PDR8d1tpLmNoYXJDb2RlQXQoYysyKV0+PjIsb1t1KytdPXI+PjgmMjU1LG9bdSsrXT1yJjI1NSksb31mdW5jdGlvbiBTcihpKXtyZXR1cm4gQltpPj4xOCY2M10rQltpPj4xMiY2M10rQltpPj42JjYzXStCW2kmNjNdfWZ1bmN0aW9uIF9yKGkscix0KXtmb3IodmFyIG4sZT1bXSxvPXI7bzx0O28rPTMpbj0oaVtvXTw8MTYmMTY3MTE2ODApKyhpW28rMV08PDgmNjUyODApKyhpW28rMl0mMjU1KSxlLnB1c2goU3IobikpO3JldHVybiBlLmpvaW4oXCJcIil9ZnVuY3Rpb24gTHIoaSl7Zm9yKHZhciByLHQ9aS5sZW5ndGgsbj10JTMsZT1bXSxvPTE2MzgzLHU9MCxmPXQtbjt1PGY7dSs9byllLnB1c2goX3IoaSx1LHUrbz5mP2Y6dStvKSk7cmV0dXJuIG49PT0xPyhyPWlbdC0xXSxlLnB1c2goQltyPj4yXStCW3I8PDQmNjNdK1wiPT1cIikpOm49PT0yJiYocj0oaVt0LTJdPDw4KStpW3QtMV0sZS5wdXNoKEJbcj4+MTBdK0Jbcj4+NCY2M10rQltyPDwyJjYzXStcIj1cIikpLGUuam9pbihcIlwiKX19KTt2YXIgdj0kKE89PntPLnJlYWQ9ZnVuY3Rpb24oaSxyLHQsbixlKXt2YXIgbyx1LGY9ZSo4LW4tMSxjPSgxPDxmKS0xLGw9Yz4+MSxzPS03LHA9dD9lLTE6MCxGPXQ/LTE6MSx4PWlbcitwXTtmb3IocCs9RixvPXgmKDE8PC1zKS0xLHg+Pj0tcyxzKz1mO3M+MDtvPW8qMjU2K2lbcitwXSxwKz1GLHMtPTgpO2Zvcih1PW8mKDE8PC1zKS0xLG8+Pj0tcyxzKz1uO3M+MDt1PXUqMjU2K2lbcitwXSxwKz1GLHMtPTgpO2lmKG89PT0wKW89MS1sO2Vsc2V7aWYobz09PWMpcmV0dXJuIHU/TmFOOih4Py0xOjEpKigxLzApO3U9dStNYXRoLnBvdygyLG4pLG89by1sfXJldHVybih4Py0xOjEpKnUqTWF0aC5wb3coMixvLW4pfTtPLndyaXRlPWZ1bmN0aW9uKGkscix0LG4sZSxvKXt2YXIgdSxmLGMsbD1vKjgtZS0xLHM9KDE8PGwpLTEscD1zPj4xLEY9ZT09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MCx4PW4/MDpvLTEsYj1uPzE6LTEsQnI9cjwwfHxyPT09MCYmMS9yPDA/MTowO2ZvcihyPU1hdGguYWJzKHIpLGlzTmFOKHIpfHxyPT09MS8wPyhmPWlzTmFOKHIpPzE6MCx1PXMpOih1PU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpLHIqKGM9TWF0aC5wb3coMiwtdSkpPDEmJih1LS0sYyo9MiksdStwPj0xP3IrPUYvYzpyKz1GKk1hdGgucG93KDIsMS1wKSxyKmM+PTImJih1KyssYy89MiksdStwPj1zPyhmPTAsdT1zKTp1K3A+PTE/KGY9KHIqYy0xKSpNYXRoLnBvdygyLGUpLHU9dStwKTooZj1yKk1hdGgucG93KDIscC0xKSpNYXRoLnBvdygyLGUpLHU9MCkpO2U+PTg7aVt0K3hdPWYmMjU1LHgrPWIsZi89MjU2LGUtPTgpO2Zvcih1PXU8PGV8ZixsKz1lO2w+MDtpW3QreF09dSYyNTUseCs9Yix1Lz0yNTYsbC09OCk7aVt0K3gtYl18PUJyKjEyOH19KTt2YXIgej0kKFQ9PntcInVzZSBzdHJpY3RcIjt2YXIgRz1RKCksVT12KCkscnI9dHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO1QuQnVmZmVyPWg7VC5TbG93QnVmZmVyPSRyO1QuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIGs9MjE0NzQ4MzY0NztULmtNYXhMZW5ndGg9aztoLlRZUEVEX0FSUkFZX1NVUFBPUlQ9TnIoKTshaC5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZTxcInVcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PVwiZnVuY3Rpb25cIiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKTtmdW5jdGlvbiBOcigpe3RyeXtsZXQgaT1uZXcgVWludDhBcnJheSgxKSxyPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpLE9iamVjdC5zZXRQcm90b3R5cGVPZihpLHIpLGkuZm9vKCk9PT00Mn1jYXRjaChpKXtyZXR1cm4hMX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoaC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoaC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGQoaSl7aWYoaT5rKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2krJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO2xldCByPW5ldyBVaW50OEFycmF5KGkpO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YocixoLnByb3RvdHlwZSkscn1mdW5jdGlvbiBoKGkscix0KXtpZih0eXBlb2YgaT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtyZXR1cm4gaihpKX1yZXR1cm4gZXIoaSxyLHQpfWgucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBlcihpLHIsdCl7aWYodHlwZW9mIGk9PVwic3RyaW5nXCIpcmV0dXJuIGtyKGkscik7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGkpKXJldHVybiBEcihpKTtpZihpPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgaSk7aWYoRShpLEFycmF5QnVmZmVyKXx8aSYmRShpLmJ1ZmZlcixBcnJheUJ1ZmZlcil8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmKEUoaSxTaGFyZWRBcnJheUJ1ZmZlcil8fGkmJkUoaS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSlyZXR1cm4gcShpLHIsdCk7aWYodHlwZW9mIGk9PVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtsZXQgbj1pLnZhbHVlT2YmJmkudmFsdWVPZigpO2lmKG4hPW51bGwmJm4hPT1pKXJldHVybiBoLmZyb20obixyLHQpO2xldCBlPWJyKGkpO2lmKGUpcmV0dXJuIGU7aWYodHlwZW9mIFN5bWJvbDxcInVcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgaVtTeW1ib2wudG9QcmltaXRpdmVdPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGguZnJvbShpW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGkpfWguZnJvbT1mdW5jdGlvbihpLHIsdCl7cmV0dXJuIGVyKGkscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKGgucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoaCxVaW50OEFycmF5KTtmdW5jdGlvbiBvcihpKXtpZih0eXBlb2YgaSE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7aWYoaTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2krJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfWZ1bmN0aW9uIE1yKGkscix0KXtyZXR1cm4gb3IoaSksaTw9MD9kKGkpOnIhPT12b2lkIDA/dHlwZW9mIHQ9PVwic3RyaW5nXCI/ZChpKS5maWxsKHIsdCk6ZChpKS5maWxsKHIpOmQoaSl9aC5hbGxvYz1mdW5jdGlvbihpLHIsdCl7cmV0dXJuIE1yKGkscix0KX07ZnVuY3Rpb24gaihpKXtyZXR1cm4gb3IoaSksZChpPDA/MDpIKGkpfDApfWguYWxsb2NVbnNhZmU9ZnVuY3Rpb24oaSl7cmV0dXJuIGooaSl9O2guYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGkpe3JldHVybiBqKGkpfTtmdW5jdGlvbiBrcihpLHIpe2lmKCh0eXBlb2YgciE9XCJzdHJpbmdcInx8cj09PVwiXCIpJiYocj1cInV0ZjhcIiksIWguaXNFbmNvZGluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7bGV0IHQ9dXIoaSxyKXwwLG49ZCh0KSxlPW4ud3JpdGUoaSxyKTtyZXR1cm4gZSE9PXQmJihuPW4uc2xpY2UoMCxlKSksbn1mdW5jdGlvbiBZKGkpe2xldCByPWkubGVuZ3RoPDA/MDpIKGkubGVuZ3RoKXwwLHQ9ZChyKTtmb3IobGV0IG49MDtuPHI7bis9MSl0W25dPWlbbl0mMjU1O3JldHVybiB0fWZ1bmN0aW9uIERyKGkpe2lmKEUoaSxVaW50OEFycmF5KSl7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoaSk7cmV0dXJuIHEoci5idWZmZXIsci5ieXRlT2Zmc2V0LHIuYnl0ZUxlbmd0aCl9cmV0dXJuIFkoaSl9ZnVuY3Rpb24gcShpLHIsdCl7aWYocjwwfHxpLmJ5dGVMZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtpZihpLmJ5dGVMZW5ndGg8cisodHx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7bGV0IG47cmV0dXJuIHI9PT12b2lkIDAmJnQ9PT12b2lkIDA/bj1uZXcgVWludDhBcnJheShpKTp0PT09dm9pZCAwP249bmV3IFVpbnQ4QXJyYXkoaSxyKTpuPW5ldyBVaW50OEFycmF5KGkscix0KSxPYmplY3Quc2V0UHJvdG90eXBlT2YobixoLnByb3RvdHlwZSksbn1mdW5jdGlvbiBicihpKXtpZihoLmlzQnVmZmVyKGkpKXtsZXQgcj1IKGkubGVuZ3RoKXwwLHQ9ZChyKTtyZXR1cm4gdC5sZW5ndGg9PT0wfHxpLmNvcHkodCwwLDAsciksdH1pZihpLmxlbmd0aCE9PXZvaWQgMClyZXR1cm4gdHlwZW9mIGkubGVuZ3RoIT1cIm51bWJlclwifHxYKGkubGVuZ3RoKT9kKDApOlkoaSk7aWYoaS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShpLmRhdGEpKXJldHVybiBZKGkuZGF0YSl9ZnVuY3Rpb24gSChpKXtpZihpPj1rKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiK2sudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiBpfDB9ZnVuY3Rpb24gJHIoaSl7cmV0dXJuK2khPWkmJihpPTApLGguYWxsb2MoK2kpfWguaXNCdWZmZXI9ZnVuY3Rpb24ocil7cmV0dXJuIHIhPW51bGwmJnIuX2lzQnVmZmVyPT09ITAmJnIhPT1oLnByb3RvdHlwZX07aC5jb21wYXJlPWZ1bmN0aW9uKHIsdCl7aWYoRShyLFVpbnQ4QXJyYXkpJiYocj1oLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpKSxFKHQsVWludDhBcnJheSkmJih0PWguZnJvbSh0LHQub2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLCFoLmlzQnVmZmVyKHIpfHwhaC5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7aWYocj09PXQpcmV0dXJuIDA7bGV0IG49ci5sZW5ndGgsZT10Lmxlbmd0aDtmb3IobGV0IG89MCx1PU1hdGgubWluKG4sZSk7bzx1OysrbylpZihyW29dIT09dFtvXSl7bj1yW29dLGU9dFtvXTticmVha31yZXR1cm4gbjxlPy0xOmU8bj8xOjB9O2guaXNFbmNvZGluZz1mdW5jdGlvbihyKXtzd2l0Y2goU3RyaW5nKHIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19O2guY29uY2F0PWZ1bmN0aW9uKHIsdCl7aWYoIUFycmF5LmlzQXJyYXkocikpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoci5sZW5ndGg9PT0wKXJldHVybiBoLmFsbG9jKDApO2xldCBuO2lmKHQ9PT12b2lkIDApZm9yKHQ9MCxuPTA7bjxyLmxlbmd0aDsrK24pdCs9cltuXS5sZW5ndGg7bGV0IGU9aC5hbGxvY1Vuc2FmZSh0KSxvPTA7Zm9yKG49MDtuPHIubGVuZ3RoOysrbil7bGV0IHU9cltuXTtpZihFKHUsVWludDhBcnJheSkpbyt1Lmxlbmd0aD5lLmxlbmd0aD8oaC5pc0J1ZmZlcih1KXx8KHU9aC5mcm9tKHUpKSx1LmNvcHkoZSxvKSk6VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx1LG8pO2Vsc2UgaWYoaC5pc0J1ZmZlcih1KSl1LmNvcHkoZSxvKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO28rPXUubGVuZ3RofXJldHVybiBlfTtmdW5jdGlvbiB1cihpLHIpe2lmKGguaXNCdWZmZXIoaSkpcmV0dXJuIGkubGVuZ3RoO2lmKEFycmF5QnVmZmVyLmlzVmlldyhpKXx8RShpLEFycmF5QnVmZmVyKSlyZXR1cm4gaS5ieXRlTGVuZ3RoO2lmKHR5cGVvZiBpIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIGkpO2xldCB0PWkubGVuZ3RoLG49YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT0hMDtpZighbiYmdD09PTApcmV0dXJuIDA7bGV0IGU9ITE7Zm9yKDs7KXN3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBXKGkpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gd3IoaSkubGVuZ3RoO2RlZmF1bHQ6aWYoZSlyZXR1cm4gbj8tMTpXKGkpLmxlbmd0aDtyPShcIlwiK3IpLnRvTG93ZXJDYXNlKCksZT0hMH19aC5ieXRlTGVuZ3RoPXVyO2Z1bmN0aW9uIFByKGkscix0KXtsZXQgbj0hMTtpZigocj09PXZvaWQgMHx8cjwwKSYmKHI9MCkscj50aGlzLmxlbmd0aHx8KCh0PT09dm9pZCAwfHx0PnRoaXMubGVuZ3RoKSYmKHQ9dGhpcy5sZW5ndGgpLHQ8PTApfHwodD4+Pj0wLHI+Pj49MCx0PD1yKSlyZXR1cm5cIlwiO2ZvcihpfHwoaT1cInV0ZjhcIik7Oylzd2l0Y2goaSl7Y2FzZVwiaGV4XCI6cmV0dXJuIHpyKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gZnIodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIFZyKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gWHIodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBqcih0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEpyKHRoaXMscix0KTtkZWZhdWx0OmlmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2kpO2k9KGkrXCJcIikudG9Mb3dlckNhc2UoKSxuPSEwfX1oLnByb3RvdHlwZS5faXNCdWZmZXI9ITA7ZnVuY3Rpb24gSShpLHIsdCl7bGV0IG49aVtyXTtpW3JdPWlbdF0saVt0XT1ufWgucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO2lmKHIlMiE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtmb3IobGV0IHQ9MDt0PHI7dCs9MilJKHRoaXMsdCx0KzEpO3JldHVybiB0aGlzfTtoLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24oKXtsZXQgcj10aGlzLmxlbmd0aDtpZihyJTQhPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKGxldCB0PTA7dDxyO3QrPTQpSSh0aGlzLHQsdCszKSxJKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9O2gucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO2lmKHIlOCE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IobGV0IHQ9MDt0PHI7dCs9OClJKHRoaXMsdCx0KzcpLEkodGhpcyx0KzEsdCs2KSxJKHRoaXMsdCsyLHQrNSksSSh0aGlzLHQrMyx0KzQpO3JldHVybiB0aGlzfTtoLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2xldCByPXRoaXMubGVuZ3RoO3JldHVybiByPT09MD9cIlwiOmFyZ3VtZW50cy5sZW5ndGg9PT0wP2ZyKHRoaXMsMCxyKTpQci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2gucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPWgucHJvdG90eXBlLnRvU3RyaW5nO2gucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihyKXtpZighaC5pc0J1ZmZlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PXI/ITA6aC5jb21wYXJlKHRoaXMscik9PT0wfTtoLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7bGV0IHI9XCJcIix0PVQuSU5TUEVDVF9NQVhfQllURVM7cmV0dXJuIHI9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpLHRoaXMubGVuZ3RoPnQmJihyKz1cIiAuLi4gXCIpLFwiPEJ1ZmZlciBcIityK1wiPlwifTtyciYmKGgucHJvdG90eXBlW3JyXT1oLnByb3RvdHlwZS5pbnNwZWN0KTtoLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHIsdCxuLGUsbyl7aWYoRShyLFVpbnQ4QXJyYXkpJiYocj1oLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpKSwhaC5pc0J1ZmZlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHIpO2lmKHQ9PT12b2lkIDAmJih0PTApLG49PT12b2lkIDAmJihuPXI/ci5sZW5ndGg6MCksZT09PXZvaWQgMCYmKGU9MCksbz09PXZvaWQgMCYmKG89dGhpcy5sZW5ndGgpLHQ8MHx8bj5yLmxlbmd0aHx8ZTwwfHxvPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKGU+PW8mJnQ+PW4pcmV0dXJuIDA7aWYoZT49bylyZXR1cm4tMTtpZih0Pj1uKXJldHVybiAxO2lmKHQ+Pj49MCxuPj4+PTAsZT4+Pj0wLG8+Pj49MCx0aGlzPT09cilyZXR1cm4gMDtsZXQgdT1vLWUsZj1uLXQsYz1NYXRoLm1pbih1LGYpLGw9dGhpcy5zbGljZShlLG8pLHM9ci5zbGljZSh0LG4pO2ZvcihsZXQgcD0wO3A8YzsrK3ApaWYobFtwXSE9PXNbcF0pe3U9bFtwXSxmPXNbcF07YnJlYWt9cmV0dXJuIHU8Zj8tMTpmPHU/MTowfTtmdW5jdGlvbiBocihpLHIsdCxuLGUpe2lmKGkubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIj8obj10LHQ9MCk6dD4yMTQ3NDgzNjQ3P3Q9MjE0NzQ4MzY0Nzp0PC0yMTQ3NDgzNjQ4JiYodD0tMjE0NzQ4MzY0OCksdD0rdCxYKHQpJiYodD1lPzA6aS5sZW5ndGgtMSksdDwwJiYodD1pLmxlbmd0aCt0KSx0Pj1pLmxlbmd0aCl7aWYoZSlyZXR1cm4tMTt0PWkubGVuZ3RoLTF9ZWxzZSBpZih0PDApaWYoZSl0PTA7ZWxzZSByZXR1cm4tMTtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIiYmKHI9aC5mcm9tKHIsbikpLGguaXNCdWZmZXIocikpcmV0dXJuIHIubGVuZ3RoPT09MD8tMTp0cihpLHIsdCxuLGUpO2lmKHR5cGVvZiByPT1cIm51bWJlclwiKXJldHVybiByPXImMjU1LHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT1cImZ1bmN0aW9uXCI/ZT9VaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoaSxyLHQpOlVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoaSxyLHQpOnRyKGksW3JdLHQsbixlKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIHRyKGkscix0LG4sZSl7bGV0IG89MSx1PWkubGVuZ3RoLGY9ci5sZW5ndGg7aWYobiE9PXZvaWQgMCYmKG49U3RyaW5nKG4pLnRvTG93ZXJDYXNlKCksbj09PVwidWNzMlwifHxuPT09XCJ1Y3MtMlwifHxuPT09XCJ1dGYxNmxlXCJ8fG49PT1cInV0Zi0xNmxlXCIpKXtpZihpLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXJldHVybi0xO289Mix1Lz0yLGYvPTIsdC89Mn1mdW5jdGlvbiBjKHMscCl7cmV0dXJuIG89PT0xP3NbcF06cy5yZWFkVUludDE2QkUocCpvKX1sZXQgbDtpZihlKXtsZXQgcz0tMTtmb3IobD10O2w8dTtsKyspaWYoYyhpLGwpPT09YyhyLHM9PT0tMT8wOmwtcykpe2lmKHM9PT0tMSYmKHM9bCksbC1zKzE9PT1mKXJldHVybiBzKm99ZWxzZSBzIT09LTEmJihsLT1sLXMpLHM9LTF9ZWxzZSBmb3IodCtmPnUmJih0PXUtZiksbD10O2w+PTA7bC0tKXtsZXQgcz0hMDtmb3IobGV0IHA9MDtwPGY7cCsrKWlmKGMoaSxsK3ApIT09YyhyLHApKXtzPSExO2JyZWFrfWlmKHMpcmV0dXJuIGx9cmV0dXJuLTF9aC5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB0aGlzLmluZGV4T2Yocix0LG4pIT09LTF9O2gucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBocih0aGlzLHIsdCxuLCEwKX07aC5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBocih0aGlzLHIsdCxuLCExKX07ZnVuY3Rpb24gT3IoaSxyLHQsbil7dD1OdW1iZXIodCl8fDA7bGV0IGU9aS5sZW5ndGgtdDtuPyhuPU51bWJlcihuKSxuPmUmJihuPWUpKTpuPWU7bGV0IG89ci5sZW5ndGg7bj5vLzImJihuPW8vMik7bGV0IHU7Zm9yKHU9MDt1PG47Kyt1KXtsZXQgZj1wYXJzZUludChyLnN1YnN0cih1KjIsMiksMTYpO2lmKFgoZikpcmV0dXJuIHU7aVt0K3VdPWZ9cmV0dXJuIHV9ZnVuY3Rpb24gR3IoaSxyLHQsbil7cmV0dXJuIEQoVyhyLGkubGVuZ3RoLXQpLGksdCxuKX1mdW5jdGlvbiBZcihpLHIsdCxuKXtyZXR1cm4gRCh2cihyKSxpLHQsbil9ZnVuY3Rpb24gcXIoaSxyLHQsbil7cmV0dXJuIEQod3IociksaSx0LG4pfWZ1bmN0aW9uIFdyKGkscix0LG4pe3JldHVybiBEKHJ0KHIsaS5sZW5ndGgtdCksaSx0LG4pfWgucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHIsdCxuLGUpe2lmKHQ9PT12b2lkIDApZT1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKG49PT12b2lkIDAmJnR5cGVvZiB0PT1cInN0cmluZ1wiKWU9dCxuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKGlzRmluaXRlKHQpKXQ9dD4+PjAsaXNGaW5pdGUobik/KG49bj4+PjAsZT09PXZvaWQgMCYmKGU9XCJ1dGY4XCIpKTooZT1uLG49dm9pZCAwKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO2xldCBvPXRoaXMubGVuZ3RoLXQ7aWYoKG49PT12b2lkIDB8fG4+bykmJihuPW8pLHIubGVuZ3RoPjAmJihuPDB8fHQ8MCl8fHQ+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtlfHwoZT1cInV0ZjhcIik7bGV0IHU9ITE7Zm9yKDs7KXN3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gT3IodGhpcyxyLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIEdyKHRoaXMscix0LG4pO2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIFlyKHRoaXMscix0LG4pO2Nhc2VcImJhc2U2NFwiOnJldHVybiBxcih0aGlzLHIsdCxuKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gV3IodGhpcyxyLHQsbik7ZGVmYXVsdDppZih1KXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShcIlwiK2UpLnRvTG93ZXJDYXNlKCksdT0hMH19O2gucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBqcihpLHIsdCl7cmV0dXJuIHI9PT0wJiZ0PT09aS5sZW5ndGg/Ry5mcm9tQnl0ZUFycmF5KGkpOkcuZnJvbUJ5dGVBcnJheShpLnNsaWNlKHIsdCkpfWZ1bmN0aW9uIGZyKGkscix0KXt0PU1hdGgubWluKGkubGVuZ3RoLHQpO2xldCBuPVtdLGU9cjtmb3IoO2U8dDspe2xldCBvPWlbZV0sdT1udWxsLGY9bz4yMzk/NDpvPjIyMz8zOm8+MTkxPzI6MTtpZihlK2Y8PXQpe2xldCBjLGwscyxwO3N3aXRjaChmKXtjYXNlIDE6bzwxMjgmJih1PW8pO2JyZWFrO2Nhc2UgMjpjPWlbZSsxXSwoYyYxOTIpPT09MTI4JiYocD0obyYzMSk8PDZ8YyY2MyxwPjEyNyYmKHU9cCkpO2JyZWFrO2Nhc2UgMzpjPWlbZSsxXSxsPWlbZSsyXSwoYyYxOTIpPT09MTI4JiYobCYxOTIpPT09MTI4JiYocD0obyYxNSk8PDEyfChjJjYzKTw8NnxsJjYzLHA+MjA0NyYmKHA8NTUyOTZ8fHA+NTczNDMpJiYodT1wKSk7YnJlYWs7Y2FzZSA0OmM9aVtlKzFdLGw9aVtlKzJdLHM9aVtlKzNdLChjJjE5Mik9PT0xMjgmJihsJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihwPShvJjE1KTw8MTh8KGMmNjMpPDwxMnwobCY2Myk8PDZ8cyY2MyxwPjY1NTM1JiZwPDExMTQxMTImJih1PXApKX19dT09PW51bGw/KHU9NjU1MzMsZj0xKTp1PjY1NTM1JiYodS09NjU1MzYsbi5wdXNoKHU+Pj4xMCYxMDIzfDU1Mjk2KSx1PTU2MzIwfHUmMTAyMyksbi5wdXNoKHUpLGUrPWZ9cmV0dXJuIEhyKG4pfXZhciBpcj00MDk2O2Z1bmN0aW9uIEhyKGkpe2xldCByPWkubGVuZ3RoO2lmKHI8PWlyKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKTtsZXQgdD1cIlwiLG49MDtmb3IoO248cjspdCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaS5zbGljZShuLG4rPWlyKSk7cmV0dXJuIHR9ZnVuY3Rpb24gVnIoaSxyLHQpe2xldCBuPVwiXCI7dD1NYXRoLm1pbihpLmxlbmd0aCx0KTtmb3IobGV0IGU9cjtlPHQ7KytlKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoaVtlXSYxMjcpO3JldHVybiBufWZ1bmN0aW9uIFhyKGkscix0KXtsZXQgbj1cIlwiO3Q9TWF0aC5taW4oaS5sZW5ndGgsdCk7Zm9yKGxldCBlPXI7ZTx0OysrZSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGlbZV0pO3JldHVybiBufWZ1bmN0aW9uIHpyKGkscix0KXtsZXQgbj1pLmxlbmd0aDsoIXJ8fHI8MCkmJihyPTApLCghdHx8dDwwfHx0Pm4pJiYodD1uKTtsZXQgZT1cIlwiO2ZvcihsZXQgbz1yO288dDsrK28pZSs9dHRbaVtvXV07cmV0dXJuIGV9ZnVuY3Rpb24gSnIoaSxyLHQpe2xldCBuPWkuc2xpY2Uocix0KSxlPVwiXCI7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aC0xO28rPTIpZSs9U3RyaW5nLmZyb21DaGFyQ29kZShuW29dK25bbysxXSoyNTYpO3JldHVybiBlfWgucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHIsdCl7bGV0IG49dGhpcy5sZW5ndGg7cj1+fnIsdD10PT09dm9pZCAwP246fn50LHI8MD8ocis9bixyPDAmJihyPTApKTpyPm4mJihyPW4pLHQ8MD8odCs9bix0PDAmJih0PTApKTp0Pm4mJih0PW4pLHQ8ciYmKHQ9cik7bGV0IGU9dGhpcy5zdWJhcnJheShyLHQpO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxoLnByb3RvdHlwZSksZX07ZnVuY3Rpb24gYShpLHIsdCl7aWYoaSUxIT09MHx8aTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGkrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1oLnByb3RvdHlwZS5yZWFkVWludExFPWgucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24ocix0LG4pe3I9cj4+PjAsdD10Pj4+MCxufHxhKHIsdCx0aGlzLmxlbmd0aCk7bGV0IGU9dGhpc1tyXSxvPTEsdT0wO2Zvcig7Kyt1PHQmJihvKj0yNTYpOyllKz10aGlzW3IrdV0qbztyZXR1cm4gZX07aC5wcm90b3R5cGUucmVhZFVpbnRCRT1oLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHIsdCxuKXtyPXI+Pj4wLHQ9dD4+PjAsbnx8YShyLHQsdGhpcy5sZW5ndGgpO2xldCBlPXRoaXNbcistLXRdLG89MTtmb3IoO3Q+MCYmKG8qPTI1Nik7KWUrPXRoaXNbcistLXRdKm87cmV0dXJuIGV9O2gucHJvdG90eXBlLnJlYWRVaW50OD1oLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsMSx0aGlzLmxlbmd0aCksdGhpc1tyXX07aC5wcm90b3R5cGUucmVhZFVpbnQxNkxFPWgucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKSx0aGlzW3JdfHRoaXNbcisxXTw8OH07aC5wcm90b3R5cGUucmVhZFVpbnQxNkJFPWgucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociwyLHRoaXMubGVuZ3RoKSx0aGlzW3JdPDw4fHRoaXNbcisxXX07aC5wcm90b3R5cGUucmVhZFVpbnQzMkxFPWgucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSwodGhpc1tyXXx0aGlzW3IrMV08PDh8dGhpc1tyKzJdPDwxNikrdGhpc1tyKzNdKjE2Nzc3MjE2fTtoLnByb3RvdHlwZS5yZWFkVWludDMyQkU9aC5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDQsdGhpcy5sZW5ndGgpLHRoaXNbcl0qMTY3NzcyMTYrKHRoaXNbcisxXTw8MTZ8dGhpc1tyKzJdPDw4fHRoaXNbciszXSl9O2gucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRT1nKGZ1bmN0aW9uKHIpe3I9cj4+PjAsUihyLFwib2Zmc2V0XCIpO2xldCB0PXRoaXNbcl0sbj10aGlzW3IrN107KHQ9PT12b2lkIDB8fG49PT12b2lkIDApJiZfKHIsdGhpcy5sZW5ndGgtOCk7bGV0IGU9dCt0aGlzWysrcl0qMioqOCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjI0LG89dGhpc1srK3JdK3RoaXNbKytyXSoyKio4K3RoaXNbKytyXSoyKioxNituKjIqKjI0O3JldHVybiBCaWdJbnQoZSkrKEJpZ0ludChvKTw8QmlnSW50KDMyKSl9KTtoLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkU9ZyhmdW5jdGlvbihyKXtyPXI+Pj4wLFIocixcIm9mZnNldFwiKTtsZXQgdD10aGlzW3JdLG49dGhpc1tyKzddOyh0PT09dm9pZCAwfHxuPT09dm9pZCAwKSYmXyhyLHRoaXMubGVuZ3RoLTgpO2xldCBlPXQqMioqMjQrdGhpc1srK3JdKjIqKjE2K3RoaXNbKytyXSoyKio4K3RoaXNbKytyXSxvPXRoaXNbKytyXSoyKioyNCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjgrbjtyZXR1cm4oQmlnSW50KGUpPDxCaWdJbnQoMzIpKStCaWdJbnQobyl9KTtoLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24ocix0LG4pe3I9cj4+PjAsdD10Pj4+MCxufHxhKHIsdCx0aGlzLmxlbmd0aCk7bGV0IGU9dGhpc1tyXSxvPTEsdT0wO2Zvcig7Kyt1PHQmJihvKj0yNTYpOyllKz10aGlzW3IrdV0qbztyZXR1cm4gbyo9MTI4LGU+PW8mJihlLT1NYXRoLnBvdygyLDgqdCkpLGV9O2gucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbihyLHQsbil7cj1yPj4+MCx0PXQ+Pj4wLG58fGEocix0LHRoaXMubGVuZ3RoKTtsZXQgZT10LG89MSx1PXRoaXNbcistLWVdO2Zvcig7ZT4wJiYobyo9MjU2KTspdSs9dGhpc1tyKy0tZV0qbztyZXR1cm4gbyo9MTI4LHU+PW8mJih1LT1NYXRoLnBvdygyLDgqdCkpLHV9O2gucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDEsdGhpcy5sZW5ndGgpLHRoaXNbcl0mMTI4PygyNTUtdGhpc1tyXSsxKSotMTp0aGlzW3JdfTtoLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihyLHQpe3I9cj4+PjAsdHx8YShyLDIsdGhpcy5sZW5ndGgpO2xldCBuPXRoaXNbcl18dGhpc1tyKzFdPDw4O3JldHVybiBuJjMyNzY4P258NDI5NDkwMTc2MDpufTtoLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihyLHQpe3I9cj4+PjAsdHx8YShyLDIsdGhpcy5sZW5ndGgpO2xldCBuPXRoaXNbcisxXXx0aGlzW3JdPDw4O3JldHVybiBuJjMyNzY4P258NDI5NDkwMTc2MDpufTtoLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSx0aGlzW3JdfHRoaXNbcisxXTw8OHx0aGlzW3IrMl08PDE2fHRoaXNbciszXTw8MjR9O2gucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDQsdGhpcy5sZW5ndGgpLHRoaXNbcl08PDI0fHRoaXNbcisxXTw8MTZ8dGhpc1tyKzJdPDw4fHRoaXNbciszXX07aC5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEU9ZyhmdW5jdGlvbihyKXtyPXI+Pj4wLFIocixcIm9mZnNldFwiKTtsZXQgdD10aGlzW3JdLG49dGhpc1tyKzddOyh0PT09dm9pZCAwfHxuPT09dm9pZCAwKSYmXyhyLHRoaXMubGVuZ3RoLTgpO2xldCBlPXRoaXNbcis0XSt0aGlzW3IrNV0qMioqOCt0aGlzW3IrNl0qMioqMTYrKG48PDI0KTtyZXR1cm4oQmlnSW50KGUpPDxCaWdJbnQoMzIpKStCaWdJbnQodCt0aGlzWysrcl0qMioqOCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjI0KX0pO2gucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFPWcoZnVuY3Rpb24ocil7cj1yPj4+MCxSKHIsXCJvZmZzZXRcIik7bGV0IHQ9dGhpc1tyXSxuPXRoaXNbcis3XTsodD09PXZvaWQgMHx8bj09PXZvaWQgMCkmJl8ocix0aGlzLmxlbmd0aC04KTtsZXQgZT0odDw8MjQpK3RoaXNbKytyXSoyKioxNit0aGlzWysrcl0qMioqOCt0aGlzWysrcl07cmV0dXJuKEJpZ0ludChlKTw8QmlnSW50KDMyKSkrQmlnSW50KHRoaXNbKytyXSoyKioyNCt0aGlzWysrcl0qMioqMTYrdGhpc1srK3JdKjIqKjgrbil9KTtoLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSxVLnJlYWQodGhpcyxyLCEwLDIzLDQpfTtoLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihyLHQpe3JldHVybiByPXI+Pj4wLHR8fGEociw0LHRoaXMubGVuZ3RoKSxVLnJlYWQodGhpcyxyLCExLDIzLDQpfTtoLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcj1yPj4+MCx0fHxhKHIsOCx0aGlzLmxlbmd0aCksVS5yZWFkKHRoaXMsciwhMCw1Miw4KX07aC5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHI9cj4+PjAsdHx8YShyLDgsdGhpcy5sZW5ndGgpLFUucmVhZCh0aGlzLHIsITEsNTIsOCl9O2Z1bmN0aW9uIHkoaSxyLHQsbixlLG8pe2lmKCFoLmlzQnVmZmVyKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+ZXx8cjxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrbj5pLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1oLnByb3RvdHlwZS53cml0ZVVpbnRMRT1oLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsbj1uPj4+MCwhZSl7bGV0IGY9TWF0aC5wb3coMiw4Km4pLTE7eSh0aGlzLHIsdCxuLGYsMCl9bGV0IG89MSx1PTA7Zm9yKHRoaXNbdF09ciYyNTU7Kyt1PG4mJihvKj0yNTYpOyl0aGlzW3QrdV09ci9vJjI1NTtyZXR1cm4gdCtufTtoLnByb3RvdHlwZS53cml0ZVVpbnRCRT1oLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsbj1uPj4+MCwhZSl7bGV0IGY9TWF0aC5wb3coMiw4Km4pLTE7eSh0aGlzLHIsdCxuLGYsMCl9bGV0IG89bi0xLHU9MTtmb3IodGhpc1t0K29dPXImMjU1Oy0tbz49MCYmKHUqPTI1Nik7KXRoaXNbdCtvXT1yL3UmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlVWludDg9aC5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDEsMjU1LDApLHRoaXNbdF09ciYyNTUsdCsxfTtoLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFPWgucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCwyLDY1NTM1LDApLHRoaXNbdF09ciYyNTUsdGhpc1t0KzFdPXI+Pj44LHQrMn07aC5wcm90b3R5cGUud3JpdGVVaW50MTZCRT1oLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsMiw2NTUzNSwwKSx0aGlzW3RdPXI+Pj44LHRoaXNbdCsxXT1yJjI1NSx0KzJ9O2gucHJvdG90eXBlLndyaXRlVWludDMyTEU9aC5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDQsNDI5NDk2NzI5NSwwKSx0aGlzW3QrM109cj4+PjI0LHRoaXNbdCsyXT1yPj4+MTYsdGhpc1t0KzFdPXI+Pj44LHRoaXNbdF09ciYyNTUsdCs0fTtoLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFPWgucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiByPStyLHQ9dD4+PjAsbnx8eSh0aGlzLHIsdCw0LDQyOTQ5NjcyOTUsMCksdGhpc1t0XT1yPj4+MjQsdGhpc1t0KzFdPXI+Pj4xNix0aGlzW3QrMl09cj4+PjgsdGhpc1t0KzNdPXImMjU1LHQrNH07ZnVuY3Rpb24gY3IoaSxyLHQsbixlKXt5cihyLG4sZSxpLHQsNyk7bGV0IG89TnVtYmVyKHImQmlnSW50KDQyOTQ5NjcyOTUpKTtpW3QrK109byxvPW8+PjgsaVt0KytdPW8sbz1vPj44LGlbdCsrXT1vLG89bz4+OCxpW3QrK109bztsZXQgdT1OdW1iZXIocj4+QmlnSW50KDMyKSZCaWdJbnQoNDI5NDk2NzI5NSkpO3JldHVybiBpW3QrK109dSx1PXU+PjgsaVt0KytdPXUsdT11Pj44LGlbdCsrXT11LHU9dT4+OCxpW3QrK109dSx0fWZ1bmN0aW9uIHByKGkscix0LG4sZSl7eXIocixuLGUsaSx0LDcpO2xldCBvPU51bWJlcihyJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7aVt0KzddPW8sbz1vPj44LGlbdCs2XT1vLG89bz4+OCxpW3QrNV09byxvPW8+PjgsaVt0KzRdPW87bGV0IHU9TnVtYmVyKHI+PkJpZ0ludCgzMikmQmlnSW50KDQyOTQ5NjcyOTUpKTtyZXR1cm4gaVt0KzNdPXUsdT11Pj44LGlbdCsyXT11LHU9dT4+OCxpW3QrMV09dSx1PXU+PjgsaVt0XT11LHQrOH1oLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFPWcoZnVuY3Rpb24ocix0PTApe3JldHVybiBjcih0aGlzLHIsdCxCaWdJbnQoMCksQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2gucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkU9ZyhmdW5jdGlvbihyLHQ9MCl7cmV0dXJuIHByKHRoaXMscix0LEJpZ0ludCgwKSxCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpfSk7aC5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbihyLHQsbixlKXtpZihyPStyLHQ9dD4+PjAsIWUpe2xldCBjPU1hdGgucG93KDIsOCpuLTEpO3kodGhpcyxyLHQsbixjLTEsLWMpfWxldCBvPTAsdT0xLGY9MDtmb3IodGhpc1t0XT1yJjI1NTsrK288biYmKHUqPTI1Nik7KXI8MCYmZj09PTAmJnRoaXNbdCtvLTFdIT09MCYmKGY9MSksdGhpc1t0K29dPShyL3U+PjApLWYmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24ocix0LG4sZSl7aWYocj0rcix0PXQ+Pj4wLCFlKXtsZXQgYz1NYXRoLnBvdygyLDgqbi0xKTt5KHRoaXMscix0LG4sYy0xLC1jKX1sZXQgbz1uLTEsdT0xLGY9MDtmb3IodGhpc1t0K29dPXImMjU1Oy0tbz49MCYmKHUqPTI1Nik7KXI8MCYmZj09PTAmJnRoaXNbdCtvKzFdIT09MCYmKGY9MSksdGhpc1t0K29dPShyL3U+PjApLWYmMjU1O3JldHVybiB0K259O2gucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDEsMTI3LC0xMjgpLHI8MCYmKHI9MjU1K3IrMSksdGhpc1t0XT1yJjI1NSx0KzF9O2gucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPXImMjU1LHRoaXNbdCsxXT1yPj4+OCx0KzJ9O2gucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPXI+Pj44LHRoaXNbdCsxXT1yJjI1NSx0KzJ9O2gucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHI9K3IsdD10Pj4+MCxufHx5KHRoaXMscix0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdGhpc1t0XT1yJjI1NSx0aGlzW3QrMV09cj4+PjgsdGhpc1t0KzJdPXI+Pj4xNix0aGlzW3QrM109cj4+PjI0LHQrNH07aC5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLG58fHkodGhpcyxyLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxyPDAmJihyPTQyOTQ5NjcyOTUrcisxKSx0aGlzW3RdPXI+Pj4yNCx0aGlzW3QrMV09cj4+PjE2LHRoaXNbdCsyXT1yPj4+OCx0aGlzW3QrM109ciYyNTUsdCs0fTtoLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEU9ZyhmdW5jdGlvbihyLHQ9MCl7cmV0dXJuIGNyKHRoaXMscix0LC1CaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDBcIiksQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKX0pO2gucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRT1nKGZ1bmN0aW9uKHIsdD0wKXtyZXR1cm4gcHIodGhpcyxyLHQsLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSxCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpfSk7ZnVuY3Rpb24gc3IoaSxyLHQsbixlLG8pe2lmKHQrbj5pLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gbHIoaSxyLHQsbixlKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLGV8fHNyKGkscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKSxVLndyaXRlKGkscix0LG4sMjMsNCksdCs0fWgucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIGxyKHRoaXMscix0LCEwLG4pfTtoLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiBscih0aGlzLHIsdCwhMSxuKX07ZnVuY3Rpb24gYXIoaSxyLHQsbixlKXtyZXR1cm4gcj0rcix0PXQ+Pj4wLGV8fHNyKGkscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpLFUud3JpdGUoaSxyLHQsbiw1Miw4KSx0Kzh9aC5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIGFyKHRoaXMscix0LCEwLG4pfTtoLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gYXIodGhpcyxyLHQsITEsbil9O2gucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24ocix0LG4sZSl7aWYoIWguaXNCdWZmZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZihufHwobj0wKSwhZSYmZSE9PTAmJihlPXRoaXMubGVuZ3RoKSx0Pj1yLmxlbmd0aCYmKHQ9ci5sZW5ndGgpLHR8fCh0PTApLGU+MCYmZTxuJiYoZT1uKSxlPT09bnx8ci5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2U+dGhpcy5sZW5ndGgmJihlPXRoaXMubGVuZ3RoKSxyLmxlbmd0aC10PGUtbiYmKGU9ci5sZW5ndGgtdCtuKTtsZXQgbz1lLW47cmV0dXJuIHRoaXM9PT1yJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09XCJmdW5jdGlvblwiP3RoaXMuY29weVdpdGhpbih0LG4sZSk6VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwocix0aGlzLnN1YmFycmF5KG4sZSksdCksb307aC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihyLHQsbixlKXtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIil7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCI/KGU9dCx0PTAsbj10aGlzLmxlbmd0aCk6dHlwZW9mIG49PVwic3RyaW5nXCImJihlPW4sbj10aGlzLmxlbmd0aCksZSE9PXZvaWQgMCYmdHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJiFoLmlzRW5jb2RpbmcoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2lmKHIubGVuZ3RoPT09MSl7bGV0IHU9ci5jaGFyQ29kZUF0KDApOyhlPT09XCJ1dGY4XCImJnU8MTI4fHxlPT09XCJsYXRpbjFcIikmJihyPXUpfX1lbHNlIHR5cGVvZiByPT1cIm51bWJlclwiP3I9ciYyNTU6dHlwZW9mIHI9PVwiYm9vbGVhblwiJiYocj1OdW1iZXIocikpO2lmKHQ8MHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPD10KXJldHVybiB0aGlzO3Q9dD4+PjAsbj1uPT09dm9pZCAwP3RoaXMubGVuZ3RoOm4+Pj4wLHJ8fChyPTApO2xldCBvO2lmKHR5cGVvZiByPT1cIm51bWJlclwiKWZvcihvPXQ7bzxuOysrbyl0aGlzW29dPXI7ZWxzZXtsZXQgdT1oLmlzQnVmZmVyKHIpP3I6aC5mcm9tKHIsZSksZj11Lmxlbmd0aDtpZihmPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK3IrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpO2ZvcihvPTA7bzxuLXQ7KytvKXRoaXNbbyt0XT11W28lZl19cmV0dXJuIHRoaXN9O3ZhciBBPXt9O2Z1bmN0aW9uIFYoaSxyLHQpe0FbaV09Y2xhc3MgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIm1lc3NhZ2VcIix7dmFsdWU6ci5hcHBseSh0aGlzLGFyZ3VtZW50cyksd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdGhpcy5uYW1lPVwiXCIuY29uY2F0KHRoaXMubmFtZSxcIiBbXCIpLmNvbmNhdChpLFwiXVwiKSx0aGlzLnN0YWNrLGRlbGV0ZSB0aGlzLm5hbWV9Z2V0IGNvZGUoKXtyZXR1cm4gaX1zZXQgY29kZShlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImNvZGVcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZSx3cml0YWJsZTohMH0pfXRvU3RyaW5nKCl7cmV0dXJuXCJcIi5jb25jYXQodGhpcy5uYW1lLFwiIFtcIikuY29uY2F0KGksXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSl9fX1WKFwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGk/XCJcIi5jb25jYXQoaSxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIik6XCJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzXCJ9LFJhbmdlRXJyb3IpO1YoXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLGZ1bmN0aW9uKGkscil7cmV0dXJuJ1RoZSBcIicuY29uY2F0KGksJ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJykuY29uY2F0KHR5cGVvZiByKX0sVHlwZUVycm9yKTtWKFwiRVJSX09VVF9PRl9SQU5HRVwiLGZ1bmN0aW9uKGkscix0KXtsZXQgbj0nVGhlIHZhbHVlIG9mIFwiJy5jb25jYXQoaSwnXCIgaXMgb3V0IG9mIHJhbmdlLicpLGU9dDtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih0KSYmTWF0aC5hYnModCk+MioqMzI/ZT1ucihTdHJpbmcodCkpOnR5cGVvZiB0PT1cImJpZ2ludFwiJiYoZT1TdHJpbmcodCksKHQ+QmlnSW50KDIpKipCaWdJbnQoMzIpfHx0PC0oQmlnSW50KDIpKipCaWdJbnQoMzIpKSkmJihlPW5yKGUpKSxlKz1cIm5cIiksbis9XCIgSXQgbXVzdCBiZSBcIi5jb25jYXQocixcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChlKSxufSxSYW5nZUVycm9yKTtmdW5jdGlvbiBucihpKXtsZXQgcj1cIlwiLHQ9aS5sZW5ndGgsbj1pWzBdPT09XCItXCI/MTowO2Zvcig7dD49bis0O3QtPTMpcj1cIl9cIi5jb25jYXQoaS5zbGljZSh0LTMsdCkpLmNvbmNhdChyKTtyZXR1cm5cIlwiLmNvbmNhdChpLnNsaWNlKDAsdCkpLmNvbmNhdChyKX1mdW5jdGlvbiBLcihpLHIsdCl7UihyLFwib2Zmc2V0XCIpLChpW3JdPT09dm9pZCAwfHxpW3IrdF09PT12b2lkIDApJiZfKHIsaS5sZW5ndGgtKHQrMSkpfWZ1bmN0aW9uIHlyKGkscix0LG4sZSxvKXtpZihpPnR8fGk8cil7bGV0IHU9dHlwZW9mIHI9PVwiYmlnaW50XCI/XCJuXCI6XCJcIixmO3Rocm93IG8+Mz9yPT09MHx8cj09PUJpZ0ludCgwKT9mPVwiPj0gMFwiLmNvbmNhdCh1LFwiIGFuZCA8IDJcIikuY29uY2F0KHUsXCIgKiogXCIpLmNvbmNhdCgobysxKSo4KS5jb25jYXQodSk6Zj1cIj49IC0oMlwiLmNvbmNhdCh1LFwiICoqIFwiKS5jb25jYXQoKG8rMSkqOC0xKS5jb25jYXQodSxcIikgYW5kIDwgMiAqKiBcIikrXCJcIi5jb25jYXQoKG8rMSkqOC0xKS5jb25jYXQodSk6Zj1cIj49IFwiLmNvbmNhdChyKS5jb25jYXQodSxcIiBhbmQgPD0gXCIpLmNvbmNhdCh0KS5jb25jYXQodSksbmV3IEEuRVJSX09VVF9PRl9SQU5HRShcInZhbHVlXCIsZixpKX1LcihuLGUsbyl9ZnVuY3Rpb24gUihpLHIpe2lmKHR5cGVvZiBpIT1cIm51bWJlclwiKXRocm93IG5ldyBBLkVSUl9JTlZBTElEX0FSR19UWVBFKHIsXCJudW1iZXJcIixpKX1mdW5jdGlvbiBfKGkscix0KXt0aHJvdyBNYXRoLmZsb29yKGkpIT09aT8oUihpLHQpLG5ldyBBLkVSUl9PVVRfT0ZfUkFOR0UodHx8XCJvZmZzZXRcIixcImFuIGludGVnZXJcIixpKSk6cjwwP25ldyBBLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUzpuZXcgQS5FUlJfT1VUX09GX1JBTkdFKHR8fFwib2Zmc2V0XCIsXCI+PSBcIi5jb25jYXQodD8xOjAsXCIgYW5kIDw9IFwiKS5jb25jYXQociksaSl9dmFyIFpyPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gUXIoaSl7aWYoaT1pLnNwbGl0KFwiPVwiKVswXSxpPWkudHJpbSgpLnJlcGxhY2UoWnIsXCJcIiksaS5sZW5ndGg8MilyZXR1cm5cIlwiO2Zvcig7aS5sZW5ndGglNCE9PTA7KWk9aStcIj1cIjtyZXR1cm4gaX1mdW5jdGlvbiBXKGkscil7cj1yfHwxLzA7bGV0IHQsbj1pLmxlbmd0aCxlPW51bGwsbz1bXTtmb3IobGV0IHU9MDt1PG47Kyt1KXtpZih0PWkuY2hhckNvZGVBdCh1KSx0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighZSl7aWYodD41NjMxOSl7KHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYodSsxPT09bil7KHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWU9dDtjb250aW51ZX1pZih0PDU2MzIwKXsoci09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSksZT10O2NvbnRpbnVlfXQ9KGUtNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgZSYmKHItPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2lmKGU9bnVsbCx0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7by5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztvLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7by5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO28ucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX1yZXR1cm4gb31mdW5jdGlvbiB2cihpKXtsZXQgcj1bXTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdClyLnB1c2goaS5jaGFyQ29kZUF0KHQpJjI1NSk7cmV0dXJuIHJ9ZnVuY3Rpb24gcnQoaSxyKXtsZXQgdCxuLGUsbz1bXTtmb3IobGV0IHU9MDt1PGkubGVuZ3RoJiYhKChyLT0yKTwwKTsrK3UpdD1pLmNoYXJDb2RlQXQodSksbj10Pj44LGU9dCUyNTYsby5wdXNoKGUpLG8ucHVzaChuKTtyZXR1cm4gb31mdW5jdGlvbiB3cihpKXtyZXR1cm4gRy50b0J5dGVBcnJheShRcihpKSl9ZnVuY3Rpb24gRChpLHIsdCxuKXtsZXQgZTtmb3IoZT0wO2U8biYmIShlK3Q+PXIubGVuZ3RofHxlPj1pLmxlbmd0aCk7KytlKXJbZSt0XT1pW2VdO3JldHVybiBlfWZ1bmN0aW9uIEUoaSxyKXtyZXR1cm4gaSBpbnN0YW5jZW9mIHJ8fGkhPW51bGwmJmkuY29uc3RydWN0b3IhPW51bGwmJmkuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmaS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIFgoaSl7cmV0dXJuIGkhPT1pfXZhciB0dD1mdW5jdGlvbigpe2xldCBpPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLHI9bmV3IEFycmF5KDI1Nik7Zm9yKGxldCB0PTA7dDwxNjsrK3Qpe2xldCBuPXQqMTY7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpcltuK2VdPWlbdF0raVtlXX1yZXR1cm4gcn0oKTtmdW5jdGlvbiBnKGkpe3JldHVybiB0eXBlb2YgQmlnSW50PlwidVwiP2l0Oml9ZnVuY3Rpb24gaXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgbm90IHN1cHBvcnRlZFwiKX19KTt2YXIgQz17fTtGcihDLHtkZWZhdWx0OigpPT5udH0pO21vZHVsZS5leHBvcnRzPUFyKEMpO3ZhciB4cj1KKHooKSk7UyhDLEooeigpKSxtb2R1bGUuZXhwb3J0cyk7dmFyIG50PXhyLmRlZmF1bHQ7XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5pZWVlNzU0L2luZGV4LmpzOlxuICAoKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqKVxuXG5idWZmZXIvaW5kZXguanM6XG4gICgqIVxuICAgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAgICpcbiAgICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAgICogQGxpY2Vuc2UgIE1JVFxuICAgKilcbiovXG4iXSwibmFtZXMiOlsiU0NIRU1FUyIsInV1aWQiLCJzY2hlbWUiLCJ1cm4iLCJtYWlsdG8iLCJ3c3MiLCJ3cyIsImh0dHBzIiwiaHR0cCIsInVybkNvbXBvbmVudHMiLCJuc3MiLCJ1dWlkQ29tcG9uZW50cyIsInRvTG93ZXJDYXNlIiwib3B0aW9ucyIsImVycm9yIiwidG9sZXJhbnQiLCJtYXRjaCIsIlVVSUQiLCJ1bmRlZmluZWQiLCJoYW5kbGVyIiwidXJpQ29tcG9uZW50cyIsInBhdGgiLCJuaWQiLCJzY2hlbWVIYW5kbGVyIiwic2VyaWFsaXplIiwidXJuU2NoZW1lIiwicGFyc2UiLCJtYXRjaGVzIiwiY29tcG9uZW50cyIsIlVSTl9QQVJTRSIsInF1ZXJ5IiwiZmllbGRzIiwiam9pbiIsImxlbmd0aCIsInB1c2giLCJuYW1lIiwicmVwbGFjZSIsIlBDVF9FTkNPREVEIiwiZGVjb2RlVW5yZXNlcnZlZCIsInRvVXBwZXJDYXNlIiwiTk9UX0hGTkFNRSIsInBjdEVuY0NoYXIiLCJoZWFkZXJzIiwiTk9UX0hGVkFMVUUiLCJPIiwibWFpbHRvQ29tcG9uZW50cyIsImJvZHkiLCJzdWJqZWN0IiwidG8iLCJ4IiwibG9jYWxQYXJ0IiwiZG9tYWluIiwiaXJpIiwiZSIsInB1bnljb2RlIiwidG9BU0NJSSIsInVuZXNjYXBlQ29tcG9uZW50IiwidG9Vbmljb2RlIiwidG9BZGRyIiwic2xpY2UiLCJhdElkeCIsIk5PVF9MT0NBTF9QQVJUIiwibGFzdEluZGV4T2YiLCJTdHJpbmciLCJ4bCIsInRvQXJyYXkiLCJhZGRyIiwidW5pY29kZVN1cHBvcnQiLCJzcGxpdCIsInVua25vd25IZWFkZXJzIiwiaGZpZWxkIiwidG9BZGRycyIsImhmaWVsZHMiLCJkZWNTdHIiLCJVTlJFU0VSVkVEIiwic3RyIiwicGN0RGVjQ2hhcnMiLCJSZWdFeHAiLCJtZXJnZSIsIlVOUkVTRVJWRUQkJCIsIlNPTUVfREVMSU1TJCQiLCJBVEVYVCQkIiwiVkNIQVIkJCIsIlBDVF9FTkNPREVEJCIsIlFURVhUJCQiLCJzdWJleHAiLCJIRVhESUckJCIsImlzSVJJIiwiZG9tYWluSG9zdCIsIndzQ29tcG9uZW50cyIsImZyYWdtZW50IiwicmVzb3VyY2VOYW1lIiwic2VjdXJlIiwicG9ydCIsImlzU2VjdXJlIiwiaG9zdCIsInRvU3RyaW5nIiwiVVJJX1BST1RPQ09MIiwiSVJJX1BST1RPQ09MIiwiRVNDQVBFIiwiZXNjYXBlQ29tcG9uZW50IiwidXJpQSIsInVyaUIiLCJ0eXBlT2YiLCJlcXVhbCIsInVyaSIsIm5vcm1hbGl6ZSIsInJlc29sdmVDb21wb25lbnRzIiwiYmFzZVVSSSIsInNjaGVtZWxlc3NPcHRpb25zIiwicmVsYXRpdmVVUkkiLCJhc3NpZ24iLCJyZXNvbHZlIiwidGFyZ2V0IiwicmVsYXRpdmUiLCJiYXNlIiwidXNlcmluZm8iLCJyZW1vdmVEb3RTZWdtZW50cyIsImNoYXJBdCIsInNraXBOb3JtYWxpemF0aW9uIiwidXJpVG9rZW5zIiwicyIsImF1dGhvcml0eSIsImFic29sdXRlUGF0aCIsInJlZmVyZW5jZSIsIl9yZWNvbXBvc2VBdXRob3JpdHkiLCJwcm90b2NvbCIsIklQVjZBRERSRVNTIiwidGVzdCIsIm91dHB1dCIsIkVycm9yIiwiaW5wdXQiLCJpbSIsIlJEUzUiLCJwb3AiLCJSRFMzIiwiUkRTMiIsIlJEUzEiLCIkMSIsIiQyIiwiX25vcm1hbGl6ZUlQdjYiLCJfbm9ybWFsaXplSVB2NCIsIl8iLCJ1cmlTdHJpbmciLCJpc05hTiIsImluZGV4T2YiLCJwYXJzZUludCIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsIlVSSV9QQVJTRSIsIm5ld0hvc3QiLCJ6b25lIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwibG9uZ2VzdFplcm9GaWVsZHMiLCJpbmRleCIsImIiLCJhIiwiYWxsWmVyb0ZpZWxkcyIsInNvcnQiLCJhY2MiLCJsYXN0TG9uZ2VzdCIsImZpZWxkIiwicmVkdWNlIiwiZmllbGRDb3VudCIsImlzTGFzdEZpZWxkSVB2NEFkZHJlc3MiLCJmaXJzdEZpZWxkcyIsImxhc3RGaWVsZHMiLCJsYXN0RmllbGRzU3RhcnQiLCJBcnJheSIsIklQVjRBRERSRVNTIiwibGFzdCIsIm1hcCIsIl9zdHJpcExlYWRpbmdaZXJvcyIsImZpcnN0IiwiYWRkcmVzcyIsInJldmVyc2UiLCJOT1RfRlJBR01FTlQiLCJOT1RfUVVFUlkiLCJOT1RfUEFUSCIsIk5PVF9QQVRIX05PU0NIRU1FIiwiTk9UX0hPU1QiLCJOT1RfVVNFUklORk8iLCJOT1RfU0NIRU1FIiwiX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIiwibmV3U3RyIiwic3Vic3RyIiwiaSIsImZyb21DaGFyQ29kZSIsImMiLCJjMiIsImMzIiwiaWwiLCJjaHIiLCJjaGFyQ29kZUF0IiwiZW5jb2RlIiwiZGVjb2RlIiwidWNzMmVuY29kZSIsInVjczJkZWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwic3RyaW5nIiwibWFwRG9tYWluIiwicmVnZXhQdW55Y29kZSIsIm4iLCJkZWx0YSIsImhhbmRsZWRDUENvdW50IiwiYWRhcHQiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJiYXNpY0xlbmd0aCIsInN0cmluZ0Zyb21DaGFyQ29kZSIsImRpZ2l0VG9CYXNpYyIsInEiLCJmbG9vciIsInFNaW51c1QiLCJiYXNlTWludXNUIiwidCIsImsiLCJiaWFzIiwidE1pbiIsInRNYXgiLCJjdXJyZW50VmFsdWUiLCJtYXhJbnQiLCJtIiwiaW5wdXRMZW5ndGgiLCJkZWxpbWl0ZXIiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZnJvbUNvZGVQb2ludCIsInNwbGljZSIsIm91dCIsIm9sZGkiLCJ3IiwiZGlnaXQiLCJiYXNpY1RvRGlnaXQiLCJiYXNpYyIsImoiLCJiYXNlTWludXNUTWluIiwic2tldyIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImRhbXAiLCJmbGFnIiwiY29kZVBvaW50IiwiYXJyYXkiLCJ2YWx1ZSIsImV4dHJhIiwiY291bnRlciIsInJlc3VsdCIsImVuY29kZWQiLCJsYWJlbHMiLCJmbiIsInJlZ2V4U2VwYXJhdG9ycyIsInBhcnRzIiwiUmFuZ2VFcnJvciIsImVycm9ycyIsInR5cGUiLCJNYXRoIiwiYnVpbGRFeHBzIiwiSVBWNkFERFJFU1MkIiwiWk9ORUlEJCIsIklQVjRBRERSRVNTJCIsIlJFU0VSVkVEJCQiLCJTVUJfREVMSU1TJCQiLCJJUFJJVkFURSQkIiwiQUxQSEEkJCIsIkRJR0lUJCQiLCJBVVRIT1JJVFlfUkVGJCIsIlVTRVJJTkZPJCIsIkhPU1QkIiwiUE9SVCQiLCJTQU1FRE9DX1JFRiQiLCJGUkFHTUVOVCQiLCJBQlNPTFVURV9SRUYkIiwiU0NIRU1FJCIsIlBBVEhfQUJFTVBUWSQiLCJQQVRIX0FCU09MVVRFJCIsIlBBVEhfUk9PVExFU1MkIiwiUEFUSF9FTVBUWSQiLCJRVUVSWSQiLCJSRUxBVElWRV9SRUYkIiwiUEFUSF9OT1NDSEVNRSQiLCJHRU5FUklDX1JFRiQiLCJBQlNPTFVURV9VUkkkIiwiSElFUl9QQVJUJCIsIlVSSV9SRUZFUkVOQ0UkIiwiVVJJJCIsIlJFTEFUSVZFJCIsIlJFTEFUSVZFX1BBUlQkIiwiQVVUSE9SSVRZJCIsIlBDSEFSJCIsIlBBVEgkIiwiU0VHTUVOVF9OWiQiLCJTRUdNRU5UX05aX05DJCIsIlNFR01FTlQkIiwiSVBfTElURVJBTCQiLCJSRUdfTkFNRSQiLCJJUFY2QUREUlpfUkVMQVhFRCQiLCJJUFZGVVRVUkUkIiwiSVBWNkFERFJFU1MxJCIsIklQVjZBRERSRVNTMiQiLCJJUFY2QUREUkVTUzMkIiwiSVBWNkFERFJFU1M0JCIsIklQVjZBRERSRVNTNSQiLCJJUFY2QUREUkVTUzYkIiwiSVBWNkFERFJFU1M3JCIsIklQVjZBRERSRVNTOCQiLCJJUFY2QUREUkVTUzkkIiwiSDE2JCIsIkxTMzIkIiwiREVDX09DVEVUX1JFTEFYRUQkIiwiREVDX09DVEVUJCIsIlVDU0NIQVIkJCIsIkdFTl9ERUxJTVMkJCIsIlNQJCQiLCJEUVVPVEUkJCIsIkNSJCIsIm9iaiIsImtleSIsInNvdXJjZSIsInNldEludGVydmFsIiwiY2FsbCIsInByb3RvdHlwZSIsIm8iLCJPYmplY3QiLCJzaGlmdCIsInNldHMiLCJfYSJdLCJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMubWFwIn0=
 globalThis.define=__define;  })(globalThis.define);