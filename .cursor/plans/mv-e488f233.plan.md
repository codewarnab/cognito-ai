<!-- e488f233-dda6-48ae-aefb-485ee33bce61 17848d71-37d2-4c34-87a1-07d9051e7c72 -->
# MV3 Background Service Worker — Queue, Alarms, Resilience

## Scope

Design the `src/background.ts` service worker to: bootstrap on install, gate on model readiness, persist a FIFO processing queue in IndexedDB with coalescing, schedule/budget work with `chrome.alarms`, and survive worker restarts. No network after first‑run model fetch.

## File Structure: src/background.ts

- Initialize runtime listeners and alarms
- Bootstrap on install/update (model version gate)
- Persistent queue API (IndexedDB wrappers)
- Coalescing and enqueue helpers
- Scheduler (alarms, budgeting, idle windows)
- Offscreen lifecycle ensure + message bridge
- Error handling and exponential backoff
- Message router for content/offscreen/worker

Suggested internal sections (single file; can later split if needed):

1. Constants/config (keys, timings, limits)
2. Types (message schemas, queue records)
3. IndexedDB open + stores (`settings`, `bgQueue`)
4. Queue ops: `enqueue`, `dequeueBatch`, `upsertCoalesced`, `markSuccess`, `markFailure`
5. Model gate: `ensureModelReady()` (reads `settings.modelVersion`)
6. Offscreen: `ensureOffscreen()`
7. Alarm scheduler: `ensureAlarms()`, `onAlarm`
8. Process loop: `runSchedulerTick()` with budgets
9. Listeners: `chrome.runtime.onInstalled`, `chrome.runtime.onMessage`, `chrome.runtime.onStartup`

## Queue Data Model (IndexedDB)

- DB name: `chromeAi`
- Version: `1`
- Store: `bgQueue` (keyPath: `id`)
  - `id: string` // `${url}#${bucketTs}` (coalesce key)
  - `url: string`
  - `title?: string`
  - `description?: string`
  - `source: "content" | "manual" | "retry"`
  - `firstEnqueuedAt: number` // ms
  - `lastUpdatedAt: number` // ms (coalesce writes)
  - `attempt: number` // starts at 0
  - `nextAttemptAt: number` // ms epoch for backoff scheduling
  - `payload: { textPreview?: string; images?: Array<{src:string; alt?:string; caption?:string; nearbyText?:string}> }`
  - Indexes:
    - `by_nextAttemptAt` (multi-field index)
    - `by_url`
- Store: `settings`
  - `modelVersion?: string`
  - `paused?: boolean`
  - `queueStats?: { total:number; successes:number; failures:number }`

### Coalescing Rules

- Coalesce by `(url, timeBucket)` where `timeBucket = floor(now / 60_000)` to merge rapid updates within 1 minute.
- If record exists, update `lastUpdatedAt`, merge latest `title/description/payload` shallowly, keep `firstEnqueuedAt`.

### Dequeue Policy

- Select up to `PROCESS_BATCH_SIZE` items where `nextAttemptAt <= now`, ordered by `firstEnqueuedAt` (FIFO) and then `lastUpdatedAt`.
- On success: delete record; update stats.
- On failure: increment `attempt`, set `nextAttemptAt = now + backoff(attempt)`; cap attempts at `MAX_ATTEMPTS`. After cap, move to `deadLetter` log (optional in `bgQueue` with `state:"dead"`).

## Alarm Cadence & Budgets

- Alarm name: `bg:schedule`
- Create periodic alarm: `periodInMinutes = 1`
- Also `chrome.runtime.onStartup` and message‑driven nudges call `runSchedulerTick()` immediately
- Budgets per tick:
  - `MAX_OFFSCREEN_LIFETIME_MS = 15_000` (close when idle)
  - `PROCESS_BATCH_SIZE = 8`
  - `PROCESS_TIME_BUDGET_MS = 250` per tick (yield if exceeded)
- Idle windows: if `chrome.idle` available, prefer `state === "idle"` for larger batches (e.g., 24 items) else default budget

## Message Schemas (Discriminated Unions)

```ts
// Background <-> Content
export type BgMsgFromContent =
  | { type: "PageSeen"; url: string; title?: string; description?: string; payload?: { textPreview?: string; images?: Array<{src:string; alt?:string; caption?:string; nearbyText?:string}> } }
  | { type: "TogglePause"; paused: boolean }
  | { type: "ClearIndex" };

export type BgMsgToContent =
  | { type: "Ack"; id?: string }
  | { type: "Error"; message: string };

// Background <-> Offscreen (document)
export type BgMsgToOffscreen =
  | { type: "ProcessBatch"; jobs: Array<{ url:string; title?:string; description?:string; payload?: any }> }
  | { type: "InitWorker" };

export type OffscreenMsgToBg =
  | { type: "BatchResult"; ok: true; results: Array<{ id:string; url:string }> }
  | { type: "BatchResult"; ok: false; errors: Array<{ id:string; url:string; message:string }> }
  | { type: "WorkerReady" };

// Offscreen <-> Embed Worker
export type WorkerMsg =
  | { type: "EmbedChunks"; jobs: Array<{ id:string; url:string; text:string; images?: Array<{caption:string}> }> }
  | { type: "EmbedResult"; id: string; ok: boolean; error?: string };
```

## Error/Backoff Strategy

- Exponential backoff with jitter: `delay = min(BASE * 2^attempt, MAX_BACKOFF_MS) * random(0.5..1.5)`
  - `BASE = 10_000 ms`, `MAX_BACKOFF_MS = 6 * 60 * 60 * 1000` (6h), `MAX_ATTEMPTS = 8`
- Classify errors:
  - Retriable: transient offscreen/worker not ready, quota exceeded, temporary IndexedDB failure
  - Non‑retriable: invalid payload, URL blocked by user policy → move to dead letter immediately
- Guardrails: pause processing if `paused === true`; ignore `PageSeen` enqueues when paused
- Resilience: on startup, `ensureAlarms()`, scan queue for due items, and `ensureOffscreen()` lazily during processing. If offscreen creation fails, reschedule with backoff.

## Bootstrap & Version Gating (onInstalled/onStartup)

- On `onInstalled`:
  - Write `settings.modelVersion = null` (if unset)
  - Kick `downloadModelAssets(version)` into offscreen or fetch from background (one‑time; allowed network)
  - After success, store `settings.modelVersion = version`
- At runtime before any `ProcessBatch`, validate `modelVersion` exists; if absent, skip processing and re‑schedule soon.

## Pseudocode Snippets (illustrative)

```ts
chrome.runtime.onInstalled.addListener(async () => {
  await ensureDb();
  await ensureAlarms();
  await bootstrapModelIfNeeded();
});

chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name !== "bg:schedule") return;
  await runSchedulerTick();
});

async function runSchedulerTick() {
  if (await isPaused() || !(await isModelReady())) return;
  await ensureOffscreen();
  const jobs = await dequeueBatch(Date.now(), getBatchSize());
  if (jobs.length === 0) return;
  const ok = await sendToOffscreen({ type: "ProcessBatch", jobs });
  // Results handled via offscreen message → markSuccess/Failure per id
}
```

## Acceptance Tests

- onInstalled bootstraps model version:
  - Simulate first install → model assets fetched once; `settings.modelVersion` set
  - Restart background: no network calls; processing gated until version present
- Queue coalescing:
  - Multiple `PageSeen` within 60s → single record, `firstEnqueuedAt` preserved, `lastUpdatedAt` updated
- FIFO and due‑time dequeue:
  - Enqueue three URLs with staggered `firstEnqueuedAt`, verify dequeue order by oldest `firstEnqueuedAt` when `nextAttemptAt <= now`
- Alarm scheduling:
  - Verify `bg:schedule` exists with period 1 min; `onAlarm` triggers `runSchedulerTick()` and respects time budget
- Backoff and retries:
  - Force transient failure from offscreen; confirm `attempt` increments and `nextAttemptAt` grows exponentially with jitter, capped at 6h
- Pause gate:
  - When `settings.paused=true`, `PageSeen` ignored for enqueue and scheduler does not process
- Resilience across restarts:
  - Kill/reload worker; on startup, alarms re‑created and due items processed without duplication
- Message contracts:
  - Send invalid `PageSeen` (missing `url`) → non‑retriable error path exercised and logged

## Notes

- All storage and queue operations are IndexedDB‑backed for durability
- No network traffic during steady‑state operation; only allowed during first‑run model asset download

### To-dos

- [ ] Define constants and TypeScript types in src/background.ts
- [ ] Implement IndexedDB open and stores for settings and bgQueue
- [ ] Build queue API with coalescing and backoff fields
- [ ] Set up chrome.alarms and idle-aware budgets
- [ ] Implement ensureOffscreen and message bridge handlers
- [ ] Implement runSchedulerTick with budgets and gating
- [ ] Implement onInstalled bootstrap + model version gating
- [ ] Author acceptance tests for queue, alarms, backoff, resilience