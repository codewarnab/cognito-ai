<!-- 08a15642-ad08-478c-9b5d-625bf7a8156e eefe3f5d-9a80-40f7-bfd0-f443d2390184 -->
# One-time Model Download & Caching — Plan

### Scope

- Add install/version-change bootstrap for local model assets.
- Cache layout: `CacheStorage@"model/<version>/*"` with integrity verification.
- Gate all embedding calls on readiness; repair partial/aged caches.
- Network only at first-run or version bump; offline thereafter.

### Triggers

- `chrome.runtime.onInstalled` with `reason in {"install","update"}`.
- Background startup: lazy verify if `modelReady !== true` or cache suspected stale.

### Asset Manifest

- Location: `MODEL_BASE_URL/<version>/manifest.json`.
- Schema:
  - `version: string` — semantic version.
  - `assets: Array<{ path: string; size: number; sha256: string; optional?: boolean }>`
  - `expires?: string` — RFC3339; allow future rotation.
  - `minAppVersion?: string` — gate incompatible builds.
- Required files example: `model.onnx`, `tokenizer.json`, `config.json`, `vocab.txt`, `meta.json`.

### Storage Keys (`chrome.storage.local`)

- `model.version: string` — current targeted version.
- `model.ready: boolean` — true only after all assets verified and cached.
- `model.bootstrapState: "idle" | "checking" | "downloading" | "verifying" | "ready" | "error"`.
- `model.error?: { code: string; message: string; at: number }` — last failure.
- `model.lastCheckAt: number` — ms epoch.
- `model.pendingVersion?: string` — during in-progress upgrade.
- `model.assetETags: Record<string,string>` — per-asset ETag for conditional requests.

### Cache Storage Layout

- Cache name: `model/<version>` (single cache per version).
- Entries:
  - `/<version>/manifest.json`
  - `/<version>/model.onnx`
  - `/<version>/tokenizer.json`
  - `/<version>/config.json`
  - `/<version>/vocab.txt`
- Keep most-recent cache only (delete older `model/*` caches when new ready).

### Background Flow

1. onInstalled/onUpdate → set `bootstrapState="checking"`, set `pendingVersion=manifest.version`.
2. Fetch manifest (no-cors blocked? use `fetch` with `cache: "no-store"`). If offline, fallback to previously cached manifest in any `model/*` cache; if none, set `error` and schedule retry.
3. If `model.version !== manifest.version` → upgrade path; else verify cache completeness and integrity.
4. Download assets sequentially or with small concurrency (e.g., 2–3 at a time):

   - Use `If-None-Match` from `assetETags[path]`.
   - Stream to `Response` and put into `caches.open("model/<version>")`.
   - Verify `sha256` by reading as `ArrayBuffer` and computing digest via `crypto.subtle.digest`.
   - Only mark asset as present if digest matches; otherwise discard and flag for retry.

5. After all assets verified, write manifest into cache, set:

   - `model.version = manifest.version`
   - `model.ready = true`
   - `bootstrapState = "ready"`
   - Delete older `model/*` caches.

6. If any failure → `bootstrapState="error"`, retain partial cache but record which assets missing; schedule backoff retry via `chrome.alarms`.

### Readiness Gating API

- Module `src/background/model-ready.ts` exporting:
  - `await ensureModelReady(): Promise<void>` — resolves when ready; may trigger bootstrap/rehydration.
  - `getModelCacheUrl(path: string): Promise<string>` — returns `chrome.runtime.getURL("offscreen/...?")` or `cache.match(...)` blob URL for worker.
- All embedding calls (`embed-worker.ts`) must call `ensureModelReady()` first; if not ready and offline, throw a typed `ModelNotReadyOffline` error for UI.

### Rehydration & Partial Cache Repair

- On each background start or before first embedding:
  - Open `caches.keys()` → if cache for `model.version` exists:
    - Load manifest from cache; verify presence of all required assets and optionally re-verify SHA256 for any missing `integrity-ok` marker kept in `storage.local` per-asset.
    - For missing/failed assets:
      - If online and allowed (first-run/version-bump only), redownload just those.
      - If offline, keep `ready=false`, surface actionable state; schedule alarm retry.
- If `model.version` missing but a newer cache exists that verified → adopt it.

### Failure & Retry Strategy

- Backoff via `chrome.alarms.create("model-retry", { delayInMinutes: backoffN })` with capped exponential backoff (1, 2, 4, 8, 16, max 60).
- Retry only missing/failed assets.
- Reset backoff on any successful asset fetch.
- Hard stop after N=10 attempts; keep partial cache; next foreground action can trigger a retry.
- Handle integrity mismatch with code `INTEGRITY_MISMATCH` and never mark ready; always re-fetch on next attempt with `cache: "reload"` and drop ETag.

### Offline Behavior

- If previous version fully cached and verified:
  - Continue to serve from `model/<version>` without network.
- First-run with no cached version and offline:
  - Fail fast with `ready=false`; show UI hint and schedule retry alarm.
- Partial cache present and offline:
  - Keep `ready=false`; on next online window, resume.

### Minimal APIs and Snippets

- Manifest fetch and verify:
```startLine:endLine:src/background.ts
// await fetch(`${MODEL_BASE_URL}/${targetVersion}/manifest.json`, { cache: "no-store" })
```

- Cache naming:
```startLine:endLine:src/constants.ts
// export const MODEL_CACHE_PREFIX = "model/"
```

- Gating call site:
```startLine:endLine:src/workers/embed-worker.ts
// await ensureModelReady()
```


### Acceptance Tests

- First install online: downloads all assets, sets `ready=true`, embeddings work; no further network.
- First install offline: stays `ready=false`, retries on backoff, becomes ready when online.
- Version bump online: downloads new version; old version remains usable until new verified; atomically switch and delete old cache.
- Integrity mismatch: corrupt asset is discarded; not ready until fixed; after server provides correct file, becomes ready.
- Partial cache recovery: missing one file → only that file fetched and verified.
- ETag hit: 304 flow retains asset; integrity not recomputed unless size/ETag changes.
- Restart robustness: survive service worker restarts without losing state; resumes download.
- No network after ready: embeddings load from cache with zero network.
- Error backoff: verify exponential schedule, cap, and reset on success.

### Files to Update/Add

- `src/constants.ts` — `MODEL_BASE_URL`, `MODEL_VERSION`, cache prefix, retry caps.
- `src/background.ts` — onInstalled, alarms, bootstrap orchestrator.
- `src/background/offscreen.ts` — ensure offscreen before worker start.
- `src/offscreen/bridge.ts` — call `ensureModelReady()` before creating worker.
- `src/workers/embed-worker.ts` — use `getModelCacheUrl` for asset loading, gated by readiness.

### To-dos

- [ ] Define manifest schema and constants in src/constants.ts
- [ ] Implement background bootstrap orchestrator with alarms/backoff
- [ ] Add cache integrity verification and partial repair logic
- [ ] Expose ensureModelReady gating API and model asset URL resolver
- [ ] Update embed-worker to await readiness and load assets from cache
- [ ] Write acceptance tests and manual QA checklist