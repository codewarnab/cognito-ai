<!-- a5218e06-9f07-4b61-bd62-b83f8080765a 3a224c43-df8c-4537-a084-16b929e27052 -->
# MiniSearch Sparse Index Integration

### Scope

Implement a `src/search/minisearch.ts` module that wraps `minisearch` for `{id, url, title, text}` with: configurable options, incremental updates, periodic `toJSON()` persistence (every N=10), size-bounded storage in IndexedDB, non-blocking operations via offscreen/worker bridge, and robust restore/rebuild flows.

### Storage & Serialization

- IndexedDB store: `miniSearchIndex` (DB helper in `src/db/index.ts`)
  - Key: `version` (e.g., `v1`), Value: `{ json: MiniSearchJSON, docCount: number, persistedAt: number, approxBytes: number }`
- Persist policy:
  - Trigger every N=10 mutations (adds/updates/removes) or on force.
  - Cap serialized size at ~20 MB preferred for better recall; if exceeded:
    - Step 1: truncate `text` field at 2,000 tokens during (re)index.
    - Step 2: evict least-recently-updated docs until under cap.
- Size estimation: `JSON.stringify(indexJSON).length` bytes.

### Initialization & Restore-on-start

- On background/offscreen startup:
  - Read `modelVersion`/`indexVersion` from `chrome.storage.local`.
  - Attempt restore: load `miniSearchIndex[vX]` from IndexedDB and `MiniSearch.fromJSON(json, options)`.
  - If missing or version mismatch/corrupt: create empty index; schedule rebuild from `pages` store in idle windows.

### Non-blocking Execution

- Run all index operations inside the offscreen document’s worker (same bridge planned for embeddings):
  - Queue commands: `init`, `addOrUpdate`, `remove`, `search`, `persist`, `stats`, `rebuild`.
  - Use micro-batching for `addOrUpdate`.
  - Yield with `requestIdleCallback`/chunked loops to avoid long tasks.

### API: `src/search/minisearch.ts`

- `initMiniSearch(options?: Partial<MiniSearchOptions>): Promise<void>`
- `addOrUpdateDocs(docs: DocInput[]): Promise<void>` // incremental, coalesces duplicates
- `removeDocs(ids: string[]): Promise<void>`
- `search(query: string, opts?: SearchOptions): Promise<SearchResult[]>`
- `persist(force?: boolean): Promise<void>` // enforces N=10 rule
- `rebuildFromPages(pages: PageIterator): Promise<void>` // chunked, truncation applied
- `getStats(): Promise<{ docCount: number; approxBytes: number; lastPersistedAt: number }>`
- `clearIndex(): Promise<void>`

### Configurable Options

- Exposed defaults:
  - fields: `['title', 'text']`, storeFields: `['id','url','title','text']`
  - tokenize: default MiniSearch; stemmer/normalizer optional toggle
  - search options: prefix search on, fuzzy `0.2`, boost `title: 2.0`
  - persistEveryN: `10` (configurable via `src/constants.ts`)
  - truncationTokens: `2000` (configurable)
  - sizeCapBytes: `20 * 1024 * 1024` (configurable)

### Rebuilds After Upgrades

- Bump `INDEX_VERSION` in `src/constants.ts` when tokenization or scoring changes.
- On mismatch: mark `needsRebuild` and start background `rebuildFromPages` using `src/db/index.ts` pages iterator.
- Hybrid search layer reads `needsRebuild` to show “index rebuilding” state, but remains operable with partial index.

### Essential Snippets

- Persist guard (pseudo):
```startLine:endLine:src/search/minisearch.ts
// if (mutationsSincePersist >= persistEveryN || force) { await persist(); }
```

- Restore:
```startLine:endLine:src/search/minisearch.ts
// const saved = await db.getMiniSearchIndex(INDEX_VERSION); // MiniSearch.fromJSON(saved.json, options)
```


### Acceptance Tests

- Location: `src/search/__tests__/minisearch.spec.ts`
- Cases:
  - Creates index, adds docs, searches by title/text, respects boosts.
  - Incremental updates overwrite existing ids; removals disappear from results.
  - Persistence triggers at N=10; restore reproduces identical results.
  - Size cap enforcement: simulate large texts ⇒ truncation applied; over-cap ⇒ doc eviction lowers size and keeps recency.
  - Rebuild-on-version-change: bump version ⇒ starts empty then rebuild populates with pages.
  - Non-blocking: batch add of 10k short docs finishes without single task >50ms (mock `rIC`).

### Integration Points

- `src/background/offscreen.ts`: route messages to worker; initialize on startup; expose `search` to popup/history page.
- `src/pages/history.tsx`: use `search(query, opts)`; display rebuilding state and index stats.
- `src/db/index.ts`: add store `miniSearchIndex`, helpers: `getMiniSearchIndex(version)`, `putMiniSearchIndex(version, payload)`, `deleteMiniSearchIndex(version)`.

### Rollout

- Ship index empty, build incrementally as pages are processed.
- Telemetry-free. Provide “Clear sparse index” action wired to `clearIndex()` and “Rebuild” action wired to `rebuildFromPages()`.

### To-dos

- [ ] Add INDEX_VERSION and MiniSearch config defaults in src/constants.ts
- [ ] Implement miniSearchIndex store helpers in src/db/index.ts
- [ ] Extend offscreen/worker bridge with minisearch commands
- [ ] Create src/search/minisearch.ts public API and internal logic
- [ ] Implement N=10 persistence, size cap, truncation, and eviction
- [ ] Restore on start; handle version mismatch and mark needsRebuild
- [ ] Implement rebuildFromPages iterator with chunked batching
- [ ] Wire history page to search, stats, and rebuilding state
- [ ] Add popup action to open history page if not present
- [ ] Add acceptance tests for correctness, persistence, size, rebuilds