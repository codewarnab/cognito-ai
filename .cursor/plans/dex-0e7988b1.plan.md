<!-- 0e7988b1-061a-4255-a729-35221c0088f1 258af441-2943-4281-8217-886f970a1afb -->
# Dexie IndexedDB Layer — Plan

### Goals

- Create `src/db/index.ts` with a typed Dexie instance, stores, and helper APIs.
- Support embeddings as `Float32Array` via `ArrayBuffer` in IndexedDB.
- Efficient bulk writes and resilient schema upgrades via Dexie migrations.
- Implement quota awareness and eviction policies.
- Provide a manual acceptance checklist (no automated tests).

### Libraries

- Dexie (promise-based IndexedDB wrapper) — use `Dexie`, `Table`, `liveQuery` optional.

### Stores & Keys

- pages
  - key: `pageId` (string) e.g., `${urlHash}-${firstSeenEpoch}`
  - indexes: `url`, `domain`, `firstSeen`, `lastUpdated`
- chunks
  - key: `chunkId` (string) e.g., `${pageId}-${chunkIndex}`
  - indexes: `url`, `pageId`, `chunkIndex`, `tokenLength`, `createdAt`
  - data: `embedding` as `ArrayBuffer`, `text`
- images
  - key: `imageId` (string) e.g., `${pageId}-${seq}`
  - indexes: `pageUrl`, `pageId`
- miniSearchIndex
  - key: `version` (number)
  - value: `json` (string or `Uint8Array`)
- settings
  - key: `key` (string), value: `any` JSON
- queue
  - key: `id` (string UUID)
  - indexes: `type`, `status`, `priority`, `createdAt`, `updatedAt`

### Schema Versions & Migrations

- v1
  - pages(chosen fields), chunks(embedding as ArrayBuffer), images, settings
- v2
  - add `miniSearchIndex` store
  - add indexes to pages/chunks for `domain`, `createdAt`
- v3
  - add `queue` store with fields `{id,type,status,priority,payload,createdAt,updatedAt,attempts}`
  - backfill defaults (`status='pending'`, `priority=0`, timestamps)
- v4
  - add `lastAccessed` to pages and chunks (for eviction) and build index
  - migration sets `lastAccessed = lastUpdated || firstSeen` on pages; `lastAccessed = createdAt` on chunks

Dexie example (concise):

```startLine:endLine:src/db/index.ts
// db.version(1).stores({ pages: 'pageId, url, domain, firstSeen, lastUpdated', ... })
```

### API Surface (`src/db/index.ts`)

- Initialization
  - `openDb(): Promise<AppDB>` — returns singleton Dexie instance
- Page APIs
  - `upsertPage(page: PageRecord): Promise<void>`
  - `getPageById(pageId: string): Promise<PageRecord|undefined>`
  - `getLatestPageByUrl(url: string): Promise<PageRecord|undefined>`
  - `listPagesByDomain(domain: string, limit?: number): Promise<PageRecord[]>`
  - `touchPage(pageId: string): Promise<void>` (updates `lastAccessed`)
  - `deletePages(pageIds: string[]): Promise<number>`
- Chunk APIs
  - `bulkPutChunks(chunks: ChunkRecord[]): Promise<void>` (uses `db.chunks.bulkPut`)
  - `listChunksByPage(pageId: string): Promise<ChunkRecord[]>`
  - `streamAllChunkEmbeddings(): AsyncGenerator<{chunkId:string; embedding: Float32Array}>`
  - `evictChunksForPage(pageId: string, keepNewest: number): Promise<number>`
  - `touchChunks(chunkIds: string[]): Promise<void>`
- Image APIs
  - `bulkPutImages(images: ImageRecord[]): Promise<void>`
  - `listImagesByPage(pageId: string): Promise<ImageRecord[]>`
- miniSearchIndex APIs
  - `saveMiniSearchIndex(version: number, json: string|Uint8Array): Promise<void>`
  - `loadMiniSearchIndex(version: number): Promise<string|Uint8Array|undefined>`
- Settings APIs
  - `getSetting<T>(key: string): Promise<T|undefined>`
  - `setSetting<T>(key: string, value: T): Promise<void>`
- Queue APIs
  - `enqueue(job: QueueItem): Promise<string>`
  - `dequeue(types?: string[]): Promise<QueueItem|undefined>` (oldest pending, highest priority first)
  - `markDone(id: string): Promise<void>` / `markFailed(id: string, error?: string): Promise<void>`

### Data Types (TS interfaces)

- `PageRecord` — { pageId, url, domain, title?, description?, firstSeen, lastUpdated, lastAccessed }
- `ChunkRecord` — { chunkId, url, pageId, chunkIndex, tokenLength, text, embedding(ArrayBuffer), createdAt, lastAccessed }
- `ImageRecord` — { imageId, url: imageSrc, pageUrl, pageId, captionText? }
- `QueueItem` — { id, type, status: 'pending'|'running'|'done'|'failed', priority, payload: any, createdAt, updatedAt, attempts, lastError? }

### Bulk & Binary Handling

- Store `Float32Array` as `embedding.buffer`; reconstruct via `new Float32Array(buf)`.
- Batch writes with Dexie `bulkPut` in chunks (e.g., 1k records) to avoid blocking.
- Use transactions spanning multiple tables when updating correlated data (pages+chunks+images).

### Quota & Eviction

- Request persistence (best-effort): `navigator.storage.persist?.()` where available; rely on `unlimitedStorage` permission in MV3.
- Eviction triggers
  - On QuotaExceededError, or when page/chunk counts exceed thresholds (configurable via settings):
    - Evict: remove oldest pages by `lastAccessed`, and their chunks/images, until under cap.
    - Per-page cap: keep newest N chunks (e.g., 50) via `evictChunksForPage`.
- Keep lightweight counters in `settings` (e.g., `totalChunkCount`) updated lazily; recompute if missing.

### Resilience to Upgrades

- Only additive migrations unless unavoidable; when changing data shape, set defaults in `upgrade`.
- Never read from a store that doesn’t exist; guard by `db.verno` or feature flags in `settings`.
- Use `try/catch` on open; if unrecoverable corruption, allow a `resetDatabase()` helper to `delete()` and recreate.

### Essential Snippets

- Dexie versioning skeleton:
```typescript
const db = new Dexie('HistorySearchDB') as AppDB;
db.version(1).stores({
  pages: 'pageId, url, domain, firstSeen, lastUpdated',
  chunks: 'chunkId, url, pageId, chunkIndex, tokenLength, createdAt',
  images: 'imageId, pageUrl, pageId',
  settings: 'key'
});
db.version(2).stores({ miniSearchIndex: 'version' });
db.version(3).stores({ queue: 'id, type, status, priority, createdAt' }).upgrade(tx => {/* backfill */});
db.version(4).upgrade(async tx => {
  await tx.table('pages').toCollection().modify(p => p.lastAccessed = p.lastUpdated ?? p.firstSeen);
  await tx.table('chunks').toCollection().modify(c => c.lastAccessed = c.createdAt);
});
```


### Manual Acceptance Checklist

- First open creates stores; subsequent opens at same version are no-ops.
- Upgrading v1→v4 preserves existing data; new fields have sensible defaults.
- Can write/read pages, chunks (with Float32 embeddings), images quickly (bulkPut 1k records) without blocking UI.
- Hybrid index persistence works: save/load `miniSearchIndex` payload of several MB.
- Eviction removes least-recently-accessed pages and prunes chunks per-page to 50.
- Queue enqueue/dequeue respects `priority` and FIFO within same priority; done/failed updates status.

### Files to Change/Add

- Add `src/db/index.ts` implementing the database, types, and helpers above.
- Optionally add `src/constants.ts` for caps (per-page chunk cap, global caps).

### To-dos

- [ ] Define Dexie schema v1–v4 with stores and indexes
- [ ] Add TypeScript types for records and DB interface
- [ ] Implement singleton openDb() and resetDatabase()
- [ ] Implement page CRUD and lookup helpers
- [ ] Implement chunk bulk writes and retrieval
- [ ] Implement image bulk writes and lookups
- [ ] Implement miniSearch index save/load
- [ ] Implement settings get/set helpers
- [ ] Implement queue enqueue/dequeue and status updates
- [ ] Implement eviction and quota error handling
- [ ] Provide manual acceptance checklist in README or comments